<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/page/3/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/page/3/">





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/04/23/tips-android-reverse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/23/tips-android-reverse/" itemprop="url">
                  Android逆向相关
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T12:06:25+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>安装apktool和dex2jar,jd-gui
homebrew安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install apktool</span><br><span class="line">brew install dex2jar</span><br></pre></td></tr></table></figure>

<p>安装结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/Cellar/apktool/2.4.0: 4 files, 15.6MB, built in 3 minutes 39 seconds</span><br><span class="line">/usr/local/Cellar/dex2jar/2.0: 34 files, 2.4MB, built in 1 minute 12 seconds</span><br></pre></td></tr></table></figure>

<p>JD-GUI去<a href="http://jd.benow.ca/下载" target="_blank" rel="noopener">http://jd.benow.ca/下载</a>
dmg可能不支持最新版本的mac用不了，打开就报错</p>
<p>反编译流程</p>
<ol>
<li>执行脚本apktool d xxx.apk   注：xxx.apk为你要反编译的apk</li>
<li>在你执行命令的目录下会生成xxx文件夹 到文件夹中查看res资源文件即可</li>
<li>将apk文件后缀名直接改为.zip并解压。得到其中的classes.dex文件，它就是java源代码经过编译再通过dx工具打包而成的。</li>
<li>将classes.dex文件复制到dex2jar所在的文件夹</li>
<li>终端cd到dex2jar目录，运行 <code>sh dex2jar.sh classes.dex</code></li>
<li>生成 classes_dex2jar.jar</li>
<li>用jd-gui打开就可以看到源代码</li>
</ol>
<p>自动化反编译
shell脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d $1 &amp;&amp; mv $1 $1.zip &amp;&amp; unzip $1.zip &quot;*.dex&quot; -d $1_dex/ &amp;&amp; cd $1_dex/ &amp;&amp; d2j-dex2jar *.dex</span><br></pre></td></tr></table></figure>

<p>解压apk:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#解压apk，获取代码中的classs.dex</span><br><span class="line">unzip apk-debug.apk -d apk-debug_code </span><br><span class="line"></span><br><span class="line">#将.dex文件转换成.jar文件</span><br><span class="line">sh dex2jar-2.0/d2j-dex2jar.sh apk-debug_code/classes.dex</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p><a href="https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/osx/apktool" target="_blank" rel="noopener">apktool wrappter</a>
<a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">apktool.jar</a>
<a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="noopener">dex2jar</a>
<a href="http://java-decompiler.github.io/" target="_blank" rel="noopener">jd-gui</a>
<a href="http://t.cn/R56KIjj" target="_blank" rel="noopener">http://t.cn/R56KIjj</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/04/21/l-cpp-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/21/l-cpp-tips/" itemprop="url">
                  CPP小技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T14:35:55+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内置宏"><a href="#内置宏" class="headerlink" title="内置宏"></a>内置宏</h3><p>标准C语言预处理要求定义某些对象宏，每个预定义宏的名称一两个下划线字符开头和结尾，这些预定义宏不能被取消定义（#undef）或由编程人员重新定义。下面预定义宏:</p>
<ul>
<li><code>__LINE__</code> 当前程序行的行号，表示为十进制整型常量</li>
<li><code>__FILE__</code>  当前源文件名，表示字符串型常量</li>
<li><code>__DATE__</code> 转换的日历日期，表示为Mmm dd yyyy 形式的字符串常量，Mmm是由asctime产生的。</li>
<li><code>__TIME__</code> 转换的时间，表示”hh:mm:ss”形式的字符串型常量，是有asctime产生的。（asctime貌似是指的一个函数）</li>
<li><code>__STDC__</code> 编辑器为ISO兼容实现时位十进制整型常量</li>
<li><code>__STDC_VERSION__</code> 如何实现复合C89整部1，则这个宏的值为19940SL；如果实现符合C99，则这个宏的值为199901L；否则数值是未定义</li>
<li><code>__STDC_EOBTED__</code> (C99)实现为宿主实现时为1,实现为独立实现为0</li>
<li><code>__STDC_IEC_559__</code> (C99)浮点数实现复合IBC 60559标准时定义为1，否者数值是未定义</li>
<li><code>__STDC_IEC_559_COMPLEX__</code> (C99)复数运算实现复合IBC 60559标准时定义为1，否者数值是未定义</li>
<li><code>__STDC_ISO_10646__</code> (C99)定义为长整型常量，yyyymmL表示wchar_t值复合ISO 10646标准及其指定年月的修订补充，否则数值未定义</li>
</ul>
<p>C++中还定义了 <code>__cplusplus</code>, C语言中的<code>__FILE__</code>、<code>__LINE__</code>和<code>__DATE__</code>等都在头文件#include<code>&lt;stdio.h&gt;</code>中</p>
<h3 id="attribute-机制"><a href="#attribute-机制" class="headerlink" title="__attribute__机制"></a><code>__attribute__</code>机制</h3><p>GNU C的一大特色就是<code>__attribute__</code>机制.<code>__attribute__</code>可以设置函数属性(Function Attribute),变量属性(Variable Attribute)和类型属性(Type Attribute)</p>
<p>其位置约束为: 放与生命的尾部”;”之前
<code>__attribute__</code>书写特征为:<code>__attribute__</code>前后都有两个下划线,并且后面会紧跟一对圆括号,括号里面是相应的<code>__attribute__</code>参数.
<code>__attribute__</code>语法格式为:`<strong>attribute</strong>((attribute-list))</p>
<h4 id="一-函数属性（Function-Attribute"><a href="#一-函数属性（Function-Attribute" class="headerlink" title="一, 函数属性（Function Attribute)"></a>一, 函数属性（Function Attribute)</h4><p>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。<strong>attribute</strong>机制也很容易同非GNU应用程序做到兼容之功效。GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。</p>
<p>下面介绍几个常见的属性参数:</p>
<p><code>__attribute__ format</code>  该属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。</p>
<p>format的语法格式为：<code>format (archetype, string-index, first-to-check)</code></p>
<p>format属性告诉编译器，按照 printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传 入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。
具体使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((format(printf,m,n)))</span><br><span class="line">__attribute__((format(scanf,m,n)))</span><br></pre></td></tr></table></figure>

<p>其中参数m与n的含义为：</p>
<ul>
<li>m：第几个参数为格式化字符串（format string）；</li>
<li>n：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几.这里需要注意，有时函数参数里还有“隐身”的，如C++的类成员函数的第一个参数实际上是”隐身”的”this”指针；
在使用上，<code>__attribute__((format(printf,m,n)))</code>是常用的，而另一种却很少见到。</li>
</ul>
<p>下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// m = 1, n = 2...如果在这里myprint()为类成员函数,则gcc编译后会提示&quot;format argument is not a pointer&quot;的警告</span><br><span class="line">extern void myprint(const char *format,...) __attribute__((format(printf,1,2)));</span><br><span class="line"></span><br><span class="line">// m = 2, n = 3</span><br><span class="line">extern void myprint(short num，const char *format,...) __attribute__((format(printf,2,3)));</span><br></pre></td></tr></table></figure>

<p>最经典的应用可以去看linux源码里的函数device_create(…)和class_device_create(…), 做linux驱动开发的小伙伴应该对这两个函数不陌生.</p>
<p><code>__attribute__ noreturn</code>  该属性通知编译器函数从不返回值。当遇到函数需要返回值却还没运行到返回值处就已退出来的情况，该属性可以避免出现错误信息。</p>
<p>C库函数中的abort()和exit()的声明格式就采用了这种格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern void exit(int)  __attribute__((noreturn));</span><br><span class="line">extern void abort(void)  __attribute__((noreturn));</span><br></pre></td></tr></table></figure>

<p>例如下面这段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extern void myexit(int);</span><br><span class="line"></span><br><span class="line">int testFunc(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;-- Enter %s --&quot;, __func__);</span><br><span class="line"></span><br><span class="line">    myexit(0);</span><br><span class="line"></span><br><span class="line">    // 其实函数运行不到这里</span><br><span class="line">    printf(&quot;-- Exit %s --&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myexit(int i)</span><br><span class="line">&#123;</span><br><span class="line">    exit(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时会报”control reaches end of non-void function”的警告, 但若将”extern void myexit(int);”改为”extern void myexit(int) <strong>attribute</strong>((noreturn));” 就不会再报警告了.
<strong>attribute</strong> constructor/destructor  若函数被设定为constructor属性，则该函数会在 main（）函数执行之前被自动的执行。类似的，若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。拥有此类属性的函数经常隐式的用在程序的初始化数据方面。</p>
<p>这两个属性还没有在面向对象C中实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) void before_main() &#123;</span><br><span class="line">   printf(&quot;--- %s\n&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) void after_main() &#123;</span><br><span class="line">   printf(&quot;--- %s\n&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">   printf(&quot;--- %s\n&quot;, __func__);</span><br><span class="line">   </span><br><span class="line">   exit(0);</span><br><span class="line">   </span><br><span class="line">   printf(&quot;--- %s, exit ?\n&quot;, __func__);</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- before_main</span><br><span class="line">--- main</span><br><span class="line">--- after_main</span><br></pre></td></tr></table></figure>

<h4 id="弱引用符号-attribute-weak"><a href="#弱引用符号-attribute-weak" class="headerlink" title="弱引用符号__attribute__((weak))"></a>弱引用符号<code>__attribute__((weak))</code></h4><p>情况是这样的，碰到一个棘手的问题：我们不确定外部模块是否提供一个函数func，但是我们不得不用这个函数，即自己模块的代码必须用到func函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extern int func(void);</span><br><span class="line">...................</span><br><span class="line">int a = func();</span><br><span class="line">if( a &gt; .....)</span><br><span class="line">&#123;</span><br><span class="line">..........</span><br><span class="line">&#125;</span><br><span class="line">............</span><br></pre></td></tr></table></figure>

<p>我们不知道func函数是否被定义了,这会导致2个结果：</p>
<ol>
<li>外部存在这个函数func，并且EXPORT_SYMBOL(func)，那么在我自己的模块使用这个函数func，正确。</li>
<li>外部其实不存在这个函数，那么我们使用func，程序直接崩溃。</li>
</ol>
<p>所以这个时候，<code>__attribute__((weak))</code> 派上了用场。
在自己的模块中定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int  __attribute__((weak))  func(......)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将本模块的func转成弱符号类型，如果遇到强符号类型（即外部模块定义了func），那么我们在本模块执行的func将会是外部模块定义的func。如果外部模块没有定义，那么，将会调用这个弱符号，也就是在本地定义的func，直接返回了一个1（返回值视具体情况而定）,相当于增加了一个默认函数。</p>
<p>原理：连接器发现同时存在弱符号和强符号，有限选择强符号，如果发现不存在强符号，只存在弱符号，则选择弱符号。如果都不存在：静态链接，恭喜，编译时报错，动态链接：对不起，系统无法启动。 </p>
<p><strong>TIPS</strong>
weak属性只会在静态库(.o .a )中生效，动态库(.so .ko(内核模块))中不会生效。</p>
<p>举个例子：
strong.c  //生成libstrong.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">void real_func()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;int real func\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>weak.c //生成libweak.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void real_func() __attribute__((weak));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void real_func()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;fake func\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c //</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">extern void real_func();</span><br><span class="line"> </span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        real_func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -lstrong -lweak</span><br></pre></td></tr></table></figure>

<p>那么输出结果”real func”。</p>
<p>如果 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -lweak -lstrong</span><br></pre></td></tr></table></figure>

<p>那么输出结果为”fake func”。</p>
<p>可见，对于动态库，weak属性毫无作用，且main中调用哪个real_func()，取决于链接的顺序。
如果将strong.c 和 weak.c编译成.a或者.o</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c strong.o weak.o</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c strong.o weak.o</span><br></pre></td></tr></table></figure>

<p>那么输出结果都是”real func”。</p>
<p>所以，如果在so中使用weak属性，那么任何不符合预期的情况，都是可能出现的。</p>
<blockquote>
<p>官方解释：<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=3946" target="_blank" rel="noopener">https://sourceware.org/bugzilla/show_bug.cgi?id=3946</a></p>
</blockquote>
<p>alias属性可以给函数名取一个外号。使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(void);</span><br><span class="line">void alias_func(void) __attribute__((alias(&quot;func&quot;)))；  需要注意c++的符号修饰机制！</span><br></pre></td></tr></table></figure>

<p>这样的意思就是函数func的别名或外号是alias_func，那么就是调用alias_func()和func()的效果是一样的，有兴趣的话可以自己写代码验证。这时需要主意func函数必须是要有定义的，否则会编译报错的。</p>
<p><code>__attribute__((weakref))</code>为弱引用，请注意引用与定义的区别。weakref就是申明某个引用为弱引用，弱引用时如果需引用符号不存在也不会链接出错，而是将需要引用的符号定义为WEAK属性及0地址(跟前面的WEAK属性很相似吧)。
weakref的用法有点特别，必须要配合alias使用及必须是static定义。<strong>attribute</strong>((weak(“target”)))相当于<strong>attribute</strong>((weakref,alias(“target”)))，以下看个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** weakref_test.c</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/* 申明func_alias函数func的带弱引用的别名 */</span><br><span class="line">void func(void)</span><br><span class="line">&#123;</span><br><span class="line">　　printf(&quot;func:%s in\n&quot;, __FUNC__);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void func_alias(void) __attribute__((weakref,alias(&quot;func&quot;)));</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　func_alias(); /* 相当于调用func */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，会发现实际运行的就是func函数。func_alias相当于是func的一个带有weakref属性的另一份申明，可以这样理解：void *func = func;void *func_alias = func(“weakref”)。
注意到前面alias属性如果func不存在时申明alias会出错，通过weakref方法，可以让func未定义就可以编译通过，使用<code>static void alias_func(void) __attribute__((weakref,alias(&quot;func&quot;)))</code>时即使func未定义也能链接通过，只不过func或alias_func的地址为0，可以去掉func的实现，验证一下即可。</p>
<h3 id="宏参数的字符串化和宏参数的连接"><a href="#宏参数的字符串化和宏参数的连接" class="headerlink" title="宏参数的字符串化和宏参数的连接"></a>宏参数的字符串化和宏参数的连接</h3><p>在宏定义中，有时还会用到#和##两个符号，它们能够对宏参数进行操作。</p>
<h4 id="的用法"><a href="#的用法" class="headerlink" title="# 的用法"></a><code>#</code> 的用法</h4><p><code>#</code>用来将宏参数转换为字符串，也就是在宏参数的开头和末尾添加引号。例如有如下宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define STR(s) #s</span><br></pre></td></tr></table></figure>

<p>那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s&quot;, STR(c.biancheng.net));</span><br><span class="line">printf(&quot;%s&quot;, STR(&quot;c.biancheng.net&quot;));</span><br></pre></td></tr></table></figure>

<p>分别被展开为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s&quot;, &quot;c.biancheng.net&quot;);</span><br><span class="line">printf(&quot;%s&quot;, &quot;\&quot;c.biancheng.net\&quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>以发现，即使给宏参数“传递”的数据中包含引号，使用#仍然会在两头添加新的引号，而原来的引号会被转义。</p>
<h3 id="的用法-1"><a href="#的用法-1" class="headerlink" title="##的用法"></a><code>##</code>的用法</h3><p><code>##</code>称为连接符，用来将宏参数或其他的串连接起来。例如有如下的宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CON1(a, b) a##e##b</span><br><span class="line">#define CON2(a, b) a##b##00</span><br></pre></td></tr></table></figure>

<p>那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%f\n&quot;, CON1(8.5, 2));</span><br><span class="line">printf(&quot;%d\n&quot;, CON2(12, 34));</span><br></pre></td></tr></table></figure>

<p>将被展开为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%f\n&quot;, 8.5e2);</span><br><span class="line">printf(&quot;%d\n&quot;, 123400);</span><br></pre></td></tr></table></figure>

<h3 id="extern-“C”的作用"><a href="#extern-“C”的作用" class="headerlink" title="`extern “C”的作用"></a>`extern “C”的作用</h3><p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p>
<p>这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略。</p>
<p>这个功能主要用在下面的情况：</p>
<ul>
<li>C++代码调用C语言代码</li>
<li>在C++的头文件中使用</li>
<li>在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到</li>
</ul>
<p>看一个简单的例子：
有moduleA、moduleB两个模块，B调用A中的代码，其中A是用C语言实现的，而B是利用C++实现的，下面给出一种实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//moduleA头文件</span><br><span class="line">#ifndef __MODULE_A_H //对于模块A来说，这个宏是为了防止头文件的重复引用</span><br><span class="line">#define __MODULE_A_H</span><br><span class="line">int fun(int, int);</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">//moduleA实现文件moduleA.C //模块A的实现部分并没有改变</span><br><span class="line">#include&quot;moduleA&quot;</span><br><span class="line">int fun(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//moduleB头文件</span><br><span class="line">#idndef __MODULE_B_H //很明显这一部分也是为了防止重复引用</span><br><span class="line">#define __MODULE_B_H</span><br><span class="line">#ifdef __cplusplus //而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件，因为cpp文件默认定义了该宏),则采用C语言方式进行编译</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#include&quot;moduleA.h&quot;</span><br><span class="line">#endif</span><br><span class="line">… //其他代码</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">//moduleB实现文件 moduleB.cpp //B模块的实现也没有改变，只是头文件的设计变化了</span><br><span class="line">#include&quot;moduleB.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　cout&lt;&lt;fun(2,3)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充介绍：
由于C、C++编译器对函数的编译处理是不完全相同的，尤其对于C++来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。例如函数void fun(int, int)，编译后的可能是_fun_int_int(不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而C语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun这样的名字。</p>
<p>看下面的一个面试题：为什么标准头文件都有类似的结构？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __INCvxWorksh /*防止该头文件被重复引用*/</span><br><span class="line">#define __INCvxWorksh</span><br><span class="line">#ifdef __cplusplus//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">/*…*/</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif /*end of __INCvxWorksh*/</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>显然，头文件中编译宏”#ifndef __INCvxWorksh 、#define __INCvxWorksh、#endif”的作用是为了防止该头文件被重复引用</li>
<li>那么以下代码的作用是什么呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus (其中__cplusplus是cpp中自定义的一个宏！！！)</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#endif</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>extern “C”包含双重含义，从字面上可以知道，首先，被它修饰的目标是”extern”的；其次，被它修饰的目标代码是”C”的。</p>
<ul>
<li>被extern “C”限定的函数或变量是extern类型的. extern是C/C++语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。记住，语句：extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，也并未为a分配空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出错。
通常来说，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字extern生命。例如，如果模块B要引用模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但并不会报错；它会在链接阶段从模块A编译生成的目标代码中找到该函数。
extern对应的关键字是static，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern C修饰。</li>
<li>被extern “C”修饰的变量和函数是按照C语言方式进行编译和链接的：这点很重要！！！！
上面也提到过，由于C++支持函数重载，而C语言不支持，因此函数被C++编译后在符号库中的名字是与C语言不同的；C++编译后的函数需要加上参数的类型才能唯一标定重载后的函数，而加上extern “C”后，是为了向编译器指明这段代码按照C语言的方式进行编译</li>
</ul>
<p>未加extern “C”声明时的链接方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//模块A头文件 moduleA.h</span><br><span class="line">#idndef _MODULE_A_H</span><br><span class="line">#define _MODULE_A_H</span><br><span class="line"> </span><br><span class="line">int foo(int x, int y);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>在模块B中调用该函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//模块B实现文件 moduleB.cpp</span><br><span class="line">#include&quot;moduleA.h&quot;</span><br><span class="line">foo(2,3);</span><br></pre></td></tr></table></figure>

<p>实际上，在链接阶段，链接器会从模块A生成的目标文件moduleA.obj中找_foo_int_int这样的符号，显然这是不可能找到的，因为foo()函数被编译成了_foo的符号，因此会出现链接错误。</p>
<h4 id="extern-“C”的使用要点总结"><a href="#extern-“C”的使用要点总结" class="headerlink" title="extern “C”的使用要点总结"></a>extern “C”的使用要点总结</h4><ol>
<li><p>可以是如下的单一语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; double sqrt(double);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以是复合语句, 相当于复合语句中的声明都加了extern “C”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">      double sqrt(double);</span><br><span class="line">      int min(int, int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以包含头文件，相当于头文件中的声明都加了extern “C”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    ＃include &lt;cmath&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不可以将extern “C” 添加在函数内部
如果函数有多个声明，可以都加extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。
除extern “C”, 还有extern “FORTRAN” 等。</p>
</li>
</ol>
<h4 id="C-11对匿名函数的支持"><a href="#C-11对匿名函数的支持" class="headerlink" title="C++11对匿名函数的支持"></a>C++11对匿名函数的支持</h4><p>C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式). Lambda表达式具体形式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条return语句组成或返回类型为void的话.形如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>下面举了几个Lambda函数的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[](int x, int y) &#123; return x + y; &#125; // 隐式返回类型</span><br><span class="line">[](int&amp; x) &#123; ++x; &#125;   // 没有return语句 -&gt; lambda 函数的返回类型是&apos;void&apos;</span><br><span class="line">[]() &#123; ++global_x; &#125;  // 没有参数,仅访问某个全局变量</span><br><span class="line">[]&#123; ++global_x; &#125;     // 与上一个相同,省略了()</span><br><span class="line">```　　　　</span><br><span class="line">可以像下面这样显示指定返回类型:</span><br></pre></td></tr></table></figure>

<p>[](int x, int y) -&gt; int { int z = x + y; return z; }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这个例子中创建了一个临时变量z来存储中间值. 和普通函数一样,这个中间值不会保存到下次调用. 什么也不返回的Lambda函数可以省略返回类型, 而不需要使用 -&gt; void 形式.Lambda函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包. 闭包被定义在Lambda表达式声明中的方括号[]内. 这个机制允许这些变量被按值或按引用捕获.下面这些例子就是:</span><br></pre></td></tr></table></figure>

<p>[]        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
[x, &amp;y]   //x 按值捕获, y 按引用捕获.
[&amp;]       //用到的任何外部变量都隐式按引用捕获
[=]       //用到的任何外部变量都隐式按值捕获
[&amp;, x]    //x显式地按值捕获. 其它变量按引用捕获
[=, &amp;z]   //z按引用捕获. 其它变量按值捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来的两个例子演示了Lambda表达式的用法.</span><br></pre></td></tr></table></figure>

<p>std::vector<int> some_list;
int total = 0;
for (int i=0;i&lt;5;++i) some_list.push_back(i);
std::for_each(begin(some_list), end(some_list), [&amp;total](int x) 
{
    total += x;
});</int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此例计算list中所有元素的总和. 变量total被存为lambda函数闭包的一部分. 因为它是栈变量(局部变量)total的引用,所以可以改变它的值.</span><br></pre></td></tr></table></figure>

<p>std::vector<int> some_list;
  int total = 0;
  int value = 5;
  std::for_each(begin(some_list), end(some_list), [&amp;, value, this](int x) 
  {
    total += x * value * this-&gt;some_func();
  });
```</int></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/04/21/l-cmake-syntax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/21/l-cmake-syntax/" itemprop="url">
                  cmake语法入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T14:35:44+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CMake-的基本操作"><a href="#CMake-的基本操作" class="headerlink" title="CMake 的基本操作"></a>CMake 的基本操作</h3><h4 id="CMake-编译可执行文件"><a href="#CMake-编译可执行文件" class="headerlink" title="CMake 编译可执行文件"></a>CMake 编译可执行文件</h4><p>一个打印 hello world 的 cpp 文件，通过 CMake 将它编译成可执行文件。</p>
<p>在 cpp 的同一目录下创建 CMakeLists.txt 文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 指定 CMake 使用版本</span><br><span class="line">cmake_minimum_required(VERSION 3.9)</span><br><span class="line"># 工程名</span><br><span class="line">project(HelloCMake)</span><br><span class="line"># 编译可执行文件</span><br><span class="line">add_executable(HelloCMake main.cpp )</span><br></pre></td></tr></table></figure>

<p>其中，通过 cmake_minimum_required 方法指定 CMake 使用版本，通过 project 指定工程名。
而 add_executable 就是指定最后编译的可执行文件名称和需要编译的 cpp 文件，如果工程很大，有多个 cpp 文件，那么都要把它们添加进来。
定义了 CMake 文件之后，就可以开始编译构建了。
CMake 在构建工程时会生成许多临时文件，避免让这些临时文件污染代码，一般会把它们放到一个单独的目录中。
操作步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在 cpp 目录下创建 build 目录</span><br><span class="line">mkdir build</span><br><span class="line"># 调用 cmake 命令生成 makefile 文件</span><br><span class="line">cmake ..</span><br><span class="line"># 编译</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>在 build 目录中可以找到最终生成的可执行文件。</p>
<p>这就是 CMake 的一个简单操作，将 cpp 编译成可执行文件，但在 Android 中，大多数场景都是把 cpp 编译成库文件。</p>
<h4 id="CMake-编译静态库和动态库"><a href="#CMake-编译静态库和动态库" class="headerlink" title="CMake 编译静态库和动态库"></a>CMake 编译静态库和动态库</h4><p>同样还是一个 cpp 文件和一个 CMake 文件，cpp 文件内容为打印字符串的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void print() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;hello lib&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，CMake 文件也要做相应更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.12)</span><br><span class="line"># 指定编译的库和文件，SHARED 编译动态库</span><br><span class="line">add_library(share_lib SHARED lib.cpp)</span><br><span class="line"># STATIC 编译静态库</span><br><span class="line"># add_library(share_lib STATIC lib.cpp)</span><br></pre></td></tr></table></figure>

<p>通过 add_library 指定要编译的库的名称，以及动态库还是静态库，还有要编译的文件。</p>
<p>最后同样地执行构建，在 build 目录下可以看到生成的库文件。</p>
<p>到这里，就基本可以使用 CMake 来构建 C/C++ 工程了。</p>
<h3 id="CMake-基本语法"><a href="#CMake-基本语法" class="headerlink" title="CMake 基本语法"></a>CMake 基本语法</h3><p>熟悉了上面的基本操作之后，就必然会遇到以下的问题了：</p>
<p>如果要参与编译的 C/C++ 文件很多，难道每个都要手动添加嘛？
可以把编译好的可执行文件或者库自动放到指定位置嘛?
可以把编译好的库指定版本号嘛？</p>
<p>带着这些问题，还是要继续深入学习 CMake 的相关语法，最好的学习材料就是 <a href="https://link.juejin.im/?target=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Fv3.12%2Findex.html" target="_blank" rel="noopener">官网文档</a> 了。
为了避免直接看官方文档时一头雾水，这里列举一些常用的语法命令。</p>
<h4 id="PROJECT-工程名字"><a href="#PROJECT-工程名字" class="headerlink" title="PROJECT(工程名字)"></a>PROJECT(工程名字)</h4><p>这条指令会自动创建两个变量：</p>
<ul>
<li><code>&lt;projectname&gt;_BINARY_DIR</code>(二进制文件保存路径)    </li>
<li><code>&lt;projectname&gt;_SOURCE_DIR</code>（源代码路径）</li>
</ul>
<p>cmake系统也帮助我们预定义了PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR其值与上述对应相等</p>
<h4 id="注释与大小写"><a href="#注释与大小写" class="headerlink" title="注释与大小写"></a>注释与大小写</h4><p>在前面就已经用到了 CMake 注释了，每一行的开头 # 代表注释。</p>
<p>另外，CMake 的所有语法指令是不区分大小写的。</p>
<h4 id="变量定义与消息打印"><a href="#变量定义与消息打印" class="headerlink" title="变量定义与消息打印"></a>变量定义与消息打印</h4><p>通过 set 来定义变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 变量名为 var，值为 hello</span><br><span class="line">set(var hello)</span><br></pre></td></tr></table></figure>

<p>当需要引用变量时，在变量名外面加上 ${} 符合来引用变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 引用 var 变量</span><br><span class="line">$&#123;var&#125;</span><br></pre></td></tr></table></figure>

<p>还可以通过 message 在命令行中输出打印内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(var hello) </span><br><span class="line">message($&#123;var&#125;)</span><br></pre></td></tr></table></figure>

<p>在IF等语句中,是直接使用变量名而不通过${}取值。</p>
<h4 id="数学和字符串操作"><a href="#数学和字符串操作" class="headerlink" title="数学和字符串操作"></a>数学和字符串操作</h4><h5 id="数学操作"><a href="#数学操作" class="headerlink" title="数学操作"></a>数学操作</h5><p>CMake 中通过 math 来实现数学操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># math 使用，EXPR 为大小</span><br><span class="line">math(EXPR &lt;output-variable&gt; &lt;math-expression&gt;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">math(EXPR var &quot;1+1&quot;)</span><br><span class="line"># 输出结果为 2</span><br><span class="line">message($&#123;var&#125;)</span><br></pre></td></tr></table></figure>

<p>math 支持 <code>+, -, *, /, %, |, &amp;, ^, ~, &lt;&lt;, &gt;&gt;</code>等操作，和 C 语言中大致相同。</p>
<h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>CMake 通过 string 来实现字符串的操作，这波操作有很多，包括将字符串全部大写、全部小写、求字符串长度、查找与替换等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set(var &quot;this is  string&quot;)</span><br><span class="line">set(sub &quot;this&quot;)</span><br><span class="line">set(sub1 &quot;that&quot;)</span><br><span class="line"># 字符串的查找，结果保存在 result 变量中</span><br><span class="line">string(FIND $&#123;var&#125; $&#123;sub1&#125; result )</span><br><span class="line"># 找到了输出 0 ，否则为 -1</span><br><span class="line">message($&#123;result&#125;)</span><br><span class="line"></span><br><span class="line"># 将字符串全部大写</span><br><span class="line">string(TOUPPER $&#123;var&#125; result)</span><br><span class="line">message($&#123;result&#125;)</span><br><span class="line"></span><br><span class="line"># 求字符串的长度</span><br><span class="line">string(LENGTH $&#123;var&#125; num)</span><br><span class="line">message($&#123;num&#125;)</span><br></pre></td></tr></table></figure>

<p>另外，通过空白或者分隔符号可以表示字符串序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(foo this is a list) // 实际内容为字符串序列</span><br><span class="line">message($&#123;foo&#125;)</span><br></pre></td></tr></table></figure>

<p>当字符串中需要用到空白或者分隔符时，再用双括号””表示为同一个字符串内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(foo &quot;this is a list&quot;) // 实际内容为一个字符串</span><br><span class="line">message($&#123;foo&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>Make 中通过 file 来实现文件操作，包括文件读写、下载文件、文件重命名等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 文件重命名</span><br><span class="line">file(RENAME &quot;test.txt&quot; &quot;new.txt&quot;)</span><br><span class="line"></span><br><span class="line"># 文件下载</span><br><span class="line"># 把文件 URL 设定为变量</span><br><span class="line">set(var &quot;http://img.zcool.cn/community/0117e2571b8b246ac72538120dd8a4.jpg&quot;)</span><br><span class="line"></span><br><span class="line"># 使用 DOWNLOAD 下载</span><br><span class="line">file(DOWNLOAD $&#123;var&#125; &quot;/Users/glumes/CLionProjects/HelloCMake/image.jpg&quot;)</span><br></pre></td></tr></table></figure>

<p>在文件的操作中，还有两个很重要的指令 GLOB 和 GLOB_RECURSE 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># GLOB 的使用</span><br><span class="line">file(GLOB ROOT_SOURCE *.cpp)</span><br><span class="line"># GLOB_RECURSE 的使用</span><br><span class="line">file(GLOB_RECURSE CORE_SOURCE ./detail/*.cpp)</span><br></pre></td></tr></table></figure>

<p>其中，GLOB 指令会将所有匹配 *.cpp 表达式的文件组成一个列表，并保存在 ROOT_SOURCE 变量中。
而 GLOB_RECURSE 指令和 GLOB 类似，但是它会遍历匹配目录的所有文件以及子目录下面的文件。
使用  GLOB 和 GLOB_RECURSE 有好处，就是当添加需要编译的文件时，不用再一个一个手动添加了，同一目录下的内容都被包含在对应变量中了，但也有弊端，就是新建了文件，但是 CMake 并没有改变，导致在编译时也会重新产生构建文件，要解决这个问题，就是动一动 CMake，让编译器检测到它有改变就好了。</p>
<h4 id="INSTALL指令"><a href="#INSTALL指令" class="headerlink" title="INSTALL指令"></a>INSTALL指令</h4><p>安装的需要有两种，一种是从代码编译后直接make install安装，一种是打包时的指定目录安装。 
这里需要引入一个新的cmake 指令 INSTALL和一个非常有用的变量CMAKE_INSTALL_PREFIX。 
CMAKE_INSTALL_PREFIX变量类似于configure脚本的 –prefix，常见的使用方法看起来是这个样子： 
<code>cmake -DCMAKE_INSTALL_PREFIX=/usr .</code></p>
<p>INSTALL指令用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。INSTALL指令包含了各种安装类型，我们需要一个个分开解释：</p>
<h5 id="目标文件的安装"><a href="#目标文件的安装" class="headerlink" title="目标文件的安装"></a>目标文件的安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(TARGETS targets...</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME]</span><br><span class="line">                   [DESTINATION &lt;dir&gt;]</span><br><span class="line">                   [PERMISSIONS permissions...]</span><br><span class="line">                   [CONFIGURATIONS</span><br><span class="line">        [Debug|Release|...]]</span><br><span class="line">                   [COMPONENT &lt;component&gt;]</span><br><span class="line">                   [OPTIONAL]</span><br><span class="line">                ] [...])</span><br></pre></td></tr></table></figure>

<p>参数中的TARGETS后面跟的就是我们通过ADD_EXECUTABLE或者ADD_LIBRARY定义的目标文件，可能是可执行二进制、动态库、静态库。目标类型也就相对应的有三种，ARCHIVE特指静态库，LIBRARY特指动态库，RUNTIME特指可执行目标二进制。
DESTINATION定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候CMAKE_INSTALL_PREFIX其实就无效了。如果你希望使用CMAKE_INSTALL_PREFIX来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是 <code>${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION定义的路径&gt;</code>
举个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(TARGETS myrun mylib mystaticlib</span><br><span class="line">       RUNTIME DESTINATION bin</span><br><span class="line">       LIBRARY DESTINATION lib</span><br><span class="line">       ARCHIVE DESTINATION libstatic</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子会将： </p>
<ul>
<li>可执行二进制myrun安装到${CMAKE_INSTALL_PREFIX}/bin目录 </li>
<li>动态库libmylib安装到${CMAKE_INSTALL_PREFIX}/lib目录 </li>
<li>静态库libmystaticlib安装到${CMAKE_INSTALL_PREFIX}/libstatic目录 
特别注意的是你不需要关心TARGETS具体生成的路径，只需要写上TARGETS名称就可以 
了。<h5 id="普通文件的安装"><a href="#普通文件的安装" class="headerlink" title="普通文件的安装"></a>普通文件的安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(FILES files... DESTINATION &lt;dir&gt;</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。
如果默认不定义权限PERMISSIONS，安装后的权限为,OWNER_WRITE,OWNER_READ,
GROUP_READ,和WORLD_READ，即644权限。</p>
<h5 id="非目标文件的可执行程序安装-比如脚本之类"><a href="#非目标文件的可执行程序安装-比如脚本之类" class="headerlink" title="非目标文件的可执行程序安装(比如脚本之类)"></a>非目标文件的可执行程序安装(比如脚本之类)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(PROGRAMS files... DESTINATION &lt;dir&gt;</span><br><span class="line">     [PERMISSIONS permissions...]</span><br><span class="line">     [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">     [COMPONENT &lt;component&gt;]</span><br><span class="line">     [RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure>

<p>跟上面的FILES指令使用方法一样，唯一的不同是安装后权限为: 
OWNER_EXECUTE, GROUP_EXECUTE, 和WORLD_EXECUTE，即755权限</p>
<h5 id="目录的安装"><a href="#目录的安装" class="headerlink" title="目录的安装"></a>目录的安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(DIRECTORY dirs... DESTINATION &lt;dir&gt;</span><br><span class="line">     [FILE_PERMISSIONS permissions...]</span><br><span class="line">     [DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">     [USE_SOURCE_PERMISSIONS]</span><br><span class="line">     [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">     [COMPONENT &lt;component&gt;]</span><br><span class="line">     [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">      [EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br></pre></td></tr></table></figure>

<p>这里主要介绍其中的DIRECTORY、PATTERN以及PERMISSIONS参数。 </p>
<ul>
<li>DIRECTORY后面连接的是所在Source目录的相对路径，但务必注意： abc和abc/有很大的区别。 abc意味着abc这个目录会安装在目标路径下； abc/意味着abc这个目录的内容会被安装在目标路径下； 如果目录名不以/结尾，那么这个目录将被安装为目标路径下的abc，如果目录名以/结尾， 代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。 </li>
<li>PATTERN用于使用正则表达式进行过滤， </li>
<li>PERMISSIONS用于指定PATTERN过滤后的文件权限。</li>
</ul>
<p>我们来看一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj</span><br><span class="line">        PATTERN &quot;CVS&quot; EXCLUDE</span><br><span class="line">        PATTERN &quot;scripts/*&quot;</span><br><span class="line">        PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ</span><br><span class="line">        GROUP_EXECUTE GROUP_READ)</span><br></pre></td></tr></table></figure>

<p>这条指令的执行结果是： 
将icons目录安装到 <code>&lt;prefix&gt;/share/myproj</code>，将<code>scripts/</code>中的内容安装到 <code>&lt;prefix&gt;/share/myproj</code>不包含目录名为CVS的目录，对于scripts/*文件指定权限为 OWNER_EXECUTE 
OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ.</p>
<h5 id="安装时cmake脚本的执行"><a href="#安装时cmake脚本的执行" class="headerlink" title="安装时cmake脚本的执行"></a>安装时cmake脚本的执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALL([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]] [...])</span><br><span class="line">SCRIPT参数用于在安装时调用cmake脚本文件（也就是&lt;abc&gt;.cmake文件）</span><br><span class="line">CODE参数用于执行CMAKE指令，必须以双引号括起来。比如：</span><br><span class="line">INSTALL(CODE &quot;MESSAGE(\&quot;Sample install message.\&quot;)&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="把相对路径转换成绝对路径"><a href="#把相对路径转换成绝对路径" class="headerlink" title="把相对路径转换成绝对路径"></a>把相对路径转换成绝对路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_filename_component(&lt;VAR&gt; &lt;FileName&gt;</span><br><span class="line">                       &lt;COMP&gt; [BASE_DIR &lt;BASE_DIR&gt;]</span><br><span class="line">                       [CACHE])</span><br></pre></td></tr></table></figure>

<p>Set <var> to the absolute path of <filename>, where <comp> is one of:</comp></filename></var></p>
<ul>
<li>ABSOLUTE = Full path to file REALPATH = Full path to existing file with symlinks resolved</li>
<li>If the provided <filename> is a relative path, it is evaluated relative to the given base directory <base_dir>. If no base directory is provided, the default base directory will be CMAKE_CURRENT_SOURCE_DIR.</base_dir></filename></li>
<li>Paths are returned with forward slashes and have no trailing slashes. If the optional CACHE argument is specified, the result variable is added to the cache.</li>
</ul>
<p>To convert an absolute path to a file into a relative paths, you might use the file command:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(RELATIVE_PATH &lt;variable&gt; &lt;directory&gt; &lt;file&gt;)</span><br></pre></td></tr></table></figure>

<p>Compute the relative path from a <code>&lt;directory&gt;</code> to a <code>&lt;file&gt;</code> and store it in the <code>&lt;variable&gt;</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(RELATIVE_PATH buildDirRelFilePath &quot;$&#123;CMAKE_BINARY_DIR&#125;&quot; &quot;$&#123;myFile&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="预定义的常量"><a href="#预定义的常量" class="headerlink" title="预定义的常量"></a>预定义的常量</h4><p>在 CMake 中有许多预定义的常量，使用好这些常量能起到事半功倍的效果。</p>
<ul>
<li><p>CMAKE_BINARY_DIR </p>
</li>
<li><p>PROJECT_BINARY_DIR </p>
</li>
<li><p>&lt; projectname &gt;_BINARY_DIR 
这三个变量指代的内容是一致的，如果是in-source编译，指得就是工程顶层目录；如果是out-of-source编译，指的是工程编译发生的目录。PROJECT_BINARY_DIR跟其它指令稍有区别，目前可以认为它们是一致的。</p>
</li>
<li><p>CMAKE_SOURCE_DIR </p>
</li>
<li><p>PROJECT_SOURCE_DIR </p>
</li>
<li><p>&lt; projectname &gt;_SOURCE_DIR 
这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。也就是在in-source编译时,他跟CMAKE_BINARY_DIR等变量一致。PROJECT_SOURCE_DIR跟其它指令稍有区别,目前可以认为它们是一致的。 
（out-of-source build与in-source build相对，指是否在CMakeLists.txt所在目录进行编译。）</p>
</li>
<li><p>CMAKE_CURRENT_SOURCE_DIR : 前处理的CMakeLists.txt所在的路径，比如上面我们提到的src子目录。</p>
</li>
<li><p>CMAKE_CURRRENT_BINARY_DIR 如果是in-source编译，它跟CMAKE_CURRENT_SOURCE_DIR一致；如果是out-of-source编译，指的是target编译目录。使用ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。使用SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径。</p>
</li>
<li><p>CMAKE_CURRENT_LIST_FILE : 输出调用这个变量的CMakeLists.txt的完整路径</p>
</li>
<li><p>CMAKE_CURRENT_LIST_LINE : 输出这个变量所在的行</p>
</li>
<li><p>CMAKE_MODULE_PATH : 这个变量用来定义自己的cmake模块所在的路径。如果工程比较复杂，有可能会自己编写一些cmake模块，这些cmake模块是随工程发布的，为了让cmake在处理CMakeLists.txt时找到这些模块，你需要通过SET指令将cmake模块路径设置一下。比如SET(CMAKE_MODULE_PATH,${PROJECT_SOURCE_DIR}/cmake) 
这时候就可以通过INCLUDE指令来调用自己的模块了。</p>
</li>
<li><p>EXECUTABLE_OUTPUT_PATH : 新定义最终结果的存放目录</p>
</li>
<li><p>LIBRARY_OUTPUT_PATH : 新定义最终结果的存放目录</p>
</li>
<li><p>PROJECT_SOURCE_DIR : 指当前工程的路径</p>
</li>
<li><p>PROJECT_NAME : 返回通过PROJECT指令定义的项目名称</p>
</li>
</ul>
<p>比如，在 add_library 中需要指定 cpp 文件的路径，以 CMAKE_CURRENT_SOURCE_DIR 为基准，指定 cpp 相对它的路径就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 利用预定义的常量来指定文件路径</span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             openglutil</span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/opengl_util.cpp</span><br><span class="line">             )</span><br></pre></td></tr></table></figure>

<h4 id="平台相关的常量"><a href="#平台相关的常量" class="headerlink" title="平台相关的常量"></a>平台相关的常量</h4><p>CMake 能够用来在 Window、Linux、Mac 平台下进行编译，在它的内部也定义了和这些平台相关的变量。</p>
<p>列举一些常见的：</p>
<ul>
<li>WIN32:如果编译的目标系统是 Window,那么 WIN32 为 True 。</li>
<li>UNIX:如果编译的目标系统是 Unix 或者类 Unix 也就是 Linux ,那么 UNIX 为 True 。</li>
<li>MSVC:如果编译器是 Window 上的 Visual C++ 之类的，那么 MSVC 为 True 。</li>
<li>ANDROID:如果目标系统是 Android ，那么 ANDROID 为 1 。</li>
<li>APPLE:如果目标系统是 APPLE ，那么 APPLE 为 1 。</li>
</ul>
<p>有了这些常量做区分，就可以在一份 CMake 文件中编写不同平台的编译选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(WIN32)&#123;</span><br><span class="line">    # do something</span><br><span class="line">&#125;elseif(UNIX)&#123;</span><br><span class="line">    # do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toolChain脚本中设置的几个重要变量"><a href="#toolChain脚本中设置的几个重要变量" class="headerlink" title="toolChain脚本中设置的几个重要变量"></a>toolChain脚本中设置的几个重要变量</h4><ol>
<li>CMAKE_SYSTEM_NAME: 即你目标机target所在的操作系统名称，比如ARM或者Linux你就需要写”Linux”,如果Windows平台你就写”Windows”,如果你的嵌入式平台没有相关OS你即需要写成”Generic”,只有当CMAKE_SYSTEM_NAME这个变量被设置了，CMake才认为此时正在交叉编译，它会额外设置一个变量CMAKE_CROSSCOMPILING为TRUE.</li>
<li>CMAKE_C_COMPILER: 顾名思义，即C语言编译器，这里可以将变量设置成完整路径或者文件名，设置成完整路径有一个好处就是CMake会去这个路径下去寻找编译相关的其他工具比如linker,binutils等，如果你写的文件名带有arm-elf等等前缀，CMake会识别到并且去寻找相关的交叉编译器。</li>
<li>CMAKE_CXX_COMPILER: 同上，此时代表的是C++编译器。</li>
<li>CMAKE_FIND_ROOT_PATH: 指定了一个或者多个优先于其他搜索路径的搜索路径。比如你设置了/opt/arm/，所有的Find_xxx.cmake都会优先根据这个路径下的/usr/lib,/lib等进行查找，然后才会去你自己的/usr/lib和/lib进行查找，如果你有一些库是不被包含在/opt/arm里面的，你也可以显示指定多个值给CMAKE_FIND_ROOT_PATH,比如<code>set(CMAKE_FIND_ROOT_PATH /opt/arm /opt/inst)</code>该变量能够有效地重新定位在给定位置下进行搜索的根路径。该变量默认为空。当使用交叉编译时，该变量十分有用：用该变量指向目标环境的根目录，然后CMake将会在那里查找。    </li>
<li>CMAKE_FIND_ROOT_PATH_MODE_PROGRAM: 对FIND_PROGRAM()起作用，有三种取值，NEVER,ONLY,BOTH,第一个表示不在你CMAKE_FIND_ROOT_PATH下进行查找，第二个表示只在这个路径下查找，第三个表示先查找这个路径，再查找全局路径，对于这个变量来说，一般都是调用宿主机的程序，所以一般都设置成NEVER</li>
<li>CMAKE_FIND_ROOT_PATH_MODE_LIBRARY: 对FIND_LIBRARY()起作用，表示在链接的时候的库的相关选项，因此这里需要设置成ONLY来保证我们的库是在交叉环境中找的.</li>
<li>CMAKE_FIND_ROOT_PATH_MODE_INCLUDE: 对FIND_PATH()和FIND_FILE()起作用，一般来说也是ONLY,如果你想改变，一般也是在相关的FIND命令中增加option来改变局部设置，有NO_CMAKE_FIND_ROOT_PATH,ONLY_CMAKE_FIND_ROOT_PATH,BOTH_CMAKE_FIND_ROOT_PATH</li>
<li>BOOST_ROOT：对于需要boost库的用户来说，相关的boost库路径配置也需要设置，因此这里的路径即ARM下的boost路径，里面有include和lib。</li>
<li>QT_QMAKE_EXECUTABLE: 对于Qt用户来说，需要更改相关的qmake命令切换成嵌入式版本，因此这里需要指定成相应的qmake路径（指定到qmake本身）</li>
</ol>
<h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><ol>
<li>CMAKE_MAJOR_VERSION，CMAKE主版本号，比如2.4.6中的2</li>
<li>CMAKE_MINOR_VERSION，CMAKE次版本号，比如2.4.6中的4</li>
<li>CMAKE_PATCH_VERSION，CMAKE补丁等级，比如2.4.6 中的6</li>
<li>CMAKE_SYSTEM，系统名称，比如Linux-2.6.22</li>
<li>CMAKE_SYSTEM_NAME，不包含版本的系统名，比如Linux</li>
<li>CMAKE_SYSTEM_VERSION，系统版本，比如2.6.22</li>
<li>CMAKE_SYSTEM_PROCESSOR，处理器名称，比如i686.</li>
<li>UNIX，在所有的类UNIX平台为TRUE，包括OS X和cygwin</li>
<li>WIN32，在所有的win32平台为TRUE，包括cygwin</li>
</ol>
<h4 id="主要的开关选项："><a href="#主要的开关选项：" class="headerlink" title="主要的开关选项："></a>主要的开关选项：</h4><ol>
<li>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS，用来控制IF ELSE语句的书写方式</li>
<li>BUILD_SHARED_LIBS 这个开关用来控制默认的库编译方式，如果不进行设置，使用ADD_LIBRARY并没有指定库类型的情况下，默认编译生成的库都是静态库。如果SET(BUILD_SHARED_LIBS ON)后，默认生成的为动态库。</li>
<li>CMAKE_C_FLAGS 设置C编译选项，也可以通过指令ADD_DEFINITIONS()添加。</li>
<li>CMAKE_CXX_FLAGS 设置C++编译选项，也可以通过指令ADD_DEFINITIONS()添加。</li>
</ol>
<h4 id="函数、宏、流程控制和选项-等命令"><a href="#函数、宏、流程控制和选项-等命令" class="headerlink" title="函数、宏、流程控制和选项 等命令"></a>函数、宏、流程控制和选项 等命令</h4><p>具体参考<a href="https://link.juejin.im/?target=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Fv3.12%2Fmanual%2Fcmake-commands.7.html" target="_blank" rel="noopener">cmake-commands</a> ，这里面包括了很多重要且常见的指令。</p>
<p>简单示例 CMake 中的函数操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function(add a b)</span><br><span class="line">    message(&quot;this is function call&quot;)</span><br><span class="line">    math(EXPR num &quot;$&#123;a&#125; + $&#123;b&#125;&quot; )</span><br><span class="line">    message(&quot;result is $&#123;aa&#125;&quot;)</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line">add(1 2)</span><br></pre></td></tr></table></figure>

<p>其中，function 为定义函数，第一个参数为函数名称，后面为函数参数。</p>
<p>在调用函数时，参数之间用空格隔开，不要用逗号。</p>
<p>宏的使用与函数使用有点类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">macro(del a b)</span><br><span class="line">    message(&quot;this is macro call&quot;)</span><br><span class="line">    math(EXPR num &quot;$&#123;a&#125; - $&#123;b&#125;&quot;)</span><br><span class="line">    message(&quot;num is $&#123;num&#125;&quot;)</span><br><span class="line">endmacro()</span><br><span class="line"></span><br><span class="line">del(1 2)</span><br></pre></td></tr></table></figure>

<p>在流程控制方面，CMake 也提供了 if、else 这样的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set(num 0)</span><br><span class="line">if (1 AND $&#123;num&#125;)</span><br><span class="line">    message(&quot;and operation&quot;)</span><br><span class="line">elseif (1 OR $&#123;num&#125;)</span><br><span class="line">    message(&quot;or operation&quot;)</span><br><span class="line">else ()</span><br><span class="line">    message(&quot;not reach&quot;)</span><br><span class="line">endif ()</span><br></pre></td></tr></table></figure>

<p>其中，CMake 提供了 AND、OR、NOT、LESS、EQUAL 等等这样的操作来对数据进行判断，比如 AND 就是要求两边同为 True 才行。</p>
<p>另外 CMake 还提供了循环迭代的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set(stringList this is string list)</span><br><span class="line">foreach (str $&#123;stringList&#125;)</span><br><span class="line">    message(&quot;str is $&#123;str&#125;&quot;)</span><br><span class="line">endforeach ()</span><br></pre></td></tr></table></figure>

<p>CMake 还提供了一个 option 指令。</p>
<p>可以通过它来给 CMake 定义一些全局选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">option(ENABLE_SHARED &quot;Build shared libraries&quot; TRUE)</span><br><span class="line"></span><br><span class="line">if(ENABLE_SHARED)</span><br><span class="line">    # do something</span><br><span class="line">else()</span><br><span class="line">    # do something   </span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<p>可能会觉得 option 无非就是一个 True or False 的标志位，可以用变量来代替，但使用变量的话，还得添加 ${} 来表示变量，而使用 option 直接引用名称就好了。</p>
<h3 id="CMake-阅读实践"><a href="#CMake-阅读实践" class="headerlink" title="CMake 阅读实践"></a>CMake 阅读实践</h3><p>明白了上述的 CMake 语法以及从官网去查找陌生的指令意思，就基本上可以看懂大部分的 CMake 文件了。
这里举两个开源库的例子：</p>
<ol>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fg-truc%2Fglm" target="_blank" rel="noopener">github.com/g-truc/glm</a></li>
</ol>
<ul>
<li>glm 是一个用来实现矩阵计算的，在 OpenGL 的开发中会用到。</li>
<li>CMakeLists.txt 地址在 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fg-truc%2Fglm%2Fblob%2Fmaster%2FCMakeLists.txt" target="_blank" rel="noopener">这里</a></li>
</ul>
<ol start="2">
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Flibjpeg-turbo%2Flibjpeg-turbo" target="_blank" rel="noopener">github.com/libjpeg-tur</a></li>
</ol>
<ul>
<li>libjpeg-turbo 是用来进行图片压缩的，在 Android 底层就是用的它。</li>
<li>CMakeLists.txt 地址在 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Flibjpeg-turbo%2Flibjpeg-turbo%2Fblob%2Fmaster%2FCMakeLists.txt" target="_blank" rel="noopener">这里</a></li>
</ul>
<p>这两个例子中大量用到了前面所讲的内容，可以试着读一读增加熟练度。</p>
<h3 id="为编译的库设置属性"><a href="#为编译的库设置属性" class="headerlink" title="为编译的库设置属性"></a>为编译的库设置属性</h3><p>接下来再回到用 CMake 编译动态库的话题上，毕竟 Android NDK 开发也主要是用来编译库了，当编译完 so 之后，我们可以对它做一些操作。</p>
<p>通过 set_target_properties 来给编译的库设定相关属性内容，函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(target1 target2 ...</span><br><span class="line">                      PROPERTIES prop1 value1</span><br><span class="line">                      prop2 value2 ...)</span><br></pre></td></tr></table></figure>

<p>比如，要将编译的库改个名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(native-lib PROPERTIES OUTPUT_NAME &quot;testlib&quot; )</span><br></pre></td></tr></table></figure>

<p>更多的属性内容可以参考 官方文档。</p>
<p>不过，这里面有一些属性设定无效，在 Android Studio 上试了无效，在 CLion 上反而可以，当然也可能是我使用姿势不对。</p>
<p>比如，实现动态库的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(native-lib PROPERTIES VERSION 1.2 SOVERSION 1 )</span><br></pre></td></tr></table></figure>

<p>对于已经编译好的动态库，想要把它导入进来，也需要用到一个属性。</p>
<p>比如编译的 FFmpeg 动态库，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 IMPORTED 表示导入库</span><br><span class="line">add_library(avcodec-57_lib SHARED IMPORTED)</span><br><span class="line"># 使用 IMPORTED_LOCATION 属性指定库的路径</span><br><span class="line">set_target_properties(avcodec-57_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                        $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/main/jniLibs/armeabi/libavcodec-57.so )</span><br></pre></td></tr></table></figure>

<h3 id="链接到其他的库"><a href="#链接到其他的库" class="headerlink" title="链接到其他的库"></a>链接到其他的库</h3><p>如果编译了多个库，并且想库与库之间进行链接，那么就要通过 target_link_libraries 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries( native-lib</span><br><span class="line">                       glm</span><br><span class="line">                       turbojpeg</span><br><span class="line">                       log )</span><br></pre></td></tr></table></figure>

<p>在 Android 底层也提供了一些 so 库供上层链接使用，也要通过上面的方式来链接，比如最常见的就是 log 库打印日志。
如果要链接自己编译的多个库文件，首先要保证每个库的代码都对应一个 CMakeLists.txt 文件，这个 CMakeLists.txt 文件指定当前要编译的库的信息。
然后在当前库的 CMakeLists.txt 文件中通过 ADD_SUBDIRECTORY 将其他库的目录添加进来，这样才能够链接到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_SUBDIRECTORY(src/main/cpp/turbojpeg)</span><br><span class="line">ADD_SUBDIRECTORY(src/main/cpp/glm)</span><br></pre></td></tr></table></figure>

<p><code>ADD_SUBDIRECTORY(src_dir [binary_dir] [EXCLUDE_FROM_ALL])</code>
向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制的存放位置
EXCLUDE_FROM_ALL含义：将这个目录从编译过程中排除
SET(EXECUTABLE_OUTPUT_PATH${PROJECT_BINARY_DIR}/bin)更改生成的可执行文件路径
SET(LIBRARY_OUTPUT_PATH${PROJECT_BINARY_DIR}/lib)更改生成的库文件路径</p>
<h3 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h3><p>在使用的时候有一个容易忽略的步骤就是添加头文件，通过 include_directories 指令把头文件目录包含进来。
这样就可以直接使用 <code>#include &quot;header.h&quot;</code> 的方式包含头文件，而不用  <code>#include &quot;path/path/header.h&quot;</code> 这样添加路径的方式来包含。</p>
<h3 id="区分debug、release版本"><a href="#区分debug、release版本" class="headerlink" title="区分debug、release版本"></a>区分debug、release版本</h3><p>建立debug/release两目录，分别在其中执行cmake -D CMAKE_BUILD_TYPE=Debug（或Release），需要编译不同版本时进入不同目录执行make即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug版会使用参数-g；</span><br><span class="line">Release版使用-O3–DNDEBUG</span><br></pre></td></tr></table></figure>

<p>另一种设置方法——例如DEBUG版设置编译参数DDEBUG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF(DEBUG_mode)</span><br><span class="line">    add_definitions(-DDEBUG)</span><br><span class="line">ENDIF()</span><br></pre></td></tr></table></figure>

<p>在执行cmake时增加参数即可，例如<code>cmake -D DEBUG_mode=ON</code></p>
<h3 id="设置条件编译"><a href="#设置条件编译" class="headerlink" title="设置条件编译"></a>设置条件编译</h3><p>例如debug版设置编译选项DEBUG，并且更改不应改变CMakelist.txt 
使用option command，eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option(DEBUG_mode&quot;ON for debug or OFF for release&quot; ON)</span><br><span class="line">IF(DEBUG_mode)</span><br><span class="line">    add_definitions(-DDEBUG)</span><br><span class="line">ENDIF()</span><br></pre></td></tr></table></figure>

<p>使其生效的方法：首先cmake生成makefile，然后make edit_cache编辑编译选项；Linux下会打开一个文本框，可以更改，改完后再make生成目标文件——emacs不支持make edit_cache；
局限：这种方法不能直接设置生成的makefile，而是必须使用命令在make前设置参数；对于debug、release版本，相当于需要两个目录，分别先cmake一次，然后分别makeedit_cache一次；
期望的效果：在执行cmake时直接通过参数指定一个开关项，生成相应的makefile。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/04/04/util-gerrit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/04/util-gerrit/" itemprop="url">
                  gerrit工具介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T10:56:50+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Gerrit的gerrit query命令就是要查询Gerrit的changes数据库。</p>
<p>默认，查询结果是根据changes的更新时间，由近及远排序。</p>
<p>对于有多个patch set的change，默认查询结果只包含最后的patch set。</p>
<p>如果查询结果有很大，则默认只返回有限个查询结果，可以设置limit:参数指定查询结果包含的changes数量。</p>
<h3 id="1-gerrit-query命令用法："><a href="#1-gerrit-query命令用法：" class="headerlink" title="1. gerrit query命令用法："></a>1. gerrit query命令用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ssh -p &lt;port&gt; &lt;host&gt; gerrit query</span><br><span class="line">  [--format &#123;TEXT | JSON&#125;]</span><br><span class="line">  [--current-patch-set]</span><br><span class="line">  [--patch-sets | --all-approvals]</span><br><span class="line">  [--files]</span><br><span class="line">  [--comments]</span><br><span class="line">  [--commit-message]</span><br><span class="line">  [--dependencies]</span><br><span class="line">  [--submit-records]</span><br><span class="line">  [--all-reviewers]</span><br><span class="line">  [--start &lt;n&gt; | -S &lt;n&gt;]</span><br><span class="line">  &lt;query&gt;</span><br><span class="line">  [limit:&lt;n&gt;]</span><br></pre></td></tr></table></figure>

<p>常见选项说明：</p>
<ul>
<li>–format=TEXT，默认</li>
<li>–format=JSON</li>
<li>–current-patch-set，给出当前patch set的信息</li>
<li>–patch-sets，给出所有patch set的信息</li>
<li>–commit-message，给出change的完整commit message</li>
<li>–all-reviewers，给出所有reviewer的name和email
<code>&lt;query&gt;</code>说明：</li>
<li>status:open等价于status:pending, is:open, is:pending</li>
<li>owner:self等价于is:owner</li>
<li>reviewer:self等价于is:reviewer</li>
<li>project:bbauto/bba或p:bbauto/bba</li>
<li>projects:bb</li>
<li>branch:develop或branch:refs/heads/develop</li>
<li>change:2311176或change:I03369813660369e983b56dcabe4cb48839be4de0</li>
<li>commit:4e8ea8d43ab22273e4949348e1e7316f88cd54e3</li>
<li>ref:refs/changes/76/2311176/1</li>
<li>message:my_commit_message</li>
<li>is:visible</li>
<li>label:Code-Review=2或label:Code-Review=+2或label:Code-Review+2</li>
<li>label:Verified+1
补充：</li>
<li>属性值除了bare words (数字、大小写字母和@-_.)之外，必须使用””或{}包含</li>
<li>多个属性之间默认为and关系，还有or关系，或者取反not/-</li>
</ul>
<p>查询Gerrit指定状态的patch set,并保存到文件。采用分段查看首先查看最近500条的，再查看最近500-1000条的。</p>
<p><code>alias gerrit=&quot;ssh -p 29418 gerrit.yourdomain.com gerrit&quot;</code>
<code>gerrit review &lt;id&gt; --abandon</code> 放弃某个commit(id是commit id不是change id)</p>
<p><code>ssh -p 29418 192.168.1.127 gerrit review --submit a6b548272aa754857b4</code> 提交某个commit
循环放弃脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">alias gerrit=&quot;ssh -p 29418 gerrit.lianjia.com gerrit&quot; </span><br><span class="line"></span><br><span class="line">for c in $(gerrit query project:mars --start 500 --current-patch-set| grep &quot;revision&quot;);do</span><br><span class="line">    if [ $c != &apos;revision:&apos; ];then</span><br><span class="line">        gerrit review $c --abandon;</span><br><span class="line">        echo $c</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="2-参考文献："><a href="#2-参考文献：" class="headerlink" title="2.参考文献："></a>2.参考文献：</h3><p><a href="https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/cmd-query.html" target="_blank" rel="noopener">https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/cmd-query.html</a>
<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/json.html" target="_blank" rel="noopener">https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/json.html</a>
<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/user-search.html" target="_blank" rel="noopener">https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/user-search.html</a></p>
<h3 id="3-gerrit-不经代码审核直接push进库的方法"><a href="#3-gerrit-不经代码审核直接push进库的方法" class="headerlink" title="3.gerrit 不经代码审核直接push进库的方法"></a>3.gerrit 不经代码审核直接push进库的方法</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h4><p>gerrit 代码审核将代码入库权限收起,可以有效控制代码质量.</p>
<p>但同时弊端也是明显的: 对于频繁改动的项目(比如新项目),每段代码都审核会明显拖慢工作效率.</p>
<p>这时可以给某个组配置不经审核直接push权限.</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h4><p>管理员账号,到 projects -&gt; access 页面下配置 reference 权限.
其他 reference 的权限配置依旧, 给如下 reference 增加权限:
refs/for/refs/heads/master
配置 submit 权限给某个具体的组即可.</p>
<p>该组用户需要忽略审核时,执行如下命令:
git push origin HEAD:refs/for/master%submit
就是在原有 push 命令基础上加上 %submit 这个后缀即可.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/27/tips-android-sqlite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/27/tips-android-sqlite/" itemprop="url">
                  tips-android-sqlite
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T09:57:57+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">08-30 20:27:36.751 E/CursorWindow(  760): Could not allocate CursorWindow &apos;/data/data/com.android.providers.media/databases/external.db&apos; of size 2097152 due to error -12.</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760): *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760): android.database.CursorWindowAllocationException: Cursor window allocation of 2048 kb failed. # Open Cursors=781 (# cursors opened by pid 3105=781)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.CursorWindow.&lt;init&gt;(CursorWindow.java:104)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.AbstractWindowedCursor.clearOrCreateWindow(AbstractWindowedCursor.java:198)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.sqlite.SQLiteCursor.fillWindow(SQLiteCursor.java:162)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.sqlite.SQLiteCursor.getCount(SQLiteCursor.java:156)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.CursorToBulkCursorAdaptor.count(CursorToBulkCursorAdaptor.java:184)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:117)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.os.Binder.execTransact(Binder.java:338)</span><br><span class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at dalvik.system.NativeStart.run(Native Method)</span><br></pre></td></tr></table></figure>

<p>错误原因
CursorWindow缓存数据达到最大限制（2Ｍ不同的机器和SQLite版本其值可能不同）后，仍有查询结果集需要缓存，在申请内存分配时申请失败发生了OOM内存溢出；SQLite查询出的数据集cursor，都由native层的CursorWindow进行数据管理，包括内存空间的申请和数据的填充。CursorWindow实际上是共享内存的抽象，以实现跨进程，跨应用数据共享（ContentProvider作为数据通道，也支持跨进程，跨应用的数据访问）
在ContentProvider端透过SQLiteDatabase的封装查询到的数据集保存在CursorWindow所指向的共享内存中，然后通过Binder把这片共享内存传递到ContentResolver端，即查询端。这样客户就可以通过Cursor来访问这块共享内存中的数据集了。
解决办法
保证CursorWindow不会达到最大限制）：</p>
<ol>
<li>只查询需要的字段；根据UI显示需要，或实际需要查询的字段进行查询，尽量不会表查询</li>
<li>二进制文件不要存在数据库中；数据库仅适用于保存一些较短文字，整数，布尔，浮点数等一些，易于查询和操作的轻量级的数据，目的也是在于快速搜索和查询。对于像图片，较长的文字（如文章）等大数据，最好直接以文件形式存储在硬盘中，然后在数据库保存它们的访问路径</li>
<li>对于大数据量的查询采用分段查询方式；无论表中的一条记录数据量如何的小，当条数达到5000级或者万级或者更多的时候，还是会达到最大的限制</li>
<li>正确的关闭Cursor，释放CursorWindow中不用的资源（需手动调用释放native中的资源，类似3.0之前的Bitmap需要手动释放。调用close的必要性：</li>
</ol>
<p><a href="https://blog.csdn.net/u011453773/article/details/50731250" target="_blank" rel="noopener">从源码看ANDROID中SQLITE是怎么通过CURSORWINDOW读DB的</a></p>
<h3 id="Sqlite性能优化"><a href="#Sqlite性能优化" class="headerlink" title="Sqlite性能优化"></a>Sqlite性能优化</h3><p>(1)编译SQL语句
Sqlite想要执行操作，需要将程序中的sql语句编译成对应的SQLiteStatement,比如select * from record这一句，被执行100次就需要编译100次。对于批量处理插入或者更新的操作，我们可以使用显示编译来做到重用SQLiteStatement。</p>
<p>想要做到重用SQLiteStatement也比较简单，基本如下：</p>
<p>编译sql语句获得SQLiteStatement对象，参数使用?代替 
在循环中对SQLiteStatement对象进行具体数据绑定，bind方法中的index从1开始，不是0</p>
<p>如下向person表中插入100条数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void insertBatchPreCompile() &#123;</span><br><span class="line">        long start = SystemClock.currentThreadTimeMillis();</span><br><span class="line">        String sql = &quot;insert into &quot; + TAB_PERSON + &quot; values (?,&apos;test&apos;,&apos;1&apos;);&quot;;</span><br><span class="line">        SQLiteStatement sqLiteStatement = getReadableDatabase().compileStatement(sql);</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (count &lt; 100) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            sqLiteStatement.clearBindings();</span><br><span class="line">            sqLiteStatement.bindLong(1, count);</span><br><span class="line">            sqLiteStatement.executeInsert();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, &quot;insert recompile use time &quot; + (SystemClock.currentThreadTimeMillis() - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（2）显示使用事务
在Android中，无论是使用SQLiteDatabase的insert,delete等方法还是execSQL都开启了事务，来确保每一次操作都具有原子性，使得结果要么是操作之后的正确结果，要么是操作之前的结果。</p>
<p>然而事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。既然属于文件，就符合Unix的文件范型(Open-Read/Write- Close)，因而对于批量的修改操作会出现反复打开文件读写再关闭的操作。然而好在，我们可以显式使用事务，将批量的数据库更新带来的journal文件打开关闭降低到1次。</p>
<p>具体的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void insertWithTransaction() &#123;</span><br><span class="line">        long start = SystemClock.currentThreadTimeMillis();</span><br><span class="line">        int count = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            getWritableDatabase().beginTransaction();</span><br><span class="line">            while (count++ &lt; 100) &#123;</span><br><span class="line">                insert(count, &quot;test&quot;, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            getWritableDatabase().setTransactionSuccessful();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            getWritableDatabase().endTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, &quot;insert traceaction use time &quot; + (SystemClock.currentThreadTimeMillis() - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用这两种方式分别优化，对比效果如下： </p>
<p>从图中可以看到在插入100条的情况下，使用预编译的方式可以稍微提升性能，但是使用事务，能够使性能提升大概8倍，所以可以看出频繁的IO操作还是比较耗时的。同时使用两种方式进行优化，可以提升17倍，优化效果非常明显。</p>
<p>（3）建立索引
a.索引的概念
索引，使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>在关系数据库中，索引是一种与表有关的数据库结构，它可以使对应于表的SQL语句执行得更快。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。 
索引是一个单独的、物理的数据库结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。</p>
<p>索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引的方式与您使用书籍中的索引的方式很相似：它搜索索引以找到特定值，然后顺指针找到包含该值的行。</p>
<p>b.建立索引
创建索引的基本语法：</p>
<p>CREATE INDEX index_name ON table_name;
1
创建单列索引</p>
<p>CREATE INDEX index_name ON table_name;
1
c.索引的利弊
毋庸置疑，索引加速了我们检索数据表的速度。然而正如西方谚语 “There are two sides of a coin”，索引亦有缺点：</p>
<p>对于增加，更新和删除来说，使用了索引会变慢，比如你想要删除字</p>
<p>列表内容典中的一个字，那么你同时也需要删除这个字在拼音索引和部首索引中的信息。
建立索引会增加数据库的大小，比如字典中的拼音索引和部首索引实际上是会增加字典的页数，让字典变厚的。
为数据量比较小的表建立索引，往往会事倍功半。
所以使用索引需要考虑实际情况进行利弊权衡，对于查询操作量级较大，业务对要求查询要求较高的，还是推荐使用索引的。</p>
<p>（4）查询数据优化
按需获取列信息</p>
<p>db.query(TableDefine.TABLE_RECORD, null, null, null, null, null, null) ;
1
其中上面方法的第二个参数类型为String[]，意思是返回结果参考的colum信息，传递null表明需要获取全部的column数据。如果我们不需要所有列的信息，最好指定一下需要的列。</p>
<p>提前获取索引 
例如下面的代码，我们可以把获取列索引的代码cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME)放到循环外，这样不需要每次获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> private void badQueryWithLoop(SQLiteDatabase db) &#123;</span><br><span class="line">    Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]&#123;TableDefine.COLUMN_INSERT_TIME&#125;, null, null, null, null, null) ;</span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        long insertTime = cursor.getLong(cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）ContentValues的容量调整
SQLiteDatabase提供了方便的ContentValues简化了我们处理列名与值的映射，ContentValues内部采用了 HashMap来存储Key-Value数据，ContentValues的初始容量是8，如果当添加的数据超过8之前，则会进行双倍扩容操作，因此建议对ContentValues填入的内容进行估量，设置合理的初始化容量，减少不必要的内部扩容操作。</p>
<p>（6）及时关闭Cursor
（7）耗时异步化
数据库的操作，属于本地IO，通常比较耗时，如果处理不好，很容易导致ANR,因此建议将这些耗时操作放入异步线程中处理</p>
<p><a href="https://blog.csdn.net/u014608640/article/details/52511310" target="_blank" rel="noopener">Android 性能优化之数据库优化(一)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/27/tips-android-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/27/tips-android-file/" itemprop="url">
                  tips-android-file
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T09:51:43+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文件句柄泄露</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line"></span><br><span class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime: Process: com.Android56, PID: 7437</span><br><span class="line"></span><br><span class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime: java.lang.RuntimeException: Could not read input channel file descriptors from parcel.</span><br><span class="line"></span><br><span class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime:    at android.view.InputChannel.nativeReadFromParcel(Native Method)</span><br><span class="line"></span><br><span class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime:    at android.view.InputChannel.readFromParcel(InputChannel.java:148)</span><br><span class="line"></span><br><span class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime:    at android.view.InputChannel$1.createFromParcel(InputChannel.java:39)</span><br></pre></td></tr></table></figure>

<p>这里有一句Could not read input channel file descriptors from parcel，然后我们在这句话的上面又发现一个有价值的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Too many open files</span><br></pre></td></tr></table></figure>

<p>通过网上搜索，基本判断这是一个文件句柄泄漏的问题。
那么我们该如何查找文件句柄泄漏的地方呢。
首先我们需要做到监控文件句柄数，由于android是linux的内核，所以，系统为每一个进程都有一个文件句柄的目录。
我们先通过ps命令，获取到我们app的进程id。
然后找到一个root过的手机，或者使用andorid模拟器，然后用adb连接到手机，通过shell命令进入到/proc/进程id/fd这个目录。由于linux关于系统的管理都是用文件方式，所以这个文件夹下面就是所有被打开的句柄。
我们可以在app运行的过程中，不断的进入到这个目录中，然后用ls -l 命令列出所有的文件句柄，这样就能看到文件句柄有哪些是增长的。然后再根据不同类型的文件句柄，初步定位是什么在泄漏。
在排查的过程中，为了方便获取某个进程的句柄数，我写了一个简单的shell脚本。有需要的同学可以拿去使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;查询进程占用文件句柄数&apos;</span><br><span class="line">set `adb shell ps |grep com.Android56 |grep -v channel |grep -v Daemon`</span><br><span class="line">pidnum=$2</span><br><span class="line">index=0</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">index=$[index+1]</span><br><span class="line">echo &apos;##################&apos;</span><br><span class="line">echo &apos;第&apos;$index&apos;次查询&apos;</span><br><span class="line">echo &apos;总句柄&apos;</span><br><span class="line">adb shell ls -l /proc/$pidnum/fd |grep &quot;&quot; -c</span><br><span class="line">echo &apos;anon句柄&apos;</span><br><span class="line">adb shell ls -l /proc/$pidnum/fd |grep anon -c</span><br><span class="line">echo &apos;##################&apos;</span><br><span class="line">sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/26/tool-markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/26/tool-markdown/" itemprop="url">
                  markdown语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T22:00:20+08:00">
                2019-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Markdown Preview Enhanced 内部支持 mermaid, PlantUML, WaveDrom, GraphViz，Vega &amp; Vega-lite，Ditaa 图像渲染。 
你也可以通过使用 Code Chunk 来渲染 TikZ, Python Matplotlib, Plotly 等图像。</p>
<h3 id="基本流程图"><a href="#基本流程图" class="headerlink" title="基本流程图"></a>基本流程图</h3><p>Markdown常用的元素有以下几种：</p>
<ul>
<li>start</li>
<li>end</li>
<li>operation</li>
<li>condition</li>
<li>inputoutput</li>
<li>subroutine</li>
</ul>
<p>以简单的登录场景为例，流程图代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: 开始</span><br><span class="line">loginInfo=&gt;inputoutput: 登录数据</span><br><span class="line">verifyLogin=&gt;subroutine: 登录验证</span><br><span class="line">isSuccess=&gt;condition: 验证成功？</span><br><span class="line">respondSuccess=&gt;operation: 响应成功</span><br><span class="line">responseFailure=&gt;operation: 响应失败</span><br><span class="line">end=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;loginInfo-&gt;verifyLogin-&gt;isSuccess</span><br><span class="line">isSuccess(yes)-&gt;respondSuccess-&gt;end</span><br><span class="line">isSuccess(no)-&gt;responseFailure-&gt;end</span><br></pre></td></tr></table></figure>

<p>注意：冒号和名称之间需要有一个空格。</p>
<p>方向调整
绘制流程图有时会出现比较一言难尽的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: start</span><br><span class="line">operation1=&gt;operation: operation1</span><br><span class="line">isSuccess=&gt;condition: success?</span><br><span class="line">operation2=&gt;operation: operation2</span><br><span class="line">operation3=&gt;operation: operation3</span><br><span class="line">operation4=&gt;operation: operation4</span><br><span class="line">end=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;operation1-&gt;isSuccess</span><br><span class="line">isSuccess(yes)-&gt;operation2-&gt;end</span><br><span class="line">isSuccess(no)-&gt;operation3-&gt;operation4-&gt;operation1</span><br></pre></td></tr></table></figure>

<p>这种情况下可以使用left、right和bottom关键字来调整线条的位置使流程图更加清晰，例如此处给operation4元素添加right关键字，就可以分离重叠的线条。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: start</span><br><span class="line">operation1=&gt;operation: operation1</span><br><span class="line">isSuccess=&gt;condition: success?</span><br><span class="line">operation2=&gt;operation: operation2</span><br><span class="line">operation3=&gt;operation: operation3</span><br><span class="line">operation4=&gt;operation: operation4</span><br><span class="line">end=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;operation1-&gt;isSuccess</span><br><span class="line">isSuccess(yes)-&gt;operation2-&gt;end</span><br><span class="line">isSuccess(no)-&gt;operation3-&gt;operation4(right)-&gt;operation1</span><br></pre></td></tr></table></figure>

<p>如果给condition元素添加这些关键字的话会调整整个分支的方向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: start</span><br><span class="line">operation1=&gt;operation: operation1</span><br><span class="line">isSuccess=&gt;condition: success?</span><br><span class="line">operation2=&gt;operation: operation2</span><br><span class="line">operation3=&gt;operation: operation3</span><br><span class="line">operation4=&gt;operation: operation4</span><br><span class="line">end=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;operation1-&gt;isSuccess</span><br><span class="line">isSuccess(yes)-&gt;operation2-&gt;end</span><br><span class="line">isSuccess(no,left)-&gt;operation3-&gt;operation4(left)-&gt;operation1</span><br></pre></td></tr></table></figure>

<p>状态标记
Markdown会使用不同的颜色来标记状态，状态主要有以下几种：</p>
<ul>
<li>past</li>
<li>current</li>
<li>future</li>
<li>approved</li>
<li>rejected</li>
<li>invalid</li>
</ul>
<p>以软件生命周期的一部分为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: 开始|past</span><br><span class="line">requirementAnalysis=&gt;operation: 需求分析|past</span><br><span class="line">design=&gt;operation: 软件设计|past</span><br><span class="line">coding=&gt;operation: 编码|past</span><br><span class="line">selfTestingPased=&gt;condition: 自测通过？|approved</span><br><span class="line">debug=&gt;operation: debug|invalid</span><br><span class="line">submitTestingPased=&gt;condition: 提测通过？|rejected</span><br><span class="line">modifyBug=&gt;operation: 修bug|current</span><br><span class="line">deploy=&gt;operation: 部署|future</span><br><span class="line">end=&gt;end: 结束|future</span><br><span class="line"></span><br><span class="line">start-&gt;requirementAnalysis-&gt;design-&gt;coding-&gt;selfTestingPased</span><br><span class="line">selfTestingPased(no)-&gt;debug(right)-&gt;selfTestingPased</span><br><span class="line">selfTestingPased(yes)-&gt;submitTestingPased</span><br><span class="line">submitTestingPased(yes)-&gt;deploy-&gt;end</span><br><span class="line">submitTestingPased(no)-&gt;modifyBug(right)-&gt;submitTestingPased</span><br></pre></td></tr></table></figure>

<p>箭头高亮
可以通过高亮某些箭头来标记出主流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: 开始</span><br><span class="line">loginInfo=&gt;inputoutput: 登录数据</span><br><span class="line">verifyLogin=&gt;subroutine: 登录验证</span><br><span class="line">isSuccess=&gt;condition: 验证成功？</span><br><span class="line">respondSuccess=&gt;operation: 响应成功</span><br><span class="line">responseFailure=&gt;operation: 响应失败</span><br><span class="line">end=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;loginInfo-&gt;verifyLogin-&gt;isSuccess</span><br><span class="line">isSuccess(yes)-&gt;respondSuccess-&gt;end</span><br><span class="line">isSuccess(no)-&gt;responseFailure-&gt;end</span><br><span class="line"></span><br><span class="line">start@&gt;loginInfo(&#123;&quot;stroke&quot;:&quot;Red&quot;&#125;)@&gt;verifyLogin(&#123;&quot;stroke&quot;:&quot;Red&quot;&#125;)@&gt;isSuccess(&#123;&quot;stroke&quot;:&quot;Red&quot;&#125;)@&gt;respondSuccess(&#123;&quot;stroke&quot;:&quot;Red&quot;&#125;)@&gt;end(&#123;&quot;stroke&quot;:&quot;Red&quot;,&quot;stroke-width&quot;:6,&quot;arrow-end&quot;:&quot;classic-wide-long&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>流程图语法详解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">## 操作块(格式为:变量=&gt;操作块: 备注名)</span><br><span class="line">st=&gt; start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">#普通操作块 opration</span><br><span class="line">op1=&gt;opration: 第一个操作块</span><br><span class="line">op2=&gt;opration: 第二个操作块</span><br><span class="line">#判断块 condition</span><br><span class="line">cond1=&gt;condition: 第一个判断</span><br><span class="line">cond2=&gt;condition: 第二个判断</span><br><span class="line">  </span><br><span class="line">#输入输出块 inputoutput[平行四边形]</span><br><span class="line">io1=&gt;inputoutput: 输入输出块1</span><br><span class="line">io2=&gt;inputoutput: 输入输出块2</span><br><span class="line">#子任务块</span><br><span class="line">sub1=&gt;subroutine: 子任务1</span><br><span class="line">sub2=&gt;subroutine: 子任务2</span><br><span class="line">  </span><br><span class="line">## 判断和位置控制</span><br><span class="line">#判断流程控制</span><br><span class="line">cond1(yes)-&gt;op1  #yes 的时候回到 op1</span><br><span class="line">cond1(no)-&gt;e   #no 的时候 去结束</span><br><span class="line">  </span><br><span class="line">#位置指定</span><br><span class="line">cond1(no)-&gt;op2(right)-&gt;op1 #控制 op2 位置置于右边，再由op2 返回 op1 (好像不能向左)</span><br><span class="line">#还可以这样 cond1(no,right)</span><br><span class="line">cond1(yes)-&gt;e </span><br><span class="line">  </span><br><span class="line">## 流程控制</span><br><span class="line">#分着写</span><br><span class="line">st-&gt;op1</span><br><span class="line">op1-&gt;e</span><br><span class="line">  </span><br><span class="line">#合着写</span><br><span class="line">st-&gt;op1-&gt;e</span><br><span class="line">  </span><br><span class="line">#判断也是一样：</span><br><span class="line">st-&gt;cond</span><br><span class="line">cond(yes)-&gt;io</span><br><span class="line">cond(no)-&gt;op1</span><br></pre></td></tr></table></figure>

<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>注意:其实时序图使用platuml也可以画的很美观
<a href="http://plantuml.com/zh/sequence-diagram" target="_blank" rel="noopener">platuml-sequence</a></p>
<ul>
<li>sequence代码块中的内容将会被js-sequence-diagrams渲染</li>
<li>支持两个主题simple(default)和hand</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bgbiao-&gt; bianbian: good morning</span><br><span class="line">note left of bgbiao: man</span><br><span class="line">bianbian -&gt; bgbiao: eat something</span><br><span class="line">note right of bianbian: woman</span><br><span class="line">  </span><br><span class="line">note over bgbiao: test</span><br></pre></td></tr></table></figure>

<h3 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h3><p>Mermaid可以用来渲染流程图和时序图</p>
<ul>
<li>mermaid代码块中的内容将会被渲染mermaid图像</li>
<li><a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">mermaid-docs图像文档</a></li>
</ul>
<p>注意:{code_block=true}会影藏图像
Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。</p>
<p>定义节点
|表述|说明|
|—|—|
|id[文字]|    矩形节点|
|id(文字)|    圆角矩形节点|
|id((文字))    |圆形节点|
|id&gt;文字]|    旗帜状节点|
|id{文字}|    菱形节点|
定义连线
|表述|    说明|
|—|—|
|&gt;|    添加尾部箭头|
|-|    不添加尾部箭头|
|–    |单线|
|–text–|    单线上加文字|
|==|    粗线|
|==text==|    粗线加文字|
|-.-|    虚线|
|-.text.-|    虚线加文字|</p>
<p>流程图方向有下面几个值</p>
<ul>
<li>TB 从上到下</li>
<li>BT 从下到上</li>
<li>RL 从右到左</li>
<li>LR 从左到右</li>
<li>TD 同TB</li>
</ul>
<p>子流程图
格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subgraph title</span><br><span class="line">    graph definition</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>自定义样式</p>
<p>语法：style id 具体样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1(Start)--&gt;id2(Stop)</span><br><span class="line">    style id1 fill:#f9f,stroke:#333,stroke-width:4px,fill-opacity:0.5</span><br><span class="line">    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 10,5</span><br></pre></td></tr></table></figure>

<h3 id="plantuml创建各种图形"><a href="#plantuml创建各种图形" class="headerlink" title="plantuml创建各种图形"></a>plantuml创建各种图形</h3><ul>
<li>可以安装graphviz来辅助生成各种图形</li>
<li>puml或plantuml代码中的内容将会被PlantUML渲染
注意：也可以为图像的容器添加属性，例如居中{align=”center”}</li>
</ul>
<h3 id="使用graphviz来绘制各种图形"><a href="#使用graphviz来绘制各种图形" class="headerlink" title="使用graphviz来绘制各种图形"></a>使用graphviz来绘制各种图形</h3><p>使用Viz.js来渲染dot语言图形。</p>
<ul>
<li>viz或者dot代码块中的内容将会被<a href="https://github.com/mdaines/viz.js" target="_blank" rel="noopener">Viz.js</a>渲染</li>
<li>可以通过{engine=”…”}来选择不同的渲染引擎。引擎circo,dot,neato,osage,或者twopi.</li>
</ul>
<p>注意:默认的dot是二叉树，twopi是依赖树，两种常用的类型</p>
<h3 id="vega和vega-lite的支持的静态图像"><a href="#vega和vega-lite的支持的静态图像" class="headerlink" title="vega和vega-lite的支持的静态图像"></a>vega和vega-lite的支持的静态图像</h3><ul>
<li>vega代码块中的内容会被vega渲染</li>
<li>vega-lite代码中的内容会被vega-lite渲染</li>
<li>支持JSON和YAML的数据源输入
<a href="https://vega.github.io/vega-lite/examples/" target="_blank" rel="noopener">vega-lite-docs</a>
<a href="https://www.jianshu.com/p/a9bd83b768d5" target="_blank" rel="noopener">vega-docs</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;https://vega.github.io/schema/vega-lite/v2.json&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A simple bar chart with embedded data.&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;values&quot;: [</span><br><span class="line">      &#123;&quot;a&quot;: &quot;A&quot;,&quot;b&quot;: 28&#125;, &#123;&quot;a&quot;: &quot;B&quot;,&quot;b&quot;: 55&#125;, &#123;&quot;a&quot;: &quot;C&quot;,&quot;b&quot;: 43&#125;,</span><br><span class="line">      &#123;&quot;a&quot;: &quot;D&quot;,&quot;b&quot;: 91&#125;, &#123;&quot;a&quot;: &quot;E&quot;,&quot;b&quot;: 81&#125;, &#123;&quot;a&quot;: &quot;F&quot;,&quot;b&quot;: 53&#125;,</span><br><span class="line">      &#123;&quot;a&quot;: &quot;G&quot;,&quot;b&quot;: 19&#125;, &#123;&quot;a&quot;: &quot;H&quot;,&quot;b&quot;: 87&#125;, &#123;&quot;a&quot;: &quot;I&quot;,&quot;b&quot;: 52&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mark&quot;: &quot;bar&quot;,</span><br><span class="line">  &quot;encoding&quot;: &#123;</span><br><span class="line">    &quot;x&quot;: &#123;&quot;field&quot;: &quot;a&quot;, &quot;type&quot;: &quot;ordinal&quot;&#125;,</span><br><span class="line">    &quot;y&quot;: &#123;&quot;field&quot;: &quot;b&quot;, &quot;type&quot;: &quot;quantitative&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/diagrams" target="_blank" rel="noopener">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/diagrams</a></p>
<h3 id="hexo中支持流程图"><a href="#hexo中支持流程图" class="headerlink" title="hexo中支持流程图"></a>hexo中支持流程图</h3><ol>
<li>hexo-filter-mermaid-diagrams:
brew install yarn
进入到博客的根目录，一定要在博客的根目录执行<code>yarn add hexo-filter-mermaid-diagrams</code>
执行完成后在博客根目录下的node_modules种看下有没有hexo-filter-mermaid-diagrams这个插件文件夹，如果没有，说明没安装成功，安装成功后执行下一步，打开博客根目录下面的_config.yml文件，在底部插入以下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mermaid chart</span><br><span class="line">mermaid: ## mermaid url https://github.com/knsv/mermaid</span><br><span class="line">  enable: true  # default true</span><br><span class="line">  version: &quot;7.1.2&quot; # default v7.1.2</span><br><span class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span><br><span class="line">    #startOnload: true  // default true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>完成上一步操作之后打开主题目录的themes/next/layout/_partials/footer.swig，这里因为我用的是next主题，其他主题应该大同小异，在footer.swig文件最后加上以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.mermaid.enable %&#125;</span><br><span class="line">  &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &apos;forest&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>添加完成后，回到博客根目录的_config.yml，把external_link的值改为false，默认的为true，这一步绝大多数教程中都没有写
Hexo中引入Mermaid流程图：<a href="https://tyloafer.github.io/2018/04/21/hexo-mermaid/" target="_blank" rel="noopener">点击查看</a>
hexo-filter-mermaid-diagrams插件开发杂谈:<a href="https://webappdevelp.github.io/2018/0%E4%B8%89/hexo-filter-mermaid-diagrams%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/" target="_blank" rel="noopener">点击查看</a>
插件官方位置:<a href="https://www.npmjs.com/package/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">点击查看</a>
插件官方使用教程:<a href="https://mermaidjs.github.io/flowchart.html" target="_blank" rel="noopener">点击查看</a></p>
<ol start="2">
<li>hexo-filter-flowchart
npm install –save hexo-filter-flowchart</li>
<li>hexo-filter-sequence
npm install –save hexo-filter-sequence</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/13/tips-net-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/13/tips-net-socket/" itemprop="url">
                  tips-net-socket
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T20:05:55+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line">FCNTL(2)                    BSD System Calls Manual                   FCNTL(2)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">     fcntl -- file control</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     #include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">     int</span><br><span class="line">     fcntl(int fildes, int cmd, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">     fcntl() provides for control over descriptors.  The argument fildes is a descriptor to be operated on</span><br><span class="line">     by cmd as follows:</span><br><span class="line"></span><br><span class="line">     F_DUPFD            Return a new descriptor as follows:</span><br><span class="line"></span><br><span class="line">                            o   Lowest numbered available descriptor greater than or equal to arg.</span><br><span class="line">                            o   Same object references as the original descriptor.</span><br><span class="line">                            o   New descriptor shares the same file offset if the object was a file.</span><br><span class="line">                            o   Same access mode (read, write or read/write).</span><br><span class="line">                            o   Same file status flags (i.e., both file descriptors share the same file</span><br><span class="line">                                status flags).</span><br><span class="line">                            o   The close-on-exec flag associated with the new file descriptor is cleared</span><br><span class="line">                                so that the descriptor remains open across an execv(2) system call.</span><br><span class="line"></span><br><span class="line">     F_DUPFD_CLOEXEC    Like F_DUPFD, except that the close-on-exec flag associated with the new file</span><br><span class="line">                        descriptor is set.</span><br><span class="line"></span><br><span class="line">     F_GETFD            Get the flags associated with the file descriptor fildes, as described below (arg</span><br><span class="line">                        is ignored).</span><br><span class="line"></span><br><span class="line">     F_SETFD            Set the file descriptor flags to arg.</span><br><span class="line"></span><br><span class="line">     F_GETFL            Get descriptor status flags, as described below (arg is ignored).</span><br><span class="line"></span><br><span class="line">     F_SETFL            Set descriptor status flags to arg.</span><br><span class="line"></span><br><span class="line">     F_GETOWN           Get the process ID or process group currently receiving SIGIO and SIGURG signals;</span><br><span class="line">                        process groups are returned as negative values (arg is ignored).</span><br><span class="line"></span><br><span class="line">     F_SETOWN           Set the process or process group to receive SIGIO and SIGURG signals; process</span><br><span class="line">                        groups are specified by supplying arg as negative, otherwise arg is interpreted as</span><br><span class="line">                        a process ID.</span><br><span class="line"></span><br><span class="line">     F_GETPATH          Get the path of the file descriptor Fildes.  The argument must be a buffer of size</span><br><span class="line">                        MAXPATHLEN or greater.</span><br><span class="line"></span><br><span class="line">     F_PREALLOCATE      Preallocate file storage space. Note: upon success, the space that is allocated</span><br><span class="line">                        can be the size requested, larger than the size requested, or (if the</span><br><span class="line">                        F_ALLOCATEALL flag is not provided) smaller than the space requested.</span><br><span class="line"></span><br><span class="line">     F_PUNCHHOLE        Deallocate a region and replace it with a hole. Subsequent reads of the affected</span><br><span class="line">                        region will return bytes of zeros that are usually not backed by physical blocks.</span><br><span class="line">                        This will not change the actual file size. Holes must be aligned to file system</span><br><span class="line">                        block boundaries. This will fail on file systems that do not support this inter-</span><br><span class="line">                        face.</span><br><span class="line"></span><br><span class="line">     F_SETSIZE          Truncate a file without zeroing space.  The calling process must have root privi-</span><br><span class="line">                        leges.</span><br><span class="line"></span><br><span class="line">     F_RDADVISE         Issue an advisory read async with no copy to user.</span><br><span class="line"></span><br><span class="line">     F_RDAHEAD          Turn read ahead off/on.  A zero value in arg disables read ahead.  A non-zero</span><br><span class="line">                        value in arg turns read ahead on.</span><br><span class="line"></span><br><span class="line">     F_READBOOTSTRAP    Read bootstrap from disk.</span><br><span class="line"></span><br><span class="line">     F_WRITEBOOTSTRAP   Write bootstrap on disk.  The calling process must have root privileges.</span><br><span class="line"></span><br><span class="line">     F_NOCACHE          Turns data caching off/on. A non-zero value in arg turns data caching off.  A</span><br><span class="line">                        value of zero in arg turns data caching on.</span><br><span class="line"></span><br><span class="line">     F_LOG2PHYS         Get disk device information.  Currently this only returns the disk device address</span><br><span class="line">                        that corresponds to the current file offset. Note that the system may return -1 as</span><br><span class="line">                        the disk device address if the file is not backed by physical blocks. This is sub-</span><br><span class="line">                        ject to change.</span><br><span class="line"></span><br><span class="line">     F_LOG2PHYS_EXT     Variant of F_LOG2PHYS that uses the passed in file offset and length.</span><br><span class="line"></span><br><span class="line">     F_FULLFSYNC        Does the same thing as fsync(2) then asks the drive to flush all buffered data to</span><br><span class="line">                        the permanent storage device (arg is ignored).  This is currently implemented on</span><br><span class="line">                        HFS, MS-DOS (FAT), and Universal Disk Format (UDF) file systems.  The operation</span><br><span class="line">                        may take quite a while to complete.  Certain FireWire drives have also been known</span><br><span class="line">                        to ignore the request to flush their buffered data.</span><br><span class="line"></span><br><span class="line">     F_SETNOSIGPIPE     Determines whether a SIGPIPE signal will be generated when a write fails on a pipe</span><br><span class="line">                        or socket for which there is no reader.  If arg is non-zero, SIGPIPE generation is</span><br><span class="line">                        disabled for descriptor fildes, while an arg of zero enables it (the default).</span><br><span class="line"></span><br><span class="line">     F_GETNOSIGPIPE     Returns whether a SIGPIPE signal will be generated when a write fails on a pipe or</span><br><span class="line">                        socket for which there is no reader.  The semantics of the return value match</span><br><span class="line">                        those of the arg of F_SETNOSIGPIPE.</span><br><span class="line"></span><br><span class="line">     The flags for the F_GETFD and F_SETFD commands are as follows:</span><br><span class="line"></span><br><span class="line">           FD_CLOEXEC   Close-on-exec; the given file descriptor will be automatically closed in the suc-</span><br><span class="line">                        cessor process image when one of the execv(2) or posix_spawn(2) family of system</span><br><span class="line">                        calls is invoked.</span><br><span class="line"></span><br><span class="line">     The flags for the F_GETFL and F_SETFL commands are as follows:</span><br><span class="line"></span><br><span class="line">           O_NONBLOCK   Non-blocking I/O; if no data is available to a read call, or if a write operation</span><br><span class="line">                        would block, the read or write call returns -1 with the error EAGAIN.</span><br><span class="line"></span><br><span class="line">           O_APPEND     Force each write to append at the end of file; corresponds to the O_APPEND flag of</span><br><span class="line">                        open(2).</span><br><span class="line"></span><br><span class="line">           O_ASYNC      Enable the SIGIO signal to be sent to the process group when I/O is possible,</span><br><span class="line">                        e.g., upon availability of data to be read.</span><br><span class="line"></span><br><span class="line">     Several commands are available for doing advisory file locking; they all operate on the following</span><br><span class="line">     structure:</span><br><span class="line"></span><br><span class="line">             struct flock &#123;</span><br><span class="line">                 off_t       l_start;    /* starting offset */</span><br><span class="line">                 off_t       l_len;      /* len = 0 means until end of file */</span><br><span class="line">                 pid_t       l_pid;      /* lock owner */</span><br><span class="line">                 short       l_type;     /* lock type: read/write, etc. */</span><br><span class="line">                 short       l_whence;   /* type of l_start */</span><br><span class="line">             &#125;;</span><br><span class="line"></span><br><span class="line">     The commands available for advisory record locking are as follows:</span><br><span class="line"></span><br><span class="line">     F_GETLK    Get the first lock that blocks the lock description pointed to by the third argument, arg,</span><br><span class="line">                taken as a pointer to a struct flock (see above).  The information retrieved overwrites</span><br><span class="line">                the information passed to fcntl in the flock structure.  If no lock is found that would</span><br><span class="line">                prevent this lock from being created, the structure is left unchanged by this function</span><br><span class="line">                call except for the lock type which is set to F_UNLCK.</span><br><span class="line"></span><br><span class="line">     F_SETLK    Set or clear a file segment lock according to the lock description pointed to by the third</span><br><span class="line">                argument, arg, taken as a pointer to a struct flock (see above).  F_SETLK is used to</span><br><span class="line">                establish shared (or read) locks (F_RDLCK) or exclusive (or write) locks, (F_WRLCK), as</span><br><span class="line">                well as remove either type of lock (F_UNLCK).  If a shared or exclusive lock cannot be</span><br><span class="line">                set, fcntl returns immediately with EAGAIN.</span><br><span class="line"></span><br><span class="line">     F_SETLKW   This command is the same as F_SETLK except that if a shared or exclusive lock is blocked</span><br><span class="line">                by other locks, the process waits until the request can be satisfied.  If a signal that is</span><br><span class="line">                to be caught is received while fcntl is waiting for a region, the fcntl will be inter-</span><br><span class="line">                rupted if the signal handler has not specified the SA_RESTART (see sigaction(2)).</span><br><span class="line"></span><br><span class="line">     When a shared lock has been set on a segment of a file, other processes can set shared locks on that</span><br><span class="line">     segment or a portion of it.  A shared lock prevents any other process from setting an exclusive lock</span><br><span class="line">     on any portion of the protected area.  A request for a shared lock fails if the file descriptor was</span><br><span class="line">     not opened with read access.</span><br><span class="line"></span><br><span class="line">     An exclusive lock prevents any other process from setting a shared lock or an exclusive lock on any</span><br><span class="line">     portion of the protected area.  A request for an exclusive lock fails if the file was not opened with</span><br><span class="line">     write access.</span><br><span class="line"></span><br><span class="line">     The value of l_whence is SEEK_SET, SEEK_CUR, or SEEK_END to indicate that the relative offset,</span><br><span class="line">     l_start bytes, will be measured from the start of the file, current position, or end of the file,</span><br><span class="line">     respectively.  The value of l_len is the number of consecutive bytes to be locked.  If l_len is nega-</span><br><span class="line">     tive, the result is undefined.  The l_pid field is only used with F_GETLK to return the process ID of</span><br><span class="line">     the process holding a blocking lock.  After a successful F_GETLK request, the value of l_whence is</span><br><span class="line">     SEEK_SET.</span><br><span class="line"></span><br><span class="line">     Locks may start and extend beyond the current end of a file, but may not start or extend before the</span><br><span class="line">     beginning of the file.  A lock is set to extend to the largest possible value of the file offset for</span><br><span class="line">     that file if l_len is set to zero. If l_whence and l_start point to the beginning of the file, and</span><br><span class="line">     l_len is zero, the entire file is locked.  If an application wishes only to do entire file locking,</span><br><span class="line">     the flock(2) system call is much more efficient.</span><br><span class="line"></span><br><span class="line">     There is at most one type of lock set for each byte in the file.  Before a successful return from an</span><br><span class="line">     F_SETLK or an F_SETLKW request when the calling process has previously existing locks on bytes in the</span><br><span class="line">     region specified by the request, the previous lock type for each byte in the specified region is</span><br><span class="line">     replaced by the new lock type.  As specified above under the descriptions of shared locks and exclu-</span><br><span class="line">     sive locks, an F_SETLK or an F_SETLKW request fails or blocks respectively when another process has</span><br><span class="line">     existing locks on bytes in the specified region and the type of any of those locks conflicts with the</span><br><span class="line">     type specified in the request.</span><br><span class="line"></span><br><span class="line">     This interface follows the completely stupid semantics of System V and IEEE Std 1003.1-1988</span><br><span class="line">     (``POSIX.1&apos;&apos;) that require that all locks associated with a file for a given process are removed when</span><br><span class="line">     any file descriptor for that file is closed by that process.  This semantic means that applications</span><br><span class="line">     must be aware of any files that a subroutine library may access.  For example if an application for</span><br><span class="line">     updating the password file locks the password file database while making the update, and then calls</span><br><span class="line">     getpwname(3) to retrieve a record, the lock will be lost because getpwname(3) opens, reads, and</span><br><span class="line">     closes the password database.  The database close will release all locks that the process has associ-</span><br><span class="line">     ated with the database, even if the library routine never requested a lock on the database.  Another</span><br><span class="line">     minor semantic problem with this interface is that locks are not inherited by a child process created</span><br><span class="line">     using the fork(2) function.  The flock(2) interface has much more rational last close semantics and</span><br><span class="line">     allows locks to be inherited by child processes.  Flock(2) is recommended for applications that want</span><br><span class="line">     to ensure the integrity of their locks when using library routines or wish to pass locks to their</span><br><span class="line">     children.  Note that flock(2) and fcntl(2) locks may be safely used concurrently.</span><br><span class="line"></span><br><span class="line">     All locks associated with a file for a given process are removed when the process terminates.</span><br><span class="line"></span><br><span class="line">     A potential for deadlock occurs if a process controlling a locked region is put to sleep by attempt-</span><br><span class="line">     ing to lock the locked region of another process.  This implementation detects that sleeping until a</span><br><span class="line">     locked region is unlocked would cause a deadlock and fails with an EDEADLK error.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     The F_PREALLOCATE command operates on the following structure:</span><br><span class="line"></span><br><span class="line">             typedef struct fstore &#123;</span><br><span class="line">                 u_int32_t fst_flags;      /* IN: flags word */</span><br><span class="line">                 int       fst_posmode;    /* IN: indicates offset field */</span><br><span class="line">                 off_t     fst_offset;     /* IN: start of the region */</span><br><span class="line">                 off_t     fst_length;     /* IN: size of the region */</span><br><span class="line">                 off_t     fst_bytesalloc; /* OUT: number of bytes allocated */</span><br><span class="line">             &#125; fstore_t;</span><br><span class="line"></span><br><span class="line">     The flags (fst_flags) for the F_PREALLOCATE command are as follows:</span><br><span class="line"></span><br><span class="line">           F_ALLOCATECONTIG   Allocate contiguous space.</span><br><span class="line"></span><br><span class="line">           F_ALLOCATEALL      Allocate all requested space or no space at all.</span><br><span class="line"></span><br><span class="line">     The position modes (fst_posmode) for the F_PREALLOCATE command indicate how to use the offset field.</span><br><span class="line">     The modes are as follows:</span><br><span class="line"></span><br><span class="line">           F_PEOFPOSMODE   Allocate from the physical end of file.</span><br><span class="line"></span><br><span class="line">           F_VOLPOSMODE    Allocate from the volume offset.</span><br><span class="line"></span><br><span class="line">     The F_PUNCHHOLE command operates on the following structure:</span><br><span class="line"></span><br><span class="line">             typedef struct fpunchhole &#123;</span><br><span class="line">                 u_int32_t fp_flags;     /* unused */</span><br><span class="line">                 u_int32_t reserved;     /* (to maintain 8-byte alignment) */</span><br><span class="line">                 off_t     fp_offset;    /* IN: start of the region */</span><br><span class="line">                 off_t     fp_length;    /* IN: size of the region */</span><br><span class="line">             &#125; fpunchhole_t;</span><br><span class="line"></span><br><span class="line">     The F_RDADVISE command operates on the following structure which holds information passed from the</span><br><span class="line">     user to the system:</span><br><span class="line"></span><br><span class="line">             struct radvisory &#123;</span><br><span class="line">                off_t   ra_offset;  /* offset into the file */</span><br><span class="line">                int     ra_count;   /* size of the read     */</span><br><span class="line">             &#125;;</span><br><span class="line"></span><br><span class="line">     The F_READBOOTSTRAP and F_WRITEBOOTSTRAP commands operate on the following structure.</span><br><span class="line"></span><br><span class="line">             typedef struct fbootstraptransfer &#123;</span><br><span class="line">                 off_t fbt_offset;       /* IN: offset to start read/write */</span><br><span class="line">                 size_t fbt_length;      /* IN: number of bytes to transfer */</span><br><span class="line">                 void *fbt_buffer;       /* IN: buffer to be read/written */</span><br><span class="line">             &#125; fbootstraptransfer_t;</span><br><span class="line"></span><br><span class="line">     The F_LOG2PHYS command operates on the following structure:</span><br><span class="line"></span><br><span class="line">             struct log2phys &#123;</span><br><span class="line">                 u_int32_t l2p_flags;        /* unused so far */</span><br><span class="line">                 off_t     l2p_contigbytes;  /* unused so far */</span><br><span class="line">                 off_t     l2p_devoffset;    /* bytes into device */</span><br><span class="line">             &#125;;</span><br><span class="line"></span><br><span class="line">     The F_LOG2PHYS_EXT command operates on the same structure as F_LOG2PHYS but treats it as an in/out:</span><br><span class="line"></span><br><span class="line">             struct log2phys &#123;</span><br><span class="line">                 u_int32_t l2p_flags;        /* unused so far */</span><br><span class="line">                 off_t     l2p_contigbytes;  /* IN: number of bytes to be queried;</span><br><span class="line">                                                OUT: number of contiguous bytes allocated at this position */</span><br><span class="line">                 off_t     l2p_devoffset;    /* IN: bytes into file;</span><br><span class="line">                                                OUT: bytes into device */</span><br><span class="line">             &#125;;</span><br><span class="line"></span><br><span class="line">     If fildes is a socket, then the F_SETNOSIGPIPE and F_GETNOSIGPIPE commands are directly analogous,</span><br><span class="line">     and fully interoperate with the SO_NOSIGPIPE option of setsockopt(2) and getsockopt(2) respectively.</span><br><span class="line"></span><br><span class="line">RETURN VALUES</span><br><span class="line">     Upon successful completion, the value returned depends on cmd as follows:</span><br><span class="line"></span><br><span class="line">           F_DUPFD    A new file descriptor.</span><br><span class="line"></span><br><span class="line">           F_GETFD    Value of flag (only the low-order bit is defined).</span><br><span class="line"></span><br><span class="line">           F_GETFL    Value of flags.</span><br><span class="line"></span><br><span class="line">           F_GETOWN   Value of file descriptor owner.</span><br><span class="line"></span><br><span class="line">           other      Value other than -1.</span><br><span class="line"></span><br><span class="line">     Otherwise, a value of -1 is returned and errno is set to indicate the error.</span><br><span class="line"></span><br><span class="line">ERRORS</span><br><span class="line">     The fcntl() system call will fail if:</span><br><span class="line"></span><br><span class="line">     [EAGAIN]           The argument cmd is F_SETLK, the type of lock (l_type) is a shared lock (F_RDLCK)</span><br><span class="line">                        or exclusive lock (F_WRLCK), and the segment of a file to be locked is already</span><br><span class="line">                        exclusive-locked by another process; or the type is an exclusive lock and some</span><br><span class="line">                        portion of the segment of a file to be locked is already shared-locked or exclu-</span><br><span class="line">                        sive-locked by another process.</span><br><span class="line"></span><br><span class="line">     [EACCESS]          The argument cmd is either F_SETSIZE or F_WRITEBOOTSTRAP and the calling process</span><br><span class="line">                        does not have root privileges.</span><br><span class="line"></span><br><span class="line">     [EBADF]            Fildes is not a valid open file descriptor.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_SETLK or F_SETLKW, the type of lock (l_type) is a shared</span><br><span class="line">                        lock (F_RDLCK), and fildes is not a valid file descriptor open for reading.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_SETLK or F_SETLKW, the type of lock (l_type) is an exclusive</span><br><span class="line">                        lock (F_WRLCK), and fildes is not a valid file descriptor open for writing.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_PREALLOCATE and the calling process does not have file write</span><br><span class="line">                        permission.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_LOG2PHYS or F_LOG2PHYS_EXT and fildes is not a valid file</span><br><span class="line">                        descriptor open for reading.</span><br><span class="line"></span><br><span class="line">     [EDEADLK]          The argument cmd is F_SETLKW, and a deadlock condition was detected.</span><br><span class="line"></span><br><span class="line">     [EINTR]            The argument cmd is F_SETLKW, and the function was interrupted by a signal.</span><br><span class="line"></span><br><span class="line">     [EINVAL]           Cmd is F_DUPFD and arg is negative or greater than the maximum allowable number</span><br><span class="line">                        (see getdtablesize(2)).</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_GETLK, F_SETLK, or F_SETLKW and the data to which arg points</span><br><span class="line">                        is not valid, or fildes refers to a file that does not support locking.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_PREALLOCATE and the fst_posmode is not a valid mode, or when</span><br><span class="line">                        F_PEOFPOSMODE is set and fst_offset is a non-zero value, or when F_VOLPOSMODE is</span><br><span class="line">                        set and fst_offset is a negative or zero value.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_PUNCHHOLE and either fp_offset or fp_length are negative, or</span><br><span class="line">                        both fp_offset and fp_length are not multiples of the file system block size.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is either F_READBOOTSTRAP or F_WRITEBOOTSTRAP and the operation</span><br><span class="line">                        was attempted on a non-HFS disk type.</span><br><span class="line"></span><br><span class="line">     [EMFILE]           Cmd is F_DUPFD and the maximum allowed number of file descriptors are currently</span><br><span class="line">                        open.</span><br><span class="line"></span><br><span class="line">     [EMFILE]           The argument cmd is F_DUPED and the maximum number of file descriptors permitted</span><br><span class="line">                        for the process are already in use, or no file descriptors greater than or equal</span><br><span class="line">                        to arg are available.</span><br><span class="line"></span><br><span class="line">     [ENOLCK]           The argument cmd is F_SETLK or F_SETLKW, and satisfying the lock or unlock request</span><br><span class="line">                        would result in the number of locked regions in the system exceeding a system-</span><br><span class="line">                        imposed limit.</span><br><span class="line"></span><br><span class="line">     [ENOSPC]           The argument cmd is F_PREALLOCATE and either there is no space available on the</span><br><span class="line">                        volume containing fildes or fst_flags contains F_ALLOCATEALL and there is not</span><br><span class="line">                        enough space available on the volume containing fildes to satisfy the entire</span><br><span class="line">                        request.</span><br><span class="line"></span><br><span class="line">                        The argument cmd is F_PUNCHHOLE and there is not enough space available on the</span><br><span class="line">                        volume containing fildes to satisfy the request. As an example, a filesystem that</span><br><span class="line">                        supports cloned files may return this error if punching a hole requires the cre-</span><br><span class="line">                        ation of a clone and there is not enough space available to do so.</span><br><span class="line"></span><br><span class="line">     [EOVERFLOW]        A return value would overflow its representation.  For example, cmd is F_GETLK,</span><br><span class="line">                        F_SETLK, or F_SETLKW and the smallest (or, if l_len is non-zero, the largest) off-</span><br><span class="line">                        set of a byte in the requested segment will not fit in an object of type off_t.</span><br><span class="line"></span><br><span class="line">     [EPERM]            The argument cmd is F_PUNCHHOLE and the calling process does not have file write</span><br><span class="line">                        permission.</span><br><span class="line"></span><br><span class="line">     [ESRCH]            Cmd is F_SETOWN and the process ID given as argument is not in use.</span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">     close(2), execve(2), flock(2), getdtablesize(2), open(2), pipe(2), socket(2), setsockopt(2),</span><br><span class="line">     sigaction(3)</span><br><span class="line"></span><br><span class="line">HISTORY</span><br><span class="line">     The fcntl() function call appeared in 4.2BSD.</span><br><span class="line"></span><br><span class="line">4.2 Berkeley Distribution       August 24, 2017      4.2 Berkeley Distribution</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GETSOCKOPT(2)               BSD System Calls Manual              GETSOCKOPT(2)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">     getsockopt, setsockopt -- get and set options on sockets</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     #include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">     int</span><br><span class="line">     getsockopt(int socket, int level, int option_name, void *restrict option_value,</span><br><span class="line">         socklen_t *restrict option_len);</span><br><span class="line"></span><br><span class="line">     int</span><br><span class="line">     setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">     getsockopt() and setsockopt() manipulate the options associated with a socket.  Options may exist at</span><br><span class="line">     multiple protocol levels; they are always present at the uppermost ``socket&apos;&apos; level.</span><br><span class="line"></span><br><span class="line">     When manipulating socket options the level at which the option resides and the name of the option</span><br><span class="line">     must be specified.  To manipulate options at the socket level, level is specified as SOL_SOCKET.  To</span><br><span class="line">     manipulate options at any other level the protocol number of the appropriate protocol controlling the</span><br><span class="line">     option is supplied.  For example, to indicate that an option is to be interpreted by the TCP proto-</span><br><span class="line">     col, level should be set to the protocol number of TCP; see getprotoent(3).</span><br><span class="line"></span><br><span class="line">     The parameters option_value and option_len are used to access option values for setsockopt().  For</span><br><span class="line">     getsockopt() they identify a buffer in which the value for the requested option(s) are to be</span><br><span class="line">     returned.  For getsockopt(), option_len is a value-result parameter, initially containing the size of</span><br><span class="line">     the buffer pointed to by option_value, and modified on return to indicate the actual size of the</span><br><span class="line">     value returned.  If no option value is to be supplied or returned, option_value may be NULL.</span><br><span class="line"></span><br><span class="line">     option_name and any specified options are passed uninterpreted to the appropriate protocol module for</span><br><span class="line">     interpretation.  The include file &lt;sys/socket.h&gt; contains definitions for socket level options,</span><br><span class="line">     described below.  Options at other protocol levels vary in format and name; consult the appropriate</span><br><span class="line">     entries in section 4 of the manual.</span><br><span class="line"></span><br><span class="line">     Most socket-level options utilize an int parameter for option_value.  For setsockopt(), the parameter</span><br><span class="line">     should be non-zero to enable a boolean option, or zero if the option is to be disabled.  SO_LINGER</span><br><span class="line">     uses a struct linger parameter, defined in &lt;sys/socket.h&gt;, which specifies the desired state of the</span><br><span class="line">     option and the linger interval (see below).  SO_SNDTIMEO and SO_RCVTIMEO use a struct timeval parame-</span><br><span class="line">     ter, defined in &lt;sys/time.h&gt;.</span><br><span class="line"></span><br><span class="line">     The following options are recognized at the socket level.  Except as noted, each may be examined with</span><br><span class="line">     getsockopt() and set with setsockopt().</span><br><span class="line"></span><br><span class="line">           SO_DEBUG        enables recording of debugging information</span><br><span class="line">           SO_REUSEADDR    enables local address reuse</span><br><span class="line">           SO_REUSEPORT    enables duplicate address and port bindings</span><br><span class="line">           SO_KEEPALIVE    enables keep connections alive</span><br><span class="line">           SO_DONTROUTE    enables routing bypass for outgoing messages</span><br><span class="line">           SO_LINGER       linger on close if data present</span><br><span class="line">           SO_BROADCAST    enables permission to transmit broadcast messages</span><br><span class="line">           SO_OOBINLINE    enables reception of out-of-band data in band</span><br><span class="line">           SO_SNDBUF       set buffer size for output</span><br><span class="line">           SO_RCVBUF       set buffer size for input</span><br><span class="line">           SO_SNDLOWAT     set minimum count for output</span><br><span class="line">           SO_RCVLOWAT     set minimum count for input</span><br><span class="line">           SO_SNDTIMEO     set timeout value for output</span><br><span class="line">           SO_RCVTIMEO     set timeout value for input</span><br><span class="line">           SO_TYPE         get the type of the socket (get only)</span><br><span class="line">           SO_ERROR        get and clear error on the socket (get only)</span><br><span class="line">           SO_NOSIGPIPE    do not generate SIGPIPE, instead return EPIPE</span><br><span class="line">           SO_NREAD        number of bytes to be read (get only)</span><br><span class="line">           SO_NWRITE       number of bytes written not yet sent by the protocol (get only)</span><br><span class="line">           SO_LINGER_SEC   linger on close if data present with timeout in seconds</span><br><span class="line"></span><br><span class="line">     SO_DEBUG enables debugging in the underlying protocol modules.</span><br><span class="line"></span><br><span class="line">     SO_REUSEADDR indicates that the rules used in validating addresses supplied in a bind(2) call should</span><br><span class="line">     allow reuse of local addresses.</span><br><span class="line"></span><br><span class="line">     SO_REUSEPORT allows completely duplicate bindings by multiple processes if they all set SO_REUSEPORT</span><br><span class="line">     before binding the port.  This option permits multiple instances of a program to each receive UDP/IP</span><br><span class="line">     multicast or broadcast datagrams destined for the bound port.</span><br><span class="line"></span><br><span class="line">     SO_KEEPALIVE enables the periodic transmission of messages on a connected socket.  Should the con-</span><br><span class="line">     nected party fail to respond to these messages, the connection is considered broken and processes</span><br><span class="line">     using the socket are notified via a SIGPIPE signal when attempting to send data.</span><br><span class="line"></span><br><span class="line">     SO_DONTROUTE indicates that outgoing messages should bypass the standard routing facilities.</span><br><span class="line">     Instead, messages are directed to the appropriate network interface according to the network portion</span><br><span class="line">     of the destination address.</span><br><span class="line"></span><br><span class="line">     SO_LINGER controls the action taken when unsent messages are queued on socket and a close(2) is per-</span><br><span class="line">     formed.  If the socket promises reliable delivery of data and SO_LINGER is set, the system will block</span><br><span class="line">     the process on the close attempt until it is able to transmit the data or until it decides it is</span><br><span class="line">     unable to deliver the information (a timeout period, termed the linger interval, is specified in the</span><br><span class="line">     setsockopt() call when SO_LINGER is requested).  If SO_LINGER is disabled and a close is issued, the</span><br><span class="line">     system will process the close in a manner that allows the process to continue as quickly as possible.</span><br><span class="line"></span><br><span class="line">     SO_LINGER_SEC is the same option as SO_LINGER except the linger time is in seconds for SO_LINGER_SEC.</span><br><span class="line"></span><br><span class="line">     The option SO_BROADCAST requests permission to send broadcast datagrams on the socket.  Broadcast was</span><br><span class="line">     a privileged operation in earlier versions of the system.</span><br><span class="line"></span><br><span class="line">     With protocols that support out-of-band data, the SO_OOBINLINE option requests that out-of-band data</span><br><span class="line">     be placed in the normal data input queue as received; it will then be accessible with recv or read</span><br><span class="line">     calls without the MSG_OOB flag.  Some protocols always behave as if this option is set.</span><br><span class="line"></span><br><span class="line">     SO_SNDBUF and SO_RCVBUF are options to adjust the normal buffer sizes allocated for output and input</span><br><span class="line">     buffers, respectively.  The buffer size may be increased for high-volume connections, or may be</span><br><span class="line">     decreased to limit the possible backlog of incoming data.  The system places an absolute limit on</span><br><span class="line">     these values.</span><br><span class="line"></span><br><span class="line">     SO_SNDLOWAT is an option to set the minimum count for output operations.  Most output operations</span><br><span class="line">     process all of the data supplied by the call, delivering data to the protocol for transmission and</span><br><span class="line">     blocking as necessary for flow control.  Nonblocking output operations will process as much data as</span><br><span class="line">     permitted (subject to flow control) without blocking, but will process no data if flow control does</span><br><span class="line">     not allow the smaller of the low-water mark value or the entire request to be processed.  A select(2)</span><br><span class="line">     operation testing the ability to write to a socket will return true only if the low-water mark amount</span><br><span class="line">     could be processed.  The default value for SO_SNDLOWAT is set to a convenient size for network effi-</span><br><span class="line">     ciency, often 2048.</span><br><span class="line"></span><br><span class="line">     SO_RCVLOWAT is an option to set the minimum count for input operations.  In general, receive calls</span><br><span class="line">     will block until any (non-zero) amount of data is received, then return with the smaller of the</span><br><span class="line">     amount available or the amount requested.  The default value for SO_RCVLOWAT is 1.  If SO_RCVLOWAT is</span><br><span class="line">     set to a larger value, blocking receive calls normally wait until they have received the smaller of</span><br><span class="line">     the low-water mark value or the requested amount.  Receive calls may still return less than the low-</span><br><span class="line">     water mark if an error occurs, a signal is caught, or the type of data next in the receive queue is</span><br><span class="line">     different than that returned.</span><br><span class="line"></span><br><span class="line">     SO_SNDTIMEO is an option to set a timeout value for output operations.  It accepts a struct timeval</span><br><span class="line">     parameter with the number of seconds and microseconds used to limit waits for output operations to</span><br><span class="line">     complete.  If a send operation has blocked for this much time, it returns with a partial count or</span><br><span class="line">     with the error EWOULDBLOCK if no data were sent.  In the current implementation, this timer is</span><br><span class="line">     restarted each time additional data are delivered to the protocol, implying that the limit applies to</span><br><span class="line">     output portions ranging in size from the low-water mark to the high-water mark for output.</span><br><span class="line"></span><br><span class="line">     SO_RCVTIMEO is an option to set a timeout value for input operations.  It accepts a struct timeval</span><br><span class="line">     parameter with the number of seconds and microseconds used to limit waits for input operations to</span><br><span class="line">     complete.  In the current implementation, this timer is restarted each time additional data are</span><br><span class="line">     received by the protocol, and thus the limit is in effect an inactivity timer.  If a receive opera-</span><br><span class="line">     tion has been blocked for this much time without receiving additional data, it returns with a short</span><br><span class="line">     count or with the error EWOULDBLOCK if no data were received.  The struct timeval parameter must rep-</span><br><span class="line">     resent a positive time interval; otherwise, setsockopt() returns with the error EDOM.</span><br><span class="line"></span><br><span class="line">     SO_NOSIGPIPE is an option that prevents SIGPIPE from being raised when a write fails on a socket to</span><br><span class="line">     which there is no reader; instead, the write to the socket returns with the error EPIPE when there is</span><br><span class="line">     no reader.</span><br><span class="line"></span><br><span class="line">     Finally, SO_TYPE, SO_ERROR, SO_NREAD, and SO_NWRITE are options used only with getsockopt().</span><br><span class="line"></span><br><span class="line">     SO_TYPE returns the type of the socket, such as SOCK_STREAM; it is useful for servers that inherit</span><br><span class="line">     sockets on startup.</span><br><span class="line"></span><br><span class="line">     SO_ERROR returns any pending error on the socket and clears the error status.  It may be used to</span><br><span class="line">     check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</span><br><span class="line"></span><br><span class="line">     SO_NREAD returns the amount of data in the input buffer that is available to be received.  For data-</span><br><span class="line">     gram oriented sockets, SO_NREAD returns the size of the first packet -- this differs from the ioctl()</span><br><span class="line">     command FIONREAD that returns the total amount of data available.</span><br><span class="line"></span><br><span class="line">     SO_NWRITE returns the amount of data in the output buffer not yet sent by the protocol.</span><br><span class="line"></span><br><span class="line">RETURN VALUES</span><br><span class="line">     Upon successful completion, the value 0 is returned; otherwise the value -1 is returned and the</span><br><span class="line">     global variable errno is set to indicate the error.</span><br><span class="line"></span><br><span class="line">ERRORS</span><br><span class="line">     The getsockopt() and setsockopt() system calls will succeed unless:</span><br><span class="line"></span><br><span class="line">     [EBADF]            The argument socket is not a valid file descriptor.</span><br><span class="line"></span><br><span class="line">     [EFAULT]           The address pointed to by option_value is not in a valid part of the process</span><br><span class="line">                        address space.  For getsockopt(), this error may also be returned if option_len is</span><br><span class="line">                        not in a valid part of the process address space.</span><br><span class="line"></span><br><span class="line">     [EINVAL]           The option is invalid at the level indicated.</span><br><span class="line"></span><br><span class="line">     [ENOBUFS]          Insufficient system resources available for the call to complete.</span><br><span class="line"></span><br><span class="line">     [ENOMEM]           Insufficient memory available for the system call to complete.</span><br><span class="line"></span><br><span class="line">     [ENOPROTOOPT]      The option is unknown at the level indicated.</span><br><span class="line"></span><br><span class="line">     [ENOTSOCK]         The argument socket is not a socket (e.g., a plain file).</span><br><span class="line"></span><br><span class="line">     The setsockopt() system call will succeed unless:</span><br><span class="line"></span><br><span class="line">     [EDOM]             The argument option_value is out of bounds.</span><br><span class="line"></span><br><span class="line">     [EISCONN]          socket is already connected and a specified option cannot be set while this is the</span><br><span class="line">                        case.</span><br><span class="line"></span><br><span class="line">     [EINVAL]           The socket has been shut down.</span><br><span class="line"></span><br><span class="line">LEGACY SYNOPSIS</span><br><span class="line">     #include &lt;sys/types.h&gt;</span><br><span class="line">     #include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">     The include file &lt;sys/types.h&gt; is necessary.</span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">     socket(2), bind(2), ioctl(2), getprotoent(3), protocols(5)</span><br><span class="line"></span><br><span class="line">BUGS</span><br><span class="line">     Several of the socket options should be handled at lower levels of the system.</span><br><span class="line"></span><br><span class="line">HISTORY</span><br><span class="line">     The getsockopt() system call appeared in 4.2BSD.</span><br><span class="line"></span><br><span class="line">4.3-Reno Berkeley Distribution  April 19, 1994  4.3-Reno Berkeley Distribution</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/12/tips-net-mars-heartbeat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/12/tips-net-mars-heartbeat/" itemprop="url">
                  Android微信智能心跳方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T15:54:04+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言：在13年11月中旬时，因为基础组件组人手紧张，Leo安排我和春哥去广州轮岗支援。刚到广州的时候，Ray让我和春哥对Line和WhatsApp的心跳机制进行分析。我和春哥抓包测试了差不多两个多礼拜，在我们基本上摸清了Line和WhatsApp的心跳机制后，Ray才告诉我们真正的任务——对微信的固定心跳进行优化，并告诉我们这不是一件容易的事情。于是我和春哥开始构思第一个方案，我们开始想用统计的方法来解决问题，当我们拿着第一个方案和Ray讨论时，发现不能优雅应对Ray的所有提问：1、测试环境的准确性，失败到底是因为网络的特性导致还是因为用户当前的环境变化导致的暂时失败。2、临界值界定，如果方案选中的心跳值是临界值，我们该怎么办。Ray和组件组同事在网络方面有极其丰富的经验，虽然他没有给我们指出明确的方向，但提出的问题帮助我们更快的补齐需要面对的核心问题。这两个问题让我和春哥意识到如果能很好的解决，就可以给出一个比较好的心跳方案。第一个问题我和春哥开始就意识到，第二个问题我们确实在一开始时疏忽了。但直接解决这两个问题确实不容易，这着实让我和春哥迷茫了几天，有两三天在纺园我都没怎么睡着，因为想不到更好的方法。直到有一天思路发生了一些转变，既然最优解比较复杂，为什么不绕过去，使用有损服务理念找次优解呢。让复杂的事情简单化，好了，想到这里突然有一种拨开云雾的感觉。</p>
<p>思路对了，方案就可以做到简单并且可靠，大家可以看到最终的方案是比较简单的，并且效果还挺好的。在方案描述之前大概讲一下减低问题复杂度的方法：</p>
<ol>
<li>延迟心跳测试法：这是测试结果准确的前提保障，我们认为长连接建立后连续三次成功的短心跳就可以很大程度的保证下一次心跳环境是正常的。</li>
<li>成功一次认定，失败连续累积认定：成功是绝对的，连续失败多次才可能是失败。</li>
<li>临界值避免：我们使用比计算出的心跳稍微小一点的值做为稳定心跳避免临界值。</li>
<li>动态调整：即使在一次完整的智能心跳计算过程中，我们没有找到最好的值，我们还有机会来进行校正。</li>
</ol>
<p>当我和春哥想出第二个简单易行的方案后，我们心里就很有底了，去找Ray讨论，Ray听完后一次通过，然后Ray约了Harvey，给Harvey讲完后，Harvey说听起来可以，可以试试。</p>
<p>然后就开始动手，分析竞品加确定方案花了差不多两个月。写心跳的主要代码，只花了一天时间，我记得那天是年会后的一天。回过头来再看这个方案花费的时间还是值得的，后来灰度的统计数据显示，70%用户都可以达到我们的心跳上限。</p>
<p>搞完智能心跳后一段时间在广州没事干，我就跟Ray商量，Ray让我去测试下WebView的性能瓶颈。然后我跟周斯基一起来做这件事，搞完了安卓客户端WebView性能瓶颈测试后，因为怀孕的老婆一个人在深圳，领导就安排我先回深圳了。春哥坚守着把GCM部分完成后才回深圳。</p>
<p>等我们的心跳版本正式发布后，一年前我在公司km上分享了智能心跳方案，吸引不少做push的同事加入了讨论，感觉这方面的交流还是很有必要的。</p>
<p>好了，废话了很多，下面分享一下微信的智能心跳方案细节。由于字数比较多，建议大家使用PC版微信查看。</p>
<h2 id="1-主要目标"><a href="#1-主要目标" class="headerlink" title="1.主要目标"></a>1.主要目标</h2><p>本方案的主要目标是，在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令TCP连接的尽可能大的心跳间隔，从而达到减少安卓微信因心跳引起的空中信道资源消耗，减少心跳Server的负载，以及减少部分因心跳引起的耗电。</p>
<p>主要方法是参考WhatsApp和Line中有价值的做法，结合影响TCP连接寿命的因素，实现Android微信后台自适应心跳算法，同时使用GCM作为辅助通道增加新消息通知的可靠性。</p>
<h2 id="2-WhatsApp、Line、微信的Push策略分析"><a href="#2-WhatsApp、Line、微信的Push策略分析" class="headerlink" title="2. WhatsApp、Line、微信的Push策略分析"></a>2. WhatsApp、Line、微信的Push策略分析</h2><h3 id="2-1-WhatsApp"><a href="#2-1-WhatsApp" class="headerlink" title="2.1 WhatsApp"></a>2.1 WhatsApp</h3><p>在不支持GCM的设备上，采用和微信类似的长连接+心跳策略，WIFI和手机网络下的心跳间隔都为4分45秒，心跳5次后，主动断开连接再重连。</p>
<p>在支持GCM的设备上，主要靠GCM来激活WhatsApp，WhatsApp启动后，会建立一个与服务器的长连接，直接通过此长连接发送Push消息，这个长连接10分钟无消息就会主动断掉，且这十分钟内不做心跳，断掉后WhatsApp客户端和它的服务器不再有连接。当有消息时候，服务器发现没有长连接会发送GCM消息，手机收到GCM消息后，会重新建立长连接来收取消息，10分钟无消息会再断开，如此循环。</p>
<h3 id="2-2-Line"><a href="#2-2-Line" class="headerlink" title="2.2 Line"></a>2.2 Line</h3><p>从测试中发现Line在国内、台湾、美国使用了不同的策略。</p>
<h4 id="2-2-1美国（使用GCM）："><a href="#2-2-1美国（使用GCM）：" class="headerlink" title="2.2.1美国（使用GCM）："></a>2.2.1美国（使用GCM）：</h4><p>启动时，会保持7分钟心跳（CDMA2000网络）维持长连接半小时，之后主动断开长连接。当有消息时，服务器会发送GCM消息，Line客户端接收到GCM消息后，重新建立长连接，并再次用心跳维持半个小时。</p>
<h4 id="2-2-2国内（不使用GCM）："><a href="#2-2-2国内（不使用GCM）：" class="headerlink" title="2.2.2国内（不使用GCM）："></a>2.2.2国内（不使用GCM）：</h4><p>在国内，同样帐号在相同网络，不同的手机上测出了两种策略：</p>
<ul>
<li>长连接+心跳策略（在Galaxy S3上使用），心跳间隔WIFI下是3分20秒，手机网络是7分钟。</li>
<li>轮询策略（在红米和Nexus S上使用），如图2-1所示。与心跳策略的主要区别用红色标出，客户端在长连接建立后也会定时发送请求，Server会回复并且同时关闭长连接。客户端等待轮询间隔T1后再次建立TCP连接。Line会根据手机的活跃状态动态调整T1，调整范围是从最小1分到最大到2小时半。而长连接存活时间T2比较固定，在WIFI下4分钟，手机网络7分钟。如果在T2时收到新消息会延长T2的时间。
<img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312164217.png" alt="图2-1 Line在国内的轮询策略"></li>
</ul>
<h4 id="2-2-3台湾（不使用GCM）："><a href="#2-2-3台湾（不使用GCM）：" class="headerlink" title="2.2.3台湾（不使用GCM）："></a>2.2.3台湾（不使用GCM）：</h4><p>从IBG同事win和guang提供的测试数据中看到，台湾使用的策略跟国内的轮询策略类似。</p>
<h3 id="2-3-微信"><a href="#2-3-微信" class="headerlink" title="2.3 微信"></a>2.3 微信</h3><p>微信没有使用GCM，自己维护TCP长连接，使用固定心跳。</p>
<h3 id="2-4心跳典型值"><a href="#2-4心跳典型值" class="headerlink" title="2.4心跳典型值"></a>2.4心跳典型值</h3><table>
<thead>
<tr>
<th></th>
<th>WhatsApp</th>
<th>Line</th>
<th>GCM</th>
</tr>
</thead>
<tbody><tr>
<td>WIFI</td>
<td>4分45秒</td>
<td>3分20秒</td>
<td>15分钟</td>
</tr>
<tr>
<td>手机网络</td>
<td>4分45秒</td>
<td>7分钟</td>
<td>28分钟</td>
</tr>
</tbody></table>
<h3 id="2-5Line、WhatsApp、微信Push策略的优点"><a href="#2-5Line、WhatsApp、微信Push策略的优点" class="headerlink" title="2.5Line、WhatsApp、微信Push策略的优点"></a>2.5Line、WhatsApp、微信Push策略的优点</h3><ol>
<li>微信：当前心跳间隔比竞品短，所以微信在新消息提醒上会最及时。</li>
<li>使用GCM：Line和WhatsApp使用GCM策略的最大优点就是省电，以及减轻系统负荷（减少后台应用数目）。</li>
<li>Line：Line的轮询策略，优点是当Line处于活跃状态时，及时收消息。当Line处于不活跃状态时，省电。</li>
</ol>
<h3 id="2-6Line、WhatsApp微信Push策略的不足"><a href="#2-6Line、WhatsApp微信Push策略的不足" class="headerlink" title="2.6Line、WhatsApp微信Push策略的不足"></a>2.6Line、WhatsApp微信Push策略的不足</h3><ol>
<li>微信当前心跳频率相对竞品较大，在耗电、耗流量，占用信令通道等方面有所影响。</li>
<li>Line的轮询策略，导致的问题是消息可能会延迟接收，测试发现最大延迟间隔到2.5小时。</li>
<li>WhatsApp和Line使用Push拉起一个定时长连接策略，缺点是要依赖Google的Push服务，如果Google的Push服务不稳定，消息也会延迟接收。</li>
<li>在国内的移动和联通2G网络下，由于运营商的策略，GCM长连接频繁断连，WhatsApp的Push消息很不及时，体验非常差。</li>
</ol>
<h2 id="3-GCM研究"><a href="#3-GCM研究" class="headerlink" title="3. GCM研究"></a>3. GCM研究</h2><h3 id="3-1-GCM特点"><a href="#3-1-GCM特点" class="headerlink" title="3.1 GCM特点"></a>3.1 GCM特点</h3><ol>
<li>Android2.2以下的手机不支持GCM，2.2到3.0需要安装Google Store并设置Google帐号，4.04及以上版本不需要设置帐号也能支持。</li>
<li>GCM只传递数据（可以传递小于4kb的数据），对这些数据的处理可以全部由开发者控制。</li>
<li>Android应用不需要运行就可以接收消息(通过Android广播)。</li>
<li>GCM不保证发送的消息的顺序，也不保证消息一定能够推送到手机。</li>
</ol>
<h3 id="3-2-GCM心跳策略以及存在的问题"><a href="#3-2-GCM心跳策略以及存在的问题" class="headerlink" title="3.2 GCM心跳策略以及存在的问题"></a>3.2 GCM心跳策略以及存在的问题</h3><ol>
<li>用心跳保活长连接，心跳间隔为WIFI下15分钟，数据网络下28分钟。</li>
<li>Google可以改变所有Android设备的心跳间隔值（目前还未改变过）。</li>
<li>GCM由于心跳间隔固定，并且较长，所以在NAT aging-time设置较小的网络（如联通2G，或有些WIFI环境下）会导致TCP长连接在下一次心跳前被网关释放。造成Push延迟接收。</li>
</ol>
<h3 id="3-3-GCM的可用性及稳定性"><a href="#3-3-GCM的可用性及稳定性" class="headerlink" title="3.3 GCM的可用性及稳定性"></a>3.3 GCM的可用性及稳定性</h3><p>目前测试发现GCM在国内可用性不高，原因有：</p>
<ol>
<li>Android很多被手机厂商定制化，厂商可能会去掉GCM服务。</li>
<li>Android2.2到3.0之间需要安装Google Store并设置Google帐号。</li>
<li>由于国内2G和移动3G的NAT超时时间都小于GCM心跳时间(28分钟)，TCP长连接必然无法保活，每次都要等28分钟心跳失败重连后才能收到Push。</li>
<li>某些运营商可能限制了5228端口，移动3G/2G下，发现几乎无法连接上GCM服务器，也就无法获得GCM通知，WhatsApp放后台10分钟后，经常很长时间都收不到Push消息。</li>
</ol>
<p>在美国3G网络下抓包的24小时，GCM的连接极其稳定，24小时内GCM长连接未曾断过，在台湾3G网络下抓包14个小时，GCM连接也只断过一次。WhatsApp用户在此类地区网络下客户端可以获得很及时的Push通知。</p>
<p>在中国电信3G下抓包，大部分时间GCM连接都比较稳定，只会因为偶尔的DHCP造成断连现象，由于频率很低(平均数小时才发生一次)，对Push体验的影响不大。</p>
<h3 id="3-4-GCM-Server类型"><a href="#3-4-GCM-Server类型" class="headerlink" title="3.4 GCM Server类型"></a>3.4 GCM Server类型</h3><p>GCM提供两种Server模型：</p>
<ol>
<li>HTTP Server : 使用同步接口发送HTTP请求，一次请求可以发给最多1000个设备。</li>
<li>XMPP Server :使用异步接口发送请求，只支持对单个设备（或同一个用户的多个关联设备发送），发送请求并发数须小于1000，支持设备到云端Server发送数据。需要Google将我们的发送Server加入白名单。</li>
</ol>
<h2 id="4-微信可能的改进点探讨"><a href="#4-微信可能的改进点探讨" class="headerlink" title="4.微信可能的改进点探讨"></a>4.微信可能的改进点探讨</h2><p>微信Push的优化主要有几个优化点：</p>
<ol>
<li>公共Push通道</li>
<li>使用GCM Push作为辅助通道</li>
<li>自适应心跳间隔优化</li>
</ol>
<h3 id="4-1-公共Push通道"><a href="#4-1-公共Push通道" class="headerlink" title="4.1 公共Push通道"></a>4.1 公共Push通道</h3><p>由于GCM在国内的可靠性很低，现在国内Android上的Push基本上是各自为政，很多软件都自己实现Push。导致手机被经常性的唤醒，耗电耗流量严重。</p>
<p>市面上已经有很多第三方的公共推送服务，大家可以选择一个适合自己应用的推送服务。腾讯也有信鸽和维纳斯组件，大家在选择方案的时候可以对比下。</p>
<p>最终因为我们国内外使用一套方案，并且是辅助公道，所以我们选择使用GCM。</p>
<h3 id="4-2-使用GCM-Push作为辅助通道"><a href="#4-2-使用GCM-Push作为辅助通道" class="headerlink" title="4.2 使用GCM Push作为辅助通道"></a>4.2 使用GCM Push作为辅助通道</h3><p>当前使用GCM的成本不大，可以使用GCM作为辅助通道来增加新消息的及时性。</p>
<p>使用GCM作为辅助通道，在支持GCM的设备上微信上传自己的注册GCM ID给微信Server。</p>
<p>微信Server在发现长连接失效的情况下，可以使用GCM 作为辅助通道通知客户端有新消息，客户端收到push通知后做一次sync。</p>
<p>只利用GCM来激活微信，不传递消息的具体数据，要控制给同一设备发送GCM通知的时间间隔(如五分钟)。</p>
<h3 id="4-3-自适应心跳间隔优化"><a href="#4-3-自适应心跳间隔优化" class="headerlink" title="4.3 自适应心跳间隔优化"></a>4.3 自适应心跳间隔优化</h3><h4 id="4-3-1影响TCP连接寿命的因素"><a href="#4-3-1影响TCP连接寿命的因素" class="headerlink" title="4.3.1影响TCP连接寿命的因素"></a>4.3.1影响TCP连接寿命的因素</h4><p>在Android下，不管是GCM，还是微信，都是通过TCP长连接来进行Push消息的，TCP长连接存活，消息Push就及时，所以要对影响TCP连接寿命的因素进行研究。</p>
<h5 id="1、NAT超时"><a href="#1、NAT超时" class="headerlink" title="1、NAT超时"></a>1、NAT超时</h5><p>大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断（NAT超时的更多描述见附录6.1）。NAT超时是影响TCP连接寿命的一个重要因素(尤其是国内)，所以客户端自动测算NAT超时时间，来动态调整心跳间隔，是一个重要的优化点。</p>
<h5 id="2、DHCP的租期（lease-time）"><a href="#2、DHCP的租期（lease-time）" class="headerlink" title="2、DHCP的租期（lease time）"></a>2、DHCP的租期（lease time）</h5><p>目前测试发现安卓系统对DHCP的处理有Bug，DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。（租期问题的具体描述见附录6.2）。</p>
<h5 id="3、网络状态变化"><a href="#3、网络状态变化" class="headerlink" title="3、网络状态变化"></a>3、网络状态变化</h5><p>手机网络和WIFI网络切换、网络断开和连上等情况有网络状态的变化，也会使长连接变为无效连接，需要监听响应的网络状态变化事件，重新建立Push长连接。</p>
<h4 id="4-3-2-心跳范围选择"><a href="#4-3-2-心跳范围选择" class="headerlink" title="4.3.2 心跳范围选择"></a>4.3.2 心跳范围选择</h4><h5 id="1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。"><a href="#1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。" class="headerlink" title="1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。"></a>1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。</h5><p>微信进入后台（或者前台关屏）时，先用几次最小心跳维持长链接。然后进入后台自适应心跳计算。这样做的目的是尽量选择用户不活跃的时间段，来减少心跳计算可能产生的消息不及时收取影响。</p>
<h5 id="2、后台自适应心跳选择区间："><a href="#2、后台自适应心跳选择区间：" class="headerlink" title="2、后台自适应心跳选择区间："></a>2、后台自适应心跳选择区间：</h5><p>可根据自身产品的特点选择合适的心跳范围。</p>
<h4 id="4-3-3-状态转换图"><a href="#4-3-3-状态转换图" class="headerlink" title="4.3.3 状态转换图"></a>4.3.3 状态转换图</h4><p><img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312164921.png" alt="tips-net-mars-heartbeat-2019312164921"></p>
<h4 id="4-3-4自适应心跳算法描述"><a href="#4-3-4自适应心跳算法描述" class="headerlink" title="4.3.4自适应心跳算法描述"></a>4.3.4自适应心跳算法描述</h4><h5 id="1、按网络类型区分计算："><a href="#1、按网络类型区分计算：" class="headerlink" title="1、按网络类型区分计算："></a>1、按网络类型区分计算：</h5><p>因为每个网络的NAT时间可能不一致。所以需要区分计算，数据网络按subType做关键字，WIFI按WIFI名做关键字。
对稳定的网络，因为NAT老化时间的存在，在自适应计算态的时候，暂设计以下步骤在当前心跳区间逼近出最大可用的心跳。</p>
<h6 id="a）-变量说明："><a href="#a）-变量说明：" class="headerlink" title="a） 变量说明："></a>a） 变量说明：</h6><ul>
<li>[MinHeart，MaxHeart]——心跳可选区间。</li>
<li>successHeart——当前成功心跳，初始为MinHeart</li>
<li>curHeart——当前心跳初始值为successHeart</li>
<li>heartStep——心跳增加步长</li>
<li>successStep——稳定期后的探测步长</li>
</ul>
<h6 id="b）-最大值探测步骤："><a href="#b）-最大值探测步骤：" class="headerlink" title="b） 最大值探测步骤："></a>b） 最大值探测步骤：</h6><p><img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312165138.png" alt="图4-1 自适应心跳计算流程"></p>
<p>自适应心跳计算流程如图4-1所示，经过该流程，会找到必然使心跳失败的curHeart（或者MaxHeart），为了保险起见，我们选择比前一个成功值稍微小一点的值作为后台稳定期的心跳间隔。</p>
<p>影响手机网络测试的因素太多，为了尽量保证测试结果的可靠性，我们使用延迟心跳测试法。在我们重新建立TCP连接后，先使用 短心跳连续成功三次，我们才认为网络相对稳定，可以使用curHeart进行一次心跳测试。图4-2显示了一次有效心跳测试过程。图4-3显示了在没有达到稳定网络环境时，我们会一直使用固定短心跳直到满足三次连续短心跳成功。</p>
<p>使用延迟心跳测试的好处是，可以剔除偶然失败，和网络变化较大的情况（如地铁），使测试结果相对可靠（五次延迟测试确定结论）。同时在网络波动较大的情况，使用短心跳，保证收取消息相对及时。</p>
<h6 id="c）-运行时的动态调整策略-已经按测算心跳稳定值后"><a href="#c）-运行时的动态调整策略-已经按测算心跳稳定值后" class="headerlink" title="c） 运行时的动态调整策略(已经按测算心跳稳定值后)"></a>c） 运行时的动态调整策略(已经按测算心跳稳定值后)</h6><p><strong>NAT超时值算出来后，在维持心跳的过程中的策略</strong></p>
<ol>
<li>无网络、网络时好时坏、偶然失败、NAT超时变小：在后台稳定期发生心跳发生失败后，我们使用延迟心跳测试法测试五次。如果有一次成功，则保持当前心跳值不变；如果五次测试全失败，重新计算合理心跳值。该过程如图4-4所示，有一点需要注意，每个新建的长连接需要先用短心跳成功维持3次后才用successHeart进行心跳。
<img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312165229.png" alt="图4-2 后台稳定态动态调整心跳策略"></li>
<li>NAT超时变大：以周为周期，每周三将后台稳定态调至自适应计算态，使用心跳延迟法往后探测心跳间隔。</li>
<li>successHeart是NAT超时临界值：因为我们现在选择的是一个比successHeart稍小的值作为稳定值，所以在计算过程中可以避开临界值。当运营商在我们后台稳定期将NAT超时调整为我们当前计算值，那么由于我们每周会去向下探索，所以下一周探测时也可以及时调整正确。</li>
</ol>
<h4 id="4-3-5-冗余Sync和心跳"><a href="#4-3-5-冗余Sync和心跳" class="headerlink" title="4.3.5 冗余Sync和心跳"></a>4.3.5 冗余Sync和心跳</h4><p>在用户的一些主动操作以及联网状态改变时，增加冗余Sync和心跳，确保及时收到消息。</p>
<ol>
<li>当用户点亮屏幕的时候，做一次心跳。</li>
<li>当微信切换到前台时，做一次Sync。</li>
<li>联网时重建信令TCP，做一次Sync</li>
</ol>
<h2 id="5-可能存在的风险及预防措施"><a href="#5-可能存在的风险及预防措施" class="headerlink" title="5. 可能存在的风险及预防措施"></a>5. 可能存在的风险及预防措施</h2><h3 id="5-1-DHCP租期因素"><a href="#5-1-DHCP租期因素" class="headerlink" title="5.1 DHCP租期因素"></a>5.1 DHCP租期因素</h3><ol>
<li>问题：根据目前的测试结果显示，安卓不续约到期的IP Bug，会导致TCP连接在不确定的时间点失效，从而会导致一次心跳失败。</li>
<li>预防：统计后台稳定期的心跳成功率，上报给后台。后台可以按地区分网络监控这个指标的波动，并且后台可以根据不同的波动，动态调整某区域特定网络下可选的心跳区间。</li>
</ol>
<h3 id="5-2-其他影响TCP寿命的因素"><a href="#5-2-其他影响TCP寿命的因素" class="headerlink" title="5.2 其他影响TCP寿命的因素"></a>5.2 其他影响TCP寿命的因素</h3><p>是否有遗漏的因素？欢迎各位联系我反馈。</p>
<h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h2><h3 id="6-1-附录A——NAT超时介绍"><a href="#6-1-附录A——NAT超时介绍" class="headerlink" title="6.1 附录A——NAT超时介绍"></a>6.1 附录A——NAT超时介绍</h3><p>因为 IP v4 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换(Network Address Translation，NAT)。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯。
<img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312165718.png" alt="NAT 功能由图中的 GGSN 模块实现"></p>
<p>大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。下表列出一些已测试过的网络的NAT超时时间(更多数据由于测试条件所限没有测到)：</p>
<table>
<thead>
<tr>
<th>地区/网络</th>
<th>NAT超时时间</th>
</tr>
</thead>
<tbody><tr>
<td>中国移动3G和2G</td>
<td>5分钟</td>
</tr>
<tr>
<td>中国联通2G</td>
<td>5分钟</td>
</tr>
<tr>
<td>中国电信3G</td>
<td>大于28分钟</td>
</tr>
<tr>
<td>美国3G</td>
<td>大于28分钟</td>
</tr>
<tr>
<td>台湾3G</td>
<td>大于28分钟</td>
</tr>
</tbody></table>
<p>长连接心跳间隔必须要小于NAT超时时间(aging-time)，如果超过aging-time不做心跳，TCP长连接链路就会中断，Server就无法发送Push给手机，只能等到客户端下次心跳失败后，重建连接才能取到消息。</p>
<h3 id="6-2-附录B——安卓DHCP的租期（lease-time）问题"><a href="#6-2-附录B——安卓DHCP的租期（lease-time）问题" class="headerlink" title="6.2 附录B——安卓DHCP的租期（lease time）问题"></a>6.2 附录B——安卓DHCP的租期（lease time）问题</h3><p>目前测试发现安卓系统对DHCP的处理有Bug：</p>
<ol>
<li>DHCP租期到了不会主动续约并且会继续使用过期IP，详细描述见<a href="http://www.net.princeton.edu/android/android-stops-renewing-lease-keeps-using-IP-address-11236.html。这个问题导致的问题表象是，在超过租期的某个时间点（没有规律）会导致IP过期，老的TCP连接不能正常收发数据。并且系统没有网络变化事件，只有等应用判断主动建立新的TCP连接才引起安卓设备重新向DHCP" target="_blank" rel="noopener">http://www.net.princeton.edu/android/android-stops-renewing-lease-keeps-using-IP-address-11236.html。这个问题导致的问题表象是，在超过租期的某个时间点（没有规律）会导致IP过期，老的TCP连接不能正常收发数据。并且系统没有网络变化事件，只有等应用判断主动建立新的TCP连接才引起安卓设备重新向DHCP</a> Server申请IP租用。</li>
<li>未到租期的一半时间，安卓设备重新向DHCP Server申请IP租用。从目前测试结果来看，这种现象恢复的比较快。</li>
<li>移动2G/3G，联通2G没有抓到DHCP。</li>
<li>美国3G下抓取24小时，没有抓到DHCP。</li>
</ol>
<blockquote>
<p>转自<a href="https://mp.weixin.qq.com/s/ghnmC8709DvnhieQhkLJpA" target="_blank" rel="noopener">Android微信智能心跳方案</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/12/tips-net-mars-ip-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/12/tips-net-mars-ip-sort/" itemprop="url">
                  微信终端跨平台组件 Mars 系列（三）连接超时与IP&Port排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T15:53:52+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mars 是微信官方的终端基础组件，是一个使用 C++ 编写的业务无关、跨平台的基础组件。目前在微信 Android、iOS、Windows、Mac、WP 等多个平台中使用。Mars 主要包括以下几个独立的部分：</p>
<ul>
<li>COMM：基础库，包括socket、线程、消息队列、协程等基础工具；</li>
<li>XLOG：通用日志模块，充分考虑移动终端的特点，提供高性能、高可用、安全性、容错性的日志功能；（详情点击：高性能日志模块xlog）</li>
<li>SDT：网络诊断模块；</li>
<li>STN：信令传输网络模块，负责终端与服务器的小数据信令通道。包含了微信终端在移动网络上的大量优化经验与成果，经历了微信海量用户的考验。</li>
</ul>
<p>Mars 系列开始，将为大家介绍 STN（信令传输网络模块）。由于 STN 的复杂性，该模块将被分解为多个篇章进行介绍。本文主要介绍微信中关于 socket 连接及 IP&amp;Port 选择的思考与设计。</p>
<h2 id="你需要知道的TCP连接"><a href="#你需要知道的TCP连接" class="headerlink" title="你需要知道的TCP连接"></a>你需要知道的TCP连接</h2><p>TCP 协议应该是目前使用的最广泛的传输层协议，它提供了可靠的端到端的传输，为应用的设计节省了大量的工作。TCP 建立连接的”三次握手”与连接终止的“四次挥手”也广为人知。在这简单的 connect 调用中，还能做怎样的思考与设计呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct *addr, socklen_t addrlen)</span><br></pre></td></tr></table></figure>

<h3 id="连接的超时重传"><a href="#连接的超时重传" class="headerlink" title="连接的超时重传"></a>连接的超时重传</h3><p>超时与重传是 TCP 协议最核心的部分，在不稳定的移动网络中，超时重传的设计尤为重要。在连接建立的过程中，由于网络本身的不可靠特性，不可避免的需要重传的机制来保障可靠服务。在《TCP/IP详解 卷1》的描述中，在大多数 BSD 实现中，若主动 connect 方没有收到 SYN 的回应，会在第6秒发送第2个 SYN 进行重试，第3个 SYN 则是与第2个间隔24秒。在第75秒还没有收到回应，则 connect 调用返回 ETIMEOUT。</p>
<p>这就意味着，在不能立刻确认失败（例如 unreachable 等）的情况下，需要75秒的时间，才能获得结果。如果真相并不是用户的网络不可用，而是某台服务器故障、繁忙、网络不稳定等因素，那75秒的时间只能尝试1个 IP&amp;Port 资源，对于大多数移动应用而言，是不可接受的。我们需要更积极的超时重传机制！！！</p>
<p>然而，我们并不能修改 TCP 的协议栈，我们只能在应用层进行干预，设计应用层的超时机制。说干就干，这个时候你是否已经在构思新的、应用层的连接超时重传机制了呢？应用层的超时重传，典型做法就是提前结束 connect 的阻塞调用，使用新的 IP&amp;Port 资源进行 connect 重试。但是，我们应该选择怎样的连接超时值呢？4秒？10秒？20秒？30秒？不同的应用场景会有不同的选择。我们来看一下常见的几种场景：</p>
<ul>
<li>连不通 or 网络不可用等</li>
<li>服务器繁忙 or 中间路由故障等</li>
<li>基站繁忙 or 连接信号弱 or 丢包率高等</li>
</ul>
<p>在第一种场景中，连接超时设置不会带来什么区别。在第二种场景中，部分服务器资源或路由不可用，我们希望连接超时能稍微短一些，使得我们能尽快的发现故障，并且通过更换 IP&amp;Port 的方式获得可用资源或路由路径。而第三种场景则是在移动网络中经常遇到的弱网络的场景。在这种场景中，我们更换 IP&amp;Port 资源也是无效的，因此希望连接超时能相对长一些，进行更多的TCP层的重传。（当然，也不是超时越长越好，后面的分析可以看到很多等待时长是效果低微的）</p>
<p>不同的场景对连接超时有不同的需求，然而，我们在程序中并没有很好的方法来区分这些场景。在进行连接超时这个阈值的选择前，我们先来看看，当前主流的 android、iOS 操作系统的连接设计。android 的 TCP 层连接超时重传如下图所示（测试机型为 nexus5，android 4.4）。超时间隔依次为（1，2，4，8，16），第5次重试后32秒返回 ETIMEOUT，总用时63秒。超时设置符合 Linux 的常规设置。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162610.png" alt="tips-net-mars-ip-sort-2019312162610"></p>
<p>但在不同的机型中，偶尔会出现差异性。如下图 android 抓包（三星 android 4.4）。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162636.png" alt="tips-net-mars-ip-sort-2019312162636"></p>
<p>iOS 的 connect 超时重传如下图所示。超时间隔依次为（1，1，1，1，1，2，4，8，16，32），总共是67s。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162711.png" alt="tips-net-mars-ip-sort-2019312162711"></p>
<p>经过 tcpdump 的调研分析后，我们发现：</p>
<ol>
<li>在 iOS 系统中对 connect 的超时重传进行了一定的修改，在 connect 初期使用更积极的策略，以适应移动网络的不稳定特征。而在 android 系统中，connect 超时重传则使用了较为“懒惰”、适用于有线网络的超时重传间隔；</li>
<li>不管什么平台，连接总超时时长都需要1分钟左右，这个时长在大多数移动应用中，都是不符合用户体验要求的；</li>
<li>连接的初始阶段，TCP 超时重传会更积极一些，越到后面，重传间隔越大。</li>
</ol>
<p>因此，在实际的连接超时设置上，我们根据不同的系统特征，结合应用能接受的“用户体验”范围，可以设置不同的连接超时间隔。例如在 iOS 系统中，由于采用了较为积极的超时间隔，我们可以将 connect 调用的超时设置为10s。在10s内，iOS 会自动进行6次的重发。在 android 系统中，系统会在第7秒发起第3次重发，之后需要在第15秒才会重发。在不同的用户体验要求下，应用可以将 connect 的调用超时设置为不同的值。例如也可以设置为10s（意味着给第3次重发3s的等待时间），从而避免无效的等待时长。同时通过更换 IP&amp;Port 后，重新调用 connect 操作的方式，来获得更积极的重发策略，更快的查找到可用的 IP&amp;Port 组合。</p>
<h3 id="连接的终止"><a href="#连接的终止" class="headerlink" title="连接的终止"></a>连接的终止</h3><p>“四次挥手”的连接终止协议已经口熟能详。过程如下图所示。需要关注的是，图中主动关闭的一方会进入 TIME_WAIT 状态，在此状态中通常将停留2倍的 MSL 时长。MSL 时长在不同的操作系统中有不同的设置，通常在30秒到60秒。TIME_WAIT 的数量太多会导致耗尽主动关闭方的 socket 端口和句柄，导致无法再发起新的连接，进而严重影响主动关闭方的并发性能。虽然在实际的使用中，可以通过 tcp_tw_recycle，tcp_tw_reuse，tcp_max_tw_buckets 等方式缓解该问题，但也会带来一些副作用。最好的解决方案是在协议的设计上，尽量的由终端来发起关闭的操作，避免服务器的大量 TIME_WAIT 状态。例如，使用长连接避免频繁的关闭；在短连接的协议设计上，务必加上终止标记（例如 http 头部加上 content-length ）使得可以由终端来发起关闭的操作。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162922.png" alt="tips-net-mars-ip-sort-2019312162922"></p>
<h3 id="串行连接-VS-并发连接-VS-复合连接"><a href="#串行连接-VS-并发连接-VS-复合连接" class="headerlink" title="串行连接 VS 并发连接 VS 复合连接"></a>串行连接 VS 并发连接 VS 复合连接</h3><p>在上述的连接超时策略中，我们选择10秒的连接超时。这就意味着我们需要10秒的时间来确认一个 IP&amp;Port 组合的 connect 超时。当我们有多个 IP&amp;Port 资源时，遍历的效率偏低。那我们是否能设置 connect 的超时为更短呢？例如4秒。我们知道移动互联网具有不稳定的特征，超时时间设置过短，会导致在弱网络的情况下，connect 总是失败，导致不可用。串行连接的策略在超时选择上，由于需要兼顾高性能与高可用的设计目标，使得该策略是一个相对“慢”的连接策略。</p>
<p>与此相应，我们会想到并发连接的策略。并发连接，同时发起对N个 IP&amp;Port 的连接调用，可以让我们第一时间发现可用的连接，并且还顺带发现了 connect 最快的 IP&amp;Port 配置。并发连接可以一举解决了“高性能”、“高可用”的设计目标，看起来很完美。然而，这个时候，服务端的同学“跳”起来了。在并发连接的策略下，服务器需要提供的连接能力是串行连接的N倍，对服务器连接资源是极大的浪费。同时，并发连接是否会引起连接资源的竞争，从而影响网络正常用户的常规体验，也是个未知的因素。</p>
<p>让我们来回顾串行连接与并行连接的优缺点。</p>
<h4 id="串行连接"><a href="#串行连接" class="headerlink" title="串行连接"></a>串行连接</h4><ul>
<li>资源占用少</li>
<li>无服务器负载问题</li>
<li>超时选择困难</li>
<li>最慢可用</li>
</ul>
<h4 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h4><ul>
<li>网络资源竞争</li>
<li>服务器负载高</li>
<li>最快可用</li>
</ul>
<p>那么，有没有一种策略，能同时满足高性能、高可用、低负载的目标呢？在微信的连接设计中，我们使用了”复合连接“的策略。如下图所示。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312163133.png" alt="tips-net-mars-ip-sort-2019312163133"></p>
<p>初始阶段，应用发起对 IP1 &amp;Port1 的 connect 调用。在第4秒的时候，如果第一个 connect 还没有返回，则发起对 IP2 &amp;Port2 的 connect 调用。以此类推，直至发起了5组 IP&amp;Port 的 connect 调用。 </p>
<ul>
<li>对比串行连接与并行连接，复合连接有以下特点：</li>
<li>常规情况下，服务器负载与串行连接策略相同，实现了低负载的目标；</li>
<li>异常情况下，每4s发起新（IP，Port）组合的 connect 调用，使得应用可以快速的查找可用 IP&amp;Port，实现高性能的目标；</li>
<li>在超时时间的选择上，复合方式的“并发”已经实现了高性能、低负载的目标，因此在超时时间的选择上可以相对宽松，以保障高可用为重。</li>
</ul>
<p>综合对比，复合连接能够维持低资源消耗的情况下，能同时实现低负载、高性能、高可用的目标。</p>
<h2 id="微信-IP-amp-Port-排序算法的演进"><a href="#微信-IP-amp-Port-排序算法的演进" class="headerlink" title="微信 IP&amp;Port 排序算法的演进"></a>微信 IP&amp;Port 排序算法的演进</h2><p>在建立连接的调用中，除了超时时间的设置外，IP&amp;Port是连接的最重要参数。IP&amp;Port 的排序、选择对于 connect 的性能也是有着重大的影响。本节主要讨论在已知 IP 列表、Port 列表的情况下，如何排序、组合的问题，而不讨论如何获得就近接入等问题。</p>
<h3 id="IP-amp-Port-的组成"><a href="#IP-amp-Port-的组成" class="headerlink" title="IP&amp;Port 的组成"></a>IP&amp;Port 的组成</h3><p>在微信中，IP有多种来源类型。优先级从上而下分别为：</p>
<ul>
<li>WXDNS IP 自建的DNS服务获得的IP列表</li>
<li>DNS IP 通过常规的 DNS 解析获得的 IP 列表</li>
<li>Auth IP 动态下发的保底列表</li>
<li>Hardcode IP 最终保底IP列表</li>
</ul>
<p>WXDNS IP 是通过微信自建的 DNS 服务获得的IP列表，自建 DNS 对防劫持、有效期控制等有重要作用。DNS IP 则是通过常规的 DNS 解析获得的 IP 列表。Auth IP 是微信动态下发的保底IP列表。而Hardcode IP 则是最终的保底IP列表。总体而言，分为常规IP列表、保底IP列表两个类别。WXDNS IP、DNS IP 为常规列表，Auth IP，Hardcode IP 为保底列表。同时，在组成实际使用的 IP&amp;Port 列表时，由于 WXDNS 与 DNS 的功能近似，因此通常只出现其中一种类型的IP列表。Auth IP 与Hardcode IP 的功能近似，也是同时只能出现两者中的一种类型。 
在 Port 的选择上，微信服务在常规情况下提供2个端口，预防端口被封锁的情况。特别情况下，可以通过配置下发进行端口更新。</p>
<h3 id="IP-amp-Port排序算法（一）：随机组合排序算法"><a href="#IP-amp-Port排序算法（一）：随机组合排序算法" class="headerlink" title="IP&amp;Port排序算法（一）：随机组合排序算法"></a>IP&amp;Port排序算法（一）：随机组合排序算法</h3><p>每个TCP连接都是以 IP&amp;Port 的组合为唯一标识。在 IP&amp;Port 的选择上，我们初步归纳为2个目标：</p>
<ul>
<li>高可用：尽快的找到可用的 IP&amp;Port 资源</li>
<li>高性能：优先使用质量好的 IP&amp;Port</li>
<li>负载均衡：IP的排序算法不带任何偏向因子，避免造成人为的负载不均衡</li>
</ul>
<p>在微信早期的排序选择上，我们使用了一种随机组合的排序算法。即将 WXDNS or DNS IP 列表与 Port 列表进行组合，组合后的结果进行随机排序。在随机排序的结果列表中，使用下述步骤进行排序：</p>
<ol>
<li>选取IP1+Port1；</li>
<li>选取IP2+Port2，尽量使得IP1与IP2不相等，Port1与Port2不相等；</li>
<li>选取IP3+Port3，尽量使得IP3与IP1、IP2都不相等，Port3与Port1、Port2都不相等；</li>
<li>以此类推，形成常规列表。</li>
</ol>
<p>同理，使用 Auth IP or Hardcode IP 列表与 Port 列表的组合，我们按照相同算法生成另外一份保底列表，并将保底列表排序在常规列表的后面，从而组成完整的 IP&amp;Port 列表。随机组合排序的算法有着以下的特点：</p>
<ul>
<li>高性能：每一次尝试都尽量使用完全不同的资源，使得能最快的发现可用资源；</li>
<li>初始随机，从而避免列表顺序的固化；</li>
<li>保底列表在最后，形成最后的保护屏障；</li>
<li>在不同的网络下，维护着不同的资源列表。</li>
</ul>
<p>在使用中，如果发现 IP&amp;Port 访问失败，则在列表中 ban 掉该资源。这里有个小优化，即当 IP1&amp;Port1 的上一次访问成功时，需要连续失败2次才 ban 该资源。目的是为了减小偶然的网络抖动造成的影响。</p>
<p>随机组合排序算法的设计初衷，是为了以最快的速度尝试不同的资源组合，从而快速寻找到可用的资源。然而，在微信的实际使用中，却发现这种算法存在着诸多的问题。例如：</p>
<ul>
<li>网络不可用或网络较大波动情况下，列表被ban的速度较快；</li>
<li>Auth IP or Hardcode IP 列表太容易被访问到：随着常规资源陆续被ban，保底资源总是会被访问到，造成对保底资源的访问量大。保底资源是为了微信服务这不符合保底资源的设计初衷。</li>
<li>当引入复合连接策略后，IP资源不足。这是因为 ban 的策略简单粗暴的丢弃失败的 IP，导致 IP 资源越来越少；</li>
<li>每次缓存超时或列表轮空后，对于新列表没有经验信息可用</li>
</ul>
<p>在随机组合排序算法的基础上，为了解决遇到的新问题，微信使用了新的“以史为鉴”的算法。</p>
<h3 id="IP-amp-Port-排序算法（二）：以史为鉴"><a href="#IP-amp-Port-排序算法（二）：以史为鉴" class="headerlink" title="IP&amp;Port 排序算法（二）：以史为鉴"></a>IP&amp;Port 排序算法（二）：以史为鉴</h3><p>由于复合连接的引入，在每次复合连接的尝试中，微信可以伪“并发”的对N个 IP&amp;Port 进行 connect（微信中目前N=5）。简单的ban丢弃的策略会使得 IP 资源越来越少。 针对这个特点，我们对IP&amp;Port算法进行了以下修改：</p>
<ul>
<li>初始资源列表分为两类列表：常规列表，保底列表，分别使用方案（一）随机组合排序算法生成初始顺序；</li>
<li>对每次复合连接使用的列表，规定5个资源的组成是4个常规资源+1个保底资源，并且保底资源在最后（完全无法获取常规资源的情况除外）。这种资源组成方式一方面解决了“保底资源太容易被访问到”的问题，一方面也保障了保底资源的作用；</li>
<li>在不同网络中，分别记录每个 IP&amp;Port 的使用情况，并根据使用记录进行评分、排序；</li>
<li>区分连续记录：对每个 IP&amp;Port 的更新，10秒内的连续成功或失败，不进行使用情况的记录。这种处理方式一方面是为了避免网络不可用或网络出现较大波动时，IP资源被过快的错误标记；一方面也避免失败历史被快速的覆盖；</li>
<li>最近的8条使用记录中，如果有超过3条失败记录，且最新一次失败记录时间为10分钟内，则本次排序ban该记录。这种处理方式的目的是避免历史分数较高的 IP&amp;Port 在突然出现故障时很难被排序算法排除的问题；</li>
<li>无历史的记录使用随机评分排序。</li>
</ul>
<p>通过上述方法，我们保证了保底资源不会被轻易访问到，解决了列表被快速标记的问题，同时也保证了历史记录好的资源在出现故障时也能被快速替换。</p>
<h3 id="IP-amp-Port-排序算法（三）：遗忘历史"><a href="#IP-amp-Port-排序算法（三）：遗忘历史" class="headerlink" title="IP&amp;Port 排序算法（三）：遗忘历史"></a>IP&amp;Port 排序算法（三）：遗忘历史</h3><p>“以史为鉴”的方案在微信中使用了一段时间，看起来运行良好。直至某一天，微信的部分服务集群出现了故障。虽然微信客户端快速的切换到可用的服务器资源，但当故障服务器恢复后，微信客户端却迟迟没有分流到已恢复服务的集群，导致部分微信服务器负载过高，而部分微信服务器却负载较低的情况。通过分析，发现“以史为鉴”的排序方案存在着一些问题：</p>
<ul>
<li>初始阶段排在前面的资源容易获得较多的成功记录，从而分数始终维持在较高的水平；</li>
<li>出灾情况下，故障机器由于有失败记录，使得很难获得“被原谅”的机会，从而也很难更新使用历史；</li>
<li>采用了无历史记录随机评分，破坏了原有的“相邻记录尽量不相同”的随机性设计；
因此，好的 IP&amp;Port 排序算法，不仅应该快速的发现可用的资源，使得在出灾情况下能快速的响应，同时，也应该具备一定的“遗忘性”、“容灾性”，使得灾情恢复后能较快的发现“灾情恢复”这一事实，并且进行重排序，使得服务器资源得到更合理的使用。在综合考虑“以史为鉴”和“遗忘历史”后，新的 方案具有以下特征：</li>
<li>内存历史、文件历史双层记录历史：反映资源使用的近期情况及历史情况；</li>
<li>初始化状态：每次进程重启或网络切换后，从文件历史中“压缩”出内存历史作为初始状态；</li>
<li>旁路检测：额外更新历史的渠道，更有助于挑选高性能的资源，并且帮助“灾情恢复”的资源获得使用的机会；</li>
<li>文件历史的遗忘性：文件历史每24小时强制刷新，避免高分数的记录长期“占有”队列；</li>
<li>无历史、有历史的混合排序。</li>
</ul>
<p>具体实现查看 Mars 源代码中的 simple_ipport_sort。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连接是信令传输的前提，一个简单的连接操作蕴含着不少的优化空间。在连接超时的选择上，我们要兼顾性能与可用性，过短的连接超时可能导致弱网络下的低可用性，但过长的连接超时又影响用户体验。在 STN 中，我们结合系统本身的 TCP 连接重传特性，进行了相应的设计考量。即使如此，串行的连接方案仍然不能满足高性能的需求。并发连接的方案获得高性能的同时，也带来了服务器负载剧增的损失。综合考虑下，STN 使用了“复合连接”的方案，获得高性能的同时，也保证通常情况下的服务器低负载。</p>
<p>IP&amp;Port 是连接的最重要资源，IP&amp;Port 的排序选择是连接过程的重要部分。在微信的实际使用中，我们依次使用了“随机组合”、“以史为鉴”、“遗忘历史”三种方案，综合的考虑了查找性能、移动互联网的不稳定性、容灾及容灾恢复等。</p>
<p>连接超时、连接策略及 IP&amp;Port 排序是连接的是三个重要组成部分，相关的方案也随着微信实践在不断的发展中。相信在不同的应用场景中，我们可能会遇到更多的不同问题及需求。随着Mars的开源，也能有机会参考、吸收其他应用中的实战经验，使得网络优化持续的深入。</p>
<blockquote>
<p>转自<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286458&idx=1&sn=320f690faa4f97f7a49a291d4de174a9&chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd" target="_blank" rel="noopener">微信终端跨平台组件 Mars 系列（三）连接超时与IP&amp;Port排序</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg" alt="轻口味">
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">190</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </div></footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
