<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/page/7/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/page/7/"/>





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/08/29/issues-android-2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/29/issues-android-2018/" itemprop="url">
                  android开发踩坑记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-29T17:43:25+08:00">
                2018-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="oppo手机无法在后台启动activity"><a href="#oppo手机无法在后台启动activity" class="headerlink" title="oppo手机无法在后台启动activity"></a>oppo手机无法在后台启动activity</h4><p>在做im语音通话功能时,应用切到后台无法收到呼叫,排查发现信令已收到,启动activity的方法已经调用,但是呼叫页面无法启动.
最开始怀疑是因为新插件化引起的,后来发现旧插件化的工程也无法换气呼叫页,最后在无插件化的demo中发现也无法唤起.
最后发现是oppo手机本身限制,试了华为,小米可以唤起.网上说需要开启自启动权限,实际开启了悬浮窗权限即可唤起.</p>
<p>网上解决方案:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//获取ActivityManager</div><div class="line"></div><div class="line">ActivityManager mAm = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line"></div><div class="line">//获得当前运行的task</div><div class="line"></div><div class="line">List&lt;ActivityManager.RunningTaskInfo&gt; taskList = mAm.getRunningTasks(100);</div><div class="line"></div><div class="line">for(ActivityManager.RunningTaskInfo rti : taskList) &#123;</div><div class="line"></div><div class="line">    //找到当前应用的task，并启动task的栈顶activity，达到程序切换到前台</div><div class="line"></div><div class="line">    if(rti.topActivity.getPackageName().equals(context.getPackageName())) &#123;</div><div class="line"></div><div class="line">        Intent LaunchIntent =new Intent(Intent.ACTION_MAIN);</div><div class="line"></div><div class="line">        ComponentName cn =new ComponentName(Constant.PACKAGE,rti.topActivity.getClassName());</div><div class="line"></div><div class="line">        LaunchIntent.setComponent(cn);</div><div class="line"></div><div class="line">        startActivity(LaunchIntent);</div><div class="line"></div><div class="line">        break;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这段代码的时候最好是判断app在后台之后才使用，在前台的时候调用这段代码，会导致这部分代码之后的程序不执行！
使用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent resultIntent =newIntent(context,Class.forName(rti.topActivity.getClassName()));</div><div class="line"></div><div class="line">            resultIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK| Intent.FLAG_ACTIVITY_SINGLE_TOP);</div><div class="line"></div><div class="line">            context.startActivity(resultIntent);</div></pre></td></tr></table></figure></p>
<p>仍无法正常唤起.</p>
<p>上述方案暂未尝试.</p>
<p>OPPO 在R9系列以上的手机，除非用户开启了“自启动”权限，否则你会在日志中看到一条拦截信息
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OppoAppStartupManager: InterceptInfo com.gx.dfttsdk com.gx.dfttsdk com.gx.dfttsdk.MainActivity com.moban.baidu true</div></pre></td></tr></table></figure></p>
<p>可以看OPPO ColorOS官方社区的帖子：<a href="http://bbs.coloros.com/forum.php?mod=viewthread&amp;tid=527188" target="_blank" rel="external">http://bbs.coloros.com/forum.php?mod=viewthread&amp;tid=527188</a></p>
<p>这是OPPO 系统更新后的拦截操作，禁止应用私自唤起后台应用，除非获得用户允许！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/08/09/android-source-mediaplayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/09/android-source-mediaplayer/" itemprop="url">
                  Android源码分析:Mediaplayer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T16:06:24+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MediaPlayer Factory分别会生成4个不同的MediaPlayer基类：StagefrightPlayer、NuPlayerDriver、MidiFile和TestPlayerStub，四者均继承于MediaPlayerBase。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/08/06/at-android-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/06/at-android-source/" itemprop="url">
                  android自动化测试(二):源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-06T10:45:50+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/autotest/" itemprop="url" rel="index">
                    <span itemprop="name">autotest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h3><p>源码位于:<code>~/development/cmds/monkey/src/com/android/commands/monkey</code></p>
<h3 id="monkeyrunner"><a href="#monkeyrunner" class="headerlink" title="monkeyrunner"></a>monkeyrunner</h3><p>源码位于:<code>~/sdk/monkeyrunner/src/com/android/monkeyrunner</code></p>
<h3 id="instrumentation"><a href="#instrumentation" class="headerlink" title="instrumentation"></a>instrumentation</h3><p>源码位于:<code>~/framenworks/base/test-runner/src</code></p>
<h3 id="uiautomator"><a href="#uiautomator" class="headerlink" title="uiautomator"></a>uiautomator</h3><p>源码位于:<code>~/frameworks/testing/uiautomator/library/src/com/android/ui/automator</code></p>
<h5 id="TestReport类-的源码"><a href="#TestReport类-的源码" class="headerlink" title="TestReport类 的源码"></a>TestReport类 的源码</h5><p><code>https://android.googlesource.com/platform/tools/build/+/tools_r22/gradle/src/fromGradle/groovy/com/android/build/gradle/internal/test/report/TestReport.java</code></p>
<h3 id="cts"><a href="#cts" class="headerlink" title="cts"></a>cts</h3><p>源码位于:<code>cts/tools/tradefed-host/src/com/android/cts/tradefed</code></p>
<p><a href="https://github.com/square/assertj-android" target="_blank" rel="external">https://github.com/square/assertj-android</a></p>
<p><a href="https://github.com/square/spoon" target="_blank" rel="external">https://github.com/square/spoon</a></p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><a href="http://appium.io/docs/en/writing-running-appium/caps/" target="_blank" rel="external">Appium Desired Capabilities</a>
<a href="https://testerhome.com/topics/2601" target="_blank" rel="external">解决部分机型 appium 安装应用时需要手动确认的问题</a></p>
<p><a href="https://python012.github.io/archives/" target="_blank" rel="external">https://python012.github.io/archives/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/08/05/tips-android-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/05/tips-android-process/" itemprop="url">
                  Android应用内多进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-05T05:14:39+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正常情况下，一个apk启动后只会运行在一个进程中，其进程名为AndroidManifest.xml文件中指定的应用包名，所有的基本组件都会在这个进程中运行。但是如果需要将某些组件（如Service、Activity等）运行在单独的进程中，就需要用到android:process属性了。我们可以为android的基础组件指定process属性来指定它们运行在指定进程中。</p>
<p>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。</p>
<p>各类组件元素的清单文件条目—<code>&lt;activity&gt;、&lt;service&gt;、&lt;receiver&gt; 和 &lt;provider&gt;</code>—均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。</p>
<p>此外，<code>&lt;application&gt;</code> 元素还支持 android:process 属性，以设置适用于所有组件的默认值。</p>
<p>如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。</p>
<p>决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 的进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面，我们介绍决定终止进程所用的规则。</p>
<h4 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h4><p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。</p>
<p>重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：</p>
<h5 id="前台进程"><a href="#前台进程" class="headerlink" title="前台进程"></a>前台进程</h5><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p>
<ul>
<li>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</li>
<li>托管某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>托管正在“前台”运行的 Service（服务已调用 startForeground()）</li>
<li>托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>托管正执行其 onReceive() 方法的 BroadcastReceiver
通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</li>
</ul>
<h5 id="可见进程"><a href="#可见进程" class="headerlink" title="可见进程"></a>可见进程</h5><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</p>
<ul>
<li>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</li>
<li>托管绑定到可见（或前台）Activity 的 Service。
可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</li>
</ul>
<h5 id="服务进程"><a href="#服务进程" class="headerlink" title="服务进程"></a>服务进程</h5><p>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
<h5 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h5><p>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。</p>
<h5 id="空进程"><a href="#空进程" class="headerlink" title="空进程"></a>空进程</h5><p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<p>根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 Activity，则会将此进程评定为可见进程，而不是服务进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h4 id="线程安全方法"><a href="#线程安全方法" class="headerlink" title="线程安全方法"></a>线程安全方法</h4><p>在某些情况下，您实现的方法可能会从多个线程调用，因此编写这些方法时必须确保其满足线程安全的要求。</p>
<p>这一点主要适用于可以远程调用的方法，如绑定服务中的方法。如果对 IBinder 中所实现方法的调用源自运行 IBinder 的同一进程，则该方法在调用方的线程中执行。但是，如果调用源自其他进程，则该方法将在从线程池选择的某个线程中执行（而不是在进程的 UI 线程中执行），线程池由系统在与 IBinder 相同的进程中维护。 例如，即使服务的 onBind() 方法将从服务进程的 UI 线程调用，在 onBind() 返回的对象中实现的方法（例如，实现 RPC 方法的子类）仍会从线程池中的线程调用。 由于一个服务可以有多个客户端，因此可能会有多个池线程在同一时间使用同一 IBinder 方法。因此，IBinder 方法必须实现为线程安全方法。</p>
<p>同样，内容提供程序也可接收来自其他进程的数据请求。尽管 ContentResolver 和 ContentProvider 类隐藏了如何管理进程间通信的细节，但响应这些请求的 ContentProvider 方法（query()、insert()、delete()、update() 和 getType() 方法）将从内容提供程序所在进程的线程池中调用，而不是从进程的 UI 线程调用。 由于这些方法可能会同时从任意数量的线程调用，因此它们也必须实现为线程安全方法。</p>
<h4 id="多进程好处"><a href="#多进程好处" class="headerlink" title="多进程好处"></a>多进程好处</h4><p> 一般来说，Android应用多进程有三个好处。</p>
<ol>
<li>我们知道Android系统对每个应用进程的内存占用是有限制的，而且占用内存越大的进程，通常被系统杀死的可能性越大。让一个组件运行在单独的进程中，可以减少主进程所占用的内存，降低被系统杀死的概率.</li>
<li>如果子进程因为某种原因崩溃了，不会直接导致主程序的崩溃，可以降低我们程序的崩溃率。</li>
<li>即使主进程退出了，我们的子进程仍然可以继续工作，假设子进程是推送服务，在主进程退出的情况下，仍然能够保证用户可以收到推送消息。</li>
</ol>
<p>在Android中，虚拟机分配给各个进程的运行内存是有限制值的（这个值可以是32M，48M，64M等，根据机型而定），试想一下，如果在app中，增加了一个很常用的图片选择模块用于上传图片或者头像，加载大量Bitmap会使app的内存占用迅速增加，如果你还把查看过的图片缓存在了内存中，那么OOM的风险将会大大增加，如果此时还需要使用WebView加载一波网页，我就问你怕不怕！</p>
<h4 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h4><p> 我们已经开启了应用内多进程，那么，开启多进程是不是只是我们看到的这么简单呢？其实这里面会有一些陷阱，稍微不注意就会陷入其中。我们首先要明确的一点是进程间的内存空间时不可见的。从而，开启多进程后，我们需要面临这样几个问题：</p>
<ol>
<li>所有运行在不同的进程中的四大组件,只要它们之间需要通过内存来共享数据,都会共享失败</li>
<li>Application的多次重建。</li>
<li>线程同步机制完全失效(不同的进程的锁都不是同一个对象)</li>
<li>静态成员和单例模式完全失效(不同进程的内存区域都不一样了)</li>
<li>SharedPreferce的可靠性下降(SharedPreference底层是读写xml文件实现的,系统对它的读写有一定的缓存策略,在内存中会有一份SharedPreferce文件的缓存,所以多个进程并发写操作可能导致数据丢失)</li>
<li>断点调试问题。</li>
</ol>
<p>多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等。在多线程的情况下我们有锁机制控制资源的共享，但是在多进程中比较难，虽然有文件锁、排队等机制，但是在Android里很难实现。解决办法就是多进程的时候不并发访问同一个文件，比如子进程涉及到操作数据库，就可以考虑调用主进程进行数据库的操作。</p>
<p>调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。不过可以通过下面的方式实现：调试时去掉AndroidManifest.xml中android:process标签，这样保证调试状态下是在同一进程中，堆栈信息是连贯的。待调试完成后，再将标签复原。</p>
<h4 id="process属性的设置有两种形式"><a href="#process属性的设置有两种形式" class="headerlink" title="process属性的设置有两种形式"></a>process属性的设置有两种形式</h4><p>第一种形式如 android:process=”:remote”，以冒号开头，冒号后面的字符串原则上是可以随意指定的。如果我们的包名为“com.example.processtest”，则实际的进程名为“com.example.processtest:remote”。这种设置形式表示该进程为当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中。</p>
<p>第二种情况如 android:process=”com.example.processtest.remote”，以小写字母开头，表示运行在一个以这个名字命名的全局进程中，其他应用通过设置相同的ShareUID可以和它跑在同一个进程。</p>
<h4 id="线程与进程区别"><a href="#线程与进程区别" class="headerlink" title="线程与进程区别"></a>线程与进程区别</h4><p>进程是系统进行资源分配和调度的一个独立单位。
线程是进程的一个实体，是CPU调度和分配的基本单位，是比进程更小的能独立运行的基本单位，线程本身不拥有系统资源（除了必不可少的资源如程序计数器、寄存器、栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
主要差别在于是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的健壮，但是多进程在切换时，资源耗费大，效率要差。</p>
<h3 id="查看当前手机中进程方式"><a href="#查看当前手机中进程方式" class="headerlink" title="查看当前手机中进程方式"></a>查看当前手机中进程方式</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>各列参数意义：</p>
<ul>
<li>USER 进程当前用户；</li>
<li>PID Process ID，进程ID；</li>
<li>PPID Process Parent ID，进程的父进程ID；</li>
<li>VSIZE Virtual Size，进程的虚拟内存大小；</li>
<li>RSS Resident Set Size，实际驻留”在内存中”的内存大小；</li>
<li>WCHAN 休眠进程在内核中的地址；</li>
<li>PC Program Counter；</li>
<li>NAME 进程名；</li>
</ul>
<h4 id="oom-adj"><a href="#oom-adj" class="headerlink" title="oom_adj"></a>oom_adj</h4><p>Android 中对于内存的回收，主要依靠 Lowmemorykiller 来完成，是一种根据 OOM_ADJ 阈值级别触发相应力度的内存回收的机制。
关于OOM_ADJ的说明如下:
<img src="http://images.wodekouwei.com/tips-android-process-201938151316.png" alt="tips-android-process-201938151316"></p>
<p>其中红色部分代表比较容易被杀死的 Android 进程（OOM_ADJ&gt;=4）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。在 Lowmemorykiller 回收内存时会根据进程的级别优先杀死 OOM_ADJ 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。</p>
<p>Android 手机中进程被杀死可能有如下情况：
|进程杀死场景|调用接口|可能影响范围|
|—|—|—|
|触发系统进程管理机制|Lowmemorykiller|从进程importance值由大到小依次杀死,释放内存|
|被第三方应用杀死(无Root)|killBackgoundProcess|只能杀死OOM_ADJ为4以上的进程|
|被第三方应用杀死(有Root)|force-stop或者kill|理论上可以杀死所有进程,一般只杀非系统关键进程和非前台和可见进程|
|厂商杀进程功能|fource-stop或者kill|理论上可以杀所有进程,包括Native进程|
|用户主动”强行停止”进程|force-stop|只能停用第三方和非system/phone进程应用(停用system进程应用会造成Android重启)|</p>
<p>通过<code>cat /proc/进程id/oom_adj</code>可以看到当前进程的adj指，比如输入<code>cat /proc/32366/oom_adj</code>,adj值具体决定了系统在资源吃紧的情况下该杀掉哪些进程。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ps | grep &quot;beike&quot;</div><div class="line">u0_a332   12952 3183  2072548 185728 SyS_epoll_ 0000000000 S com.lianjia.beike</div><div class="line">u0_a332   12972 3183  1792404 45848 SyS_epoll_ 0000000000 S com.lianjia.beike:coreservice</div><div class="line">u0_a332   13141 3183  1824480 61480 SyS_epoll_ 0000000000 S com.lianjia.beike:pushservice</div><div class="line">u0_a332   13225 3183  1787776 49968 SyS_epoll_ 0000000000 S com.lianjia.beike:remote</div><div class="line">nobleltechn:/ $ cat /proc/12952/oom_adj</div><div class="line">0</div><div class="line">nobleltechn:/ $ cat /proc/12972/oom_adj</div><div class="line">1</div><div class="line">nobleltechn:/ $ cat /proc/13141/oom_adj</div><div class="line">8</div><div class="line">nobleltechn:/ $ cat /proc/13225/oom_adj</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>而adj值则在ProcessList中定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">final class ProcessList &#123;</div><div class="line">// OOM adjustments for processes in various states:</div><div class="line"></div><div class="line">// Adjustment used in certain places where we don&apos;t know it yet.</div><div class="line">// (Generally this is something that is going to be cached, but we</div><div class="line">// don&apos;t know the exact value in the cached range to assign yet.)</div><div class="line">static final int UNKNOWN_ADJ = 16;</div><div class="line"></div><div class="line">// This is a process only hosting activities that are not visible,</div><div class="line">// so it can be killed without any disruption.</div><div class="line">static final int CACHED_APP_MAX_ADJ = 15;</div><div class="line">static final int CACHED_APP_MIN_ADJ = 9;</div><div class="line"></div><div class="line">// The B list of SERVICE_ADJ -- these are the old and decrepit</div><div class="line">// services that aren&apos;t as shiny and interesting as the ones in the A list.</div><div class="line">static final int SERVICE_B_ADJ = 8;</div><div class="line"></div><div class="line">// This is the process of the previous application that the user was in.</div><div class="line">// This process is kept above other things, because it is very common to</div><div class="line">// switch back to the previous app.  This is important both for recent</div><div class="line">// task switch (toggling between the two top recent apps) as well as normal</div><div class="line">// UI flow such as clicking on a URI in the e-mail app to view in the browser,</div><div class="line">// and then pressing back to return to e-mail.</div><div class="line">static final int PREVIOUS_APP_ADJ = 7;</div><div class="line"></div><div class="line">// This is a process holding the home application -- we want to try</div><div class="line">// avoiding killing it, even if it would normally be in the background,</div><div class="line">// because the user interacts with it so much.</div><div class="line">static final int HOME_APP_ADJ = 6;</div><div class="line"></div><div class="line">// This is a process holding an application service -- killing it will not</div><div class="line">// have much of an impact as far as the user is concerned.</div><div class="line">static final int SERVICE_ADJ = 5;</div><div class="line"></div><div class="line">// This is a process with a heavy-weight application.  It is in the</div><div class="line">// background, but we want to try to avoid killing it.  Value set in</div><div class="line">// system/rootdir/init.rc on startup.</div><div class="line">static final int HEAVY_WEIGHT_APP_ADJ = 4;</div><div class="line"></div><div class="line">// This is a process currently hosting a backup operation.  Killing it</div><div class="line">// is not entirely fatal but is generally a bad idea.</div><div class="line">static final int BACKUP_APP_ADJ = 3;</div><div class="line"></div><div class="line">// This is a process only hosting components that are perceptible to the</div><div class="line">// user, and we really want to avoid killing them, but they are not</div><div class="line">// immediately visible. An example is background music playback.</div><div class="line">static final int PERCEPTIBLE_APP_ADJ = 2;</div><div class="line"></div><div class="line">// This is a process only hosting activities that are visible to the</div><div class="line">// user, so we&apos;d prefer they don&apos;t disappear.</div><div class="line">static final int VISIBLE_APP_ADJ = 1;</div><div class="line"></div><div class="line">// This is the process running the current foreground app.  We&apos;d really</div><div class="line">// rather not kill it!</div><div class="line">static final int FOREGROUND_APP_ADJ = 0;</div><div class="line"></div><div class="line">// This is a process that the system or a persistent process has bound to,</div><div class="line">// and indicated it is important.</div><div class="line">static final int PERSISTENT_SERVICE_ADJ = -11;</div><div class="line"></div><div class="line">// This is a system persistent process, such as telephony.  Definitely</div><div class="line">// don&apos;t want to kill it, but doing so is not completely fatal.</div><div class="line">static final int PERSISTENT_PROC_ADJ = -12;</div><div class="line"></div><div class="line">// The system process runs at the default adjustment.</div><div class="line">static final int SYSTEM_ADJ = -16;</div><div class="line"></div><div class="line">// Special code for native processes that are not being managed by the system (so</div><div class="line">// don&apos;t have an oom adj assigned by the system).</div><div class="line">static final int NATIVE_ADJ = -17;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>较于Importance等级而言adj值可以赋予我们更多的参考价值，从上述adj值的定义中我们可以看到，值越小优先级越高，比如native进程的adj值为－17，对于这个adj值的进程来说，系统根本不会动它一分一毫，实质上当进程的adj值去到2时系统就很少会因为其它原因而去杀死它，这些在研究进程保活中都非常重要。</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ul>
<li>IPC: InterProcess Communication</li>
<li>RPC: Remote Procedure Call</li>
</ul>
<h5 id="进程间通信的方式-对比"><a href="#进程间通信的方式-对比" class="headerlink" title="进程间通信的方式-对比"></a>进程间通信的方式-对比</h5><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Intent</td>
<td>简单易用</td>
<td>只能传输Bundle所支持的数据类型</td>
<td>四大组件的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发</td>
<td>简单的数据共享,无高并发场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大,支持一对多并发实时通信</td>
<td>适用稍微复杂,需要注意线程同步</td>
<td>复杂的进程间调用,Android中最常用</td>
</tr>
<tr>
<td>Messenger</td>
<td>比AIDL稍微简单易用些</td>
<td>比AIDL功能弱,只支持一对多串行实时通信</td>
<td>简单的进程间通信</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>功能强大的数据共享能力,可通过call方法扩张</td>
<td>受约束的AIDL,主要对外提供数据线的CRUD操作</td>
<td>进程间的大量数据共享</td>
</tr>
<tr>
<td>RemoteViews</td>
<td>在跨进程方法UI方面有奇效</td>
<td>比较小众的通信方式</td>
<td>某些特殊的场景</td>
</tr>
<tr>
<td>Socket</td>
<td>跨主机,通信范围广</td>
<td>只能传输原始的字节流</td>
<td>常用与网络通信中</td>
</tr>
</tbody>
</table>
<h4 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h4><ul>
<li>四大组件中的三大组件（Activity、Service、Receiver）都支持在Intent中传递Bundle数据</li>
<li>Bundle中的数据除了基本类型，其他的都需要可序列化</li>
<li>适用于从一个进程启动另一个进程，比如在一个进程中启动另一个进程中的Activity、Service、Receiver，与此同时传递数据的情况</li>
</ul>
<h5 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h5><ul>
<li>2个进程通过读写同一个文件来交换数据</li>
<li>当然要把数据写入文件，必然要求数据可以序列化和反序列化</li>
<li>文件共享对文件格式没有要求，只要读写双方约定好数据格式</li>
<li>文件共享的方式存在并发读写的问题，适合对数据同步要求不高的进程间通信，并且要妥善处理并发读写的问题</li>
</ul>
<h5 id="使用Messager"><a href="#使用Messager" class="headerlink" title="使用Messager"></a>使用Messager</h5><p>使用Messager来传递Message，Message中能使用的字段只有what、arg1、arg2、Bundle和replyTo,自定义的Parcelable对象无法通过object字段来传输
Message中的Bundle支持多种数据类型，replyTo字段用于传输Messager对象，以便进程间相互通信
Messager以串行的方式处理客户端发来的消息，不适合有大量并发的请求
Messager方法只能传递消息，不能跨进程调用方法</p>
<h5 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h5><p>AIDL接口可以通过编写AIDL文件然后由系统生成对应的Binder类，通过Binder我们就可以进行跨进程通信了
AIDL文件中只支持如下几种类型：</p>
<ul>
<li>基本类型，如int、long等</li>
<li>String和CharSequence</li>
<li>List：只支持ArrayList，里面的每个元素都必须被AIDL支持</li>
<li>Map：只支持HashMap，里面的key、value都必须被AIDL支持</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用</li>
</ul>
<p>AIDL文件中用到的自定义Parcelable对象和AIDL对象必须要显示的import进来
除了基本数据类型，其他类型的参数必须标明是入参还是出参，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数</p>
<h4 id="进程保活机制"><a href="#进程保活机制" class="headerlink" title="进程保活机制"></a>进程保活机制</h4><p>Android 进程拉活包括两个层面：</p>
<ol>
<li>提供进程优先级，降低进程被杀死的概率</li>
<li>在进程被杀死后，进行拉活</li>
</ol>
<h5 id="提升进程优先级的方案"><a href="#提升进程优先级的方案" class="headerlink" title="提升进程优先级的方案"></a>提升进程优先级的方案</h5><h6 id="利用-Activity-提升权限"><a href="#利用-Activity-提升权限" class="headerlink" title="利用 Activity 提升权限"></a>利用 Activity 提升权限</h6><ol>
<li>方案设计思想:监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。注意该 Activity 需设计成用户无感知。通过该方案，可以使进程的优先级在屏幕锁屏时间由4提升为最高优先级1。</li>
<li>方案适用范围</li>
</ol>
<ul>
<li>适用场景：本方案主要解决第三方应用及系统管理工具在检测到锁屏事件后一段时间（一般为5分钟以内）内会杀死后台进程，已达到省电的目的问题。</li>
<li>适用版本： 适用于所有的 Android 版本。</li>
</ul>
<ol>
<li>方案具体实现
首先定义 Activity，并设置 Activity 的大小为1像素：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">protected void onCreate(Bundle savedInstanceState)&#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    Window window = getWindow();</div><div class="line">    window.setGravity(Gravity.LEFT|Gravity.TOP);</div><div class="line">    WindowManager.LayoutParams params = window.getAttributes();</div><div class="line">    params.x = 0;</div><div class="line">    params.y = 0;</div><div class="line">    params.height = 1;</div><div class="line">    params.width = 1;</div><div class="line">    window.setAttributes(params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过如下属性,排除Activity在RecentTask中的显示:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">    android:excludeFromRecents = &quot;true&quot;</div><div class="line">    android:exported = &quot;false&quot;</div><div class="line">    android:finishOnTaskLaunch = &quot;false&quot;</div><div class="line">    android:launchMode = &quot;singleInstance&quot;</div><div class="line">    android:process = &quot;:live&quot;</div><div class="line">    android:theme=&quot;@style/LiveActivityStyle&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>控制Activity为透明:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;LiveActivityStyle&gt;</div><div class="line">&lt;item name=&quot;android:windowBackground&gt;@android:color/transparent&lt;/item&gt;</div><div class="line">&lt;item name=&quot;android:windowBackGround&gt;@null&lt;/item&gt;</div><div class="line">&lt;item name=&quot;android:windowContentOverlay&gt;@null&lt;/item&gt;</div><div class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;@null&lt;/item&gt;</div><div class="line">...</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>Activity启动与销毁时机的控制:监控Intent.ACTION_SCREEN_OFF与Intent.ACTION_USER_PRESENT广播接收者</p>
<h6 id="利用-Notification-提升权限"><a href="#利用-Notification-提升权限" class="headerlink" title="利用 Notification 提升权限"></a>利用 Notification 提升权限</h6><ol>
<li>方案设计思想: Android 中 Service 的优先级为4，通过 setForeground 接口可以将后台 Service 设置为前台 Service，使进程的优先级由4提升为2，从而使进程的优先级仅仅低于用户当前正在交互的进程，与可见进程优先级一致，使进程被杀死的概率大大降低。</li>
<li>方案实现挑战: 从 Android2.3 开始调用 setForeground 将后台 Service 设置为前台 Service 时，必须在系统的通知栏发送一条通知，也就是前台 Service 与一条可见的通知时绑定在一起的。对于不需要常驻通知栏的应用来说，该方案虽好，但却是用户感知的，无法直接使用。</li>
<li>方案挑战应对措施: 通过实现一个内部 Service，在 LiveService 和其内部 Service 中同时发送具有相同 ID 的 Notification，然后将内部 Service 结束掉。随着内部 Service 的结束，Notification 将会消失，但系统优先级依然保持为2。</li>
<li>方案适用范围: 适用于目前已知所有版本。</li>
<li>方案具体实现</li>
</ol>
<h5 id="进程死后拉活的方案"><a href="#进程死后拉活的方案" class="headerlink" title="进程死后拉活的方案"></a>进程死后拉活的方案</h5><h6 id="利用系统广播拉活"><a href="#利用系统广播拉活" class="headerlink" title="利用系统广播拉活"></a>利用系统广播拉活</h6><ol>
<li>方案设计思想：在发生特定系统事件时，系统会发出响应的广播，通过在 AndroidManifest 中“静态”注册对应的广播监听器，即可在发生响应事件时拉活。常用的用于拉活的广播事件包括：开机广播,网络变化,文件挂载,屏幕亮灭,锁屏解屏,应用安装卸载</li>
<li>方案适用范围：适用于全部 Android 平台。但存在如下几个缺点：广播接收器被管理软件、系统软件通过“自启管理”等功能禁用的场景无法接收到广播，从而无法自启;系统广播事件不可控，只能保证发生事件时拉活进程，但无法保证进程挂掉后立即拉活。因此，该方案主要作为备用手段。</li>
</ol>
<h6 id="利用第三方应用广播拉活"><a href="#利用第三方应用广播拉活" class="headerlink" title="利用第三方应用广播拉活"></a>利用第三方应用广播拉活</h6><ol>
<li>方案设计思想：该方案总的设计思想与接收系统广播类似，不同的是该方案为接收第三方 Top 应用广播。通过反编译第三方 Top 应用，如：手机QQ、微信、支付宝、UC浏览器等，以及友盟、信鸽、个推等 SDK，找出它们外发的广播，在应用中进行监听，这样当这些应用发出广播时，就会将我们的应用拉活。</li>
<li>方案适用范围：该方案的有效程度除与系统广播一样的因素外，主要受如下因素限制：反编译分析过的第三方应用的多少;第三方应用的广播属于应用私有，当前版本中有效的广播，在后续版本随时就可能被移除或被改为不外发。这些因素都影响了拉活的效果。</li>
</ol>
<h6 id="利用系统Service机制拉活"><a href="#利用系统Service机制拉活" class="headerlink" title="利用系统Service机制拉活"></a>利用系统Service机制拉活</h6><ol>
<li>方案设计思想：将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活：</li>
<li>方案适用范围：如下两种情况无法拉活. 1.Service 第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内 Service 被杀死达到5次，则系统不再拉;。2.进程被取得 Root 权限的管理工具或系统工具通过 forestop 停止掉，无法重启。</li>
</ol>
<h6 id="利用Native进程拉活"><a href="#利用Native进程拉活" class="headerlink" title="利用Native进程拉活"></a>利用Native进程拉活</h6><ol>
<li>方案设计思想：</li>
</ol>
<ul>
<li>主要思想：利用 Linux 中的 fork 机制创建 Native 进程，在 Native 进程中监控主进程的存活，当主进程挂掉后，在 Native 进程中立即对主进程进行拉活。</li>
<li>主要原理：在 Android 中所有进程和系统组件的生命周期受 ActivityManagerService 的统一管理。而且，通过 Linux 的 fork 机制创建的进程为纯 Linux 进程，其生命周期不受 Android 的管理。</li>
</ul>
<ol>
<li>方案实现挑战：
挑战一：在 Native 进程中如何感知主进程死亡。
要在 Native 进程中感知主进程是否存活有两种实现方式：</li>
</ol>
<ul>
<li>在 Native 进程中通过死循环或定时器，轮训判断主进程是否存活，档主进程不存活时进行拉活。该方案的很大缺点是不停的轮询执行判断逻辑，非常耗电。</li>
<li>在主进程中创建一个监控文件，并且在主进程中持有文件锁。在拉活进程启动后申请文件锁将会被堵塞，一旦可以成功获取到锁，说明主进程挂掉，即可进行拉活。由于 Android 中的应用都运行于虚拟机之上，Java 层的文件锁与 Linux 层的文件锁是不同的，要实现该功能需要封装 Linux 层的文件锁供上层调用。
封装 Linux 文件锁的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int linuxflock(JNIEnv *env, jobject obj, jstring lockFilePath)&#123;</div><div class="line">    LOGI(&quot;flock&quot;);</div><div class="line">    int fd = linuxgetlockfd(env, lockFilePath);</div><div class="line">    LOGD(&quot;Lock file fd : %d&quot;, fd);</div><div class="line">    if(fd &gt; 0)&#123;</div><div class="line">        if(linuxtestflock(fd) == 0)&#123;</div><div class="line">            LOGD(&quot;try to lock the file&quot;);</div><div class="line">            return flock(fd, LOCK_EX);//创建文件排它锁</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Native 层中堵塞申请文件锁的部分代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void *thread_watch(void* arg)&#123;</div><div class="line">    LOGI(&quot;jni thread_watch);</div><div class="line">    int fd = 0;</div><div class="line">    if((fd == open(mLockFilePath, O_RDWR)))&#123;</div><div class="line">        LOGE(&quot;jni thread_watch open file failed,errno: %d&quot;, errno);</div><div class="line">        pthread_exit(0);</div><div class="line">    &#125;</div><div class="line">    LOGD(&quot;jni thread_watch,open file success, try to lock the file&quot;);</div><div class="line">    set_watch_state_symbol(1);</div><div class="line">    if(flock(fd, LOCK_EX) == 0)//申请文件的排他锁</div><div class="line">    &#123;</div><div class="line">        LOGD(&quot;jni thread_watch successfuly get file lock&quot;);</div><div class="line">        try_pullup();</div><div class="line">    &#125;else&#123;</div><div class="line">        set_watch_state_symbol(0);</div><div class="line">        LOGD(&quot;jni thread_watch,lock file error!!!&quot;);</div><div class="line">    &#125;</div><div class="line">    close(fd);//关闭文件会将锁自动释放</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>挑战二：在 Native 进程中如何拉活主进程。
通过 Native 进程拉活主进程的部分代码如下，即通过 am 命令进行拉活。通过指定“–include-stopped-packages”参数来拉活主进程处于 forestop 状态的情况。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static void try_pullup()</div><div class="line">&#123;</div><div class="line">    LOGI(&quot;jni try_pullup&quot;);</div><div class="line">    if(!is_application_exist(mPackageName))</div><div class="line">    &#123;</div><div class="line">        LOGD(&quot;jni try_pullup process exit, because xlb has been removed!&quot;);</div><div class="line">        set_watch_state_symbol(0);</div><div class="line">        freeAppMsg();</div><div class="line">        exit(0);</div><div class="line">    &#125;</div><div class="line">    LOGD(&quot;jni try_pullup try to wake up live service...&quot;);</div><div class="line">    char pkg[256] = &quot;&quot;;</div><div class="line">    strcat(pkg, &quot; -n &quot;);</div><div class="line">    strcat(pkg, mPackageName);</div><div class="line">    strcat(pkg, &quot;/com.xlb.keeplive.KeepLiveService\&quot;&quot;);</div><div class="line">    int ret - execlp(&quot;am&quot;, &quot;am&quot;, &quot;startservice&quot;, &quot;--user&quot;, mSerial, &quot;-n&quot;, pkg, &quot;--include-stopped-packages&quot;, NULL);</div><div class="line">    LOGD(&quot;start service, ret = %d&quot;, ret);</div><div class="line">    freeAppMsg();</div><div class="line">    set_watch_state_symbol(0);</div><div class="line">    pthread_exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>挑战三：如何保证 Native 进程的唯一。
从可扩展性和进程唯一等多方面考虑，将 Native 进程设计层 C/S 结构模式，主进程与 Native 进程通过 Localsocket 进行通信。在Native进程中利用 Localsocket 保证 Native 进程的唯一性，不至于出现创建多个 Native 进程以及 Native 进程变成僵尸进程等问题。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int main(const int argc, const char *argv[])</div><div class="line">&#123;</div><div class="line">    LOGI(&quot;jni do_main&quot;);</div><div class="line">    if(argc &lt; 2)&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    struct sockaddr addr;</div><div class="line">    socklen_t alen;</div><div class="line">    int lsocket, s, count;</div><div class="line"></div><div class="line">    const char* socket_name = argv[1];</div><div class="line">    LOGD(&quot;jni socket name: %s&quot;, socket_name);</div><div class="line">    lsocket = socket_local_server(socket_name, ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM);</div><div class="line">    if(lsocket &lt;0)</div><div class="line">    &#123;</div><div class="line">        LOGE(&quot;jni Failed to get socket from environment: %s&quot;, strerror(errno));</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line">    fcntl(lsocket, F_SETFD&lt; FD_CLOEXEC);</div><div class="line">    LOGD(&quot;jni native pid = %d&quot;, getpid());</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案适用范围：该方案主要适用于 Android5.0 以下版本手机。该方案不受 forcestop 影响，被强制停止的应用依然可以被拉活，在 Android5.0 以下版本拉活效果非常好。对于 Android5.0 以上手机，系统虽然会将native进程内的所有进程都杀死，这里其实就是系统“依次”杀死进程时间与拉活逻辑执行时间赛跑的问题，如果可以跑的比系统逻辑快，依然可以有效拉起。记得网上有人做过实验，该结论是成立的，在某些 Android 5.0 以上机型有效。</li>
</ol>
<h6 id="利用-JobScheduler-机制拉活"><a href="#利用-JobScheduler-机制拉活" class="headerlink" title="利用 JobScheduler 机制拉活"></a>利用 JobScheduler 机制拉活</h6><ol>
<li>方案设计思想：Android5.0 以后系统对 Native 进程等加强了管理，Native 拉活方式失效。系统在 Android5.0 以上版本提供了 JobScheduler 接口，系统会定时调用该进程以使应用进行一些逻辑操作。</li>
</ol>
<p>在本项目中，我对 JobScheduler 进行了进一步封装，兼容 Android5.0 以下版本。封装后 JobScheduler 接口的使用如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class KeepLiveService extends JobService&#123;</div><div class="line">    private final static String TAG = &quot;keeplive&quot;;</div><div class="line">    private boolean isServiceExit = false;//通过变量控制是否需要退出service</div><div class="line">    private volatile static Service mKeepLiveService = null;</div><div class="line">    public static boolean isServiceLive()&#123;</div><div class="line">        return mKeepLiveSErvice != null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">* 启动JobScheduler拉活</div><div class="line">* 适用范围:用于Android5.0以后版本进程保活,对被&quot;强制停止&quot;有效</div><div class="line">*/</div><div class="line">public void startJobScheduler()&#123;</div><div class="line">    try&#123;</div><div class="line">        int jobId = 1;</div><div class="line">        JobInfo.Builer builder = new JobInfo.Builder(jobId, new CompentName(FZApplication.self, KeepLiveSErvice.class));</div><div class="line">        builder.setPeriodic(10);</div><div class="line">        builder.setPersisted(true);</div><div class="line">        JobScheduler.getInstance(FZApplication.self()).schedule(builder.build());</div><div class="line">    &#125;catch(Throwable t)&#123;</div><div class="line">        t.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案适用范围：该方案主要适用于 Android5.0 以上版本手机。方案在 Android5.0 以上版本中不受 forcestop 影响，被强制停止的应用依然可以被拉活，在 Android5.0 以上版本拉活效果非常好。仅在小米手机可能会出现有时无法拉活的问题。</li>
</ol>
<h6 id="利用账号同步机制拉活"><a href="#利用账号同步机制拉活" class="headerlink" title="利用账号同步机制拉活"></a>利用账号同步机制拉活</h6><ol>
<li>方案设计思想：Android 系统的账号同步机制会定期同步账号进行，该方案目的在于利用同步机制进行进程的拉活。添加账号和设置同步周期的代码如下：</li>
</ol>
<p>该方案需要在 AndroidManifest 中定义账号授权与同步服务。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 添加账户,并启用账号同步功能&lt;br/&gt;</div><div class="line">* 利用账户同步功能进行拉活,适用范围为目前所有版本&lt;br/&gt;</div><div class="line">* 这是设置的账号同步周期为30秒,可以通过常量SYNC_FREQUENCY修改</div></pre></td></tr></table></figure></p>
<p>private void addAccount(){
    AccountManager accountManager = (AccountManager)this.getSystemService(Context.ACCOUNT_SERVICE);
    Account account = null;
    Account[] accounts = accountManager.getAccountsByType(ACCOUNT_TYPE);
    if(accounts.length &gt; 0){
        account = accounts[0];
    }else{
        account = new Account(getString(R.string.account_name), ACCOUNT_TYPE);
    }
    if(accountManager.addAccountExplicitly(account,null,null)){
        //开启同步,并设置同步周期
        ContentResolver.setIsSyncable(Account, CONTENT_AUTHORITY, 1);
        ContentResolver.setSyncAutomatically(account,CONTENT_AUTHORITY, true);
        ContentResolver.addPeriodicSync(account, CONTENT_AUTHORITY, new Bundle…);
    }
}
该方案需要在AndroidManifest中定义账号授权与同步服务.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=&quot;com.xlb.keeplive.KeepLiveService$AuthenticationSErvice&quot;</div><div class="line">    android:exported=&quot;true&quot;</div><div class="line">    android:process=&quot;:live&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;android.accounts.AccountAuthenticator&quot;/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">    &lt;meta-data</div><div class="line">        android:name = &quot;android.accounts.AccountAuthenticator&quot;</div><div class="line">        android:resource=&quot;@xml/authenticator&quot;/&gt;</div><div class="line">/&gt;</div><div class="line">&lt;service</div><div class="line">    android:name=&quot;com.xlb.keeplive.KeepLiveService$AccountSyncService&quot;</div><div class="line">    android:exported=&quot;true&quot;</div><div class="line">    android:process=&quot;:live&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;android.accounts.SyncAdapter&quot;/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">    &lt;meta-data</div><div class="line">        android:name = &quot;android.accounts.SyncAdapter&quot;</div><div class="line">        android:resource=&quot;@xml/SyncAdapter&quot;/&gt;</div><div class="line">/&gt;</div><div class="line">&lt;&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案适用范围：该方案适用于所有的 Android 版本，包括被 forestop 掉的进程也可以进行拉活。最新 Android 版本（Android N）中系统好像对账户同步这里做了变动，该方法不再有效。</li>
</ol>
<h6 id="其他有效拉活方案"><a href="#其他有效拉活方案" class="headerlink" title="其他有效拉活方案"></a>其他有效拉活方案</h6><p>经研究发现还有其他一些系统拉活措施可以使用，但在使用时需要用户授权，用户感知比较强烈。
这些方案包括：</p>
<ol>
<li>利用系统通知管理权限进行拉活</li>
<li>利用辅助功能拉活，将应用加入厂商或管理软件白名单。</li>
</ol>
<p>这些方案需要结合具体产品特性来搞。</p>
<p>上面所有解释这些方案都是考虑的无 Root 的情况。其他还有一些技术之外的措施，比如说应用内 Push 通道的选择：</p>
<ol>
<li>国外版应用：接入 Google 的 GCM。</li>
<li>国内版应用：根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</li>
</ol>
<h4 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h4><h5 id="Parcelable和Serializable"><a href="#Parcelable和Serializable" class="headerlink" title="Parcelable和Serializable"></a>Parcelable和Serializable</h5><h6 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h6><p>Serializable接口实现序列化比较简单，只需要在需要实现序列化的类实现Serializable接口就行
serialVersionUID可以指定也可以不指定，不指定的话系统会默认给我们生成
serialVersionUID的作用是用于标识当前类的版本，便于在反序列化过程中判断类是否有更改，如果serialVersionUID不一致，反序列化就会失败
人为指定serialVersionUID后，如果不是破坏性的改动了类，比如版本升级后增加了一个字段，那反序列化以后仍然能成功；而如果没有指定，反序列化就会失败
serialVersionUID是否指定需要根据具体的需要来确定
静态成员变量和transient关键字标记的变量不参与序列化过程</p>
<h6 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h6><p>Parcelable接口实现序列化稍微复杂，需要实现writeToParcel方法、describeContents方法以及生成器Creator
内容描述功能的describeContents方法一般都返回0，当前对象中存在文件描述符时才返回1
Parcelable接口中的Parcel内部包装了可序列化的数据，可以在Binder中自由传输</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>Serializable使用简单但是开销很大，序列化和反序列化过程需要大量的IO操作，一般用于将对象序列化到存储设备中或者将对象序列化后通过网络传输。</p>
<p>Parcelable使用麻烦，但效率很高。</p>
<h5 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h5><p>binder是Android中的一种跨进程通信方式
可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder.
从Android Framework角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。
从Android应用层来说，Binder是客户端和服务端进行通信的媒介。当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
<p>更安全，比如socket的ip地址可以进行伪造，而Binder机制从协议本身就支持对通信双方做身份校验，因而大大提升了安全性，这个也是Android权限模型的基础。</p>
<p><img src="http://images.wodekouwei.com/tips-android-process-201938104639.png" alt="tips-android-process-201938104639"></p>
<p>如下图，伪装。即代理模式。对代理对象的操作会通过驱动最终转发到Binder本地对象上去完成，当然使用者无需关心这些细节。
<img src="http://images.wodekouwei.com/tips-android-process-201938104833.png" alt="tips-android-process-201938104833"></p>
<p>Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，它的引用却遍布于系统的各个进程中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给另一个进程，让大家都能访问同一Server，就像一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/07/31/tips-android-pluggable-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/31/tips-android-pluggable-8/" itemprop="url">
                  tips-android-pluggable-8
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-31T20:20:35+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/07/25/tips-android-serialization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/25/tips-android-serialization/" itemprop="url">
                  android数据序列化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T10:41:25+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h3><p>序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。
二进制序列化保持类型保真度，这对于在应用程序的不同调用之间保留对象的状态很有用。例如，通过将对象序列化到剪贴板，可在不同的应用程序之间共享对象。您可以将对象序列化到流、磁盘、内存和网络等等。远程处理使用序列化“通过值”在计算机或应用程序域之间传递对象。</p>
<p>简单地说，“序列化”就是将运行时的对象状态转换成二进制，然后保存到流、内存或者通过网络传输给其他端。
在安卓开发中，我们在组件中传递数据时常常使用 Intent 传输数据时需要传递 Serializable 或者 Parcelable 的数据，比如 Intent.putExtra 方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public Intent putExtra(String name, Parcelable value) &#123;...&#125;</div><div class="line">public Intent putExtra(String name, Serializable value) &#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>也会使用 Binder 传递数据。</p>
<h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>Serializable 是 Java 提供的序列化接口，它是一个空接口:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface Serializable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。
Serializable 有以下几个特点：</p>
<ul>
<li>可序列化类中，未实现 Serializable 的属性状态无法被序列化/反序列化</li>
<li>也就是说，反序列化一个类的过程中，它的非可序列化的属性将会调用无参构造函数重新创建</li>
<li>因此这个属性的无参构造函数必须可以访问，否者运行时会报错</li>
<li>一个实现序列化的类，它的子类也是可序列化的</li>
</ul>
<p>下面是一个实现了 Serializable 的实体类：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class GroupBean implements Serializable &#123;</div><div class="line"></div><div class="line">    private static final long serialVersionUID = 8829975621220483374L;</div><div class="line">    private String mName;</div><div class="line">    private List&lt;String&gt; mMemberNameList;</div><div class="line"></div><div class="line">    public GroupBean() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return mName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;String&gt; getMemberNameList() &#123;</div><div class="line">        return mMemberNameList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMemberNameList(List&lt;String&gt; memberNameList) &#123;</div><div class="line">        mMemberNameList = memberNameList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到实现 Serializable 的实现非常简单，除了实体内容外只要创建一个 serialVersionUID 属性就好。</p>
<h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>从名字就可以看出来，这个 serialVersionUID ，有些类似我们平时的接口版本号，在运行时这个版本号唯一标识了一个可序列化的类。</p>
<p>也就是说，一个类序列化时，运行时会保存它的版本号，然后在反序列化时检查你要反序列化成的对象版本号是否一致，不一致的话就会报错：·InvalidClassException。</p>
<p>如果我们不自己创建这个版本号，序列化过程中运行时会根据类的许多特点计算出一个默认版本号。然而只要你对这个类修改了一点点，这个版本号就会改变。这种情况如果发生在序列化之后，反序列化时就会导致上面说的错误。</p>
<p>因此 JVM 规范强烈 建议我们手动声明一个版本号，这个数字可以是随机的，只要固定不变就可以。同时最好是 private 和 final 的，尽量保证不变。</p>
<p>此外，序列化过程中不会保存 static 和 transient 修饰的属性，前者很好理解，因为静态属性是与类管理的，不属于对象状态；而后者则是 Java 的关键字，专门用来标识不序列化的属性。</p>
<p>默认实现 Serializable 不会自动创建 serialVersionUID 属性，为了提示我们及时创建 serialVersionUID ，可以在设置中搜索 serializable 然后选择下图所示的几个选项，为那些没有声明 serialVersionUID 属性的类以及内部类添加一个警告:
setting-&gt;Editor-&gt;Inspections-&gt;搜索serializable-&gt;勾选:</p>
<ul>
<li>Serializable class without’readObject()’ and ‘writeObject()’</li>
<li>Serializable class without’seriaVersionUID’</li>
<li>Serializable not-‘static’ inner class with not-Serializable outer class</li>
<li>Serializable object implicitly stores non-Serializable Object</li>
</ul>
<p>这样当我们创建一个类不声明 UID 属性时，类名上就会有黄黄的警告,鼠标放上去就会显示警告内容：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GroupBean’ does not define a ‘serialVersionUID’ field less… (Ctrl+F1) </div><div class="line">Reports any Serializable classes which do not provide a serialVersionUID field. Without a serialVersionUID field, any change to a class will make previously serialized versions unreadable.</div></pre></td></tr></table></figure></p>
<p>这时我们按代码提示快捷键就可以生成 serialVersionUID 了。</p>
<h4 id="序列化与反序列化-Serializable"><a href="#序列化与反序列化-Serializable" class="headerlink" title="序列化与反序列化 Serializable"></a>序列化与反序列化 Serializable</h4><p>Serializable 的序列化与反序列化分别通过 ObjectOutputStream 和 ObjectInputStream 进行，实例代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">**</div><div class="line"> * 序列化对象</div><div class="line"> *</div><div class="line"> * @param obj</div><div class="line"> * @param path</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">synchronized public static boolean saveObject(Object obj, String path) &#123;</div><div class="line">    if (obj == null) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    ObjectOutputStream oos = null;</div><div class="line">    try &#123;</div><div class="line">        oos = new ObjectOutputStream(new FileOutputStream(path));</div><div class="line">        oos.writeObject(obj);</div><div class="line">        oos.close();</div><div class="line">        return true;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">        if (oos != null) &#123;</div><div class="line">            try &#123;</div><div class="line">                oos.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 反序列化对象</div><div class="line"> *</div><div class="line"> * @param path</div><div class="line"> * @param &lt;T&gt;</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">@SuppressWarnings(&quot;unchecked &quot;)</div><div class="line">synchronized public static &lt;T&gt; T readObject(String path) &#123;</div><div class="line">    ObjectInputStream ojs = null;</div><div class="line">    try &#123;</div><div class="line">        ojs = new ObjectInputStream(new FileInputStream(path));</div><div class="line">        return (T) ojs.readObject();</div><div class="line">    &#125; catch (IOException | ClassNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">        close(ojs);</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><p>Parcelable 是 Android 特有的序列化接口：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Parcelable &#123;</div><div class="line">    //writeToParcel() 方法中的参数，用于标识当前对象作为返回值返回</div><div class="line">    //有些实现类可能会在这时释放其中的资源</div><div class="line">    public static final int PARCELABLE_WRITE_RETURN_VALUE = 0x0001;</div><div class="line"></div><div class="line">    //writeToParcel() 方法中的第二个参数，它标识父对象会管理内部状态中重复的数据</div><div class="line">    public static final int PARCELABLE_ELIDE_DUPLICATES = 0x0002;</div><div class="line"></div><div class="line">    //用于 describeContents() 方法的位掩码，每一位都代表着一种对象类型</div><div class="line">    public static final int CONTENTS_FILE_DESCRIPTOR = 0x0001;</div><div class="line"></div><div class="line">    //描述当前 Parcelable 实例的对象类型</div><div class="line">    //比如说，如果对象中有文件描述符，这个方法就会返回上面的 CONTENTS_FILE_DESCRIPTOR</div><div class="line">    //其他情况会返回一个位掩码</div><div class="line">    public int describeContents();</div><div class="line"></div><div class="line">    //将对象转换成一个 Parcel 对象</div><div class="line">    //参数中 dest 表示要写入的 Parcel 对象</div><div class="line">    //flags 表示这个对象将如何写入</div><div class="line">    public void writeToParcel(Parcel dest, int flags);</div><div class="line"></div><div class="line">    //实现类必须有一个 Creator 属性，用于反序列化，将 Parcel 对象转换为 Parcelable </div><div class="line">    public interface Creator&lt;T&gt; &#123;</div><div class="line"></div><div class="line">        public T createFromParcel(Parcel source);</div><div class="line"></div><div class="line">        public T[] newArray(int size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //对象创建时提供的一个创建器</div><div class="line">    public interface ClassLoaderCreator&lt;T&gt; extends Creator&lt;T&gt; &#123;</div><div class="line">        //使用类加载器和之前序列化成的 Parcel 对象反序列化一个对象</div><div class="line">        public T createFromParcel(Parcel source, ClassLoader loader);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现了 Parcelable 接口的类在序列化和反序列化时会被转换为 Parcel 类型的数据 。
Parcel 是一个载体，它可以包含数据或者对象引用，然后通过 IBinder 在进程间传递。
实现 Parcelable 接口的类必须有一个 CREATOR 类型的静态变量，下面是一个实例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class ParcelableGroupBean implements Parcelable &#123;</div><div class="line"></div><div class="line">    private String mName;</div><div class="line">    private List&lt;String&gt; mMemberNameList;</div><div class="line">    private User mUser;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 需要我们手动创建的构造函数</div><div class="line">     * @param name</div><div class="line">     * @param memberNameList</div><div class="line">     * @param user</div><div class="line">     */</div><div class="line">    public ParcelableGroupBean(String name, List&lt;String&gt; memberNameList, User user) &#123;</div><div class="line">        mName = name;</div><div class="line">        mMemberNameList = memberNameList;</div><div class="line">        mUser = user;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 1.内容描述</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int describeContents() &#123;</div><div class="line">        //几乎都返回 0，除非当前对象中存在文件描述符时为 1</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 2.序列化</div><div class="line">     * @param dest</div><div class="line">     * @param flags 0 或者 1</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">        dest.writeString(mName);</div><div class="line">        dest.writeStringList(mMemberNameList);</div><div class="line">        dest.writeParcelable(mUser, flags);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 3.反序列化</div><div class="line">     */</div><div class="line">    public static final Creator&lt;ParcelableGroupBean&gt; CREATOR = new Creator&lt;ParcelableGroupBean&gt;() &#123;</div><div class="line">        /**</div><div class="line">         * 反序列创建对象</div><div class="line">         * @param in</div><div class="line">         * @return</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public ParcelableGroupBean createFromParcel(Parcel in) &#123;</div><div class="line">            return new ParcelableGroupBean(in);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 反序列创建对象数组</div><div class="line">         * @param size</div><div class="line">         * @return</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public ParcelableGroupBean[] newArray(int size) &#123;</div><div class="line">            return new ParcelableGroupBean[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 4.自动创建的的构造器，使用反序列化得到的 Parcel 构造对象</div><div class="line">     * @param in</div><div class="line">     */</div><div class="line">    protected ParcelableGroupBean(Parcel in) &#123;</div><div class="line">        mName = in.readString();</div><div class="line">        mMemberNameList = in.createStringArrayList();</div><div class="line">        //反序列化时，如果熟悉也是 Parcelable 的类，需要使用它的类加载器作为参数，否则报错无法找到类</div><div class="line">        mUser = in.readParcelable(User.class.getClassLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Parcelable原理"><a href="#Parcelable原理" class="headerlink" title="Parcelable原理"></a>Parcelable原理</h4><p>Parcelable具体的写入（dest.writeInt(mAge);）与读取（gril.mAge = in.readInt();）都是针对Parcel对象进行的操作，下面贴出的是Parcle 读写int类型数据的定义。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public final class Parcel &#123;</div><div class="line"> </div><div class="line">    ......</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Write an integer value into the parcel at the current dataPosition(),</div><div class="line">     * growing dataCapacity() if needed.</div><div class="line">     */</div><div class="line">    public final native void writeInt(int val);</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * Read an integer value from the parcel at the current dataPosition().</div><div class="line">     */</div><div class="line">    public final native int readInt();</div><div class="line">    </div><div class="line">     ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出都是native方法说明都是使用JNI，其具体位置在<code>frameworks/base/core/jni/android_util_Binder.cpp</code> ，以下也仅以int类型读写为例
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void android_os_Parcel_writeInt(JNIEnv* env, jobject clazz, jint val)</div><div class="line">&#123;</div><div class="line">    Parcel* parcel = parcelForJavaObject(env, clazz);</div><div class="line">    if (parcel != NULL) &#123;</div><div class="line">        const status_t err = parcel-&gt;writeInt32(val);</div><div class="line">        if (err != NO_ERROR) &#123;</div><div class="line">            jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, NULL);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">static jint android_os_Parcel_readInt(JNIEnv* env, jobject clazz)</div><div class="line">&#123;</div><div class="line">    Parcel* parcel = parcelForJavaObject(env, clazz);</div><div class="line">    if (parcel != NULL) &#123;</div><div class="line">        return parcel-&gt;readInt32();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面可以看出都会调用Parcel实现且分别调用writeInt32与readInt32函数，接着来看看具体实现。位置：<code>/system/frameworks/base/libs/binder/Parcel.cpp</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeInt32(int32_t val)</div><div class="line">&#123;</div><div class="line">    return writeAligned(val);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">template&lt;class T&gt;</div><div class="line">status_t Parcel::writeAligned(T val) &#123;</div><div class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));</div><div class="line"> </div><div class="line">    if ((mDataPos+sizeof(val)) &lt;= mDataCapacity) &#123;</div><div class="line">restart_write:</div><div class="line">        *reinterpret_cast&lt;T*&gt;(mData+mDataPos) = val;</div><div class="line">        return finishWrite(sizeof(val));</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    status_t err = growData(sizeof(val));</div><div class="line">    if (err == NO_ERROR) goto restart_write;</div><div class="line">    return err;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">status_t Parcel::readInt32(int32_t *pArg) const</div><div class="line">&#123;</div><div class="line">    return readAligned(pArg);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">template&lt;class T&gt;</div><div class="line">status_t Parcel::readAligned(T *pArg) const &#123;</div><div class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));</div><div class="line"> </div><div class="line">    if ((mDataPos+sizeof(T)) &lt;= mDataSize) &#123;</div><div class="line">        const void* data = mData+mDataPos;</div><div class="line">        mDataPos += sizeof(T);</div><div class="line">        *pArg =  *reinterpret_cast&lt;const T*&gt;(data);</div><div class="line">        return NO_ERROR;</div><div class="line">    &#125; else &#123;</div><div class="line">        return NOT_ENOUGH_DATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本的思路总结一下：</p>
<ol>
<li>整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比JAVA序列化中使用外部存储器会高很多；</li>
<li>读写时是4字节对齐的，可以看到#define PAD_SIZE(s) (((s)+3)&amp;~3)这句宏定义就是在做这件事情；</li>
<li>如果预分配的空间不够时newSize = ((mDataSize+len)*3)/2;会一次多分配50%；</li>
<li>对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>任何实体类都需要复写Parcelable接口吗？</li>
<li>如果子类新增属性，需要复写父类writeToParcel与CREATOR吗？</li>
<li>writeToParcel 与 createFromParcel 对变量的读写前后顺序可以不一致吗，会出现什么结果？</li>
<li>读写Parcelable对象（写操作dest.writeParcelable(obj, flags);  读操作in.readParcelable(ObjectA.class.getClassLoader()); ）</li>
<li>读写Parcelable对象数组<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>可以看到，Serializable 的使用比较简单，创建一个版本号即可；而 Parcelable 则相对复杂一些，会有四个方法需要实现。</li>
</ol>
<p>一般在保存数据到 SD 卡或者网络传输时建议使用 Serializable 即可，虽然效率差一些，好在使用方便。</p>
<p>而在运行时数据传递时建议使用 Parcelable，比如 Intent，Bundle 等，Android 底层做了优化处理，效率很高。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/caowenbin/article/details/6532217" target="_blank" rel="external">《探索Android中的Parcel机制（上）》</a></li>
<li><a href="https://blog.csdn.net/caowenbin/article/details/6532238" target="_blank" rel="external">《探索Android中的Parcel机制（下）》</a></li>
<li><a href="https://blog.codingnow.com/2010/03/c_serialization.html" target="_blank" rel="external">《C 语言的数据序列化 （C语言实现序列化机制的思路）</a></li>
<li><a href="https://blog.csdn.net/niu_gao/article/details/6451699" target="_blank" rel="external"> 《Android中的Parcel是什么》</a></li>
<li><a href="https://blog.csdn.net/niu_gao/article/details/6453391" target="_blank" rel="external"> 《Android开发：什么是Parcel(2)》</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/07/20/tips-audiomanager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/20/tips-audiomanager/" itemprop="url">
                  Android听筒与喇叭切换遇到的坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T08:18:29+08:00">
                2018-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h4><p>在聊天场景中,收到对方语音时,用户可以选择外放播放,也可以选择插入耳机收听.更人性化一点当用户把手机靠近耳朵时屏幕关闭自动切换到听筒中播放,播放完毕后拿开手机屏幕自动点亮.比如微信就是如此.</p>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>从上面场景中我们可以得出我们需要的要点:</p>
<p>播放模式切换:外放&lt;—&gt;耳机
播放模式切换:外放&lt;—&gt;听筒
屏幕操作:亮屏&lt;—&gt;息屏&lt;—&gt;亮屏</p>
<h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>从需求分析我们可以得出需要代码进行控制的有:</p>
<p>音乐播放控制
外放,耳机,听筒之间的切换
屏幕的息屏与亮屏</p>
<h5 id="外放-耳机-听筒之间的切换"><a href="#外放-耳机-听筒之间的切换" class="headerlink" title="外放,耳机,听筒之间的切换"></a>外放,耳机,听筒之间的切换</h5><p>在Android系统中是用AudioManager来管理播放模式的,通过AudioManager.setMode()方法来实现.</p>
<p>在setMode()方法中有以下几种对应不同的播放模式:</p>
<ul>
<li>MODE_NORMAL: 普通模式,既不是铃声模式也不是通话模式</li>
<li>MODE_RINGTONE:铃声模式</li>
<li>MODE_IN_CALL:通话模式</li>
<li>MODE_IN_COMMUNICATION:通信模式,包括音/视频,VoIP通话.(3.0加入的,与通话模式类似)</li>
</ul>
<p>其中:播放音乐的对应的就是MODE_NORMAL, 如果使用外放播则调用audioManager.setSpeakerphoneOn(true)即可.若使用耳机和听筒,则需要先设置模式为MODE_IN_CALL(3.0以前)或MODE_IN_COMMUNICATION(3.0以后).</p>
<p><strong>注意:</strong>
需要权限android.permission.MODIFY_AUDIO_SETTINGS
3.0以后设置模式为MODE_IN_CALL,在华为的某些机型中,根本不起作用.</p>
<p>切换代码如下:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</div><div class="line">/**</div><div class="line"> * 切换到外放</div><div class="line"> */</div><div class="line">public void changeToSpeaker()&#123;</div><div class="line">    audioManager.setMode(AudioManager.MODE_NORMAL);</div><div class="line">    audioManager.setSpeakerphoneOn(true);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 切换到耳机模式</div><div class="line"> */</div><div class="line">public void changeToHeadset()&#123;</div><div class="line">    audioManager.setSpeakerphoneOn(false);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 切换到听筒</div><div class="line"> */</div><div class="line">public void changeToReceiver()&#123;</div><div class="line">    audioManager.setSpeakerphoneOn(false);</div><div class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB)&#123;</div><div class="line">        audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);</div><div class="line">    &#125; else &#123;</div><div class="line">        audioManager.setMode(AudioManager.MODE_IN_CALL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>听筒切换到外放模式,使用上面的changeToSpeaker()即可,但是外放切换到听筒时会丢失大概3秒的语音,解决办法是设置mediaplayer.setAudioStreamType(AudioManager.STREAM_VOICE_CALL),该方法需要在player的prepare前调用,所以外放切听筒会导致重新播放</strong></p>
<h5 id="是否插入耳机判断"><a href="#是否插入耳机判断" class="headerlink" title="是否插入耳机判断"></a>是否插入耳机判断</h5><p>在插入或者拔出耳机时系统会发出Action为Intent.ACTION_HEADSET_PLUG的广播,并且该广播不能使用静态接收器处理,故写一个广播接收器处理耳机事件即可.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class HeadsetReceiver extends BroadcastReceiver&#123;</div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line">        switch (action)&#123;</div><div class="line">            //插入和拔出耳机会触发此广播</div><div class="line">            case Intent.ACTION_HEADSET_PLUG:</div><div class="line">                int state = intent.getIntExtra(&quot;state&quot;, 0);</div><div class="line">                if (state == 1)&#123;//切换到耳机</div><div class="line">                    changeToHeadset();</div><div class="line">                &#125; else if (state == 0)&#123;</div><div class="line">                    changeToSpeaker();</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>耳机切换到外放会出现丢失语音
由于耳机切换到外放需要一段时间导致,故解决此问题的方法是先暂停再续播.那么什么时候暂停什么时候续播呢?
耳机拔出时系统还会发出Action为<code>AudioManager.ACTION_AUDIO_BECOMING_NOISY</code>的广播,且此广播比<code>Intent.ACTION_HEADSET_PLUG</code>要早.</p>
<h5 id="屏幕的息屏与亮屏"><a href="#屏幕的息屏与亮屏" class="headerlink" title="屏幕的息屏与亮屏"></a>屏幕的息屏与亮屏</h5><p>现在几乎每个手机都有距离感应器,通过举例感应器可获得距离.距离感应器由SensorManager管理:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);</div><div class="line">sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);</div><div class="line">sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL);</div></pre></td></tr></table></figure></p>
<p>注册监听的方法的最后一个参数是敏感度,敏感度越高越费电,此处选择一般敏感度即可.此外Activity还需实现SensorEventListener接口,覆写其方法:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onSensorChanged(SensorEvent event) &#123;</div><div class="line">    float value = event.values[0];</div><div class="line">    if (playerManager.isPlaying())&#123;</div><div class="line">        if (value == sensor.getMaximumRange()) &#123;</div><div class="line">            changeToSpeaker();</div><div class="line">            setScreenOn();</div><div class="line">        &#125; else &#123;</div><div class="line">            changeToReceiver();</div><div class="line">            setScreenOff();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if(value == sensor.getMaximumRange())&#123;</div><div class="line">            changeToSpeaker();</div><div class="line">            setScreenOn();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Android系统中硬件的工作状态的控制由PowerManager与WakeLock掌管.PowerManager通过不同的WakeLock来控制CPU,屏幕,键盘等硬件的工作状态.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">powerManager = (PowerManager) getSystemService(POWER_SERVICE);</div><div class="line">wakeLock = powerManager.newWakeLock(PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK, TAG);</div></pre></td></tr></table></figure></p>
<p>注意:需要权限<code>android.Manifest.permission.DEVICE_POWER</code>和<code>android.permission.WAKE_LOCK</code>
其中第一个参数代表控制级别,可选值有:</p>
<ul>
<li>PARTIAL_WAKE_LOCK : CPU运行,屏幕和键盘可能关闭</li>
<li>SCREEN_DIM_WAKE_LOCK :　屏幕亮,键盘灯可能关闭</li>
<li>SCREEN_BRIGHT_WAKE_LOCK : 屏幕全亮,键盘灯可能关闭</li>
<li>FULL_WAKE_LOCK : 屏幕和键盘灯全亮</li>
<li>PROXIMITY_SCREEN_OFF_WAKE_LOCK : 屏幕关闭,键盘灯关闭,CPU运行</li>
<li>DOZE_WAKE_LOCK : 屏幕灰显,CPU延缓工作</li>
</ul>
<p>此处我们选取<code>PROXIMITY_SCREEN_OFF_WAKE_LOCK.WakeLock</code>通过<code>acquire()</code>和<code>release()</code>方法上锁和解锁.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private void setScreenOff()&#123;</div><div class="line">    if (wakeLock == null)&#123;</div><div class="line">        wakeLock = powerManager.newWakeLock(PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK, TAG);</div><div class="line">    &#125;</div><div class="line">    wakeLock.acquire();</div><div class="line">&#125;</div><div class="line">private void setScreenOn()&#123;</div><div class="line">    if (wakeLock != null)&#123;</div><div class="line">        wakeLock.setReferenceCounted(false);</div><div class="line">        wakeLock.release();</div><div class="line">        wakeLock = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="三星Galaxy-note5在熄灭屏幕是会调用Activity的onPause-onStop-方法"><a href="#三星Galaxy-note5在熄灭屏幕是会调用Activity的onPause-onStop-方法" class="headerlink" title="三星Galaxy note5在熄灭屏幕是会调用Activity的onPause(),onStop()方法"></a>三星Galaxy note5在熄灭屏幕是会调用Activity的onPause(),onStop()方法</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/07/06/gradle-config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/06/gradle-config/" itemprop="url">
                  gradle系列之配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-06T15:16:08+08:00">
                2018-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Gradle/" itemprop="url" rel="index">
                    <span itemprop="name">Gradle</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AndroidStudio中build.gradle配置信息
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Top-level build file where you can add configuration options common to all sub-projects/modules.</div><div class="line">// Gradle中可以使用“//”或“/**/”来添加注释，与Java类似。</div><div class="line">// 根目录下的build.gradle用于添加子工程或模块共用的配置项。</div><div class="line"> </div><div class="line">// &quot;buildscript&quot;的类型为script block，而且是最上层的script block，用于配置Gradle的Project实例。其API文档为https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure)</div><div class="line">// 其余的根script block有&quot;allprojects&quot;, &quot;dependencies&quot;, &quot;configurations&quot;等，更多的可见https://docs.gradle.org/current/dsl/的“Build script structure”一节。</div><div class="line">// Script Block是一种method的调用，传入的参数为configuration closure。执行后会对Project的属性进行配置。</div><div class="line">// 此处的&quot;buildscript&quot;用于配置Project的build script的classpath。</div><div class="line">    buildscript &#123;</div><div class="line">    // 如果需要的话，从https://jcenter.bintray.com/下载code reposities。</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    // 定义classpath，gradle会从“repositories”中下载对应版本的Gradle。如果使用gradle wrapper的话，感觉这个配置会被忽略。Wrapper会自己去下载所使用的gradle版本。</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:2.1.3&apos;</div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 该配置会被应用到所有的子工程。</div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 运行gradle clean时，执行此处定义的task。</div><div class="line">// 该任务继承自Delete，删除根目录中的build目录。</div><div class="line">// 相当于执行Delete.delete(rootProject.buildDir)。</div><div class="line">// gradle使用groovy语言，调用method时可以不用加（）。</div><div class="line">task clean(type: Delete) &#123;</div><div class="line">    delete rootProject.buildDir</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>buildscript中的声明是gradle脚本自身需要使用的资源。可以声明的资源包括依赖项、第三方插件、maven仓库地址等。而在build.gradle文件中直接声明的依赖项、仓库地址等信息是项目自身需要的资源。</p>
<p>gradle是由groovy语言编写的，支持groovy语法，可以灵活的使用已有的各种ant插件、基于jvm的类库，这也是它比maven、ant等构建脚本强大的原因。虽然gradle支持开箱即用，但是如果你想在脚本中使用一些第三方的插件、类库等，就需要自己手动添加对这些插件、类库的引用。而这些插件、类库又不是直接服务于项目的，而是支持其它build脚本的运行。所以你应当将这部分的引用放置在buildscript代码块中。gradle在执行脚本时，会优先执行buildscript代码块中的内容，然后才会执行剩余的build脚本。</p>
<p>举个例子，假设我们要编写一个task，用于解析csv文件并输出其内容。虽然我们可以使用gradle编写解析csv文件的代码，但其实apache有个库已经实现了一个解析csv文件的库供我们直接使用。我们如果想要使用这个库，需要在gradle.build文件中加入对该库的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">repositories &#123;</div><div class="line">mavenLocal()</div><div class="line">mavenCentral()</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">classpath &apos;org.apache.commons:commons-csv:1.0&apos;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">import org.apache.commons.csv.*</div><div class="line">task printCSV() &#123;</div><div class="line">doLast &#123;</div><div class="line">def records = CSVFormat.EXCEL.parse(new FileReader(&apos;config/sample.csv&apos;))</div><div class="line">for (item in records) &#123;</div><div class="line">print item.get(0) + &apos; &apos;</div><div class="line">println item.get(1)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>buildscript代码块中的repositories和dependencies的使用方式与直接在build.gradle文件中的使用方式几乎完全一样。唯一不同之处是在buildscript代码块中你可以对dependencies使用classpath声明。该classpath声明说明了在执行其余的build脚本时，class loader可以使用这些你提供的依赖项。这也正是我们使用buildscript代码块的目的。</p>
<p>而如果你的项目中需要使用该类库的话，就需要定义在buildscript代码块之外的dependencies代码块中。所以有可能会看到在build.gradle中出现以下代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">mavenLocal()</div><div class="line">mavenCentral()</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">compile &apos;org.springframework.ws:spring-ws-core:2.2.0.RELEASE&apos;,</div><div class="line">&apos;org.apache.commons:commons-csv:1.0&apos;</div><div class="line">&#125;</div><div class="line">buildscript &#123;</div><div class="line">repositories &#123;</div><div class="line">mavenLocal()</div><div class="line">mavenCentral()</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">classpath &apos;org.apache.commons:commons-csv:1.0&apos;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">import org.apache.commons.csv.*</div><div class="line">task printCSV() &#123;</div><div class="line">doLast &#123;</div><div class="line">def records = CSVFormat.EXCEL.parse(new FileReader(&apos;config/sample.csv&apos;))</div><div class="line">for (item in records) &#123;</div><div class="line">print item.get(0) + &apos; &apos;</div><div class="line">println item.get(1)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="依赖更新"><a href="#依赖更新" class="headerlink" title="依赖更新"></a>依赖更新</h5><p>项目依赖的远程包如果有更新，会有提醒或者自动更新吗？ 不会的，需要你手动设置changing标记为true，这样gradle会每24小时检查更新，通过更改resolutionStrategy可以修改检查周期。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">configurations.all &#123;</div><div class="line">    // check for updates every build</div><div class="line">    resolutionStrategy.cacheChangingModulesFor 0, &apos;seconds&apos;</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">    compile group: &quot;group&quot;, name: &quot;projectA&quot;, version: &quot;1.1-SNAPSHOT&quot;, changing: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之前上传aar同一版本到maven仓库，但依赖却没有更新，该怎么办呢?可以直接删除本地缓存，缓存在~/.gradle/caches目录下，删除缓存后，下次运行就会自动重新下载远程依赖了。</p>
<h5 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h5><p>项目构建过程中那么多任务，有些test相关的任务可能根本不需要，可以直接关掉，在build.gradle中加入如下脚本：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tasks.whenTaskAdded &#123; task -&gt;</div><div class="line">    if (task.name.contains(&apos;AndroidTest&apos;)) &#123;</div><div class="line">        task.enabled = false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tasks会获取当前project中所有的task，enabled属性控制任务开关，whenTaskAdded后面的闭包会在gradle配置阶段完成。</p>
<h5 id="加入任务"><a href="#加入任务" class="headerlink" title="加入任务"></a>加入任务</h5><p>任务可以取消了，但还不尽兴啊，想加入任务怎么搞？前面讲了dependsOn的方法，那就拿过来用啊，但是原有任务的依赖关系你又不是很清楚，甚至任务名称都不知道，怎么搞？</p>
<p>比如我想在执行dex打包之前，加入一个hello任务，可以这么写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">afterEvaluate &#123;</div><div class="line">    android.applicationVariants.each &#123; variant -&gt;</div><div class="line">        def dx = tasks.findByName(&quot;dex$&#123;variant.name.capitalize()&#125;&quot;)</div><div class="line">        def hello = &quot;hello$&#123;variant.name.capitalize()&#125;&quot;</div><div class="line">        task(hello) &lt;&lt; &#123;</div><div class="line">            println &quot;hello&quot;</div><div class="line">        &#125;</div><div class="line">        tasks.findByName(hello).dependsOn dx.taskDependencies.getDependencies(dx)</div><div class="line">        dx.dependsOn tasks.findByName(hello)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>afterEvaluate是什么鸟？你可以理解为在配置阶段要结束，项目评估完会走到这一步。</p>
<p>variant呢？variant = productFlavors+ buildTypes，所以dex打包的任务可能就是dexCommonDebug。</p>
<p>你怎么知道dex任务的具体名称？Android Studio中的Gradle Console在执行gradle任务的时候会有输出，可以仔细观察一下。</p>
<p>hello任务定义的这么复杂干啥？我直接就叫hello不行吗?不行，each就是遍历variants，如果每个都叫hello，多个variant都一样，岂不是傻傻分不清楚，加上variant的name做后缀，才有任务的区分。</p>
<p>关键来了，dx.taskDependencies.getDependencies(dx)会获取dx任务的所有依赖，让hello任务依赖dx任务的所有依赖，再让dx任务依赖hello任务，这样就可以加入某个任务到构建流程了，是不是感觉非常灵活。</p>
<p>我突然想到，用doFirst的方式加入一个action到dx任务中，应该也可以达到上面效果。</p>
<h5 id="任务监听"><a href="#任务监听" class="headerlink" title="任务监听"></a>任务监听</h5><p>你想知道每个执行任务的运行时间吗？你想知道每个执行任务都是干嘛的吗？把下面这段脚本加入build.gradle中即可：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class TimingsListener implements TaskExecutionListener, BuildListener &#123;</div><div class="line">    private Clock clock</div><div class="line">    private timings = []</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void beforeExecute(Task task) &#123;</div><div class="line">        clock = new org.gradle.util.Clock()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void afterExecute(Task task, TaskState taskState) &#123;</div><div class="line">        def ms = clock.timeInMs</div><div class="line">        timings.add([ms, task.path])</div><div class="line">        task.project.logger.warn &quot;$&#123;task.path&#125; took $&#123;ms&#125;ms&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void buildFinished(BuildResult result) &#123;</div><div class="line">        println &quot;Task timings:&quot;</div><div class="line">        for (timing in timings) &#123;</div><div class="line">            if (timing[0] &gt;= 50) &#123;</div><div class="line">                printf &quot;%7sms  %s\n&quot;, timing</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    void buildStarted(Gradle gradle) &#123;&#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void projectsEvaluated(Gradle gradle) &#123;&#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void projectsLoaded(Gradle gradle) &#123;&#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void settingsEvaluated(Settings settings) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.addListener new TimingsListener()</div></pre></td></tr></table></figure></p>
<p>上面是对每个任务计时的一个例子，想要了解每个任务的作用，你可以修改上面的脚本，打印出每个任务的inputs和outputs。比如assembleDebug那么多依赖任务，每个都是干什么的，一会compile，一会generate，有什么区别？看到每个task的输入输出，就可以大体看出它的作用。如果对assemble的每个任务监听，你会发现改一行代码build的时间主要花费在了dex上，buck牛逼的地方就是对这个地方进行了优化，大大减少了增量编译运行的时间。</p>
<h5 id="buildscript方法"><a href="#buildscript方法" class="headerlink" title="buildscript方法"></a>buildscript方法</h5><p>Android项目中，根工程默认的build.gradle应该是这样的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// Top-level build file where you can add configuration options common to all sub-projects/modules.</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:1.2.3&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一会一个jcenter()这是在干什么？buildscript方法的作用是配置脚本的依赖，而我们平常用的compile是配置project的依赖。repositories的意思就是需要包的时候到哥这里来找，然后你以为com.android.tools.build:gradle:1.2.3会从jcenter那里下载了是吧，图样图森破，不信加入下面这段脚本看看输出：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    repositories.each &#123;</div><div class="line">        println it.getUrl()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:1.2.3&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果是这样的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file:/Applications/Android%20Studio.app/Contents/gradle/m2repository/ https://jcenter.bintray.com/</div></pre></td></tr></table></figure></p>
<p>我靠，仓库竟然直接在Android Studio应用内部，所以说你去掉buildscript的jcenter()完全没有关系啊，下面还有更爽的，我们知道有依赖传递，上面classpath 中的gradle依赖gradle-core，gradle-core依赖lint，lint依赖lint-checks，lint-checks最后依赖到了asm，并且这个根目录中的依赖配置会传到所有工程的配置文件，所以如果你要引用asm相关的类，不用设置classpath，直接import就可以了。你怎么知道前面的依赖关系的？看上面m2repository目录中对应的pom文件就可以了。
为什么讲到ASM呢？<a href="http://asm.ow2.org/" target="_blank" rel="external">ASM</a>又是个比较刁的东西，可以直接用来操纵Java字节码，达到动态更改class文件的效果。可以用ASM<a href="http://developer.51cto.com/art/201309/410861_all.htm" target="_blank" rel="external">面向切面编程</a>，达到解耦效果。<a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="external">Android DEX自动拆包及动态加载</a>简介中提到的class依赖分析和R常量替换的脚本都可以用ASM来搞</p>
<h5 id="引入脚本"><a href="#引入脚本" class="headerlink" title="引入脚本"></a>引入脚本</h5><p>脚本写多了，都挤在一个build.gradle里也不好，人长大了总要自己出去住，那可以把部分脚本抽出去吗？当然可以，新建一个other.gradle把脚本抽离，然后在build.gradle中添加apply from ‘other.gradle’即可，抽出去以后你会发现本来可以直接import的asm包找不到了，怎么回事？根工程中配置的buildscript会传递到所有工程，但只会传到build.gradle脚本中，其他脚本可不管，所以你要在other.gradle中重新配置buildscript，并且other.gradle中的repositories不再包含m2repository目录，自己配置jcenter()又会导致依赖重新下载到~/.gradle/caches目录。如果不想额外下载，也可以在other.gradle中这么搞：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        maven &#123;</div><div class="line">            url rootProject.buildscript.repositories[0].getUrl()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:1.2.3&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="获取AndroidManifest文件"><a href="#获取AndroidManifest文件" class="headerlink" title="获取AndroidManifest文件"></a>获取AndroidManifest文件</h5><p><a href="http://tools.android.com/tech-docs/new-build-system/applicationid-vs-packagename" target="_blank" rel="external">ApplicationId versus PackageName</a>提到，gradle中的applicationid用来区分应用，manifest中packageName用来指定R文件包名，并且各个productFlavor 的manifest中的packageName应该一致。applicationid只是gradle脚本中的定义，其实最后生成的apk中的manifest文件的packageName还是会被applicationid替换掉。</p>
<p>那获取R文件的包名怎么搞？要获取AndroidManifest中package属性，并且这个manifest要是起始的文件，因为最终文件中的package属性会被applicationid冲掉，由于各个manifest中的package属性一样，并且非主manifest可以没有package属性，所以只有获取主manifest的package属性才是最准确的。</p>
<p>def manifestFile = android.sourceSets.main.manifest.srcFile
def packageName = new XmlParser().parse(manifestFile).attribute(‘package’)</p>
<h5 id="无用资源"><a href="#无用资源" class="headerlink" title="无用资源"></a><a href="https://developer.android.com/studio/build/shrink-code" target="_blank" rel="external">无用资源</a></h5><h5 id="transitive-true"><a href="#transitive-true" class="headerlink" title="transitive = true"></a><code>transitive = true</code></h5><p>transitive dependencies 被称为依赖的依赖，称为“间接依赖”比较合适。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">compile(&apos;com.meituan.android.terminus:library:6.6.1.16@aar&apos;)&#123;</div><div class="line">        transitive = true</div><div class="line">        exclude module: &apos;hotel_model&apos;</div><div class="line">        exclude module: &apos;base_model&apos;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在后面加上@aar，意指你只是下载该aar包，而并不下载该aar包所依赖的其他库，那如果想在使用@aar的前提下还能下载其依赖库，则需要添加transitive=true的条件。 
排除 transitive dependencies 
通过configuration或者dependency可以除去 transitive dependencies：</p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">configurations &#123;</div><div class="line">    compile.exclude module: &apos;commons&apos;</div><div class="line">    all*.exclude group: &apos;org.gradle.test.excludes&apos;, module: &apos;reports&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile(&quot;org.gradle.test.excludes:api:1.0&quot;) &#123;</div><div class="line">        exclude module: &apos;shared&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在configuration中定义一个exclude,那么所有依赖的transitive dependency (指定的)都会被去除。 
定义exclude时候，或只指定group, 或只指定module名字，或二者都指定。</p>
<p>不是所有的transitive dependency 都可以被去除的，如runtime时候使用到的。一般来说，runtime时候用不到的，或者目标环境及平台已经包含该依赖的可以执行exclude去除。</p>
<p>那exclude选per-dependency还是per-configuration?，大多数情况我们都选用per-configuration，下面是一些使用exclude的典型场合： </p>
<ul>
<li>有licensing问题 </li>
<li>从远程仓库上无法获取到依赖 </li>
<li>runtime时候用不到 </li>
<li>有版本冲突</li>
</ul>
<p>可以给dependencies统一指定transitive为false，再次执行dependencies可以看到如下结果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">configurations.all &#123;</div><div class="line">   transitive = false</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">   androidTestCompile(&apos;com.android.support.test:runner:0.2&apos;)</div><div class="line">   androidTestCompile(&apos;com.android.support.test:rules:0.2&apos;)</div><div class="line">   androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.1&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="exclude的疑问"><a href="#exclude的疑问" class="headerlink" title="exclude的疑问"></a>exclude的疑问</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exclude module: &apos;base_model&apos;</div></pre></td></tr></table></figure>
<p>和
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exclude group:&apos;com.name.group&apos; module:&apos;base_model&apos;</div></pre></td></tr></table></figure></p>
<p>的区别是？
经过测试，二者的作用是完全一样的。 </p>
<h5 id="force-true"><a href="#force-true" class="headerlink" title="force=true"></a>force=true</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile(&apos;com.squareup.okhttp:okhttp-mt:2.5.0&apos;) &#123;</div><div class="line">        force = true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，我们在依赖okhttp的时候很可能发生冲突，就比如依赖的依赖中也包含了okhttp，这种场合下，就会产生版本冲突的问题，加上force = true表明的意思就是即使在有依赖库版本冲突的情况下坚持使用被标注的这个依赖库版本。</p>
<h5 id="gradle命令"><a href="#gradle命令" class="headerlink" title="gradle命令"></a>gradle命令</h5><ul>
<li>gradlew projects:查看所有项目</li>
<li>gradlew tasks:查看任务信息</li>
<li>-b参数指定其他的构建文件</li>
<li>-p:参数指定要使用的构建文件的文件夹，例如我们将subdir中的构建文件重命名为build.gradle，然后运行gradle -q -p subdir hello</li>
<li>gradle -q projects 列出所有项目的信息(-q静默参数，功能是只显示任务输出，不显示其他构建过程的输出)</li>
<li>gradle -q tasks 列出所有任务</li>
<li>gradle help –task someTask:显示任务帮助</li>
<li>使用-m参数可以以Dry Run的方式运行Gradle，在这种方式下不会执行任何任务，只会列出这些任务的执行顺序 </li>
</ul>
<p>在运行Gradle的时候我们不用完整输入任务名称，如果任务的前几个字母就可以区分任务，我们就可以只输入这几个字母。比如gradle d相当于gradle dist。另外Gradle还支持驼峰命名法的缩写。比如说我们可以运行gradle cT，相当于gradle compileTest。</p>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><ul>
<li><a href="https://blog.csdn.net/qinxiandiqi/article/details/44458707" target="_blank" rel="external">建立企业内部maven服务器并使用Android Studio发布公共项目</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/04/03/ml-anaconda-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/03/ml-anaconda-intro/" itemprop="url">
                  anaconda环境搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T15:54:06+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ml/" itemprop="url" rel="index">
                    <span itemprop="name">ml</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。因为包含了大量的科学包，比如ipython、ipython notebook、numpy等一些数据分析包，这样我们不必单独的安装各种工具包，简单有效！</p>
<p>官网下载地址为：<a href="https://www.anaconda.com/download/" target="_blank" rel="external">https://www.anaconda.com/download/</a></p>
<h4 id="安装anaconda"><a href="#安装anaconda" class="headerlink" title="安装anaconda"></a>安装anaconda</h4><p>对于Mac、Linux系统，Anaconda安装好后，实际上就是在主目录下多了个文件夹（~/anaconda）而已，Windows会写入注册表。安装时，安装程序会把bin目录加入PATH（Linux/Mac写入~/.bashrc，Windows添加到系统变量PATH），这些操作也完全可以自己完成。以Linux/Mac为例，安装完成后设置PATH的操作是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 将anaconda的bin目录加入PATH，根据版本不同，也可能是~/anaconda3/bin</div><div class="line">echo &apos;export PATH=&quot;~/anaconda2/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc</div><div class="line"># 更新bashrc以立即生效</div><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure>
<p>配置好PATH后，可以通过which conda或conda –version命令检查是否正确。假如安装的是Python 2.7对应的版本，运行python –version或python -V可以得到Python 2.7.12 :: Anaconda 4.1.1 (64-bit)，也说明该发行版默认的环境是Python 2.7。</p>
<h4 id="Conda的环境管理"><a href="#Conda的环境管理" class="headerlink" title="Conda的环境管理"></a>Conda的环境管理</h4><p>Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。对于上述安装过程，假设我们采用的是Python 2.7对应的安装包，那么Python 2.7就是默认的环境（默认名字是root，注意这个root不是超级管理员的意思）。</p>
<p>假设我们需要安装Python 3.4，此时，我们需要做的操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）</div><div class="line">conda create --name python34 python=3.4</div><div class="line"></div><div class="line"># 安装好后，使用activate激活某个环境</div><div class="line">activate python34 # for Windows</div><div class="line">source activate python34 # for Linux &amp; Mac</div><div class="line"># 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH</div><div class="line"></div><div class="line"># 此时，再次输入</div><div class="line">python --version</div><div class="line"># 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境</div><div class="line"></div><div class="line"># 如果想返回默认的python 2.7环境，运行</div><div class="line">deactivate python34 # for Windows</div><div class="line">source deactivate python34 # for Linux &amp; Mac</div><div class="line"></div><div class="line"># 删除一个已有的环境</div><div class="line">conda remove --name python34 --all</div></pre></td></tr></table></figure>
<p>用户安装的不同python环境都会被放在目录~/anaconda/envs下，可以在命令中运行conda info -e查看已安装的环境，当前被激活的环境会显示有一个星号或者括号。</p>
<p>说明：有些用户可能经常使用python 3.4环境，因此直接把~/anaconda/envs/python34下面的bin或者Scripts加入PATH，去除anaconda对应的那个bin目录。这个办法，怎么说呢，也是可以的，但总觉得不是那么elegant……</p>
<p>如果直接按上面说的这么改PATH，你会发现conda命令又找不到了（当然找不到啦，因为conda在~/anaconda/bin里呢），这时候怎么办呢？方法有二：1. 显式地给出conda的绝对地址 2. 在python34环境中也安装conda工具（推荐）。</p>
<h4 id="Conda的包管理"><a href="#Conda的包管理" class="headerlink" title="Conda的包管理"></a>Conda的包管理</h4><p>Conda的包管理就比较好理解了，这部分功能与pip类似。</p>
<p>例如，如果需要安装scipy：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 安装scipy</div><div class="line">conda install scipy</div><div class="line"># conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）</div><div class="line"></div><div class="line"># 查看已经安装的packages</div><div class="line">conda list</div><div class="line"># 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包</div></pre></td></tr></table></figure></p>
<p>conda的一些常用操作如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">conda的一些常用操作如下：</div><div class="line"></div><div class="line"># 查看当前环境下已安装的包</div><div class="line">conda list</div><div class="line"></div><div class="line"># 查看某个指定环境的已安装包</div><div class="line">conda list -n python34</div><div class="line"></div><div class="line"># 查找package信息</div><div class="line">conda search numpy</div><div class="line"></div><div class="line"># 安装package</div><div class="line">conda install -n python34 numpy</div><div class="line"># 如果不用-n指定环境名称，则被安装在当前活跃环境</div><div class="line"># 也可以通过-c指定通过某个channel安装</div><div class="line"></div><div class="line"># 更新package</div><div class="line">conda update -n python34 numpy</div><div class="line"></div><div class="line"># 删除package</div><div class="line">conda remove -n python34 numpy</div></pre></td></tr></table></figure></p>
<p>前面已经提到，conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 更新conda，保持conda最新</div><div class="line">conda update conda</div><div class="line"></div><div class="line"># 更新anaconda</div><div class="line">conda update anaconda</div><div class="line"></div><div class="line"># 更新python</div><div class="line">conda update python</div><div class="line"># 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本</div></pre></td></tr></table></figure>
<p>补充：如果创建新的python环境，比如3.4，运行conda create -n python34 python=3.4之后，conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 在当前环境下安装anaconda包集合</div><div class="line">conda install anaconda</div><div class="line"></div><div class="line"># 结合创建环境的命令，以上操作可以合并为</div><div class="line">conda create -n python34 python=3.4 anaconda</div><div class="line"># 也可以不用全部安装，根据需求安装自己需要的package即可</div></pre></td></tr></table></figure></p>
<h5 id="通过pip将packages安装到Conda环境中"><a href="#通过pip将packages安装到Conda环境中" class="headerlink" title="通过pip将packages安装到Conda环境中"></a>通过pip将packages安装到Conda环境中</h5><p>发行版Anaconda附带安装了200多个Python软件包，还可以使用conda install 命令快速轻松地安装许多软件包。</p>
<p>除了安装和管理软件包的实用程序外，conda还拥有创建虚拟环境的能力，这些虚拟环境是在没有任何Python包预先加载的情况下创建的。
但是不是所有的软件包都可以通过 conda 安装，如果你想要一个不可用的软件，那么你将不得不使用备用软件包管理器pip。Anaconda的软件包管理器conda和pip如何相互交互？
目前有两种方法:</p>
<h6 id="一、以下是如何在conda虚拟环境中使用pip安装软件包。首先要建立起来："><a href="#一、以下是如何在conda虚拟环境中使用pip安装软件包。首先要建立起来：" class="headerlink" title="一、以下是如何在conda虚拟环境中使用pip安装软件包。首先要建立起来："></a>一、以下是如何在conda虚拟环境中使用pip安装软件包。首先要建立起来：</h6><ol>
<li>使用conda create - name virtual_env_name 创建您的虚拟环境，用虚拟环境的 名称 替换virtual_env_name</li>
<li>使用source activate virtual_env_name切换到您的虚拟环境 ，再次用您的虚拟环境的名称替换virtual_env_name</li>
<li>运行conda install pip ，它会将pip安装到您的虚拟环境目录中</li>
<li>后续直接使用以下两步即可：1）source activate virtual_env_name 2）pip install ‘package_name’</li>
</ol>
<h6 id="二、第二种方法不单独创建虚拟环境，直接用Anaconda本身的虚拟环境。个人还是建议第一种。"><a href="#二、第二种方法不单独创建虚拟环境，直接用Anaconda本身的虚拟环境。个人还是建议第一种。" class="headerlink" title="二、第二种方法不单独创建虚拟环境，直接用Anaconda本身的虚拟环境。个人还是建议第一种。"></a>二、第二种方法不单独创建虚拟环境，直接用Anaconda本身的虚拟环境。个人还是建议第一种。</h6><ol>
<li>运行conda install pip ，它会将pip安装到您的Anaconda虚拟环境目录中。</li>
<li>你需要找到你的Anaconda bin目录运行pip，如：//anaconda/bin/pip install package_name将软件包安装到您的虚拟环境中 。</li>
</ol>
<h4 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h4><p>如果需要安装很多packages，你会发现conda下载的速度经常很慢，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 添加Anaconda的TUNA镜像</div><div class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</div><div class="line"># TUNA的help中镜像地址加有引号，需要去掉</div><div class="line"></div><div class="line"># 设置搜索时显示通道地址</div><div class="line">conda config --set show_channel_urls yes</div></pre></td></tr></table></figure></p>
<p>执行完上述命令后，会生成<code>~/.condarc(Linux/Mac)</code>或<code>C:\Users\USER_NAME\.condarc</code>文件，记录着我们对conda的配置，直接手动创建、编辑该文件是相同的效果。</p>
<h4 id="为vscode配置集成环境"><a href="#为vscode配置集成环境" class="headerlink" title="为vscode配置集成环境"></a>为vscode配置集成环境</h4><p>VS Code下载地址为： <a href="https://code.visualstudio.com/Download" target="_blank" rel="external">https://code.visualstudio.com/Download</a>
安装完anaconda会自动提示安装VS Code,如果已安装就不会安装,只会安装插件Anaconda Extension.</p>
<h5 id="添加Python编译配置"><a href="#添加Python编译配置" class="headerlink" title="添加Python编译配置"></a>添加Python编译配置</h5><p>首选项-&gt;设置，打开一个setting.json
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//配置python的路径</div><div class="line">     &quot;python.pythonPath&quot;: &quot;D:/Program Files/Anaconda3/python&quot;,</div><div class="line">     &quot;editor.fontFamily&quot;: &quot;Consolas&quot;,</div><div class="line">     //忽略pylint检查代码时，出现无谓的波浪线的问题</div><div class="line">     &quot;python.linting.pylintArgs&quot;: [</div><div class="line">         &quot;--disable=W,C&quot;</div><div class="line">     ]</div></pre></td></tr></table></figure></p>
<h5 id="Python脚本编译测试"><a href="#Python脚本编译测试" class="headerlink" title="Python脚本编译测试"></a>Python脚本编译测试</h5><p>新建test.py，代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># plot a sine wave from 0 to 4pi  </div><div class="line">from pylab import *  </div><div class="line">x_values = arange(0.0, math.pi * 4, 0.01)  </div><div class="line">y_values = sin(x_values)  </div><div class="line">plot(x_values, y_values, linewidth=1.0)  </div><div class="line">xlabel(&apos;x&apos;)  </div><div class="line">ylabel(&apos;sin(x)&apos;)  </div><div class="line">title(&apos;Simple plot&apos;)  </div><div class="line">grid(True)  </div><div class="line">savefig(&quot;sin.png&quot;)  </div><div class="line">show()</div></pre></td></tr></table></figure></p>
<p>我们可以看到，代码中调用了matplotlib数据包，并且代码编译通过，显示出所打印的正弦波图像。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/03/04/media-signal-digitization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/04/media-signal-digitization/" itemprop="url">
                  多媒体技术(四)之音频,视频信号及数字化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T22:55:11+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/media/" itemprop="url" rel="index">
                    <span itemprop="name">media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>宽应用的领域非常多，可以用来标识信号传输的数据传输能力、标识单位时间内通过链路的数据量、标识显示器的显示能力。</p>
<ol>
<li>在模拟信号系统又叫频宽，是指在固定的时间可传输的资料数量，亦即在传输管道中可以传递数据的能力。通常以每秒传送周期或赫兹(Hz)来表示。</li>
<li>在数字设备中，带宽指单位时间能通过链路的数据量。通常以bps来表示，即每秒可传输之位数。</li>
<li>信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。频宽对基本输出入系统 (BIOS ) 设备尤其重要，如快速磁盘驱动器会受低频宽的总线所阻碍。</li>
</ol>
<p>带宽：带宽是反映信号频率通过能力，带宽越大，对信号中的各种频率成分（特别是高频成分）能准确有效地放大与显示，也就较为准确，如果带宽不够，那就会损失很多高频成分，信号自然就显示不准确了，出现较大误差。
在一秒的时间内最大最多能通过的信号，所以带宽要大于等于最高频率fmax.
采样率： 而采样率是将模拟量转换为数字量时对信号转换的频率（即每秒采集次数），这个频率越高，单位时间内对信号的采集就越多，信号中的信息就保留越多，丢失信息就少，转换出的数字量就能准确反映信号的数值.</p>
<p>香农采样定理：采样定理说明采样频率与信号频谱之间的关系，是连续信号离散化的基本依据，在进行模拟/数字信号的转换过程中，当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max&gt;2fmax)，采样之后的数字信号完整地保留了原始信号中的信息，一般实际应用中保证采样频率为信号最高频率的2.56～4倍；采样定理又称奈奎斯特定理。
在工程中为了方便计算机的计算，一般去fs=2.56fmax.
一个正弦波形至少可用2个点来描述.
对连续信号进行等间隔采样时，如果采样频率不满足采样定理，采样后信号的频率就会发生混叠，即高于奈奎斯特频率的频率成分将被重构成低于奈奎斯特频率的信号,如果发生混叠，就无法准确的重建出原始声音的音频信号。</p>
<p>如何查看最高频率(或者是感兴趣的)呢？
用AU打开一段音频，在波形下边打开频域图，看看你感兴趣的谐波或者共振峰的频域的什么范围，找出最大值，即可确定为带宽，那么 采样率 ＝ 带宽＊2.5</p>
<p>频段,是一个有关通讯和声音理学方面的词语,通讯方面的频段意思是指一定的无线电波的频率范围；声音和音乐中的频段是指声音频率而言,人耳对声音频率的感觉是从最低的20Hz到最高的20KHz,而人的语音频率范围则集中在80Hz~12kHz之间,不同频段的声音对人的感受是不同的.
带宽（band width）又叫频宽,是指在固定的的时间可传输的资料数量,亦即在传输管道中可以传递数据的能力.在数字设备中,频宽通常以bps表示,即每秒可传输之位数.在模拟设备中,频宽通常以每秒传送周期或赫兹 (Hz)来表示.
速率：是物体运动的快慢,即速率是速度的大小或等价于路程的变化率.在初中物理中被称为速度,但应与高中物理中的速度加以区别.在网络应用中应该是传输速度之比.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">167</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
