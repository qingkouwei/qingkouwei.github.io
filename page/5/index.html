<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/page/5/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/page/5/"/>





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/11/05/l-rxjava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/11/05/l-rxjava/" itemprop="url">
                  rxjava用法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-05T16:35:48+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在越来越多Android开发者使用到RxJava，在Android使用RxJava主要有如下好处： 
1，轻松切换线程。以前我们切换线程主要使用Handler等手段来做。 
2，轻松解决回调的嵌套问题。现在的app业务逻辑越来越复杂，多的时候3，4层回调嵌套，使得代码可维护性变得很差。RxJava链式调用使得这些调用变得扁平化。</p>
<p>随着RxJava的流行，越来越多的开源项目开始支持RxJava，像Retrofit、GreenDao等。这些开源项目支持RxJava使得我们解决复杂业务变得非常方便。</p>
<p>但是这些还不够，有的时候我们自己的封装的业务也需要支持RxJava，举个例子：查询数据、处理本地文件等操作，总而言之就是一些耗时任务。而且还要处理这些操作的成功、失败、线程切换等操作。 </p>
<h4 id="RX操作符之Observable的创建方式"><a href="#RX操作符之Observable的创建方式" class="headerlink" title="RX操作符之Observable的创建方式"></a>RX操作符之Observable的创建方式</h4><h5 id="创建方式一-just、from、repeat、repeatWhen"><a href="#创建方式一-just、from、repeat、repeatWhen" class="headerlink" title="创建方式一:just、from、repeat、repeatWhen"></a>创建方式一:just、from、repeat、repeatWhen</h5><h6 id="1-just方法"><a href="#1-just方法" class="headerlink" title="1.just方法"></a>1.just方法</h6><p>创建发送指定值的Observerble，just只是简单的原样发射，将数组或Iterable当做单个数据。如果传递的值为null，则发送的Observable的值为null。参数最多为9个
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; myObservable = Observable.just(&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;);</div><div class="line"></div><div class="line">       Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               System.out.println(s);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               System.out.println(&quot;onError....................&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p>结果:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">onCompleted.............</div></pre></td></tr></table></figure></p>
<h6 id="2-from方法"><a href="#2-from方法" class="headerlink" title="2.from方法"></a>2.from方法</h6><p>将数据转换成为Observables，而不是需要混合使用Observables和其它类型的数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">String[]items = &#123;&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;,&quot;just1&quot;&#125;;</div><div class="line"></div><div class="line">       Observable&lt;String&gt; myObservable = Observable.from(items);</div><div class="line"></div><div class="line">       Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               System.out.println(s);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               System.out.println(&quot;onError....................&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p>结果:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">just1</div><div class="line">onCompleted.............</div></pre></td></tr></table></figure></p>
<h6 id="3-repeat方法"><a href="#3-repeat方法" class="headerlink" title="3.repeat方法"></a>3.repeat方法</h6><p>repeat()重复地执行某个操作，如果不传递参数，结果将会被无限地重复执行，默认在trampoline调度器上执行，该方法为非静态方法，不可以直接通过Observable来调用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">String[]items = &#123;&quot;just1&quot;,&quot;just2&quot;,&quot;just3&quot;,&quot;just4&quot;,&quot;just5&quot;,&quot;just6&quot;&#125;;</div><div class="line"></div><div class="line">       Observable&lt;String&gt; myObservable = Observable.from(items).repeat();</div><div class="line"></div><div class="line"></div><div class="line">       Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               System.out.println(s);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               System.out.println(&quot;onError....................&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p>repeat()如果传入数字类型的参数，则重复地执行指定次数的某个操作，默认在trampoline调度器上执行，不可以直接通过Observable来调用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">String[]items = &#123;&quot;just1&quot;,&quot;just2&quot;,&quot;just3&quot;,&quot;just4&quot;,&quot;just5&quot;,&quot;just6&quot;&#125;;</div><div class="line"> </div><div class="line">        Observable&lt;String&gt; myObservable = Observable.from(items).repeat(2);</div><div class="line"> </div><div class="line"> </div><div class="line">        Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                System.out.println(&quot;onError....................&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p>repeatWhen()不是缓存和重放原始Observable的数据序列，而是有条件的重新订阅和发射原来的Observable,当Observable中的call()方法中调用了重复执行的代码时，onNext()将会被重复执行。如果该方法执行后返回void，则结束执行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">final String[]items = &#123;&quot;just1&quot;,&quot;just2&quot;,&quot;just3&quot;,&quot;just4&quot;,&quot;just5&quot;,&quot;just6&quot;&#125;;</div><div class="line"></div><div class="line">       Observable&lt;String&gt; myObservable = Observable.from(items).repeatWhen(new Func1&lt;Observable&lt;? extends Void&gt;, Observable&lt;?&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;?&gt; call(Observable&lt;? extends Void&gt; observable) &#123;</div><div class="line">               return observable.delay(5, TimeUnit.SECONDS);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line"></div><div class="line">       Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               System.out.println(&quot;onNext..................&quot;+s);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               System.out.println(&quot;onError....................&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p>doWhile 属于可选包rxjava-computation-expressions，不是RxJava标准操作符的一部分。doWhile在原始序列的每次重复后检查某个条件，如果满足条件才重复发射。
whileDo 属于可选包rxjava-computation-expressions，不是RxJava标准操作符的一部分。whileDo在原始序列的每次重复前检查某个条件，如果满足条件才重复发射。</p>
<h5 id="创建方式二-defer、range、interval、timer、Empty、Never、Throw"><a href="#创建方式二-defer、range、interval、timer、Empty、Never、Throw" class="headerlink" title="创建方式二:defer、range、interval、timer、Empty、Never、Throw"></a>创建方式二:defer、range、interval、timer、Empty、Never、Throw</h5><h6 id="1-defer"><a href="#1-defer" class="headerlink" title="1.defer"></a>1.defer</h6><p>Defer操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">String[]items = &#123;&quot;just1&quot;,&quot;just2&quot;,&quot;just3&quot;,&quot;just4&quot;,&quot;just5&quot;,&quot;just6&quot;&#125;;</div><div class="line"> </div><div class="line">    Observable&lt;String&gt; myObservable = Observable.from(items);</div><div class="line"> </div><div class="line">    Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void onNext(String s) &#123;</div><div class="line">            System.out.println(&quot;onNext.................&quot;+s);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        @Override</div><div class="line">        public void onCompleted() &#123;</div><div class="line">            System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        @Override</div><div class="line">        public void onError(Throwable e) &#123;</div><div class="line">            System.out.println(&quot;onError....................&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    Subscriber&lt;String&gt; mySubscriber1 = new Subscriber&lt;String&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void onNext(String s) &#123;</div><div class="line">            System.out.println(&quot;onNext.................&quot;+s);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        @Override</div><div class="line">        public void onCompleted() &#123;</div><div class="line">            System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        @Override</div><div class="line">        public void onError(Throwable e) &#123;</div><div class="line">            System.out.println(&quot;onError....................&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    myObservable.subscribe(mySubscriber);</div><div class="line">    myObservable.subscribe(mySubscriber1);</div></pre></td></tr></table></figure></p>
<p><img src="http://images.wodekouwei.com/technology/rxjava1.png" alt="image">
尽管打印的结果一样，但是它们不是取自同一个Observable的数据</p>
<h6 id="2-Range"><a href="#2-Range" class="headerlink" title="2.Range"></a>2.Range</h6><p>创建一个发射特定整数序列的Observable,接收两个参数，第一个参数是范围的起始值，第二个参数是范围的数据数目，即需要多产生多少个这样的值。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。range默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">String[]items = &#123;&quot;just1&quot;,&quot;just2&quot;,&quot;just3&quot;,&quot;just4&quot;,&quot;just5&quot;,&quot;just6&quot;&#125;;</div><div class="line"> </div><div class="line">        Observable&lt;Integer&gt; myObservable = Observable.range(5,10);</div><div class="line"> </div><div class="line"> </div><div class="line">        Subscriber&lt;Integer&gt; mySubscriber = new Subscriber&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onNext(Integer s) &#123;</div><div class="line">                System.out.println(&quot;onNext.................&quot;+s);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                System.out.println(&quot;onError....................&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p><img src="http://images.wodekouwei.com/technology/rxjava2.png" alt="image"></p>
<h6 id="3-Interval"><a href="#3-Interval" class="headerlink" title="3.Interval"></a>3.Interval</h6><p>Interval操作符返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。RxJava将这个操作符实现为interval方法。它接受一个表示时间间隔的参数和一个表示时间单位的参数。结果递增且不断增加
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Long&gt; myObservable = Observable.interval(2,TimeUnit.SECONDS);</div><div class="line">        Subscriber&lt;Long&gt; mySubscriber = new Subscriber&lt;Long&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onNext(Long s) &#123;</div><div class="line">                System.out.println(&quot;onNext.................&quot;+s);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                System.out.println(&quot;onError....................&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p><img src="http://images.wodekouwei.com/technology/rxjava3.png" alt="image"></p>
<h6 id="4-Timer"><a href="#4-Timer" class="headerlink" title="4.Timer"></a>4.Timer</h6><p>创建一个Observable，它在一个给定的延迟后发射一个特殊的值,延迟2s后发送数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Long&gt; myObservable = Observable</div><div class="line">                .timer(2,TimeUnit.SECONDS);</div><div class="line">        Subscriber&lt;Long&gt; mySubscriber = new Subscriber&lt;Long&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onNext(Long s) &#123;</div><div class="line">                System.out.println(&quot;onNext.................&quot;+s);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                System.out.println(&quot;onCompleted.................&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                System.out.println(&quot;onError....................&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure></p>
<p>结果:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">onNext.................0</div><div class="line">onCompleted.................</div></pre></td></tr></table></figure></p>
<h6 id="5-Empty"><a href="#5-Empty" class="headerlink" title="5.Empty"></a>5.Empty</h6><p>创建一个不发射任何数据但是正常终止的Observable</p>
<h6 id="6-Never"><a href="#6-Never" class="headerlink" title="6.Never"></a>6.Never</h6><p>创建一个不发射数据也不终止的Observable</p>
<h6 id="7-Throw"><a href="#7-Throw" class="headerlink" title="7.Throw"></a>7.Throw</h6><p>创建一个不发射数据以一个错误终止的Observable</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/10/31/tips-gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/31/tips-gc/" itemprop="url">
                  Java GC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-31T18:37:21+08:00">
                2018-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tips/" itemprop="url" rel="index">
                    <span itemprop="name">tips</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要想深入了解Java的GC(Garbage Collection)，我们应该先探寻如下三个问题：</p>
<p>What? – 哪些内存需要回收？
When? – 什么时候回收？
How? – 如何回收？</p>
<h3 id="GC-Definition"><a href="#GC-Definition" class="headerlink" title="GC Definition"></a>GC Definition</h3><p>Definition: Program itself finds and collects memory which is useless. It is a form of automatic memory management which doesn’t need programmers release memory.
Java中为什么会有GC机制呢？</p>
<ul>
<li>安全性考虑；– for security.</li>
<li>减少内存泄露；– erase memory leak in some degree.</li>
<li>减少程序员工作量。– Programmers don’t worry about memory releasing.</li>
</ul>
<h3 id="What-–-哪些内存需要回收？"><a href="#What-–-哪些内存需要回收？" class="headerlink" title="What? – 哪些内存需要回收？"></a>What? – 哪些内存需要回收？</h3><p>我们知道，内存运行时JVM会有一个运行时数据区来管理内存。它主要包括5大部分：程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap).</p>
<p>而其中程序计数器、虚拟机栈、本地方法栈是每个线程私有的内存空间，随线程而生，随线程而亡。例如栈中每一个栈帧中分配多少内存基本上在类结构去诶是哪个下来时就已知了，因此这3个区域的内存分配和回收都是确定的，无需考虑内存回收的问题。</p>
<p>但方法区和堆就不同了，一个接口的多个实现类需要的内存可能不一样，我们只有在程序运行期间才会知道会创建哪些对象，这部分内存的分配和回收都是动态的，GC主要关注的是这部分内存。</p>
<blockquote>
<p>总而言之，GC主要进行回收的内存是JVM中的方法区和堆；涉及到多线程(指堆)、多个对该对象不同类型的引用(指方法区)，才会涉及GC的回收。</p>
</blockquote>
<h3 id="When-–-什么时候回收？"><a href="#When-–-什么时候回收？" class="headerlink" title="When? – 什么时候回收？"></a>When? – 什么时候回收？</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>在面试中经常会碰到这样一个问题（事实上笔者也碰到过）：如何判断一个对象已经死去？</p>
<p>很容易想到的一个答案是：对一个对象添加引用计数器。每当有地方引用它时，计数器值加1；当引用失效时，计数器值减1.而当计数器的值为0时这个对象就不会再被使用，判断为已死。是不是简单又直观。然而，很遗憾。这种做法是错误的！为什么是错的呢？事实上，用引用计数法确实在大部分情况下是一个不错的解决方案，而在实际的应用中也有不少案例，但它却无法解决对象之间的循环引用问题。比如对象A中有一个字段指向了对象B，而对象B中也有一个字段指向了对象A，而事实上他们俩都不再使用，但计数器的值永远都不可能为0，也就不会被回收，然后就发生了内存泄露。。</p>
<p>所以，正确的做法应该是怎样呢？
在Java，C#等语言中，比较主流的判定一个对象已死的方法是：可达性分析(Reachability Analysis).
所有生成的对象都是一个称为”GC Roots”的根的子树。从GC Roots开始向下搜索，搜索所经过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链可以到达时，就称这个对象是不可达的（不可引用的），也就是可以被GC回收了。如下图所示：
<img src="http://images.wodekouwei.com/technology/gc1.png" alt="image"></p>
<p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<p>无论是引用计数器还是可达性分析，判定对象是否存活都与引用有关！那么，如何定义对象的引用呢？</p>
<p>我们希望给出这样一类描述：当内存空间还够时，能够保存在内存中；如果进行了垃圾回收之后内存空间仍旧非常紧张，则可以抛弃这些对象。所以根据不同的需求，给出如下四种引用，根据引用类型的不同，GC回收时也会有不同的操作：</p>
<ul>
<li>强引用(Strong Reference):Object obj = new Object();只要强引用还存在，GC永远不会回收掉被引用的对象。</li>
<li>软引用(Soft Reference)：描述一些还有用但非必需的对象。在系统将会发生内存溢出之前，会把这些对象列入回收范围进行二次回收（即系统将会发生内存溢出了，才会对他们进行回收。）</li>
<li>弱引用(Weak Reference):程度比软引用还要弱一些。这些对象只能生存到下次GC之前。当GC工作时，无论内存是否足够都会将其回收（即只要进行GC，就会对他们进行回收。）</li>
<li>虚引用(Phantom Reference):一个对象是否存在虚引用，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的 唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>What部分我们已经提到，GC主要回收的是堆和方法区中的内存，而上面的How主要是针对对象的回收，他们一般位于堆内。那么，方法区中的东西该怎么回收呢？</p>
<p>关于方法区中需要回收的是一些废弃的常量和无用的类。</p>
<ol>
<li>废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。</li>
<li>无用的类的回收。什么是无用的类呢？<ul>
<li>该类所有的实例都已经被回收。也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>总而言之，对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而根据我们实际对引用的不同需求，又分成了4中引用，每种引用的回收机制也是不同的。对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。</p>
</blockquote>
<h3 id="How-–-如何回收？"><a href="#How-–-如何回收？" class="headerlink" title="How? – 如何回收？"></a>How? – 如何回收？</h3><h4 id="标记-清除-Mark-Sweep-算法"><a href="#标记-清除-Mark-Sweep-算法" class="headerlink" title="标记-清除(Mark-Sweep)算法"></a>标记-清除(Mark-Sweep)算法</h4><p>分为两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
缺点：效率问题，标记和清除两个过程的效率都不高；空间问题，会产生很多碎片。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存按容量划分为大小相等的两块，每次只用其中一块。当这一块用完了，就将还存活的对象复制到另外一块上面，然后把原始空间全部回收。高效、简单。
缺点：将内存缩小为原来的一半。</p>
<h4 id="标记-整理-Mark-Compat-算法"><a href="#标记-整理-Mark-Compat-算法" class="headerlink" title="标记-整理(Mark-Compat)算法"></a>标记-整理(Mark-Compat)算法</h4><p>标记过程与标记-清除算法过程一样，但后面不是简单的清除，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p>
<h4 id="分代收集-Generational-Collection-算法"><a href="#分代收集-Generational-Collection-算法" class="headerlink" title="分代收集(Generational Collection)算法"></a>分代收集(Generational Collection)算法</h4><p>新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；
老年代中，其存活率较高、没有额外空间对它进行分配担保，就应该使用“标记-整理”或“标记-清理”算法进行回收。</p>
<h3 id="一些收集器"><a href="#一些收集器" class="headerlink" title="一些收集器"></a>一些收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程收集器，表示在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。”Stop The World”.</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>实际就是Serial收集器的多线程版本。</p>
<ul>
<li>并发(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</li>
<li>并行(Concurrent):指用户线程与垃圾收集线程同时执行，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
<p>####Parallel Scavenge收集器
该收集器比较关注吞吐量(Throughout)(CPU用于用户代码的时间与CPU总消耗时间的比值)，保证吞吐量在一个可控的范围内。</p>
<h4 id="CMS-Concurrent-Mark-Sweep-收集器"><a href="#CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="CMS(Concurrent Mark Sweep)收集器"></a>CMS(Concurrent Mark Sweep)收集器</h4><p>CMS收集器是一种以获得最短停顿时间为目标的收集器。</p>
<h4 id="G1-Garbage-First-收集器"><a href="#G1-Garbage-First-收集器" class="headerlink" title="G1(Garbage First)收集器"></a>G1(Garbage First)收集器</h4><p>从JDK1.7 Update 14之后的HotSpot虚拟机正式提供了商用的G1收集器，与其他收集器相比，它具有如下优点：并行与并发；分代收集；空间整合；可预测的停顿等。</p>
<blockquote>
<p>本部分主要分析了三种不同的垃圾回收算法：Mark-Sweep, Copy, Mark-Compact. 每种算法都有不同的优缺点，也有不同的适用范围。而JVM中对垃圾回收器并没有严格的要求，不同的收集器会结合多个算法进行垃圾回收</p>
</blockquote>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决2个问题：给对象分配内存以及回收分配给对象的内存。</p>
<h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的内存时，虚拟机将发起一次Minor GC。</p>
<ul>
<li>Minor GC(新生代GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC发生的非常频繁。</li>
<li>Full GC/Major GC(老年代GC):指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。</li>
</ul>
<h4 id="大对象直接进老年代"><a href="#大对象直接进老年代" class="headerlink" title="大对象直接进老年代"></a>大对象直接进老年代</h4><p>大对象是指需要大量连续内存空间的Java对象（例如很长的字符串以及数组）。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>JVM为每个对象定义一个对象年龄计数器。</p>
<ul>
<li>如果对象在Eden出生并经历过第一次Minor GC后仍然存活，并且能够被Survivor容纳，则应该被移动到Survivor空间中，并且年龄对象设置为1；</li>
<li>对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度(默认为15岁，可通过参数-XX:MaxTenuringThreshold设置)，就会被晋升到老年代中。</li>
<li>要注意的是：JVM并不是永远的要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</li>
</ul>
<h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p>= 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，则进行Minor GC是安全的；</p>
<ul>
<li>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，则急促检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管它是有风险的；</li>
<li>如果小于或者HandePromotionFailure设置为不允许冒险，则这时要改为进行一次Full GC.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/10/31/tips-innerclass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/31/tips-innerclass/" itemprop="url">
                  Java内部类详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-31T18:32:17+08:00">
                2018-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tips/" itemprop="url" rel="index">
                    <span itemprop="name">tips</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-内部类基础"><a href="#1-内部类基础" class="headerlink" title="1.内部类基础"></a>1.内部类基础</h3><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>
<h4 id="1-1-成员内部类"><a href="#1-1-成员内部类" class="headerlink" title="1.1.成员内部类"></a>1.1.成员内部类</h4><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Circle &#123;</div><div class="line">    double radius = 0;</div><div class="line">     </div><div class="line">    public Circle(double radius) &#123;</div><div class="line">        this.radius = radius;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    class Draw &#123;     //内部类</div><div class="line">        public void drawSahpe() &#123;</div><div class="line">            System.out.println(&quot;drawshape&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Circle &#123;</div><div class="line">    private double radius = 0;</div><div class="line">    public static int count =1;</div><div class="line">    public Circle(double radius) &#123;</div><div class="line">        this.radius = radius;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    class Draw &#123;     //内部类</div><div class="line">        public void drawSahpe() &#123;</div><div class="line">            System.out.println(radius);  //外部类的private成员</div><div class="line">            System.out.println(count);   //外部类的静态成员</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">外部类.this.成员变量</div><div class="line">外部类.this.成员方法</div></pre></td></tr></table></figure></p>
<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Circle &#123;</div><div class="line">    private double radius = 0;</div><div class="line"> </div><div class="line">    public Circle(double radius) &#123;</div><div class="line">        this.radius = radius;</div><div class="line">        getDrawInstance().drawSahpe();   //必须先创建成员内部类的对象，再进行访问</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    private Draw getDrawInstance() &#123;</div><div class="line">        return new Draw();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    class Draw &#123;     //内部类</div><div class="line">        public void drawSahpe() &#123;</div><div class="line">            System.out.println(radius);  //外部类的private成员</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">        //第一种方式：</div><div class="line">        Outter outter = new Outter();</div><div class="line">        Outter.Inner inner = outter.new Inner();  //必须通过Outter对象来创建</div><div class="line">         </div><div class="line">        //第二种方式：</div><div class="line">        Outter.Inner inner1 = outter.getInnerInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Outter &#123;</div><div class="line">    private Inner inner = null;</div><div class="line">    public Outter() &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Inner getInnerInstance() &#123;</div><div class="line">        if(inner == null)</div><div class="line">            inner = new Inner();</div><div class="line">        return inner;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    class Inner &#123;</div><div class="line">        public Inner() &#123;</div><div class="line">             </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="1-2-局部内部类"><a href="#1-2-局部内部类" class="headerlink" title="1.2.局部内部类"></a>1.2.局部内部类</h4><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">    public People() &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Man&#123;</div><div class="line">    public Man()&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public People getWoman()&#123;</div><div class="line">        class Woman extends People&#123;   //局部内部类</div><div class="line">            int age =0;</div><div class="line">        &#125;</div><div class="line">        return new Woman();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<h4 id="1-3-匿名内部类"><a href="#1-3-匿名内部类" class="headerlink" title="1.3.匿名内部类"></a>1.3.匿名内部类</h4><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">scan_bt.setOnClickListener(new OnClickListener() &#123;</div><div class="line">             </div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                // TODO Auto-generated method stub</div><div class="line">                 </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">         </div><div class="line">        history_bt.setOnClickListener(new OnClickListener() &#123;</div><div class="line">             </div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                // TODO Auto-generated method stub</div><div class="line">                 </div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new OnClickListener() &#123;</div><div class="line">             </div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                // TODO Auto-generated method stub</div><div class="line">                 </div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void setListener()</div><div class="line">&#123;</div><div class="line">    scan_bt.setOnClickListener(new Listener1());       </div><div class="line">    history_bt.setOnClickListener(new Listener2());</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Listener1 implements View.OnClickListener&#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">    // TODO Auto-generated method stub</div><div class="line">             </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Listener2 implements View.OnClickListener&#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">    // TODO Auto-generated method stub</div><div class="line">             </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<h4 id="1-4-静态内部类"><a href="#1-4-静态内部类" class="headerlink" title="1.4.静态内部类"></a>1.4.静态内部类</h4><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">        Outter.Inner inner = new Outter.Inner();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Outter &#123;</div><div class="line">    public Outter() &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    static class Inner &#123;</div><div class="line">        public Inner() &#123;</div><div class="line">             </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-深入理解内部类"><a href="#2-深入理解内部类" class="headerlink" title="2.深入理解内部类"></a>2.深入理解内部类</h3><h4 id="2-1-为什么成员内部类可以无条件访问外部类的成员？"><a href="#2-1-为什么成员内部类可以无条件访问外部类的成员？" class="headerlink" title="2.1.为什么成员内部类可以无条件访问外部类的成员？"></a>2.1.为什么成员内部类可以无条件访问外部类的成员？</h4><p>在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Outter &#123;</div><div class="line">    private Inner inner = null;</div><div class="line">    public Outter() &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Inner getInnerInstance() &#123;</div><div class="line">        if(inner == null)</div><div class="line">            inner = new Inner();</div><div class="line">        return inner;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    protected class Inner &#123;</div><div class="line">        public Inner() &#123;</div><div class="line">             </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译之后，出现了两个字节码文件：</p>
<ul>
<li>Outter$Inner.class</li>
<li>Outter.class
反编译Outter$Inner.class文件得到下面信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">E:\Workspace\Test\bin\com\cxh\test2&gt;javap -v Outter$Inner</div><div class="line">Compiled from &quot;Outter.java&quot;</div><div class="line">public class com.cxh.test2.Outter$Inner extends java.lang.Object</div><div class="line">  SourceFile: &quot;Outter.java&quot;</div><div class="line">  InnerClass:</div><div class="line">   #24= #1 of #22; //Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes</div><div class="line">t2/Outter</div><div class="line">  minor version: 0</div><div class="line">  major version: 50</div><div class="line">  Constant pool:</div><div class="line">const #1 = class        #2;     //  com/cxh/test2/Outter$Inner</div><div class="line">const #2 = Asciz        com/cxh/test2/Outter$Inner;</div><div class="line">const #3 = class        #4;     //  java/lang/Object</div><div class="line">const #4 = Asciz        java/lang/Object;</div><div class="line">const #5 = Asciz        this$0;</div><div class="line">const #6 = Asciz        Lcom/cxh/test2/Outter;;</div><div class="line">const #7 = Asciz        &lt;init&gt;;</div><div class="line">const #8 = Asciz        (Lcom/cxh/test2/Outter;)V;</div><div class="line">const #9 = Asciz        Code;</div><div class="line">const #10 = Field       #1.#11; //  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t</div><div class="line">est2/Outter;</div><div class="line">const #11 = NameAndType #5:#6;//  this$0:Lcom/cxh/test2/Outter;</div><div class="line">const #12 = Method      #3.#13; //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">const #13 = NameAndType #7:#14;//  &quot;&lt;init&gt;&quot;:()V</div><div class="line">const #14 = Asciz       ()V;</div><div class="line">const #15 = Asciz       LineNumberTable;</div><div class="line">const #16 = Asciz       LocalVariableTable;</div><div class="line">const #17 = Asciz       this;</div><div class="line">const #18 = Asciz       Lcom/cxh/test2/Outter$Inner;;</div><div class="line">const #19 = Asciz       SourceFile;</div><div class="line">const #20 = Asciz       Outter.java;</div><div class="line">const #21 = Asciz       InnerClasses;</div><div class="line">const #22 = class       #23;    //  com/cxh/test2/Outter</div><div class="line">const #23 = Asciz       com/cxh/test2/Outter;</div><div class="line">const #24 = Asciz       Inner;</div><div class="line"> </div><div class="line">&#123;</div><div class="line">final com.cxh.test2.Outter this$0;</div><div class="line"> </div><div class="line">public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</div><div class="line">  Code:</div><div class="line">   Stack=2, Locals=2, Args_size=2</div><div class="line">   0:   aload_0</div><div class="line">   1:   aload_1</div><div class="line">   2:   putfield        #10; //Field this$0:Lcom/cxh/test2/Outter;</div><div class="line">   5:   aload_0</div><div class="line">   6:   invokespecial   #12; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">   9:   return</div><div class="line">  LineNumberTable:</div><div class="line">   line 16: 0</div><div class="line">   line 18: 9</div><div class="line"> </div><div class="line">  LocalVariableTable:</div><div class="line">   Start  Length  Slot  Name   Signature</div><div class="line">   0      10      0    this       Lcom/cxh/test2/Outter$Inner;</div><div class="line"> </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第11行到35行是常量池的内容，下面逐一第38行的内容：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final com.cxh.test2.Outter this$0;</div></pre></td></tr></table></figure></p>
<p>这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</div></pre></td></tr></table></figure></p>
<p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
<h4 id="2-2-为什么局部内部类和匿名内部类只能访问局部final变量？"><a href="#2-2-为什么局部内部类和匿名内部类只能访问局部final变量？" class="headerlink" title="2.2.为什么局部内部类和匿名内部类只能访问局部final变量？"></a>2.2.为什么局部内部类和匿名内部类只能访问局部final变量？</h4><p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void test(final int b) &#123;</div><div class="line">        final int a = 10;</div><div class="line">        new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(a);</div><div class="line">                System.out.println(b);</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码会被编译成两个class文件：Test.class和Test1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）。test方法中的匿名内部类的名字被起为 Test$1。上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题：当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 复制  的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：
<img src="http://images.wodekouwei.com/technology/innerclass1.jpg" alt="image">
我们看到在run方法中有一条指令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bipush 10</div></pre></td></tr></table></figure></p>
<p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p>
<p>下面再看一个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void test(final int a) &#123;</div><div class="line">        new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(a);</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反编译得到
<img src="http://images.wodekouwei.com/technology/innerclass2.jpg" alt="image"></p>
<p>我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。</p>
<p>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p>
<p>从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？</p>
<p>对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>
<p>到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用final进行限定了。</p>
<h4 id="2-3-静态内部类有特殊的地方吗？"><a href="#2-3-静态内部类有特殊的地方吗？" class="headerlink" title="2.3.静态内部类有特殊的地方吗？"></a>2.3.静态内部类有特殊的地方吗？</h4><p>从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个可以尝试反编译class文件看一下就知道了，是没有Outter this&amp;0引用的。</p>
<h3 id="3-内部类的使用场景和好处"><a href="#3-内部类的使用场景和好处" class="headerlink" title="3.内部类的使用场景和好处"></a>3.内部类的使用场景和好处</h3><p>为什么在Java中需要内部类？总结一下主要有以下四点：</p>
<ol>
<li>每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，</li>
<li>方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</li>
<li>方便编写事件驱动程序</li>
<li>方便编写线程代码</li>
</ol>
<p>个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>
<h3 id="4-常见的与内部类相关的笔试面试题"><a href="#4-常见的与内部类相关的笔试面试题" class="headerlink" title="4.常见的与内部类相关的笔试面试题"></a>4.常见的与内部类相关的笔试面试题</h3><h4 id="4-1-根据注释填写-1-，-2-，-3-处的代码"><a href="#4-1-根据注释填写-1-，-2-，-3-处的代码" class="headerlink" title="4.1.根据注释填写(1)，(2)，(3)处的代码"></a>4.1.根据注释填写(1)，(2)，(3)处的代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">           // 初始化Bean1</div><div class="line">           (1)</div><div class="line">           bean1.I++;</div><div class="line">           // 初始化Bean2</div><div class="line">           (2)</div><div class="line">           bean2.J++;</div><div class="line">           //初始化Bean3</div><div class="line">           (3)</div><div class="line">           bean3.k++;</div><div class="line">    &#125;</div><div class="line">    class Bean1&#123;</div><div class="line">           public int I = 0;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    static class Bean2&#123;</div><div class="line">           public int J = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Bean&#123;</div><div class="line">    class Bean3&#123;</div><div class="line">           public int k = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>
<p>创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()
创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()
因此，（1），（2），（3）处的代码分别为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Test test = new Test();    </div><div class="line">Test.Bean1 bean1 = test.new Bean1();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Test.Bean2 b2 = new Test.Bean2();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bean bean = new Bean();     </div><div class="line">Bean.Bean3 bean3 =  bean.new Bean3();</div></pre></td></tr></table></figure>
<h4 id="4-2-下面这段代码的输出结果是什么？"><a href="#4-2-下面这段代码的输出结果是什么？" class="headerlink" title="4.2.下面这段代码的输出结果是什么？"></a>4.2.下面这段代码的输出结果是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">        Outter outter = new Outter();</div><div class="line">        outter.new Inner().print();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">class Outter</div><div class="line">&#123;</div><div class="line">    private int a = 1;</div><div class="line">    class Inner &#123;</div><div class="line">        private int a = 2;</div><div class="line">        public void print() &#123;</div><div class="line">            int a = 3;</div><div class="line">            System.out.println(&quot;局部变量：&quot; + a);</div><div class="line">            System.out.println(&quot;内部类变量：&quot; + this.a);</div><div class="line">            System.out.println(&quot;外部类变量：&quot; + Outter.this.a);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">3</div><div class="line">2</div><div class="line">1</div></pre></td></tr></table></figure>
<p>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>
<ol>
<li>成员内部类的引用方式必须为 Outter.Inner.</li>
<li>构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class WithInner &#123;</div><div class="line">    class Inner&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class InheritInner extends WithInner.Inner &#123;</div><div class="line">      </div><div class="line">    // InheritInner() 是不能通过编译的，一定要加上形参</div><div class="line">    InheritInner(WithInner wi) &#123;</div><div class="line">        wi.super(); //必须有这句调用</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        WithInner wi = new WithInner();</div><div class="line">        InheritInner obj = new InheritInner(wi);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/10/25/tips-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/25/tips-thread/" itemprop="url">
                  多线程只是总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T15:08:43+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><h4 id="线程5种状态"><a href="#线程5种状态" class="headerlink" title="线程5种状态"></a>线程5种状态</h4><p><img src="http://images.wodekouwei.com/technology/thread-lifecycle.jpeg" alt="image"></p>
<ol>
<li>新建状态(New)：
当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</li>
<li>就绪状态(Runnable)
一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。
处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。</li>
<li>运行状态(Running)
当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.</li>
<li>阻塞状态(Blocked)
线程运行过程中，可能由于各种原因进入阻塞状态:
1&gt;线程通过调用sleep方法进入睡眠状态；
2&gt;线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
3&gt;线程试图得到一个锁，而该锁正被其他线程持有；
4&gt;线程在等待某个触发条件；<br>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</li>
<li>死亡状态(Dead)
有两个原因会导致线程死亡：
1) run方法正常退出而自然死亡，
2) 一个未捕获的异常终止了run方法而使线程猝死。
为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.</li>
</ol>
<h4 id="线程同步的7种方式"><a href="#线程同步的7种方式" class="headerlink" title="线程同步的7种方式"></a>线程同步的7种方式</h4><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， 将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<h5 id="方式1-同步方法"><a href="#方式1-同步方法" class="headerlink" title="方式1:同步方法"></a>方式1:同步方法</h5><p>即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
代码如： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public synchronized void save()&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</p>
<h5 id="方式2-同步代码块"><a href="#方式2-同步代码块" class="headerlink" title="方式2:同步代码块"></a>方式2:同步代码块</h5><p>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
代码如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">synchronized(object)&#123; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 </p>
<h5 id="方式3-使用特殊域变量-volatile-实现线程同步"><a href="#方式3-使用特殊域变量-volatile-实现线程同步" class="headerlink" title="方式3:使用特殊域变量(volatile)实现线程同步"></a>方式3:使用特殊域变量(volatile)实现线程同步</h5><ol>
<li>volatile关键字为域变量的访问提供了一种免锁机制， </li>
<li>使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， </li>
<li>因此每次使用该域就要重新计算，而不是使用寄存器中的值 </li>
<li>volatile不会提供任何原子操作，它也不能用来修饰final类型的变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Bank &#123;</div><div class="line">    //需要同步的变量加上volatile</div><div class="line">    private volatile int account = 100;</div><div class="line"></div><div class="line">    public int getAccount() &#123;</div><div class="line">        return account;</div><div class="line">    &#125;</div><div class="line">    //这里不再需要synchronized </div><div class="line">    public void save(int money) &#123;</div><div class="line">        account += money;</div><div class="line">    &#125;</div><div class="line">｝</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。 </p>
<h5 id="方式4-使用重入锁实现线程同步"><a href="#方式4-使用重入锁实现线程同步" class="headerlink" title="方式4:使用重入锁实现线程同步"></a>方式4:使用重入锁实现线程同步</h5><p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 
ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力
ReenreantLock类的常用方法有：</p>
<ol>
<li>ReentrantLock() : 创建一个ReentrantLock实例 </li>
<li>lock() : 获得锁 </li>
<li>unlock() : 释放锁 </li>
</ol>
<p>注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Bank &#123;</div><div class="line">    </div><div class="line">    private int account = 100;</div><div class="line">    //需要声明这个锁</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">    public int getAccount() &#123;</div><div class="line">        return account;</div><div class="line">    &#125;</div><div class="line">    //这里不再需要synchronized </div><div class="line">    public void save(int money) &#123;</div><div class="line">        lock.lock();</div><div class="line">        try&#123;</div><div class="line">            account += money;</div><div class="line">        &#125;finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">｝</div></pre></td></tr></table></figure></p>
<p>注：关于Lock对象和synchronized关键字的选择： </p>
<ol>
<li>最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。 </li>
<li>如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 </li>
<li>如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 </li>
</ol>
<h5 id="方式5-使用局部变量实现线程同步"><a href="#方式5-使用局部变量实现线程同步" class="headerlink" title="方式5:使用局部变量实现线程同步"></a>方式5:使用局部变量实现线程同步</h5><p>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p> ThreadLocal 类的常用方法</p>
<ul>
<li>ThreadLocal() : 创建一个线程本地变量 </li>
<li>get() : 返回此线程局部变量的当前线程副本中的值 </li>
<li>initialValue() : 返回此线程局部变量的当前线程的”初始值” </li>
<li>set(T value) : 将此线程局部变量的当前线程副本中的值设置为value</li>
</ul>
<p>首先定义一个ThreadLocal对象，这里选择Boolean类型的，如下所示：</p>
<p>private ThreadLocal<boolean>mBooleanThreadLocal = new ThreadLocal<boolean>();</boolean></boolean></p>
<p>然后分别在主线程、子线程1和子线程2中设置和访问它的值，代码如下所示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mBooleanThreadLocal.set(true);</div><div class="line">Log.d(TAG, &quot;[Thread#main]mBooleanThreadLocal=&quot; + mBooleanThreadLocal.get());</div><div class="line"> </div><div class="line">new Thread(&quot;Thread#1&quot;) &#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		mBooleanThreadLocal.set(false);</div><div class="line">		Log.d(TAG, &quot;[Thread#1]mBooleanThreadLocal=&quot; + mBooleanThreadLocal.get());</div><div class="line">	&#125;;</div><div class="line">&#125;.start();</div><div class="line"> </div><div class="line">new Thread(&quot;Thread#2&quot;) &#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		Log.d(TAG, &quot;[Thread#2]mBooleanThreadLocal=&quot; + mBooleanThreadLocal.get());</div><div class="line">	&#125;;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure></p>
<p>上面的代码中，在主线程中设置mBooleanThreadLocal的值为true，在子线程1中设置mBooleanThreadLocal的值为false，在子线程2中不设置mBooleanThreadLocal的值，然后分别在3个线程中通过get方法去mBooleanThreadLocal的值，根据前面对ThreadLocal的描述，这个时候，主线程中应该是true，子线程1中应该是false，而子线程2中由于没有设置值，所以应该是null，安装并运行程序，日志如下所示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">D/TestActivity(8676):[Thread#main]mBooleanThreadLocal=true</div><div class="line"></div><div class="line">D/TestActivity(8676):[Thread#1]mBooleanThreadLocal=false</div><div class="line"></div><div class="line">D/TestActivity(8676):[Thread#2]mBooleanThreadLocal=null</div></pre></td></tr></table></figure></p>
<p>注：ThreadLocal与同步机制 </p>
<ol>
<li>ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 </li>
<li>前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式</li>
</ol>
<h5 id="方式6-使用阻塞队列实现线程同步"><a href="#方式6-使用阻塞队列实现线程同步" class="headerlink" title="方式6:使用阻塞队列实现线程同步"></a>方式6:使用阻塞队列实现线程同步</h5><p>前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 这里主要是使用LinkedBlockingQueue<e>来实现线程的同步.
LinkedBlockingQueue<e>是一个基于已连接节点的，范围任意的blocking queue。 队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~ 
LinkedBlockingQueue 类常用方法 </e></e></p>
<ul>
<li>LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue </li>
<li>put(E e) : 在队尾添加一个元素，如果队列满则阻塞 </li>
<li>size() : 返回队列中的元素个数 </li>
<li>take() : 移除并返回队头元素，如果队列空则阻塞 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">package com.xhj.thread;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.LinkedBlockingQueue;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用</div><div class="line"> * </div><div class="line"> * @author XIEHEJUN</div><div class="line"> * </div><div class="line"> */</div><div class="line">public class BlockingSynchronizedThread &#123;</div><div class="line">    /**</div><div class="line">     * 定义一个阻塞队列用来存储生产出来的商品</div><div class="line">     */</div><div class="line">    private LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;Integer&gt;();</div><div class="line">    /**</div><div class="line">     * 定义生产商品个数</div><div class="line">     */</div><div class="line">    private static final int size = 10;</div><div class="line">    /**</div><div class="line">     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程</div><div class="line">     */</div><div class="line">    private int flag = 0;</div><div class="line"></div><div class="line">    private class LinkBlockThread implements Runnable &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            int new_flag = flag++;</div><div class="line">            System.out.println(&quot;启动线程 &quot; + new_flag);</div><div class="line">            if (new_flag == 0) &#123;</div><div class="line">                for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">                    int b = new Random().nextInt(255);</div><div class="line">                    System.out.println(&quot;生产商品：&quot; + b + &quot;号&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        queue.put(b);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        // TODO Auto-generated catch block</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(100);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        // TODO Auto-generated catch block</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                for (int i = 0; i &lt; size / 2; i++) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        int n = queue.take();</div><div class="line">                        System.out.println(&quot;消费者买去了&quot; + n + &quot;号商品&quot;);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        // TODO Auto-generated catch block</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(100);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        // TODO: handle exception</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BlockingSynchronizedThread bst = new BlockingSynchronizedThread();</div><div class="line">        LinkBlockThread lbt = bst.new LinkBlockThread();</div><div class="line">        Thread thread1 = new Thread(lbt);</div><div class="line">        Thread thread2 = new Thread(lbt);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：BlockingQueue<e>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：</e></p>
<ul>
<li>add()方法会抛出异常</li>
<li>offer()方法返回false</li>
<li>put()方法会阻塞</li>
</ul>
<h5 id="方式7-使用原子变量实现线程同步"><a href="#方式7-使用原子变量实现线程同步" class="headerlink" title="方式7:使用原子变量实现线程同步"></a>方式7:使用原子变量实现线程同步</h5><p>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<p>那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作,即-这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。</p>
<p>其中AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，
但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。</p>
<p>AtomicInteger类常用方法：</p>
<ul>
<li>AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger</li>
<li>addAddGet(int dalta) : 以原子方式将给定值与当前值相加</li>
<li>get() : 获取当前值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Bank &#123;</div><div class="line">        private AtomicInteger account = new AtomicInteger(100);</div><div class="line"></div><div class="line">        public AtomicInteger getAccount() &#123;</div><div class="line">            return account;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void save(int money) &#123;</div><div class="line">            account.addAndGet(money);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>补充–原子操作主要有：
对于引用变量和大多数原始变量(long和double除外)的读写操作；
对于所有使用volatile修饰的变量(包括long和double)的读写操作。</p>
<h4 id="线程局部存储ThreadLocal"><a href="#线程局部存储ThreadLocal" class="headerlink" title="线程局部存储ThreadLocal"></a>线程局部存储ThreadLocal</h4><h4 id="分析Java线程中断机制stop和interrupted的用法"><a href="#分析Java线程中断机制stop和interrupted的用法" class="headerlink" title="分析Java线程中断机制stop和interrupted的用法"></a>分析Java线程中断机制stop和interrupted的用法</h4><p>当我们点击某个杀毒软件的取消按钮来停止查杀病毒时，当我们在控制台敲入quit命令以结束某个后台服务时……都需要通过一个线程去取消另一个线程正在执行的任务。Java没有提供一种安全直接的方法来停止某个线程，但是Java提供了中断机制。如果对Java中断没有一个全面的了解，可能会误以为被中断的线程将立马退出运行，但事实并非如此。中断机制是如何工作的？捕获或检测到中断后，是抛出InterruptedException还是重设中断状态以及在方法中吞掉中断状态会有什么后果？Thread.stop与中断相比又有哪些异同？什么情况下需要使用中断？中断的原理Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。这好比是家里的父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。Java中断模型也是这么简单，每个线程对象里都有一个boolean类型的标识（不一定就要是Thread类的字段，实际上也的确不是，这几个方法最终都是通过native方法来完成的），代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。例如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。java.lang.Thread类提供了几个方法来操作这个中断状态，这些方法包括：</p>
<ul>
<li>public static boolean interrupted测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</li>
<li>public boolean isInterrupted()测试线程是否已经中断。线程的中断状态不受该方法的影响。</li>
<li>public void interrupt()中断线程。其中，interrupt方法是唯一能将中断状态设置为true的方法。静态方法interrupted会将当前线程的中断状态清除，但这个方法的命名极不直观，很容易造成误解，需要特别注意。</li>
</ul>
<p>上面的例子中，线程t1通过调用interrupt方法将线程t2的中断状态置为true，t2可以在合适的时候调用interrupted或isInterrupted来检测状态并做相应的处理。此外，类库中的有些类的方法也可能会调用中断，如FutureTask中的cancel方法，如果传入的参数为true，它将会在正在运行异步任务的线程上调用interrupt方法，如果正在执行的异步任务中的代码没有对中断做出响应，那么cancel方法中的参数将不会起到什么效果；又如ThreadPoolExecutor中的shutdownNow方法会遍历线程池中的工作线程并调用线程的interrupt方法来中断线程，所以如果工作线程中正在执行的任务没有对中断做出响应，任务将一直执行直到正常结束。</p>
<p>既然Java中断机制只是设置被中断线程的中断状态，那么被中断线程该做些什么？显然，作为一种协作机制，不会强求被中断线程一定要在某个点进行处理。实际上，被中断线程只需在合适的时候处理即可，如果没有合适的时间点，甚至可以不处理，这时候在任务处理层面，就跟没有调用中断方法一样。“合适的时候”与线程正在处理的业务逻辑紧密相关，例如，每次迭代的时候，进入一个可能阻塞且无法中断的方法之前等，但多半不会出现在某个临界区更新另一个对象状态的时候，因为这可能会导致对象处于不一致状态。
处理时机决定着程序的效率与中断响应的灵敏性。频繁的检查中断状态可能会使程序执行效率下降，相反，检查的较少可能使中断请求得不到及时响应。如果发出中断请求之后，被中断的线程继续执行一段时间不会给系统带来灾难，那么就可以将中断处理放到方便检查中断，同时又能从一定程度上保证响应灵敏度的地方。当程序的性能指标比较关键时，可能需要建立一个测试模型来分析最佳的中断检测点，以平衡性能和响应灵敏性。</p>
<p>一般说来，当可能阻塞的方法声明中有抛出InterruptedException则暗示该方法是可中断的，如BlockingQueue#put、BlockingQueue#take、Object#wait、Thread#sleep等，如果程序捕获到这些可中断的阻塞方法抛出的InterruptedException或检测到中断后，这些中断信息该如何处理？一般有以下两个通用原则：</p>
<ol>
<li>如果遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常，如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。 若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态。如果是检测并清除了中断状态，亦是如此。 一般的代码中，尤其是作为一个基础类库时，绝不应当吞掉中断，即捕获到InterruptedException后在catch里什么也不做，清除中断状态后又不重设中断状态也不抛出InterruptedException等。因为吞掉中断状态会导致方法调用栈的上层得不到这些信息。当然，凡事总有例外的时候，当你完全清楚自己的方法会被谁调用，而调用者也不会因为中断被吞掉了而遇到麻烦，就可以这么做。总得来说，就是要让方法调用栈的上层获知中断的发生。假设你写了一个类库，类库里有个方法amethod，在amethod中检测并清除了中断状态，而没有抛出InterruptedException，作为amethod的用户来说，他并不知道里面的细节，如果用户在调用amethod后也要使用中断来做些事情，那么在调用amethod之后他将永远也检测不到中断了，因为中断信息已经被amethod清除掉了。如果作为用户，遇到这样有问题的类库，又不能修改代码，那该怎么处理？只好在自己的类里设置一个自己的中断状态，在调用interrupt方法的时候，同时设置该状态，这实在是无路可走时才使用的方法。</li>
<li>中断的响应 程序里发现中断后该怎么响应？这就得视实际情况而定了。有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务……作为一种协作机制，这要与中断方协商好，当调用interrupt会发生些什么都是事先知道的，如做一些事务回滚操作，一些清理工作，一些补偿操作等。若不确定调用某个线程的interrupt后该线程会做出什么样的响应，那就不应当中断该线程。</li>
</ol>
<p>Thread.interrupt VS Thread.stopThread.stop方法已经不推荐使用了。而在某些方面Thread.stop与中断机制有着相似之处。如当线程在等待内置锁或IO时，stop跟interrupt一样，不会中止这些操作；当catch住stop导致的异常时，程序也可以继续执行，虽然stop本意是要停止线程，这么做会让程序行为变得更加混乱。那么它们的区别在哪里？最重要的就是中断需要程序自己去检测然后做相应的处理，而Thread.stop会直接在代码执行过程中抛出ThreadDeath错误，这是一个java.lang.Error的子类。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package com.ticmy.interrupt;  </div><div class="line">import java.util.Arrays;  </div><div class="line">import java.util.Random;  </div><div class="line">import java.util.concurrent.TimeUnit;  </div><div class="line">public class TestStop &#123;  </div><div class="line">    private static final int[] array = new int[80000];  </div><div class="line">    private static final Thread t = new Thread() &#123;  </div><div class="line">        public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                System.out.println(sort(array));  </div><div class="line">            &#125; catch (Error err) &#123;  </div><div class="line">                err.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">            System.out.println(&quot;in thread t&quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;;  </div><div class="line"></div><div class="line">    static &#123;  </div><div class="line">        Random random = new Random();  </div><div class="line">        for(int i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">            array[i] = random.nextInt(i + 1);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private static int sort(int[] array) &#123;  </div><div class="line">        for (int i = 0; i &lt; array.length-1; i++)&#123;  </div><div class="line">            for(int j = 0 ;j &lt; array.length - i - 1; j++)&#123;  </div><div class="line">                if(array[j] &lt; array[j + 1])&#123;  </div><div class="line">                    int temp = array[j];  </div><div class="line">                    array[j] = array[j + 1];  </div><div class="line">                    array[j + 1] = temp;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return array[0];  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        t.start();  </div><div class="line">        TimeUnit.SECONDS.sleep(1);  </div><div class="line">        System.out.println(&quot;go to stop thread t&quot;);  </div><div class="line">        t.stop();  </div><div class="line">        System.out.println(&quot;finish main&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子很简单，线程t里面做了一个非常耗时的排序操作，排序方法中，只有简单的加、减、赋值、比较等操作，一个可能的执行结果如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">go to stop thread t  </div><div class="line">java.lang.ThreadDeath  </div><div class="line">    at java.lang.Thread.stop(Thread.java:758)  </div><div class="line">    at com.ticmy.interrupt.TestStop.main(TestStop.java:44)  </div><div class="line">finish main  </div><div class="line">in thread t</div></pre></td></tr></table></figure></p>
<p>这里sort方法是个非常耗时的操作，也就是说主线程休眠一秒钟后调用stop的时候，线程t还在执行sort方法。就是这样一个简单的方法，也会抛出错误！换一句话说，调用stop后，大部分Java字节码都有可能抛出错误，哪怕是简单的加法！
如果线程当前正持有锁，stop之后则会释放该锁。由于此错误可能出现在很多地方，那么这就让编程人员防不胜防，极易造成对象状态的不一致。例如，对象obj中存放着一个范围值：最小值low，最大值high，且low不得大于high，这种关系由锁lock保护，以避免并发时产生竞态条件而导致该关系失效。假设当前low值是5，high值是10，当线程t获取lock后，将low值更新为了15，此时被stop了，真是糟糕，如果没有捕获住stop导致的Error，low的值就为15，high还是10，这导致它们之间的小于关系得不到保证，也就是对象状态被破坏了！如果在给low赋值的时候catch住stop导致的Error则可能使后面high变量的赋值继续，但是谁也不知道Error会在哪条语句抛出，如果对象状态之间的关系更复杂呢？这种方式几乎是无法维护的，太复杂了！如果是中断操作，它决计不会在执行low赋值的时候抛出错误，这样程序对于对象状态一致性就是可控的。
正是因为可能导致对象状态不一致，stop才被禁用。</p>
<p>中断的使用通常，中断的使用场景有以下几个：</p>
<ul>
<li>点击某个桌面应用中的取消按钮时；</li>
<li>某个操作超过了一定的执行时间限制需要中止时；</li>
<li>多个线程做相同的事情，只要一个线程成功其它线程都可以取消时；</li>
<li>一组线程中的一个或多个出现错误导致整组都无法继续时；</li>
<li>当一个应用或服务需要停止时。</li>
</ul>
<p>下面来看一个具体的例子。这个例子里，本打算采用GUI形式，但考虑到GUI代码会使程序复杂化，就使用控制台来模拟下核心的逻辑。这里新建了一个磁盘文件扫描的任务，扫描某个目录下的所有文件并将文件路径打印到控制台，扫描的过程可能会很长。若需要中止该任务，只需在控制台键入quit并回车即可。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.ticmy.interrupt;  </div><div class="line">import java.io.BufferedReader;  </div><div class="line">import java.io.File;  </div><div class="line">import java.io.InputStreamReader;  </div><div class="line"></div><div class="line">public class FileScanner &#123;  </div><div class="line">    private static void listFile(File f) throws InterruptedException &#123;  </div><div class="line">        if(f == null) &#123;  </div><div class="line">            throw new IllegalArgumentException();  </div><div class="line">        &#125;  </div><div class="line">        if(f.isFile()) &#123;  </div><div class="line">            System.out.println(f);  </div><div class="line">            return;  </div><div class="line">        &#125;  </div><div class="line">        File[] allFiles = f.listFiles();  </div><div class="line">        if(Thread.interrupted()) &#123;  </div><div class="line">            throw new InterruptedException(&quot;文件扫描任务被中断&quot;);  </div><div class="line">        &#125;  </div><div class="line">        for(File file : allFiles) &#123;  </div><div class="line">            //还可以将中断检测放到这里  </div><div class="line">            listFile(file);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static String readFromConsole() &#123;  </div><div class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  </div><div class="line">        try &#123;  </div><div class="line">            return reader.readLine();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">            return &quot;&quot;;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        final Thread fileIteratorThread = new Thread() &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                try &#123;  </div><div class="line">                    listFile(new File(&quot;c:\\&quot;));  </div><div class="line">                &#125; catch (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;;  </div><div class="line">        new Thread() &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                while(true) &#123;  </div><div class="line">                    if(&quot;quit&quot;.equalsIgnoreCase(readFromConsole())) &#123;  </div><div class="line">                        if(fileIteratorThread.isAlive()) &#123;  </div><div class="line">                            fileIteratorThread.interrupt();  </div><div class="line">                            return;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125; else &#123;  </div><div class="line">                        System.out.println(&quot;输入quit退出文件扫描&quot;);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;.start();  </div><div class="line">        fileIteratorThread.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在扫描文件的过程中，对于中断的检测这里采用的策略是，如果碰到的是文件就不检测中断，是目录才检测中断，因为文件可能是非常多的，每次遇到文件都检测一次会降低程序执行效率。此外，在fileIteratorThread线程中，仅是捕获了InterruptedException，没有重设中断状态也没有继续抛出异常，因为我非常清楚它的使用环境，run方法的调用栈上层已经没有可能需要检测中断状态的方法了。
在这个程序中，输入quit完全可以执行System.exit(0)操作来退出程序，但正如前面提到的，这是个GUI程序核心逻辑的模拟，在GUI中，执行System.exit(0)会使得整个程序退出。</p>
<p>线程stop方法源码:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Forces the thread to stop executing.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt;</div><div class="line">     * method is called with &lt;code&gt;this&lt;/code&gt;</div><div class="line">     * as its argument. This may result in a</div><div class="line">     * &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).</div><div class="line">     * &lt;p&gt;</div><div class="line">     * If this thread is different from the current thread (that is, the current</div><div class="line">     * thread is trying to stop a thread other than itself), the</div><div class="line">     * security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method (with a</div><div class="line">     * &lt;code&gt;RuntimePermission(&quot;stopThread&quot;)&lt;/code&gt; argument) is called in</div><div class="line">     * addition.</div><div class="line">     * Again, this may result in throwing a</div><div class="line">     * &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The thread represented by this thread is forced to stop whatever</div><div class="line">     * it is doing abnormally and to throw a newly created</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * It is permitted to stop a thread that has not yet been started.</div><div class="line">     * If the thread is eventually started, it immediately terminates.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * An application should not normally try to catch</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; unless it must do some extraordinary</div><div class="line">     * cleanup operation (note that the throwing of</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; causes &lt;code&gt;finally&lt;/code&gt; clauses of</div><div class="line">     * &lt;code&gt;try&lt;/code&gt; statements to be executed before the thread</div><div class="line">     * officially dies).  If a &lt;code&gt;catch&lt;/code&gt; clause catches a</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; object, it is important to rethrow the</div><div class="line">     * object so that the thread actually dies.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The top-level error handler that reacts to otherwise uncaught</div><div class="line">     * exceptions does not print out a message or otherwise notify the</div><div class="line">     * application if the uncaught exception is an instance of</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @exception  SecurityException  if the current thread cannot</div><div class="line">     *               modify this thread.</div><div class="line">     * @see        #interrupt()</div><div class="line">     * @see        #checkAccess()</div><div class="line">     * @see        #run()</div><div class="line">     * @see        #start()</div><div class="line">     * @see        ThreadDeath</div><div class="line">     * @see        ThreadGroup#uncaughtException(Thread,Throwable)</div><div class="line">     * @see        SecurityManager#checkAccess(Thread)</div><div class="line">     * @see        SecurityManager#checkPermission</div><div class="line">     * @deprecated This method is inherently unsafe.  Stopping a thread with</div><div class="line">     *       Thread.stop causes it to unlock all of the monitors that it</div><div class="line">     *       has locked (as a natural consequence of the unchecked</div><div class="line">     *       &lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up the stack).  If</div><div class="line">     *       any of the objects previously protected by these monitors were in</div><div class="line">     *       an inconsistent state, the damaged objects become visible to</div><div class="line">     *       other threads, potentially resulting in arbitrary behavior.  Many</div><div class="line">     *       uses of &lt;code&gt;stop&lt;/code&gt; should be replaced by code that simply</div><div class="line">     *       modifies some variable to indicate that the target thread should</div><div class="line">     *       stop running.  The target thread should check this variable</div><div class="line">     *       regularly, and return from its run method in an orderly fashion</div><div class="line">     *       if the variable indicates that it is to stop running.  If the</div><div class="line">     *       target thread waits for long periods (on a condition variable,</div><div class="line">     *       for example), the &lt;code&gt;interrupt&lt;/code&gt; method should be used to</div><div class="line">     *       interrupt the wait.</div><div class="line">     *       For more information, see</div><div class="line">     *       &lt;a href=&quot;&#123;@docRoot&#125;/../technotes/guides/concurrency/threadPrimitiveDeprecation.html&quot;&gt;Why</div><div class="line">     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.</div><div class="line">     */</div><div class="line">    @Deprecated</div><div class="line">    public final void stop() &#123;</div><div class="line">        stop(new ThreadDeath());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面注释，第9行到第16行表明，stop()方法可以停止“其他线程”。执行thread.stop()方法这条语句的线程称为当前线程，而“其他线程”则是 调用thread.stop()方法的对象thread所代表的线程。
第21行至23行表明，可以停止一个尚未started(启动)的线程。它的效果是：当该线程启动后，就立马结束了。</p>
<p>第48行以后的注释，则深刻表明了为什么stop()方法被弃用！为什么它是不安全的。比如说，threadA线程拥有了监视器，这些监视器负责保护某些临界资源，比如说银行的转账的金额。当正在转账过程中，main线程调用 threadA.stop()方法。结果导致监视器被释放，其保护的资源（转账金额）很可能出现不一致性。比如，A账户减少了100，而B账户却没有增加100</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/10/23/interview-repository-android/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/23/interview-repository-android/" itemprop="url">
                  面试题库Android
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T17:22:53+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tips/" itemprop="url" rel="index">
                    <span itemprop="name">tips</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-View-的绘制原理"><a href="#1-View-的绘制原理" class="headerlink" title="1. View 的绘制原理"></a>1. View 的绘制原理</h4><pre><code>https://www.cnblogs.com/jycboy/p/6219915.html
https://www.jianshu.com/p/5a71014e7b1b
http://blog.csdn.net/fwt336/article/details/52979876
</code></pre><h4 id="2-Android-进程间通信方式"><a href="#2-Android-进程间通信方式" class="headerlink" title="2. Android 进程间通信方式"></a>2. Android 进程间通信方式</h4><pre><code>http://blog.csdn.net/fiendvip/article/details/50954393
</code></pre><h4 id="3-Android-Binder-机制"><a href="#3-Android-Binder-机制" class="headerlink" title="3. Android Binder 机制"></a>3. Android Binder 机制</h4><pre><code>http://blog.csdn.net/qq_23191031/article/details/60145022
</code></pre><h4 id="4-Activity-加载过程"><a href="#4-Activity-加载过程" class="headerlink" title="4. Activity 加载过程"></a>4. Activity 加载过程</h4><pre><code>http://blog.csdn.net/yyh352091626/article/details/51086117
</code></pre><h4 id="5-Activity-启动模式"><a href="#5-Activity-启动模式" class="headerlink" title="5. Activity 启动模式"></a>5. Activity 启动模式</h4><pre><code>https://mp.weixin.qq.com/s/GAFRItGiKnrAN76erxpnLw
</code></pre><h4 id="6-MVP-和-MVC-和MVVM-有什么区别"><a href="#6-MVP-和-MVC-和MVVM-有什么区别" class="headerlink" title="6. MVP 和 MVC 和MVVM 有什么区别"></a>6. MVP 和 MVC 和MVVM 有什么区别</h4><pre><code>http://blog.csdn.net/greathfs/article/details/52017155
</code></pre><h4 id="7-Android-性能优化"><a href="#7-Android-性能优化" class="headerlink" title="7. Android 性能优化"></a>7. Android 性能优化</h4><pre><code>https://mp.weixin.qq.com/s/ax6O76RF4VpZ66keEgPABw
</code></pre><h4 id="8-Service-概况"><a href="#8-Service-概况" class="headerlink" title="8. Service 概况"></a>8. Service 概况</h4><pre><code>http://blog.csdn.net/lqb3732842/article/details/54892813
</code></pre><h4 id="9-Android-最新官方框架"><a href="#9-Android-最新官方框架" class="headerlink" title="9. Android 最新官方框架"></a>9. Android 最新官方框架</h4><pre><code>https://mp.weixin.qq.com/s/qN3JvC_BBuPIHU4mNc9UqQ
https://mp.weixin.qq.com/s/4wAcKoHFv4iQH84w2sccew
</code></pre><h4 id="10-Android-类加载机制"><a href="#10-Android-类加载机制" class="headerlink" title="10. Android 类加载机制"></a>10. Android 类加载机制</h4><pre><code>https://www.jianshu.com/p/3afa47e9112e
https://www.jianshu.com/p/a620e368389a
</code></pre><h4 id="11-Android-消息处理机制（Looper、Handler、MessageQueue-Message）"><a href="#11-Android-消息处理机制（Looper、Handler、MessageQueue-Message）" class="headerlink" title="11. Android 消息处理机制（Looper、Handler、MessageQueue,Message）"></a>11. Android 消息处理机制（Looper、Handler、MessageQueue,Message）</h4><pre><code>https://www.jianshu.com/p/02962454adf7
http://blog.csdn.net/qian520ao/article/details/78262289?locationNum=2&amp;fps=1#4-handler-是如何能够线程切换
</code></pre><ol>
<li>说下什么是Android消息处理机制？</li>
<li>Android消息处理机制的工作原理</li>
<li>Looper、Handler、MessageQueue,Message作用和存在的意义？</li>
<li>Looper 死循环为什么不会导致应用卡死，会消耗大量资源吗？</li>
<li>主线程的消息循环机制是什么（死循环如何处理其它事务）？</li>
<li>ActivityThread 的动力是什么？（ActivityThread执行Looper的线程是什么）</li>
<li>Handler 是如何能够线程切换，发送Message的？（线程间通讯）</li>
<li>子线程有哪些更新UI的方法。</li>
<li>子线程中Toast，showDialog，的方法。（和子线程不能更新UI有关吗）</li>
<li>如何处理Handler 使用不当导致的内存泄露？</li>
</ol>
<h4 id="12-Android-事件分发机制"><a href="#12-Android-事件分发机制" class="headerlink" title="12. Android 事件分发机制"></a>12. Android 事件分发机制</h4><pre><code>https://www.jianshu.com/p/e99b5e8bd67b
</code></pre><h4 id="13-Retrofit-分析"><a href="#13-Retrofit-分析" class="headerlink" title="13. Retrofit 分析"></a>13. Retrofit 分析</h4><pre><code>https://www.jianshu.com/p/45cb536be2f4
</code></pre><h4 id="14-Android-动画"><a href="#14-Android-动画" class="headerlink" title="14. Android 动画"></a>14. Android 动画</h4><pre><code>https://www.jianshu.com/p/420629118c10
</code></pre><h4 id="15-Rxjava-使用介绍"><a href="#15-Rxjava-使用介绍" class="headerlink" title="15. Rxjava 使用介绍"></a>15. Rxjava 使用介绍</h4><pre><code>https://mp.weixin.qq.com/s/2vDZ7h6SL-LR7n3FR6OMrw
</code></pre><h4 id="16-View-和-SurfaceView-的区别"><a href="#16-View-和-SurfaceView-的区别" class="headerlink" title="16. View 和 SurfaceView 的区别"></a>16. View 和 SurfaceView 的区别</h4><pre><code>http://blog.csdn.net/shareus/article/details/51538507
</code></pre><h4 id="17-LruCache-原理解析"><a href="#17-LruCache-原理解析" class="headerlink" title="17. LruCache 原理解析"></a>17. LruCache 原理解析</h4><pre><code>https://www.jianshu.com/p/b49a111147ee
</code></pre><h4 id="18-多线程断点续传"><a href="#18-多线程断点续传" class="headerlink" title="18. 多线程断点续传"></a>18. 多线程断点续传</h4><pre><code>http://blog.csdn.net/tianzhaoai/article/details/56673071
https://www.jianshu.com/p/1bb084d282be
</code></pre><h4 id="19-Android-APP-冷启动时间统计及优化"><a href="#19-Android-APP-冷启动时间统计及优化" class="headerlink" title="19. Android APP 冷启动时间统计及优化"></a>19. Android APP 冷启动时间统计及优化</h4><pre><code>https://www.jianshu.com/p/c967653a9468
http://blog.csdn.net/code_dream_wq/article/details/75012353
http://blog.csdn.net/zhangyongfeiyong/article/details/61925399
</code></pre><h4 id="20-热修复原理"><a href="#20-热修复原理" class="headerlink" title="20. 热修复原理"></a>20. 热修复原理</h4><pre><code>https://mp.weixin.qq.com/s/1SYmgZfVKczAGvXcydn0bA
</code></pre><h4 id="21-插件化原理"><a href="#21-插件化原理" class="headerlink" title="21. 插件化原理"></a>21. 插件化原理</h4><pre><code>类的加载
    1)替换App的ClassLoader
    2)修改PathList(例如在PathList中加入我们需要加载的Dex的对应项)
资源的加载：安卓资源由AssetManager加载,应用启动时,系统会为其创建一个AssetManager实例,并由addAssetPath方 法添加资源搜索路径
    1. 插件独立使用一个资源管理器
    2. 添加所有资源路径到宿主,为避免资源冲突,需要对资源ID进行分段,不同的插件使用不同分段的资源ID
组件的动态注册
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/10/23/interview-repository-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/23/interview-repository-java/" itemprop="url">
                  面试题库java
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T17:22:47+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tips/" itemprop="url" rel="index">
                    <span itemprop="name">tips</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>数组实现队列
 <a href="http://blog.csdn.net/qq_25722767/article/details/52234509" target="_blank" rel="external">http://blog.csdn.net/qq_25722767/article/details/52234509</a></p>
</li>
<li><p>GC 的流程<br> <a href="https://www.cnblogs.com/little-YTMM/p/5613642.html" target="_blank" rel="external">https://www.cnblogs.com/little-YTMM/p/5613642.html</a>
 <a href="https://www.cnblogs.com/zhguang/p/3257367.html" target="_blank" rel="external">https://www.cnblogs.com/zhguang/p/3257367.html</a></p>
</li>
<li><p>Java 软引用和弱引用的区别<br> 强引用（StrongReference）：只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象
 软引用（SoftReference）：只有在内存不足的时候JVM才会回收该对象
 弱引用（WeakReference）：当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
 虚引用（PhantomReference）：垃圾回收时回收，虚引用并不会决定对象的生命周期，无法通过引用取到对象值</p>
</li>
<li><p>Java 中 this 编译时的原理
 this调用本类中的属性，也就是类中的成员变量；
 this调用本类中的其他方法；
 this调用本类中的其他构造方法，调用时要放在构造方法的首行。    </p>
</li>
<li><p>final 变量用反射修改
 public static void modify(Object object, String fieldName, Object newFieldValue) throws Exception {</p>
<pre><code>Field field = object.getClass().getDeclaredField(fieldName);

Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);
modifiersField.setAccessible(true); //Field 的 modifiers 是私有的
modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);

if(!field.isAccessible()) {
field.setAccessible(true);
}

field.set(object, newFieldValue);
</code></pre><p> }</p>
<p> class Person {</p>
<pre><code>public final String firstName = &quot;Mike&quot;;
public final String lastName = new String(&quot;Jordan&quot;); //可被有效修改
public final float age = 50.5f;
public final Float height = 1.99f; //可被有效修改
public final Address address = new Address(&quot;aaa&quot;, &quot;bbb&quot;); //可被有效修改

public final String city; //可被有效修改

public Person(String city) {
this.city = city;
}
</code></pre><p> }</p>
</li>
<li><p>HashMap的内部结构，给定一个key，如何找到对应的value<br> <a href="https://www.cnblogs.com/shipengzhi/articles/2087505.html" target="_blank" rel="external">https://www.cnblogs.com/shipengzhi/articles/2087505.html</a></p>
</li>
<li><p>volatile 
 <a href="https://www.cnblogs.com/tangyanbo/p/6538488.html" target="_blank" rel="external">https://www.cnblogs.com/tangyanbo/p/6538488.html</a></p>
</li>
<li><p>Java线程池有什么作用
 在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程 
 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 
 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 
 第三：提高线程的可管理性。 
 常用线程池：ExecutorService 是主要的实现类，其中常用的有 :
 Executors.newSingleThreadPool() 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
 Executors.newFixedThreadPool() 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
 Executors.newcachedTheadPool() 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
 Executors.newScheduledThreadPool() 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。
 <a href="https://www.jianshu.com/p/ade771d2c9c0" target="_blank" rel="external">https://www.jianshu.com/p/ade771d2c9c0</a>
 <a href="https://www.cnblogs.com/ruiati/p/6134131.html" target="_blank" rel="external">https://www.cnblogs.com/ruiati/p/6134131.html</a></p>
</li>
<li><p>Java 动态代理 
 <a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="external">https://www.cnblogs.com/xiaoluo501395377/p/3383130.html</a></p>
</li>
<li><p>求 n 的 m 次幂
<a href="http://blog.csdn.net/derrantcm/article/details/47098373" target="_blank" rel="external">http://blog.csdn.net/derrantcm/article/details/47098373</a></p>
</li>
<li><p>java 集合<br><a href="https://www.cnblogs.com/lwlxqlccc/p/6121307.html" target="_blank" rel="external">https://www.cnblogs.com/lwlxqlccc/p/6121307.html</a></p>
</li>
<li><p>String 的 spit 实现
<a href="http://fangguanhong.iteye.com/blog/2069993" target="_blank" rel="external">http://fangguanhong.iteye.com/blog/2069993</a></p>
</li>
<li><p>Http和Https的区别
<a href="https://www.jianshu.com/p/37654eb66b58" target="_blank" rel="external">https://www.jianshu.com/p/37654eb66b58</a></p>
</li>
<li><p>java线程池—ThreadPoolExecutor 
<a href="https://www.jianshu.com/p/ade771d2c9c0" target="_blank" rel="external">https://www.jianshu.com/p/ade771d2c9c0</a></p>
</li>
<li><p>冒泡排序
<a href="http://blog.csdn.net/u010853261/article/details/54891710" target="_blank" rel="external">http://blog.csdn.net/u010853261/article/details/54891710</a></p>
</li>
<li><p>排序算法 
<a href="http://blog.csdn.net/pzhtpf/article/details/7560294" target="_blank" rel="external">http://blog.csdn.net/pzhtpf/article/details/7560294</a></p>
</li>
<li><p>抽象类和接口的区别
接口是对动作的抽象，而抽象类是对根源的抽象。
接口和抽象类都是继承树的上层，他们的共同点如下：1)    都是上层的抽象层。2)    都不能被实例化3)    都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。他们的区别如下：1)    在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。2)    一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。</p>
</li>
<li><p>java基本数据类型
8位：Byte（字节型）<br>16位：short（短整型）、char（字符型）<br>32位：int（整型）、float（单精度型/浮点型）<br>64位：long（长整型）、double（双精度型）<br>最后一个：boolean(布尔类型）</p>
</li>
<li><p>Java堆的实现、排序
<a href="http://blog.csdn.net/idealemail/article/details/51382837" target="_blank" rel="external">http://blog.csdn.net/idealemail/article/details/51382837</a></p>
</li>
<li><p>数组中重复数字
<a href="http://blog.csdn.net/zjkc050818/article/details/72800175" target="_blank" rel="external">http://blog.csdn.net/zjkc050818/article/details/72800175</a></p>
</li>
<li><p>字符串中判断另一个字符串是否存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static int indexOf(String source,</div><div class="line">                   String target,</div><div class="line">                   int fromIndex) &#123;</div><div class="line">    if (fromIndex &gt;= source.count) &#123;</div><div class="line">        return (target.count == 0 ? source.count : -1);</div><div class="line">    &#125;</div><div class="line">    if (fromIndex &lt; 0) &#123;</div><div class="line">        fromIndex = 0;</div><div class="line">    &#125;</div><div class="line">    if (target.count == 0) &#123;</div><div class="line">        return fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    char first = target.charAt(0);</div><div class="line">    int max = (source.count - target.count);</div><div class="line"></div><div class="line">    for (int i = fromIndex; i &lt;= max; i++) &#123;</div><div class="line">        /* Look for first character. */</div><div class="line">        if (source.charAt(i)!= first) &#123;</div><div class="line">            while (++i &lt;= max &amp;&amp; source.charAt(i) != first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Found first character, now look at the rest of v2 */</div><div class="line">        if (i &lt;= max) &#123;</div><div class="line">            int j = i + 1;</div><div class="line">            int end = j + target.count - 1;</div><div class="line">            for (int k = 1; j &lt; end &amp;&amp; source.charAt(j)</div><div class="line">                     == target.charAt(k); j++, k++);</div><div class="line"></div><div class="line">            if (j == end) &#123;</div><div class="line">                /* Found whole string. */</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ThreadLocal 使用及原理<br><a href="https://www.cnblogs.com/coshaho/p/5127135.html" target="_blank" rel="external">https://www.cnblogs.com/coshaho/p/5127135.html</a></p>
</li>
<li><p>Java 泛型
<a href="https://www.cnblogs.com/demingblog/p/5495610.html" target="_blank" rel="external">https://www.cnblogs.com/demingblog/p/5495610.html</a></p>
</li>
<li><p>Java 内部类
<a href="http://blog.csdn.net/roamer314/article/details/48598633" target="_blank" rel="external">http://blog.csdn.net/roamer314/article/details/48598633</a></p>
</li>
<li><p>Java ConcurrentHashMap的原理<br><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="external">https://www.cnblogs.com/chengxiao/p/6842045.html</a></p>
</li>
<li><p>线程的几种状态<br><a href="http://blog.csdn.net/sinat_36042530/article/details/52565296" target="_blank" rel="external">http://blog.csdn.net/sinat_36042530/article/details/52565296</a>
<a href="https://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="external">https://www.cnblogs.com/wxd0108/p/5479442.html</a></p>
</li>
<li><p>Java 双亲委派机制<br><a href="https://www.cnblogs.com/wxd0108/p/6681618.html" target="_blank" rel="external">https://www.cnblogs.com/wxd0108/p/6681618.html</a></p>
</li>
<li><p>Java 运算符
<a href="https://jingyan.baidu.com/article/1612d5008ff5b7e20f1eee4c.html" target="_blank" rel="external">https://jingyan.baidu.com/article/1612d5008ff5b7e20f1eee4c.html</a></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/09/11/interview-repository/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/11/interview-repository/" itemprop="url">
                  面试题库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T23:00:17+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tips/" itemprop="url" rel="index">
                    <span itemprop="name">tips</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>跨进程的远程方法的是执行在哪个进程的哪个线程?</li>
<li>SharedPreference实现原理,跨进程使用问题,为什么引起这个问题</li>
<li>Parcelable和Serializable区别,以及他们实现的原理</li>
<li>Binder相较于Socket实现进程通信的有点(拷贝少,安全)</li>
<li>A Activity的onCreate中启动一个新的activiy, A Activity的OnResume ,onPause与新Activity生命周期方法的执行顺序</li>
<li>同一台主机,udp和tcp可否使用同一个端口</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/09/11/env-vpn-l2tp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/11/env-vpn-l2tp/" itemprop="url">
                  l2tp VPN搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T22:25:48+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/env/" itemprop="url" rel="index">
                    <span itemprop="name">env</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="l2tp-VPN搭建"><a href="#l2tp-VPN搭建" class="headerlink" title="l2tp VPN搭建"></a>l2tp VPN搭建</h2><h3 id="l2tp-server搭建"><a href="#l2tp-server搭建" class="headerlink" title="l2tp server搭建"></a>l2tp server搭建</h3><p>完成<code>使用方法</code>步骤即可翻墙</p>
<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>本脚本适用环境：
系统支持：CentOS6+，Debian7+，Ubuntu12+
内存要求：≥128M
更新日期：2017 年 02 月 25 日
关于本脚本名词解释如下</p>
<ul>
<li>L2TP（Layer 2 Tunneling Protocol）</li>
<li>IPSec（Internet Protocol Security）</li>
<li>IKEv2 (Internet Key Exchange v2)
能实现 IPsec 的目前总体上有 openswan，libreswan，strongswan 这3种。
libreswan 是基于 openswan 的 fork，所以现在各个发行版基本已经看不到 openswan 的身影了。当然也有使用 strongswan 的。</li>
</ul>
<p>之所以要更新 L2TP 一键安装脚本，是因为随着各个 Linux 发行版不断推陈出新，原有的脚本已经不适应现在的需求。
本脚本通过编译安装最新版 libreswan 来实现 IPSec（CentOS7 下则是全部 yum 安装），yum 或 apt-get 来安装 xl2tpd，再根据各个发行版的使用方法不同，部署防火墙规则。</p>
<p>基于 OpenVZ 虚拟化技术的 VPS 需要开启TUN/TAP才能正常使用，购买 VPS 时请先咨询服务商是否支持开启 TUN/TAP。</p>
<p>OpenVZ 虚拟的 VPS 需要系统内核支持 IPSec 才行。也就是说，母服务器的内核如果不支持的话那就没办法，只能换 VPS。
因此，一般不建议在 OpenVZ 的 VPS 上安装本脚本。脚本如果检测到该 VPS 为 OpenVZ 架构，会出现警告提醒。</p>
<p>如何检测是否支持TUN模块？
执行命令：
<code>cat /dev/net/tun</code>
如果返回信息为：<code>cat: /dev/net/tun: File descriptor in bad state</code> 说明正常</p>
<p>如何检测是否支持ppp模块？
执行命令：
<code>cat /dev/ppp</code>
如果返回信息为：<code>cat: /dev/ppp: No such device or address</code> 说明正常
当然，脚本在安装时也会执行检查，如果不适用于安装，脚本会予以提示。</p>
<p>搬瓦工使用的是OpenVZ架构,就算检测到支持TUN模块也不能成功翻墙,新出了KVM架构的VPS,价格稍微贵些</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote>
<p>一键安装脚本:<a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md" target="_blank" rel="external">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md</a>
root 用户登录后，运行以下命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/across/master/l2tp.sh</div><div class="line">chmod +x l2tp.sh</div><div class="line">./l2tp.sh</div></pre></td></tr></table></figure></p>
</blockquote>
<p>Please input IP-Range:
(Default Range: 192.168.18):
输入本地IP段范围（本地电脑连接到VPS后给分配的一个本地IP地址），直接回车意味着输入默认值192.168.18</p>
<p>Please input PSK:
(Default PSK: teddysun.com):
PSK意为预共享密钥，即指定一个密钥将来在连接时需要用到，直接回车意味着输入默认值teddysun.com</p>
<p>Please input Username:
(Default Username: teddysun):
Username意为用户名，即第一个默认用户。直接回车意味着输入默认值teddysun</p>
<p>Please input teddysun’s password:
(Default Password: Q4SKhu2EXQ):
输入用户的密码，默认会随机生成一个10位包含大小写字母和数字的密码，当然你也可以指定密码。</p>
<p>ServerIP:your_server_main_IP
显示你的 VPS 的主 IP（如果是多 IP 的 VPS 也只显示一个）</p>
<p>Server Local IP:192.168.18.1
显示你的 VPS 的本地 IP（默认即可）</p>
<p>Client Remote IP Range:192.168.18.2-192.168.18.254
显示 IP 段范围</p>
<p>PSK:teddysun.com
显示 PSK</p>
<p>Press any key to start…or Press Ctrl+c to cancel
按下任意按键继续，如果想取消安装，请按Ctrl+c键</p>
<p>安装完成后，脚本会执行 ipsec verify 命令并提示如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">If there are no [FAILED] above, then you can connect to your</div><div class="line">L2TP VPN Server with the default Username/Password is below:</div><div class="line"></div><div class="line">ServerIP:your_server_IP</div><div class="line">PSK:your PSK</div><div class="line">Username:your usename</div><div class="line">Password:your password</div><div class="line"></div><div class="line">If you want to modify user settings, please use command(s):</div><div class="line">l2tp -a (Add a user)</div><div class="line">l2tp -d (Delete a user)</div><div class="line">l2tp -l (List all users)</div><div class="line">l2tp -m (Modify a user password)</div><div class="line">Welcome to visit https://teddysun.com/448.html</div><div class="line">Enjoy it!</div></pre></td></tr></table></figure></p>
<p>其他事项:</p>
<ol>
<li>脚本在安装完成后，已自动启动进程，并加入了开机自启动。</li>
<li>脚本会改写 iptables 或 firewalld 的规则。</li>
<li>脚本安装时，会即时将安装日志写到 /root/l2tp.log 文件里，如果你安装失败，可以通过此文件来寻找错误信息。</li>
</ol>
<p>安装完成需要修改路由配置才能翻墙,要不会导致客户端能连上但是不能翻墙.创建脚本set_iptables.sh,输入:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A POSTROUTING -s 10.10.10.0/24 -o $eth -j MASQUERADE</div><div class="line">iptables -t nat -A POSTROUTING -s 10.10.10.0/24 -j SNAT --to-source 119.28.59.230</div></pre></td></tr></table></figure></p>
<p>$eth一般换成eth0,可以使用ifconfig查看,119.28.59.230换成自己服务器公网地址</p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>安卓6.0系统无法成功连接l2tp，查了谷歌之后发现好像是安卓是sha256加密
我是这么做的，目前正常连接一小时，没有断线，mac ios android
需要在 <code>/etc/ipsec.conf</code> 的 <code>conn L2TP-PSK-noNAT</code> 下加入
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sha2-truncbug=yes</div></pre></td></tr></table></figure></p>
<p>然后重启 IPSec 和 xl2tpd 服务，重新连接就可以了。
可以解决安卓 6.0 的 vpn 无法连接问题。</p>
<h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><p>在<code>/etc/ipsec.conf</code> 的 <code>conn L2TP-PSK-noNAT</code> 下加入
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">leftnexthop defaultroute</div><div class="line">rightnexthop defaultroute</div></pre></td></tr></table></figure></p>
<p>然后重启 IPSec 和 xl2tpd 服务应该可以解决同一局域下多人连接的时候，出现连接不上的情况。
如果还是不行，就得看下这个链接里面的配置：
<a href="https://segmentfault.com/a/1190000005626927" target="_blank" rel="external">https://segmentfault.com/a/1190000005626927</a>
我就是根据这个里面的配置和你的对比改好了。</p>
<h4 id="安装完成后配置文件"><a href="#安装完成后配置文件" class="headerlink" title="安装完成后配置文件"></a>安装完成后配置文件</h4><p><strong>(不需要手动配置,学习用)</strong></p>
<h5 id="l2tp-etc-xl2tpd-xl2tpd-conf"><a href="#l2tp-etc-xl2tpd-xl2tpd-conf" class="headerlink" title="l2tp/etc/xl2tpd/xl2tpd.conf"></a>l2tp<code>/etc/xl2tpd/xl2tpd.conf</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">ipsec saref = no</div><div class="line"></div><div class="line">[lns default]</div><div class="line">ip range = 10.152.2.2-10.152.2.254</div><div class="line">local ip = 10.152.2.1</div><div class="line">require chap = yes</div><div class="line">refuse pap = yes</div><div class="line">require authentication = yes</div><div class="line">ppp debug = yes</div><div class="line">pppoptfile = /etc/ppp/options.xl2tpd</div><div class="line">length bit = yes</div></pre></td></tr></table></figure>
<p>配置说明如下：</p>
<ul>
<li>ip range = 可以连接VPN服务的客户端IP地址范围</li>
<li>local ip = VPN 服务器的IP，必须在客户端IP范围之外</li>
<li>refuse pap = 拒绝 pap 认证</li>
<li>ppp debug = 测试时打开<h5 id="l2tp-etc-xl2tpd-l2tp-secrets"><a href="#l2tp-etc-xl2tpd-l2tp-secrets" class="headerlink" title="l2tp/etc/xl2tpd/l2tp-secrets"></a>l2tp<code>/etc/xl2tpd/l2tp-secrets</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * exampleforchallengestring</div></pre></td></tr></table></figure>
</li>
</ul>
<p>配置密码</p>
<h5 id="l2tp-etc-ppp-options-xl2tpd"><a href="#l2tp-etc-ppp-options-xl2tpd" class="headerlink" title="l2tp/etc/ppp/options.xl2tpd"></a>l2tp<code>/etc/ppp/options.xl2tpd</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">refuse-mschap-v2</div><div class="line">refuse-mschap</div><div class="line">ms-dns 8.8.8.8</div><div class="line">ms-dns 8.8.4.4</div><div class="line">asyncmap 0</div><div class="line">auth</div><div class="line">crtscts</div><div class="line">idle 1800</div><div class="line">mtu 1200</div><div class="line">mru 1200</div><div class="line">lock</div><div class="line">hide-password</div><div class="line">local</div><div class="line">#debug</div><div class="line">name l2tpd</div><div class="line">proxyarp</div><div class="line">lcp-echo-interval 30</div><div class="line">lcp-echo-failure 4</div></pre></td></tr></table></figure>
<ul>
<li>ms-dns 选项设置要给客户端分配的 DNS 服务器，当客户端连接时，就会被分配这些 DNS。如果要加入多个 DNS，就每行一个，分别写几行。</li>
</ul>
<p>如果你要给客户端推送wins设置，可以分别设置如下选项。</p>
<p>mtu 和 mru 按照openswan.org的说法，减小 mru/mtu 的大小非常重要。因为  l2tp/ipsec 会封装几次，可能导致性能下降，减小这个配置的大小可以一次性传输全部的包。</p>
<p>proxyarp 可以将连接的客户端的IP地址和以太网地址加入的系统的ARP表中。这会影响到本地局域网内其它客户端。</p>
<p>name l2tpd 用在 PPP验证文件里面。</p>
<h5 id="ipsec-etc-ppp-chap-secrets"><a href="#ipsec-etc-ppp-chap-secrets" class="headerlink" title="ipsec/etc/ppp/chap-secrets"></a>ipsec<code>/etc/ppp/chap-secrets</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user1 l2tpd chooseagoodpassword *</div><div class="line">user2 * chooseagoodpassword *</div></pre></td></tr></table></figure>
<p>每行包括如下字段：</p>
<ul>
<li>客户端 = 用户名称</li>
<li>服务器 = 在上面的 /etc/ppp/options.xl2tpd 定义的名字</li>
<li>密码 = 用户密码，你应该设置一个足够复杂的密码</li>
<li>IP 地址 = * 表示用户可以从任何地址连接，否则设置用户只能从特定的地址连接</li>
</ul>
<h5 id="ipsec-etc-ipsec-conf"><a href="#ipsec-etc-ipsec-conf" class="headerlink" title="ipsec/etc/ipsec.conf"></a>ipsec<code>/etc/ipsec.conf</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">config setup</div><div class="line">        nat_traversal=yes</div><div class="line">        virtual_private=%v4:10.0.0.0/8,%v4:192.168.0.0/16,%v4:172.16.0.0/12,%v4:!10.152.2.0/24</div><div class="line">        # 这里包含的网络地址允许配置为远程客户端所在的子网。换句话说，</div><div class="line">        # 这些地址范围应该是你的NAT路由器后面的客户端的地址。</div><div class="line">        oe=off</div><div class="line">        protostack=netkey</div><div class="line"></div><div class="line">conn L2TP-PSK-NAT</div><div class="line">        rightsubnet=vhost:%priv</div><div class="line">        also=L2TP-PSK-noNAT</div><div class="line"></div><div class="line">conn L2TP-PSK-noNAT</div><div class="line">        authby=secret</div><div class="line">        pfs=no</div><div class="line">        auto=add</div><div class="line">        keyingtries=3</div><div class="line">        rekey=no</div><div class="line">        # Apple 的 iOS 不会发送 delete 提醒，</div><div class="line">        # 所以我们需要通过死亡对端（dead peer）检测来识别断掉的客户端</div><div class="line">        dpddelay=30</div><div class="line">        dpdtimeout=120</div><div class="line">        dpdaction=clear</div><div class="line">        # 设置 ikelifetime 和 keylife 和 Windows 的默认设置一致</div><div class="line">        ikelifetime=8h</div><div class="line">        keylife=1h</div><div class="line">        type=transport</div><div class="line">        # 替换 IP 地址为你的本地IP （一般是，私有地址、NAT内的地址）</div><div class="line">        left=x.x.x.x</div><div class="line">        # 用于升级过的 Windows 2000/XP 客户端</div><div class="line">        leftprotoport=17/1701</div><div class="line">        # 要支持老的客户端，需要设置 leftprotoport=17/%any</div><div class="line">        right=%any</div><div class="line">        rightprotoport=17/%any</div><div class="line">        # 强制所有连接都NAT，因为 iOS</div><div class="line">        forceencaps=yes</div></pre></td></tr></table></figure>
<p>注意你的ipsec.conf文件，”config setup” 和 “L2TP-PSK-NAT”、 “L2TP-PSK-NAT”应该顶着行头写，而其它行应该以8个空格缩进。</p>
<h5 id="ipsec-etc-ipsec-secrets"><a href="#ipsec-etc-ipsec-secrets" class="headerlink" title="ipsec/etc/ipsec.secrets"></a>ipsec<code>/etc/ipsec.secrets</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x.x.x.x   %any:  PSK &quot;somegoodpassword&quot;</div></pre></td></tr></table></figure>
<p>这里x.x.x.x 替换为你的服务器的IP地址，并设置一个复杂的密码</p>
<h5 id="etc-init-d"><a href="#etc-init-d" class="headerlink" title="/etc/init.d"></a><code>/etc/init.d</code></h5><p>在<code>/etc/init.d</code>下创建一个名为<code>ipsec.vpn</code>的文件，内容如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">case &quot;$1&quot; in</div><div class="line">  start)</div><div class="line">    echo &quot;Starting my Ipsec VPN&quot;</div><div class="line">    iptables  -t nat   -A POSTROUTING -o eth0 -s 10.152.2.0/24 -j MASQUERADE</div><div class="line">    echo 1 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">    for each in /proc/sys/net/ipv4/conf/*</div><div class="line">    do</div><div class="line">      echo 0 &gt; $each/accept_redirects</div><div class="line">      echo 0 &gt; $each/send_redirects</div><div class="line">    done</div><div class="line">    /etc/init.d/ipsec start</div><div class="line">    /etc/init.d/xl2tpd start</div><div class="line">;;</div><div class="line">  stop)</div><div class="line">    echo &quot;Stopping my Ipsec VPN&quot;</div><div class="line">    iptables --table nat --flush</div><div class="line">    echo 0 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">    /etc/init.d/ipsec stop</div><div class="line">    /etc/init.d/xl2tpd stop</div><div class="line">;;</div><div class="line">  restart)</div><div class="line">    echo &quot;Restarting my Ipsec VPN&quot;</div><div class="line">    iptables  -t nat   -A POSTROUTING -o eth0 -s 10.152.2.0/24 -j MASQUERADE</div><div class="line">    echo 1 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">    for each in /proc/sys/net/ipv4/conf/*</div><div class="line">    do</div><div class="line">      echo 0 &gt; $each/accept_redirects</div><div class="line">      echo 0 &gt; $each/send_redirects</div><div class="line">    done</div><div class="line">    /etc/init.d/ipsec restart</div><div class="line">    /etc/init.d/xl2tpd restart</div><div class="line">;;</div><div class="line">  *)</div><div class="line">    echo &quot;Usage: /etc/init.d/ipsec.vpn  &#123;start|stop|restart&#125;&quot;</div><div class="line">    exit 1</div><div class="line">;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<p>这会配置防火墙转发。记得修改上面文件的本地IP地址池10.152.2.0/24为你自己的。
给这个文件设置可执行权限：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod 755 ipsec.vpn</div></pre></td></tr></table></figure></p>
<p>禁止默认的 ipsec 服务脚本运行：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-rc.d -f ipsec remove</div></pre></td></tr></table></figure></p>
<p>然后，启用我们刚才定制的这个
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-rc.d ipsec.vpn defaults</div></pre></td></tr></table></figure></p>
<h4 id="l2tp-sh脚本命令"><a href="#l2tp-sh脚本命令" class="headerlink" title="l2tp.sh脚本命令"></a>l2tp.sh脚本命令</h4><p>如果你要想对用户进行操作，可以使用如下命令：</p>
<ul>
<li>l2tp -a 新增用户</li>
<li>l2tp -d 删除用户</li>
<li>l2tp -m 修改现有的用户的密码</li>
<li>l2tp -l 列出所有用户名和密码</li>
<li>l2tp -h 列出帮助信息</li>
</ul>
<h4 id="ipsec-amp-xl2tpd命令-用"><a href="#ipsec-amp-xl2tpd命令-用" class="headerlink" title="ipsec &amp; xl2tpd命令(用)"></a>ipsec &amp; xl2tpd命令(用)</h4><ul>
<li>ipsec status （查看 IPSec 运行状态）</li>
<li>ipsec verify （查看 IPSec 检查结果）</li>
<li>/etc/init.d/ipsec start|stop|restart|status （CentOS6 下使用）</li>
<li>/etc/init.d/xl2tpd start|stop|restart （CentOS6 下使用）</li>
<li>systemctl start|stop|restart|status ipsec （CentOS7 下使用）</li>
<li>systemctl start|stop|restart xl2tpd （CentOS7 下使用）</li>
<li>service ipsec start|stop|restart|status （Debian/Ubuntu 下使用）</li>
<li><p>service xl2tpd start|stop|restart （Debian/Ubuntu 下使用）</p>
</li>
<li><p><code>ipsec whack --trafficstatus</code>:查看链接客户端信息</p>
</li>
</ul>
<h4 id="排除故障"><a href="#排除故障" class="headerlink" title="排除故障"></a>排除故障</h4><p>如果遇到了问题，以下命令可以帮助你找到问题：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i ppp0</div><div class="line">sudo tail -f /var/log/auth.log</div><div class="line">sudo tail -f /var/log/syslog</div></pre></td></tr></table></figure></p>
<p>你可以可以在服务器上使用如下命令来监控：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i eth0 host aaa.bbb.ccc.ddd and not port ssh</div></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://linux.cn/article-3409-1.html" target="_blank" rel="external">参考</a></p>
<h3 id="l2tp-客户端连接-主要是ubuntu"><a href="#l2tp-客户端连接-主要是ubuntu" class="headerlink" title="l2tp 客户端连接(主要是ubuntu)"></a>l2tp 客户端连接(主要是ubuntu)</h3><p>以下步骤是在 <a href="https://gist.github.com/psanford/42c550a1a6ad3cb70b13e4aaa94ddb1c" target="_blank" rel="external">Peter Sanford 的工作</a> 基础上修改。这些命令必须在你的 VPN 客户端上使用 <code>root</code> 账户运行。</p>
</blockquote>
<p>参考自:<a href="https://github.com/hwdsl2/setup-ipsec-vpn" target="_blank" rel="external">https://github.com/hwdsl2/setup-ipsec-vpn</a> 下doc下的clients-zh.md,客户端和服务器配置教程工具都下载到了<code>Doc/vpn_doc</code>
要配置 VPN 客户端，首先安装以下软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Ubuntu &amp; Debian</div><div class="line">apt-get update</div><div class="line">apt-get -y install strongswan xl2tpd</div><div class="line"></div><div class="line"># CentOS &amp; RHEL</div><div class="line">yum -y install epel-release</div><div class="line">yum -y install strongswan xl2tpd</div><div class="line"></div><div class="line"># Fedora</div><div class="line">yum -y install strongswan xl2tpd</div></pre></td></tr></table></figure>
<p>创建 VPN 变量 （替换为你自己的值）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">VPN_SERVER_IP=&apos;your_vpn_server_ip&apos;</div><div class="line">VPN_IPSEC_PSK=&apos;your_ipsec_pre_shared_key&apos;</div><div class="line">VPN_USER=&apos;your_vpn_username&apos;</div><div class="line">VPN_PASSWORD=&apos;your_vpn_password&apos;</div></pre></td></tr></table></figure>
<p>配置 strongSwan：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/ipsec.conf &lt;&lt;EOF</div><div class="line"># ipsec.conf - strongSwan IPsec configuration file</div><div class="line"></div><div class="line"># basic configuration</div><div class="line"></div><div class="line">config setup</div><div class="line">  # strictcrlpolicy=yes</div><div class="line">  # uniqueids = no</div><div class="line"></div><div class="line"># Add connections here.</div><div class="line"></div><div class="line"># Sample VPN connections</div><div class="line"></div><div class="line">conn %default</div><div class="line">  ikelifetime=60m</div><div class="line">  keylife=20m</div><div class="line">  rekeymargin=3m</div><div class="line">  keyingtries=1</div><div class="line">  keyexchange=ikev1</div><div class="line">  authby=secret</div><div class="line">  ike=aes128-sha1-modp1024,3des-sha1-modp1024!</div><div class="line">  esp=aes128-sha1-modp1024,3des-sha1-modp1024!</div><div class="line"></div><div class="line">conn myvpn</div><div class="line">  keyexchange=ikev1</div><div class="line">  left=%defaultroute</div><div class="line">  auto=add</div><div class="line">  authby=secret</div><div class="line">  type=transport</div><div class="line">  leftprotoport=17/1701</div><div class="line">  rightprotoport=17/1701</div><div class="line">  right=$VPN_SERVER_IP</div><div class="line">EOF</div><div class="line"></div><div class="line">cat &gt; /etc/ipsec.secrets &lt;&lt;EOF</div><div class="line">: PSK &quot;$VPN_IPSEC_PSK&quot;</div><div class="line">EOF</div><div class="line"></div><div class="line">chmod 600 /etc/ipsec.secrets</div><div class="line"></div><div class="line"># For CentOS/RHEL &amp; Fedora ONLY</div><div class="line">mv /etc/strongswan/ipsec.conf /etc/strongswan/ipsec.conf.old 2&gt;/dev/null</div><div class="line">mv /etc/strongswan/ipsec.secrets /etc/strongswan/ipsec.secrets.old 2&gt;/dev/null</div><div class="line">ln -s /etc/ipsec.conf /etc/strongswan/ipsec.conf</div><div class="line">ln -s /etc/ipsec.secrets /etc/strongswan/ipsec.secrets</div></pre></td></tr></table></figure></p>
<p>配置 xl2tpd：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/xl2tpd/xl2tpd.conf &lt;&lt;EOF</div><div class="line">[lac myvpn]</div><div class="line">lns = $VPN_SERVER_IP</div><div class="line">ppp debug = yes</div><div class="line">pppoptfile = /etc/ppp/options.l2tpd.client</div><div class="line">length bit = yes</div><div class="line">EOF</div><div class="line"></div><div class="line">cat &gt; /etc/ppp/options.l2tpd.client &lt;&lt;EOF</div><div class="line">ipcp-accept-local</div><div class="line">ipcp-accept-remote</div><div class="line">refuse-eap</div><div class="line">require-chap</div><div class="line">noccp</div><div class="line">noauth</div><div class="line">mtu 1280</div><div class="line">mru 1280</div><div class="line">noipdefault</div><div class="line">defaultroute</div><div class="line">usepeerdns</div><div class="line">connect-delay 5000</div><div class="line">name $VPN_USER</div><div class="line">password $VPN_PASSWORD</div><div class="line">EOF</div><div class="line"></div><div class="line">chmod 600 /etc/ppp/options.l2tpd.client</div></pre></td></tr></table></figure></p>
<p>至此 VPN 客户端配置已完成。按照下面的步骤进行连接。</p>
<p>创建 xl2tpd 控制文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p /var/run/xl2tpd</div><div class="line">touch /var/run/xl2tpd/l2tp-control</div></pre></td></tr></table></figure></p>
<p>重启服务：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service strongswan restart</div><div class="line">service xl2tpd restart</div></pre></td></tr></table></figure></p>
<p>开始 IPsec 连接：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Ubuntu &amp; Debian</div><div class="line">ipsec up myvpn</div><div class="line"></div><div class="line"># CentOS/RHEL &amp; Fedora</div><div class="line">strongswan up myvpn</div></pre></td></tr></table></figure></p>
<p>开始 L2TP 连接：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;c myvpn&quot; &gt; /var/run/xl2tpd/l2tp-control</div></pre></td></tr></table></figure></p>
<p>运行 <code>ifconfig</code> 并且检查输出。现在你应该看到一个新的网络接口 <code>ppp0</code>。</p>
<p>检查你现有的默认路由：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route</div></pre></td></tr></table></figure></p>
<p>在输出中查找以下行： <code>default via X.X.X.X ...</code>。记下这个网关 IP，并且在下面的两个命令中使用。</p>
<p>从新的默认路由中排除你的 VPN 服务器 IP （替换为你自己的值）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route add YOUR_VPN_SERVER_IP gw X.X.X.X</div></pre></td></tr></table></figure></p>
<p>如果你的 VPN 客户端是一个远程服务器，则必须从新的默认路由中排除你本地电脑的公有 IP，以避免 SSH 会话被断开 （替换为你自己的公有 IP，可在 <a href="https://www.ipchicken.com" target="_blank" rel="external">这里</a>查看）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route add YOUR_LOCAL_PC_PUBLIC_IP gw X.X.X.X</div></pre></td></tr></table></figure></p>
<p>添加一个新的默认路由，并且开始通过 VPN 服务器发送数据：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route add default dev ppp0</div></pre></td></tr></table></figure></p>
<p>至此 VPN 连接已成功完成。检查 VPN 是否正常工作：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -qO- http://ipv4.icanhazip.com; echo</div></pre></td></tr></table></figure></p>
<p>以上命令应该返回 <code>你的 VPN 服务器 IP</code>。</p>
<p>要停止通过 VPN 服务器发送数据：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route del default dev ppp0</div></pre></td></tr></table></figure></p>
<p>要断开连接：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Ubuntu &amp; Debian</div><div class="line">echo &quot;d myvpn&quot; &gt; /var/run/xl2tpd/l2tp-control</div><div class="line">ipsec down myvpn</div><div class="line"></div><div class="line"># CentOS/RHEL &amp; Fedora</div><div class="line">echo &quot;d myvpn&quot; &gt; /var/run/xl2tpd/l2tp-control</div><div class="line">strongswan down myvpn</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/09/11/env-mac-tools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/11/env-mac-tools/" itemprop="url">
                  mac环境配置之小工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T22:25:48+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/env/" itemprop="url" rel="index">
                    <span itemprop="name">env</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><h4 id="JSON-Tools"><a href="#JSON-Tools" class="headerlink" title="JSON Tools"></a>JSON Tools</h4><p>Ctrl(Cmd)+Alt+M for JSON pretty.</p>
<p>Alt+M for JSON minify.</p>
<h4 id="VS-Code-mac下配置终端环境为zsh"><a href="#VS-Code-mac下配置终端环境为zsh" class="headerlink" title="VS Code mac下配置终端环境为zsh"></a>VS Code mac下配置终端环境为zsh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;terminal.integrated.shell.osx&quot;:&quot;/bin/zsh&quot;</div></pre></td></tr></table></figure>
<p>配置终端字体大小:
设置-&gt;终端-&gt;Font Size</p>
<h4 id="打开文件覆盖之前tab问题"><a href="#打开文件覆盖之前tab问题" class="headerlink" title="打开文件覆盖之前tab问题"></a>打开文件覆盖之前tab问题</h4><p>这是因为你单击文件名的缘故，这个是“预览模式”，所以再单击其他文件时，会覆盖当前打开的文件。
预览模式是现在各类编辑器的默认功能，可以关掉, 给配置settings.json里加一条：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;workbench.editor.enablePreview&quot;: false,</div></pre></td></tr></table></figure></p>
<h3 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh-key"></a>ssh-key</h3><h4 id="更新代码、SSH服务器总是提示："><a href="#更新代码、SSH服务器总是提示：" class="headerlink" title="更新代码、SSH服务器总是提示："></a>更新代码、SSH服务器总是提示：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Enter passphrase for .../id_rsa:</div></pre></td></tr></table></figure>
<p>ssh-add命令是把专用密钥添加到ssh-agent的高速缓存中。该命令位置在/usr/bin/ssh-add
ssh-add
可以使用的参数：
-D：删除ssh-agent中的所有密钥.
-d：从ssh-agent中的删除密钥
-e pkcs11：删除PKCS#11共享库pkcs1提供的钥匙。
-s pkcs11：添加PKCS#11共享库pkcs1提供的钥匙。
-L：显示ssh-agent中的公钥
-l：显示ssh-agent中的密钥
-t life：对加载的密钥设置超时时间，超时ssh-agent将自动卸载密钥
-X：对ssh-agent进行解锁 -x：对ssh-agent进行加锁来</p>
<p>执行一下命令就好了，就不用再反复输入密码了
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<h4 id="Host-key-verification-failed"><a href="#Host-key-verification-failed" class="headerlink" title="Host key verification failed."></a>Host key verification failed.</h4><p>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
85:82:b1:58:20:21:a5:da:be:24:e8:14:9a:12:b2:d2.
Please contact your system administrator.
Add correct host key in /root/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /root/.ssh/known_hosts:5
ECDSA host key for 172.xxx.xxx.xxx has changed and you have requested strict checking.
Host key verification failed.</p>
<p>ssh会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告，避免你受到DNS Hijack之类的攻击.SSH对主机的public_key的检查等级是根据StrictHostKeyChecking变量来配置的。默认情况下，StrictHostKeyChecking=ask。</p>
<p>简单说下它的三种配置值：</p>
<ul>
<li><p><code>StrictHostKeyChecking=no</code> 最不安全的级别，当然也没有那么多烦人的提示了，相对安全的内网时建议使用。如果连接server的key在本地不存在，那么就自动添加到文件中（默认是known_hosts），并且给出一个警告。</p>
</li>
<li><p><code>StrictHostKeyChecking=ask</code> 默认的级别，就是出现刚才的提示了。如果连接和key不匹配，给出提示，并拒绝登录。</p>
</li>
<li><code>StrictHostKeyChecking=yes</code> 最安全的级别，如果连接与key不匹配，就拒绝连接，不会提示详细信息。</li>
</ul>
<p>解决方案:</p>
<ol>
<li>除<code>~/.ssh/known_hosts</code>文件中对应ip的相关rsa信息, 输入命令<code>vi ~/.ssh/known_hosts</code>，编辑文件删除对应ip的相关rsa信息，即可。</li>
<li>使用 <code>ssh-keygen -R hostname</code> 命令, 目的是清除你当前机器里关于你的远程服务器的缓存和公钥信息，注意是大写的字母“R”。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/09/11/env-vpn-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/11/env-vpn-introduce/" itemprop="url">
                  vpn(Virtual Private Network)虚拟专用网络介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T22:25:48+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/env/" itemprop="url" rel="index">
                    <span itemprop="name">env</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vpn-Virtual-Private-Network-虚拟专用网络"><a href="#vpn-Virtual-Private-Network-虚拟专用网络" class="headerlink" title="vpn(Virtual Private Network)虚拟专用网络"></a>vpn(Virtual Private Network)虚拟专用网络</h2><p>VPN是企业通信的常用技术，可以对网络加密，使得其安全性能提升。常用的VPN协议有PPTP、L2TP、OpenVPN</p>
<h3 id="一、PPTP、L2TP、OpenVPN三种隧道协议的概念"><a href="#一、PPTP、L2TP、OpenVPN三种隧道协议的概念" class="headerlink" title="一、PPTP、L2TP、OpenVPN三种隧道协议的概念"></a>一、PPTP、L2TP、OpenVPN三种隧道协议的概念</h3><h4 id="1、PPTP-Point-to-Point-Tunneling-Protocol，点对点隧道协议-默认端口号：1723"><a href="#1、PPTP-Point-to-Point-Tunneling-Protocol，点对点隧道协议-默认端口号：1723" class="headerlink" title="1、PPTP(Point to Point Tunneling Protocol，点对点隧道协议)默认端口号：1723"></a>1、PPTP(Point to Point Tunneling Protocol，点对点隧道协议)默认端口号：1723</h4><p>　　PPTP，即PPTF协议。该协议是在PPP协议的基础上开发的一种新的增强型安全协议，支持多协议虚拟专用网(VPN)，可以通过密码身份验证协议(PAP)、可扩展身份验证协议(EAP)等方法增强安全性。可以使远程用户通过拨入ISP、通过直接连接Internet或其他网络安全地访问企业网。</p>
<p>　　点对点隧道协议(PPTP)是一种支持多协议虚拟专用网络的网络技术，它工作在第二层。通过该协议，远程用户能够通过 Microsoft Windows NT工作站、Windows xp 、Windows 2000 和windows2003、windows7操作系统以及其它装有点对点协议的系统安全访问公司网络，并能拨号连入本地ISP，通过Internet 安全链接到公司网络。</p>
<p>　　PPTP协议是点对点隧道协议，其将控制包与数据包分开，控制包采用TCP控制。PPTP使用TCP协议，适合在没有防火墙限制的网络中使用。</p>
<h4 id="2、L2TP-Layer-2-Tunneling-Protocol，第二层隧道协议"><a href="#2、L2TP-Layer-2-Tunneling-Protocol，第二层隧道协议" class="headerlink" title="2、L2TP(Layer 2 Tunneling Protocol，第二层隧道协议)"></a>2、L2TP(Layer 2 Tunneling Protocol，第二层隧道协议)</h4><p>　　L2TP是一种工业标准的Internet隧道协议，功能大致和PPTP协议类似，比如同样可以对网络数据流进行加密。不过也有不同之处，比如PPTP要求网络为IP网络，L2TP要求面向数据包的点对点连接;PPTP使用单一隧道，L2TP使用多隧道;L2TP提供包头压缩、隧道验证，而PPTP不支持。</p>
<p>　　L2TP是一个数据链路层协议，基于UDP。其报文分为数据消息和控制消息两类。数据消息用投递 PPP 帧，该帧作为L2TP报文的数据区。L2TP不保证数据消息的可靠投递，若数据报文丢失，不予重传，不支持对数据消息的流量控制和拥塞控制。控制消息用以建立、维护和终止控制连接及会话，L2TP确保其可靠投递，并支持对控制消息的流量控制和拥塞控制。</p>
<p>　　L2TP是国际标准隧道协议，它结合了PPTP协议以及第二层转发L2F协议的优点，能以隧道方式使PPP包通过各种网络协议，包括ATM、SONET和帧中继。但是L2TP没有任何加密措施，更多是和IPSec协议结合使用，提供隧道验证。</p>
<p>　　L2TP使用UDP协议，一般可以穿透防火墙，适合在有防火墙限制、局域网用户，如公司、网吧、学校等场合使用。</p>
<p>　　PPTP和L2TP二个连接类型在性能上差别不大，如果使用PPTP不正常，那就更换为L2TP。</p>
<h4 id="3、OpenVPN"><a href="#3、OpenVPN" class="headerlink" title="3、OpenVPN"></a>3、OpenVPN</h4><p>　　OpenVpn的技术核心是虚拟网卡，其次是SSL协议实现。</p>
<p>　　虚拟网卡是使用网络底层编程技术实现的一个驱动软件，安装后在主机上多出现一个网卡，可以像其它网卡一样进行配置。服务程序可以在应用层打开虚拟网卡，如果应用软件(如IE)向虚拟网卡发送数据，则服务程序可以读取到该数据，如果服务程序写合适的数据到虚拟网卡，应用软件也可以接收得到。虚拟网卡在很多的操作系统下都有相应的实现，这也是OpenVpn能够跨平台一个很重要的理由。</p>
<p>　　OpenVPN使用OpenSSL库加密数据与控制信息：它使用了OpenSSL的加密以及验证功能，意味着，它能够使用任何OpenSSL支持的算法。它提供了可选的数据包HMAC功能以提高连接的安全性。此外，OpenSSL的硬件加速也能提高它的性能。</p>
<p>　　OpenVPN所有的通信都基于一个单一的IP端口，默认且推荐使用UDP协议通讯，同时TCP也被支持。</p>
<p>　　在选择协议时候，需要注意2个加密隧道之间的网络状况，如有高延迟或者丢包较多的情况下，请选择TCP协议作为底层协议，UDP协议由于存在无连接和重传机制，导致要隧道上层的协议进行重传，效率非常低下。</p>
<p>　　OpenVPN是一个基于SSL加密的纯应用层VPN协议，是SSL VPN的一种，支持UDP与TCP两种方式(说明：UDP和TCP是2种通讯协议，这里通常UDP的效率会比较高，速度也相对较快。所以尽量使用UDP连接方式，实在UDP没法使用的时候，再使用TCP连接方式)。</p>
<p>　　由于其运行在纯应用层，避免了PPTP和L2TP在某些NAT设备后面不被支持的情况，并且可以绕过一些网络的封锁(通俗点讲，基本上能上网的地方就能用OpenVPN)。</p>
<p>　　OpenVPN客户端软件可以很方便地配合路由表，实现不同线路(如国内和国外)的路由选择，实现一部分IP走VPN，另一部分IP走原网络。</p>
<h3 id="二、PPTP、L2TP、OpenVPN三种隧道协议的优缺点对比"><a href="#二、PPTP、L2TP、OpenVPN三种隧道协议的优缺点对比" class="headerlink" title="二、PPTP、L2TP、OpenVPN三种隧道协议的优缺点对比"></a>二、PPTP、L2TP、OpenVPN三种隧道协议的优缺点对比</h3><ul>
<li>易用性： PPTP &gt; L2TP &gt; OpenVPN</li>
<li>速度： PPTP &gt; OpenVPN UDP &gt; L2TP &gt; OpenVPN TCP</li>
<li>安全性： OpenVPN &gt; L2TP &gt; PPTP</li>
<li>稳定性： OpenVPN &gt; L2TP &gt; PPTP</li>
<li>网络适用性：OpenVPN &gt; PPTP &gt; L2TP</li>
</ul>
<h3 id="三、VPN协议的选择"><a href="#三、VPN协议的选择" class="headerlink" title="三、VPN协议的选择"></a>三、VPN协议的选择</h3><p>电脑上优先使用PPTP，无法使用可以尝试L2TP，对安全性要求高的优先使用OpenVPN。手持设备推荐使用L2TP。</p>
<ul>
<li>PPTP： 最常用，设置最简单，大多数设备都支持;</li>
<li>L2TP： 支持PPTP的设备基本都支持此种方式，设置略复杂，需要选择L2TP/IPSec PSK方式，且设置预共享密钥PSK;</li>
<li>OpenVPN：最稳定，适用于各种网络环境，但需要安装第三方软件和配置文件，较复杂。</li>
</ul>
<p>　　但如今有了更加优秀的选择 IKEv2，更加轻便、快速，也是windows phone中唯一支持的VPN协议(好像最近支持了L2TP)</p>
<h3 id="IKEV2介绍"><a href="#IKEV2介绍" class="headerlink" title="IKEV2介绍"></a>IKEV2介绍</h3><p>是Internet Key Exchange version 2的缩写,它是用来完成认证,协商加密,哈希算法,以及对应秘钥,定义什么流量需要加密完成IKE SA,IP sec SA的建立.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">159</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
