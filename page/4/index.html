<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/page/4/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/page/4/">





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/12/tips-net-mars-timeout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/12/tips-net-mars-timeout/" itemprop="url">
                  微信终端跨平台组件 mars 系列(二) - 信令传输超时设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T15:53:08+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>mars 是微信官方使用 C++ 编写的业务性无关、平台性无关的终端基础组件，目前在微信 Android、iOS、Windows、Mac、Windows Phone 等多个平台中使用，并正在筹备开源，它主要包含以下几个独立的部分：</p>
<ol>
<li>COMM：基础库，包括 socket、线程、消息队列、协程等基础工具；</li>
<li>XLOG：通用日志模块，充分考虑移动终端的特点，提供高性能、高可用、安全性、容错性的日志功能；（详情点击：高性能日志模块xlog ）</li>
<li>SDT：网络诊断模块；</li>
<li>STN：信令传输网络模块，负责终端与服务器的小数据信令通道。包含了微信终端在移动网络上的大量优化经验与成果，经历了微信海量用户的考验。</li>
</ol>
<p>本篇文章将为大家介绍 STN（信令传输网络模块），由于 STN 的复杂性，该模块将被分解为多个篇章进行介绍，本文主要内容为微信中关于读写超时的思考与设计。</p>
<h2 id="读写超时与设计目标"><a href="#读写超时与设计目标" class="headerlink" title="读写超时与设计目标"></a>读写超时与设计目标</h2><h3 id="TCP-IP中的超时设计"><a href="#TCP-IP中的超时设计" class="headerlink" title="TCP/IP中的超时设计"></a>TCP/IP中的超时设计</h3><p>微信信令通信主要使用 TCP/IP 协议，数据经过应用层、传输层、网络层、链路层（见图1）。其中，链路层与传输层，协议提供了超时重传的机制。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-201931215560.png" alt="图1 使用 TCP/IP 协议"></p>
<h3 id="链路层的超时与重传"><a href="#链路层的超时与重传" class="headerlink" title="链路层的超时与重传"></a>链路层的超时与重传</h3><p>在链路层，一般使用混合自动重传请求（即 HARQ）。HARQ 是一种结合 FEC（前馈式错误修正）与 ARQ（自动重传请求）的技术，原理如图2所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155629.png" alt="图2 HARQ 原理"></p>
<p>通过使用确认和超时这两个机制，链路层在不可靠物理设备的基础上实现可靠的信息传输。这个方案需要手机和 RNC 都支持，目前在 EDGE、HSDPA、HSUPA、UMTS和 LTE 上都已实现支持。</p>
<h3 id="传输层的超时与重传"><a href="#传输层的超时与重传" class="headerlink" title="传输层的超时与重传"></a>传输层的超时与重传</h3><p>传输层（即 TCP 层）提供可靠的传输，然而，TCP 层依赖的链路本身是不可靠的，TCP 是如何在不可靠的环境中提供可靠服务的呢？答案是超时和重传。TCP 在发送数据时设置一个定时器，当定时器溢出还没有收到 ACK，则重传该数据。因此，超时与重传的关键之处在于如何决定定时器间隔与重传频率。</p>
<p>传统 Unix 实现中，定时器的间隔取决于数据的往返时间（即 RTT），根据 RTT 进行一定的计算得到重传超时间隔（即 RTO）。由于网络路由、流量等的变化，RTT 是经常发生变化的，RTT 的测量也极为复杂（平滑算法、Karn 算法、Jacbson 算法等）。在《TCP/IP详解》中，实际测量的重传机制如图3所示，重传的时间间隔，取整后分别为1、3、6、12、24、48和多个64秒。这个倍乘的关系被称为“指数退避”。</p>
<p><img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155711.png" alt="图3 实际测量的重传机制"></p>
<p>在移动终端中，RTO 的设计以及重试频率的设计是否与传统实现一致呢？对此我们进行了实测，实测数据如下：</p>
<p>图4所示为OPPO手机TCP超时重传的间隔，依次为[ 0.25s，0.5s，1s，2s，4s，8s，16s，32s，64s，64s，64s …]：
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155757.png" alt="图4 OPPO 手机 TCP 超时重传间隔"></p>
<p>而 SamSung 中 TCP 超时重传的间隔依次为[0.42s, 0.9s, 1.8s, 3.7s, 7.5s, 15s, 30s, 60s, 120s, 120s …]，见图5。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155816.png" alt="图5 三星手机 TCP 超时重传间隔"></p>
<p>经过多次实际测试我们可以看出虽然由于不同厂商的 Android 系统实现，RTO 的值可能会有不同的设定，但都基本符合“指数退避”原则。</p>
<p>接下来再看 iOS 系统中，TCP RTO 的实验数据，图6所示为实验中第一次的数据[ 1s，1s，1s，2s，4.5s，9s，13.5s，26s，26s … ]。</p>
<p><img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155855.png" alt="图6 iOS 系统 TCP RTO 第一次实验数据"></p>
<p>上面的数据看起来并不完全符合指数退避，开始阶段的重试会较为频繁且 RTO 最终固定在 26s 这一较小的值上。</p>
<p>进行第二次测试后发现数据有了新的变化[1s，1s，1s，2s，3.5s，8.5s，12.5s，24s，24s …]，如图7所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155936.png" alt="图7 iOS 系统 TCP RTO 第二次实验数据"></p>
<p>RTO 终值由26秒缩减至24秒，最终经过多次测试并未发现 iOS 中 TCP RTO 的规律，但可以看出 iOS 确实采用了较为激进的超时时间设定，对重试更为积极。</p>
<h3 id="读写超时的目标"><a href="#读写超时的目标" class="headerlink" title="读写超时的目标"></a>读写超时的目标</h3><p>通过上述的调研与实验，可以发现在 TCP/IP 中，协议栈已经帮助我们进行了超时与重传的控制。并且在 Android、iOS 的移动操作系统中进行了优化，使用了更为积极的策略，以适应移动网络不稳定的特征。</p>
<p>那是否意味着我们的应用层已经不需要超时与重传的控制了呢？其实不然。在链路层，HARQ 提供的是节点之间每一数据帧的可靠传输；在传输层，TCP 超时重传机制提供的是端与端之间每个 TCP 数据包的可靠传输；同理，在微信所处的应用层中，我们仍然需要提供以“请求”为粒度的可靠传输。</p>
<p>那么，应用层的超时重传机制应该提供怎样的服务呢？</p>
<p>首先，我们来看一下应用层重传的做法。在应用层中，重传的做法是：断掉当前连接，重新建立连接并发送请求。这种重传方式能带来怎样的作用呢？回顾 TCP 层的超时重传机制可以发现，当发生超时重传时，重传的间隔以“指数退避”的规律急剧上升。在 Android 系统中，直到16分钟，TCP 才确认失败；在 iOS 系统中，直到1分半到3分半之间，TCP 才确认失败。这些数值在大部分应用中都是不为“用户体验”所接受的。因此，应用层的超时重传的目标首先应是：
<strong>在用户体验的接受范围内，尽可能地提高成功率</strong>
尽可能地增加成功率，是否意味着在有限的时间内，做尽可能多的重试呢？其实不然。当网络为高延迟/低速率的网络时，较快的应用层重传会导致“请求”在这种网络下很难成功。因此，应用层超时重传的目标二：
<strong>保障弱网络下的可用性</strong>
TCP连接是有固定物理线路的连接，当已 Connect 的线路中，如果中间设备出现较大波动或严重拥塞，即使在限定时间内该请求能成功，但带来的却是性能低下，反应迟钝的用户体验。通过应用层重连，期待的目标三是：
<strong>具有网络敏感性，快速的发现新的链路</strong></p>
<p>我们总结应用层超时重传，可以带来以下作用：</p>
<ol>
<li>减少无效等待时间，增加重试次数：当 TCP 层的重传间隔已经太大的时候，断连重连，使得 TCP 层保持积极的重连间隔，提高成功率；</li>
<li>切换链路：当链路存在较大波动或严重拥塞时，通过更换连接（一般会顺带更换IP&amp;Port）获得更好的性能。</li>
</ol>
<h2 id="微信读写超时"><a href="#微信读写超时" class="headerlink" title="微信读写超时"></a>微信读写超时</h2><h3 id="方案一：总读写超时"><a href="#方案一：总读写超时" class="headerlink" title="方案一：总读写超时"></a>方案一：总读写超时</h3><p>在TCP层的超时重传设计中，超时间隔取决于RTT，RTT即TCP包往返的时间。同理，在微信的早期设计中，我们分析应用层“请求”的往返时间，将其RTT分解为：</p>
<ul>
<li>请求发送耗时 - 类比TCP包传输耗时；</li>
<li>响应信令接收耗时 - 类比ACK传输耗时；</li>
<li>服务器处理请求耗时 - TCP接收端接收和处理数据包的时间相对固定，而微信服务器由于信令所属业务的不同，逻辑处理的耗时会差异明显，所以无法类比；</li>
<li>等待耗时 - 受应用中请求并发数影响。</li>
</ul>
<p>因此，我们提出了应用层的总读写超时如图8所示，最低网速根据不同的网络取不同的值。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-201931216249.png" alt="图8 应用层的总读写超时"></p>
<h3 id="方案二：分步的读写超时"><a href="#方案二：分步的读写超时" class="headerlink" title="方案二：分步的读写超时"></a>方案二：分步的读写超时</h3><p>在实际的使用过程中，我们发现这仅仅是一个可用的方案，并不是一个高性能的解决方案：超时时长的设置使用了差网络下、完整的完成单次信令交互的时间估值。这使得超时时间过长，在网络波动或拥塞时，无法敏感地发现问题并重试。进一步分析可以发现，我们无法预知服务器回包的大小，因此使用了最大的回包进行估算（微信中目前最大回包可到 128KB）。然而，TCP 传输中当发送数据大于 MSS 时，数据将被分段传输，分段到达接收端后重新组合。如果服务器的回包较大，客户端可能会收到多个数据段。因此，我们可以对首个数据分段的到达时间进行预期，从而提出首包超时，如图9所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-201931216413.png" alt="图9 首包超时计算"></p>
<p>首包超时缩短了发现问题的周期，但是我们发现如果首个数据分段按时到达，而后续数据包丢失的情况下，仍然要等待整个读写超时才能发现问题。为此我们引入了包包超时，即两个数据分段之间的超时时间。因为包包超时在首包超时之后，这个阶段已经确认服务器收到了请求，且完成了请求的处理，因此不需要计算等待耗时、请求传输耗时、服务器处理耗时，只需要估算网络的 RTT。</p>
<p>在目前方案中，使用了不同网络下的固定 RTT。由于有了“首包已收到”的上下文，使得包包超时的间隔大大缩短，从而提高了对网络突然波动、拥塞、突发故障的敏感性，使得应用获得较高的性能。</p>
<h3 id="方案三：动态的读写超时"><a href="#方案三：动态的读写超时" class="headerlink" title="方案三：动态的读写超时"></a>方案三：动态的读写超时</h3><p>在上述的方案中，总读写超时、首包超时都使用了一些估值，使得这两个超时是较大的值。假如我们能获得实时的动态网速等，我们能获得更好的超时机制，如图10所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312161353.png" alt="图10 实时动态网速下的超时估算"></p>
<p>但是，理想是丰满的，现实是残酷的：</p>
<ul>
<li>动态网速需要通过工具方法测定，实时性要求高，并且要考虑网络波动的影响；</li>
<li>服务器动态耗时需要服务器下发不同业务信令的处理耗时；</li>
<li>真实回包大小则只能靠服务器通知。</li>
</ul>
<p>上述的三种途径对客户端和服务器都是巨大的流量、性能的消耗，所以动态化这些变量看起来并不可行。</p>
<p>因此，这里需要换个角度思考动态优化，手机的网络状况可以大概地归为优质、正常、差三种情况，针对三种网络状况进行不同程度的调整，也是动态优化的一种手段。这里选择优质网络状况进行分析：</p>
<ul>
<li>如何判定网络状况好？网速快、稳定，网络模块中与之等价的是能够短时间完成信令收发，并且能够连续长时间地完成短时间内信令收发。</li>
<li>即使出现网络波动，也可以预期会很快恢复。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312161536.png" alt="图11 优质网络状况优化"></li>
</ul>
<p>根据对网络状况好的分析，我们可以做出这样的优化（如图11所示）：</p>
<ul>
<li>将客户端网络环境区分为优良（Excellent）、评估（Evaluating）两种状态；</li>
<li>网速快、稳定就是条件1，信令失败或网络类型切换是条件2。</li>
</ul>
<p>进入Exc状态后，就缩短信令收发的预期，即减小首包超时时间，这样做的原因是我们认为用户的网络状况好，可以设置较短的超时时间，当遇到网络波动时预期它能够快速恢复，所以可以尽快超时然后进行重试，从而改善用户体验。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 TCP/IP 协议栈中的链路层、传输层都已经提供了超时重传，保障了传输的可靠性。但应用层有着不同的可靠性需求，从而需要额外的应用层超时重传机制来保障应用的高性能、高可用。应用层超时重传的设计目标，笔者从自身经验出发，总结为：</p>
<ul>
<li>在用户体验的接受范围内，尽可能地提高成功率；</li>
<li>保障弱网络下的可用性；</li>
<li>具有网络敏感性，快速地发现新的链路。</li>
</ul>
<p>依从这些目标，mars STN 的超时重传机制在使用中不断的精细化演进，使用了包含总读写超时、首包超时、包包超时、动态超时等多种方案的综合。即使如此，STN 的超时重传机制也有着不少的缺点与局限性，例如相对适用于小数据传输的信令通道、局限于一来一回的通信模式等。mars STN 也会不断发现新的问题持续演进，并且所有的演进都将在微信的海量用户中进行验证。同时也期待随着 mars STN 的开源，能收获更多、更广的经验交流、问题反馈、新想法的碰撞等。</p>
<blockquote>
<p>转自<a href="https://mp.weixin.qq.com/s/PnICVDyVuMSyvpvTrdEpSQ?" target="_blank" rel="noopener">微信终端跨平台组件 mars 系列(二) - 信令传输超时设计</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/12/tips-net-applicationlayer-diff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/12/tips-net-applicationlayer-diff/" itemprop="url">
                  tips-net-applicationlayer-diff
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T15:09:49+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="I-协议优化演进"><a href="#I-协议优化演进" class="headerlink" title="I. 协议优化演进"></a>I. 协议优化演进</h3><h4 id="1-带宽与拥塞"><a href="#1-带宽与拥塞" class="headerlink" title="1. 带宽与拥塞"></a>1. 带宽与拥塞</h4><p><strong>现状</strong></p>
<p>目前的网络基建越来越好，因此带宽的已经不再是瓶颈， 但是由于相关协议(如TCP)的拥塞窗口(CWND, congestion window)控制算法，很多时候并没有将带宽有效的利用，因此更有效的利用带宽是一个优化方向，特别针对视频、游戏等领域。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>QUIC:</strong> 基于UDP，QUIC可以支持无序的递交，因此通常单个丢包最多只会影响1个请求stream，并且QUIC中一定程度上拆分拥塞窗口来更好的适配多个多路复用的连接，来尽可能的利用带宽，目前已经在Youtube以及一些Google通用库(如字体库)上应用</li>
<li><strong>HTTP:</strong> 通过同时建立多个连接通道，由于每个通道有单独的拥塞窗口保证一个丢包最多只拥塞一个连接通道</li>
<li><strong>BBR:</strong> Google推出的全新的阻塞拥塞控制算法，从根本上解决该问题，通过交替测量带宽和激进的估算算法尽可能的占满带宽与降低延迟（此方式极大的提高了带宽利用率），目前已经在Youtube上应用</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>TCP:</strong> 由于采用”加性增，乘性减”的拥塞控制算法，错误的将网络中的错误丢包也认为是拥塞丢包，导致拥塞窗口被收敛的很小，带宽无法有效利用</li>
<li><strong>SPDY:</strong> 由于SPDY基于TCP，因此存在TCP相同的缺陷问题，并且虽然SPDY采用了多路复用，也做个各类优化，但是由于一个TCP连接只有一个拥塞窗口，因此一个请求stream丢包，就会导致整个通道被阻塞</li>
</ul>
<h4 id="2-握手的N-RTT的开销"><a href="#2-握手的N-RTT的开销" class="headerlink" title="2. 握手的N-RTT的开销"></a>2. 握手的N-RTT的开销</h4><p><strong>现状</strong></p>
<p>目前TCP与SSL/TLS(1.0,1.1,1.2)，每次建连需要TCP三次握手+安全握手需要: <code>4~5-RRT</code>，导致建连效率低下，Google、Facebook、Tencent(Wechat)等公司推出了各类优化策略。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>TLS1.3:</strong> 安全握手提出了0-RTT草案</li>
<li><strong>QUIC:</strong> 通过实现自己的安全模块，整个握手过程(TCP + TLS)采用全新的0-RTT方案，并计划当完成时适配到TLS1.3中</li>
<li><strong>Proxygen:</strong> Facebook基于QUIC的0-RTT协议进行优化，保证安全握手最多只有1-RTT，并运用在TCP中 ，并将贡献各类优化成果给TLS1.3</li>
<li><strong>mmtls:</strong> Wechat基于TLS1.3草案中的0-RTT，进行优化推出自己的mmtls，其对于长连接保障安全握手1-RTT，对于短连接安全握手尽可能使用0-RTT</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>SSL、TLS1.3之前版本:</strong>  在TLS1.2中，需要2~1-RTT(全握手需要2-RTT)</li>
</ul>
<h4 id="3-冗余数据"><a href="#3-冗余数据" class="headerlink" title="3. 冗余数据"></a>3. 冗余数据</h4><p><strong>现状</strong></p>
<p>通常的一般的HTTP请求，每次请求header基本上没什么变化；在一些情况下多个页面使用相同静态资源(js、logo等)，却每次都重复下载。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>SPDY:</strong> 采用<a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">DEFLATE</a>对请求头/响应头进行压缩</li>
<li><strong>HTTP/2:</strong> 采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="noopener">HPACK</a>算法对请求头/响应头进行压缩，并且通讯双方各自cache一份header fields表，避免了重复header的传输</li>
<li><strong>QUIC:</strong> 目前版本采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="noopener">HPACK</a>算法对请求头/响应头进行压缩</li>
<li><strong>HTTP/1.1、HTTP/2:</strong> 支持<code>Cache-Control</code>用于控制资源有效时间,支持<code>Last-Modified</code>来控制资源是否可复用</li>
<li><strong>Facebook geek方案:</strong>  将<code>expiration time</code>全部设置为1年，所有的资源请求链接，都采用概念性的连接(在请求链接后加上资源名的md5，再做mapping)(只要资源不变化链接就不变化)，保证已下载资源能被有效利用的同时，避免重复检测资源有效性</li>
<li><strong>浏览器优化:</strong> Facebook联系Chrome与Firefox，针对复用资源可复用检测频率进行调整(如firefox支持在<code>cache-control</code>中的<code>immutable</code>关键字表示资源不可变不用重复检测)</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>HTTP/1:</strong> 请求头未做压缩，不支持<code>Cache-Control</code>与<code>Last-Modified</code>因此存在冗余资源重复下载问题</li>
<li><strong>HTTP/1.1:</strong> 请求头未做压缩</li>
</ul>
<h4 id="4-预准备"><a href="#4-预准备" class="headerlink" title="4. 预准备"></a>4. 预准备</h4><ul>
<li><strong>Taobao:</strong> DNS-Prefetch、Preconnect、Prefetch、Flush HTML early、PreRender</li>
<li><strong>SPDY、HTTP/2、QUIC:</strong>: 允许服务端主动推服务端认为客户端需要的静态资源</li>
</ul>
<h4 id="5-负载均衡、超时策略优化与其他"><a href="#5-负载均衡、超时策略优化与其他" class="headerlink" title="5. 负载均衡、超时策略优化与其他"></a>5. 负载均衡、超时策略优化与其他</h4><ul>
<li><strong>负载均衡:</strong> 收益较小的长连接，带来服务端没必要的性能开销</li>
<li><strong>超时策略:</strong> 策略性的调整建连与维连时的超时重连的频率、时间、IP/端口，来应对弱网状况，何时快速放弃节约资源(无网状态)，何时找到可用资源快速恢复连接(被劫持、服务器某端口/IP故障、基站繁忙、连接信号弱、丢包率高)</li>
<li><strong>策略性阻塞:</strong> 根据网络情况、请求数目动态调整连接数来保证吞吐量与稳定性（如SPDY、HTTP/2、QUIC中的多路复用）</li>
<li><strong>DNS:</strong> 结合TTL有效管理本地DNS缓存的有效时间、以及缓存大小来减少DNS查询的阻塞，以及可以通过HTTPDNS优化DNS请求的线路以及来避免DNS被篡改等问题(如果使用okhttp3，可以指定DNS，并且可以为请求设定缓存大小与时间，可以很轻易的实现自己的HTTPDNS)</li>
</ul>
<h3 id="II-常见协议区分"><a href="#II-常见协议区分" class="headerlink" title="II. 常见协议区分"></a>II. 常见协议区分</h3><h4 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1. TCP"></a>1. TCP</h4><blockquote>
<p>关于TCP窗口的研究与学习，请移步<a href="/tcp-window/">TCP窗口</a></p>
</blockquote>
<p>目前应用最广泛的可靠的、有序的、自带问题校验修复(<a href="https://en.wikipedia.org/wiki/Error_detection_and_correction" target="_blank" rel="noopener">error-checked</a>)、传输协议，通常情况下发送端与接收端通过TCP协议来保障数据的可靠到达，中间层通过IP协议来路由数据的传递。</p>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152553.png" alt="tips-net-applicationlayer-diff-2019312152553"></p>
<ul>
<li><strong>建连:</strong> 通过三次握手，保障连接已可靠连接</li>
<li><strong>超时重试:</strong> 通过连接超时重试、读写超时重试机制，来保障连接的稳定性</li>
<li><strong>拥塞控制:</strong> 通过”加性增，乘性减”算法，来保障尽量少的报文传输尽量多的数据的同时，减少丢包重传的概率</li>
<li><strong>校验和:</strong> 通过对TCP/IP头进行”校验和”检查，来保障传输数据与地址信息的可靠</li>
<li><strong>有序性:</strong> 通过”序列号”来鉴别每个字节数据，保证接收端能够有序的重建传输数据，以及校验数据完整性</li>
<li><strong>应答机制:</strong> 每次接收端会发送Acks(Acknowledgements)给发送端告知数据以被接收</li>
<li><strong>断连:</strong> 通过四次挥手，保障连接已可靠断开</li>
</ul>
<h4 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h4><p><strong><code>HTTP1.1</code> vs <code>HTTP1.0</code></strong></p>
<ul>
<li><strong>更灵活缓存处理:</strong> 引入Etag(Entity tag)等目前常用的缓存相关策略</li>
<li><strong>优化带宽使用:</strong> 引入<code>range</code>头域，支持206(Partial Content)，用于数据断点续传。</li>
<li><strong>错误机制更完善:</strong> 引入24个错误状态码，如409(Conflict)请求资源与当前状态冲突； 410(Gone)资源在服务器上被永久删除</li>
<li><strong>Host头处理:</strong> 请求头中必须带上<code>host</code>，否则会报400 Bad Request，为了支持一台服务器上有多台虚拟主机，因此通常一个IP对应了多个域名</li>
<li><strong>长连接:</strong> 默认<code>Connection: keep-alive</code>，以复用已建连通道，不像<code>http1.0</code>每个请求都需要重新创建</li>
</ul>
<h4 id="3-HTTPS"><a href="#3-HTTPS" class="headerlink" title="3. HTTPS"></a>3. HTTPS</h4><p>1994年由 <strong>网景</strong> 提出，并应用在网景导航者浏览器中。最新的HTTPS协议在2000年5月公布的<code>RFC 2818</code>正式确定。</p>
<p>HTTPS协议是基于TLS(Transport Layer Security)/SSL(Secure Sockets Layer)对数据进行加密校验，保障了网络通信中的数据安全。</p>
<p>在当前大陆的网络环境而言，是有效避免运营商劫持的手段。</p>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152610.png" alt="image_1b8ji5se91a1kvn431umcc2vk9.png-44.3kB"></p>
<ul>
<li><strong>SSL与TLS:</strong> 早期HTTPS是通过SSL对数据验证加密，后SSL逐渐演变为现在的TLS，所以大多数为了有效的支持加密，都同时支持了SSL与STL</li>
<li><strong>TLS提高了SSL:</strong> 虽然最早的TLS1.0与SSL3.0非常类似，但是TLS采用HMAC(keyed-Hashing for Message Authentication Code)算法对数据验证相比SSL的MAC(Message Authentication Code)算法会更难破解，并且在其他方面也有一些小的改进</li>
<li><strong>请求端口:</strong> 443</li>
</ul>
<h4 id="4-SPDY"><a href="#4-SPDY" class="headerlink" title="4. SPDY"></a>4. SPDY</h4><blockquote>
<p>读音speedy</p>
</blockquote>
<p>是谷歌开发为了加快网页加载速度的网络协议。</p>
<p>SPDY兼容性: <a href="http://caniuse.com/#feat=spdy" target="_blank" rel="noopener">http://caniuse.com/#feat=spdy</a></p>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152616.png" alt="image_1b8jj8l511lag13eslpm1al918krm.png-23.8kB"></p>
<ul>
<li><strong>采用多路复用(multiplexing):</strong> 多个请求stream共享一个tcp连接， 降低延时、提高带宽利用率</li>
<li><strong>请求优先级:</strong> 允许给每个请求设置优先级，使得重要的请求得到优先响应</li>
<li><strong>TLS/SSL的加密传输:</strong> 强制要求使用TLS/SSL提高数据安全可靠性</li>
<li><strong>压缩<code>请求头/响应头</code>:</strong> 通过DEFLATE或gzip算法进行对<code>请求头/响应头</code>进行压缩</li>
<li><strong>支持Server Push:</strong> 允许服务端主动的推送资源(js、css)给客户端，当分析获知客户端将会需要时，以此利用起空闲带宽</li>
<li><strong>支持Server Hints:</strong> 允许服务端可以在客户端还没有发现将需要哪些资源的时候，主动通知客户端，以便于客户端实现准备好相关资源的缓存</li>
</ul>
<h4 id="5-HTTP-2"><a href="#5-HTTP-2" class="headerlink" title="5. HTTP/2"></a>5. HTTP/2</h4><blockquote>
<p>HTTP/2基于SPDY设计</p>
</blockquote>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152623.png" alt="image_1b90ik3e01di41tgr16hc12ks19uvp.png-129.5kB">
<img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152632.png" alt="image_1b8jku3ol1rbveu4es1tp8rk61j.png-125kB"></p>
<p><strong>HTTP/2 vs SPDY</strong></p>
<ul>
<li><strong>SSL/TLS:</strong> SPDY强制使用SSL/TLS，HTTP/2非强制(但是部分浏览器(如Chrome)不允许，所以目前如果使用HTTP/2最好都配置SSL/TLS)</li>
<li><strong>消息头压缩算法:</strong> HTTP/2消息头压缩算法采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="noopener">HPACK</a>，SPDY采用<a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">DEFLATE</a>，一般情况下HPACK的压缩率会高于DEFLATE</li>
<li><strong>传输格式:</strong> HTTP/2传输采用二进制而非文本，因此HTTP/2中的基本单位是帧, 文本形式众多很难权衡健壮、性能与复杂度，二进制弥补了这个缺陷，并且是无序的帧，最终根据头帧重新组装</li>
<li><strong>继承与优化:</strong> HTTP/2继承并优化了SPDY的多路复用与Server Push</li>
</ul>
<h4 id="6-QUIC"><a href="#6-QUIC" class="headerlink" title="6. QUIC"></a>6. QUIC</h4><ul>
<li>发音<code>quick</code></li>
<li>QUIC 参考了HTTP/2与SPDY</li>
<li>Google在2013年10月第一次在IETF展示QUIC, 2016年7月启动工作群</li>
<li>可靠的，多路复用的基于UDP的网络协议，内置安全加密模块，低延迟、运行在用户空间、开源的新一代网络协议。Google计划在完成后将其服务于所有的Google服务。</li>
</ul>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152640.png" alt>
<img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152646.png" alt></p>
<ul>
<li><strong>减少建连延迟:</strong> 从未访问过服务的情况下1-RTT，其他的可以立马开始传输数据(0-RTT)</li>
<li><strong>拥塞控制:</strong> 提升TCP Cubic拥塞控制</li>
<li><strong>HOL阻塞:</strong> 消除多路复用中的HOL阻塞(head-of-line blocking)</li>
<li><strong>更少的帧消耗:</strong> Quic数据包包含更少的帧，因此更多的数据包可以携带数据</li>
<li><strong>提升丢包重试:</strong> 丢包重试时使用新的序列号以及采用重新加密</li>
<li><strong>安全加密:</strong> 内置的加密模块(支持SNI，因此支持一个IP部署多个证书)，并且是默认打开的，相比TLS更高效的向前加密 - 完成以后，将计划适配到TLS 1.3中</li>
<li><strong>端口:</strong> 使用443端口来处理UDP协议数据 - <a href="https://community.spiceworks.com/topic/601177-port-80-443-udp-traffic-to-google" target="_blank" rel="noopener">Port 80/443 UDP Traffic to Google?</a></li>
<li><strong>其他:</strong> 更好的FEC(Forward error correction)机制、与Connection migration机制</li>
</ul>
<hr>
<ul>
<li><a href="http://lovestblog.cn/blog/2014/05/20/tcp-broken-pipe/" target="_blank" rel="noopener">从tcp原理角度理解Broken pipe和Connection Reset by Peer的区别</a></li>
<li><a href="http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf" target="_blank" rel="noopener">淘宝HTTPS探索</a></li>
<li><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="noopener">HTTP,HTTP/2,SPDY,HTTPS你应该知道的一些事</a></li>
<li><a href="https://docs.google.com/document/d/1lmL9EF6qKrk7gbazY8bIdvq3Pno2Xj_l_YShP40GLQE" target="_blank" rel="noopener">QUIC Geek FAQ</a></li>
<li><a href="https://github.com/google/bbr" target="_blank" rel="noopener">google/bbr</a></li>
<li><a href="http://www.cnblogs.com/mydomain/archive/2013/04/18/3027668.html" target="_blank" rel="noopener">滑动窗口和拥塞窗口简述</a></li>
<li><a href="https://www.zhihu.com/question/53559433" target="_blank" rel="noopener">BBR算法原理 - 李博杰</a></li>
<li><a href="https://www.nanog.org/sites/default/files/meetings/NANOG64/1051/20150603_Rogan_Quic_Next_Generation_v1.pdf" target="_blank" rel="noopener">QUIC - Next generation multiplexed transport over UDP</a></li>
<li><a href="https://code.facebook.com/posts/608854979307125/building-zero-protocol-for-fast-secure-mobile-connections/" target="_blank" rel="noopener">Building Zero protocol for fast, secure mobile connections</a></li>
<li><a href="https://github.com/WeMobileDev/article/blob/master/%E5%9F%BA%E4%BA%8ETLS1.3%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AEmmtls%E4%BB%8B%E7%BB%8D.md" target="_blank" rel="noopener">基于TLS1.3的微信安全通信协议mmtls介绍</a></li>
<li><a href="https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit" target="_blank" rel="noopener">QUIC Wire Layout Specification</a></li>
<li><a href="https://en.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY - Wiki</a></li>
<li><a href="https://code.facebook.com/posts/557147474482256/this-browser-tweak-saved-60-of-requests-to-facebook/" target="_blank" rel="noopener">This browser tweak saved 60% of requests to Facebook</a></li>
<li><a href="http://jiaolonghuang.github.io/2015/08/16/http2/" target="_blank" rel="noopener">HTTP2学习(四)—HTTP2的新特性</a></li>
<li><a href="https://www.chromium.org/spdy/link-headers-and-server-hint" target="_blank" rel="noopener">Server Push and Server Hints</a></li>
<li><a href="https://technet.microsoft.com/en-us/library/cc784450(v=ws.10).aspx" target="_blank" rel="noopener">What is TLS/SSL?</a></li>
<li><a href="http://peering.google.com/#/learn-more/quic" target="_blank" rel="noopener">QUIC - Google-peering</a></li>
<li><a href="https://www.chromium.org/quic" target="_blank" rel="noopener">QUIC教材</a></li>
<li><a href="https://www.youtube.com/watch?v=hQZ-0mXFmk8" target="_blank" rel="noopener">QUIC视频介绍</a></li>
<li><a href="https://tools.keycdn.com/http2-test" target="_blank" rel="noopener">Http2-test</a></li>
<li><a href="https://community.akamai.com/community/web-performance/blog/2015/06/05/useful-tools-for-http2-debugging" target="_blank" rel="noopener">Http2-debug</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-summarize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-summarize/" itemprop="url">
                  网络相关总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:42:21+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="TCP和UDP是否可以绑定同一端口进行通信"><a href="#TCP和UDP是否可以绑定同一端口进行通信" class="headerlink" title="TCP和UDP是否可以绑定同一端口进行通信"></a>TCP和UDP是否可以绑定同一端口进行通信</h3><p>TCP、UDP可以绑定同一端口来进行通信：
网络中可以被命名和寻址的通信端口，是操作系统可分配的一种资源。 
按照OSI七层协议的描述，传输层与网络层在功能上的最大区别是传输层提供进程通信能力。从这个意义上讲，网络通信的最终地址就不仅仅是主机地址了，还包括可以描述进程的某种标识符。为此，TCP/IP协议提出了协议端口（protocol   port，简称端口）的概念，用于标识通信的进程。 端口是一种抽象的软件结构（包括一些数据结构和I/O缓冲区）。应用程序（即进程）通过系统调用与某端口建立连接（binding）后，传输层传给该端口的数据都被相应进程所接收，相应进程发给传输层的数据都通过该端口输出。在TCP/IP协议的实现中，端口操作类似于一般的I/O操作，进程获取一个端口，相当于获取本地唯一的I/O文件，可以用一般的读写原语访问之。 类似于文件描述符，每个端口都拥有一个叫端口号（port   number）的整数型标识符，用于区别不同端口。由于TCP/IP传输层的两个协议TCP和UDP是完全独立的两个软件模块，因此各自的端口号也相互独立，如TCP有一个255号端口，UDP也可以有一个255号端口，二者并不冲突。 </p>
<p>端口号的分配是一个重要问题。有两种基本分配方式：第一种叫全局分配，这是一种集中控制方式，由一个公认的中央机构根据用户需要进行统一分配，并将结果公布于众。第二种是本地分配，又称动态连接，即进程需要访问传输层服务时，向本地操作系统提出申请，操作系统返回一个本地唯一的端口号，进程再通过合适的系统调用将自己与该端口号联系起来（绑扎）。TCP/IP端口号的分配中综合了上述两种方式。TCP/IP将端口号分为两部分，少量的作为保留端口，以全局方式分配给服务进程。因此，每一个标准服务器都拥有一个全局公认的端口（即周知口，well-known   port），即使在不同机器上，其端口号也相同。剩余的为自由端口，以本地方式进行分配。TCP和UDP均规定，小于256的端口号才能作保留端口。</p>
<p> 再讨论一下，一个服务器监控一个端口，比如80端口，它为什么可以建立上成千上万的连接？
首先， 一个TCP连接需要由四元组来形成，即(src_ip,src_port,dst_ip,dst_port)。当一个连接请求过来的时候，服务端调用accept函数，新生成一个socket，这个socket所占用的本地端口依然是80端口。由四元组就很容易分析到了，同一个(src_ip,src_port)，它所对应的(dst_ip,dst_port)可以无穷变化，这样就可以建立很多个客户端的请求了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-http/" itemprop="url">
                  tips-net-http
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:22:25+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-mars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-mars/" itemprop="url">
                  tips-net-mars
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:17:18+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-tcp/" itemprop="url">
                  tips-net-tcp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T16:59:43+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311171945.png" alt="tips-net-tcp-2019311171945"></p>
<p>各个段位说明:</p>
<ul>
<li>源端口和目的端口:　　各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现</li>
<li>序号:　　占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li>
<li>确认号:　　占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号</li>
<li>数据偏移/首部长度:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)</li>
<li>保留:　　占 6 位,保留为今后使用,但目前应置为 0</li>
<li>紧急URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)</li>
<li>确认ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效</li>
<li>PSH(PuSH):　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付</li>
<li>RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接</li>
<li>同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文</li>
<li>终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接</li>
<li>检验和:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部</li>
<li>紧急指针:　　占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li>
<li>选项:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]</li>
<li>填充:　　这是为了使整个首部长度是 4 字节的整数倍</li>
<li>其他选项:<ul>
<li>窗口扩大:　　占 3 字节,其中有一个字节表示移位值 S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小</li>
<li>时间戳:　　占10 字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)</li>
<li>选择确认:　　接收方收到了和前面的字节流不连续的两2字节.如果这些字节的序号都在接收窗口之内,那么接收方就先收下这些数据,但要把这些信息准确地告诉发送方,使发送方不要再重复发送这些已收到的数据</li>
</ul>
</li>
</ul>
<h2 id="数据单位"><a href="#数据单位" class="headerlink" title="数据单位"></a>数据单位</h2><p>TCP 传送的数据单位协议是 TCP 报文段(segment)</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>TCP 是面向连接的传输层协议 每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的（一对一） TCP 提供可靠交付的服务 TCP 提供全双工通信 面向字节流</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的 TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的) TCP 可把太长的数据块划分短一些再传送.TCP 也可等待积累有足够多的字节后再构成报文段发送出去 每一条 TCP 连接有两个端点 TCP 连接的端点不是主机,不是主机的IP 地址,不是应用进程,也不是传输层的协议端口.TCP 连接的端点叫做套接字(socket)或插口</p>
<h2 id="自动重传请求ARQ"><a href="#自动重传请求ARQ" class="headerlink" title="自动重传请求ARQ"></a>自动重传请求ARQ</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)</p>
<h3 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认:"></a>累积确认:</h3><ul>
<li>定义:　　接收方一般采用累积确认的方式.即不必对收到的分组逐个发送确认,而是对按序到达的最后一个分组发送确认,这样就表示：到这个分组为止的所有分组都已正确收到了</li>
<li>优点:　　容易实现,即使确认丢失也不必重传</li>
<li>缺点:　　不能向发送方反映出接收方已经正确收到的所有分组的信息<h3 id="Go-back-N-回退N"><a href="#Go-back-N-回退N" class="headerlink" title="Go-back-N(回退N):"></a>Go-back-N(回退N):</h3>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了.这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li>TCP 连接的每一端都必须设有两个窗口      一个发送窗口和一个接收窗口</li>
<li>TCP 可靠传输机制用字节的序号进行控制.TCP 所有的确认都是基于序号而不是基于报文段</li>
<li>TCP 两端的四个窗口经常处于动态变化之中</li>
<li>TCP连接的往返时间 RTT 也不是固定不变的.需要使用特定的算法估算较为合理的重传时间</li>
</ul>
<h3 id="图释"><a href="#图释" class="headerlink" title="图释"></a>图释</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117259.png" alt="tips-net-tcp-201931117259"></p>
<h2 id="发送缓存"><a href="#发送缓存" class="headerlink" title="发送缓存"></a>发送缓存</h2><h3 id="发送缓存用来暂时存放："><a href="#发送缓存用来暂时存放：" class="headerlink" title="发送缓存用来暂时存放："></a>发送缓存用来暂时存放：</h3><ul>
<li>发送应用程序传送给发送方 TCP 准备发送的数据</li>
<li>TCP 已发送出但尚未收到确认的数据<h3 id="图释-1"><a href="#图释-1" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172637.png" alt="tips-net-tcp-2019311172637"></li>
</ul>
<h2 id="接收缓存"><a href="#接收缓存" class="headerlink" title="接收缓存"></a>接收缓存</h2><h3 id="接收缓存用来暂时存放："><a href="#接收缓存用来暂时存放：" class="headerlink" title="接收缓存用来暂时存放："></a>接收缓存用来暂时存放：</h3><ul>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据<h3 id="图释-2"><a href="#图释-2" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172725.png" alt="tips-net-tcp-2019311172725"></li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口(rwnd)是用于流控的动态缩放可靠滑动的接收与发送窗口，防止发送端发送过快接收端被淹没
对应的还有拥塞窗口(rwnd),是在一个RTT内可以最多一次可发送的报文段数 — 发送方的流量控制</p>
<p>TCP是以报文段(若干字节)为单位，每一个报文段需要一次ACK确认收到，但是其带来的问题很明显，频繁的发送确认等待导致用于确认与等待的时间太长。引入窗口后，发送端只要在窗口内，便不用每次都等待ACK才发送下一个报文段，可以在发送窗口内一次连续发送几个报文段而无需等待ACK</p>
<h3 id="图释-3"><a href="#图释-3" class="headerlink" title="图释:"></a>图释:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172750.png" alt="tips-net-tcp-2019311172750"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点:"></a>特点:</h3><ul>
<li>以字节为单位的滑动窗口</li>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）<h3 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h3></li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程</li>
<li>TCP 要求接收方必须有累积确认的功能,这样可以减小传输开销</li>
</ul>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现:"></a>具体实现:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117296.png" alt="tips-net-tcp-201931117296">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172934.png" alt="tips-net-tcp-2019311172934">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172949.png" alt="tips-net-tcp-2019311172949">
<img src="http://images.wodekouwei.com/tips-net-tcp-201931117305.png" alt="tips-net-tcp-201931117305"></p>
<h3 id="发送窗口与接收窗口的关系"><a href="#发送窗口与接收窗口的关系" class="headerlink" title="发送窗口与接收窗口的关系"></a>发送窗口与接收窗口的关系</h3><p>TCP是双工协议，会话双方都可以同时接收与发送数据，因此双方都同时维护一个发送窗口与接收窗口。</p>
<ul>
<li>接收窗口大小取决于应用、系统、硬件等限制；</li>
<li>发送窗口大小取决于对方接收窗口的大小</li>
</ul>
<h3 id="窗口滑动协定"><a href="#窗口滑动协定" class="headerlink" title="窗口滑动协定"></a>窗口滑动协定</h3><ul>
<li>发送窗口只有在收到窗口内字节的ACK确认，才会滑动其左边界</li>
<li>接收窗口只有在窗口中所有的段都正确收到的情况下，才会滑动其左边界；当有字节未接收，但收到后面的字节的情况下，也会滑动，也不对后续字节确认，确保对方重传未接收字节<h3 id="哪些允许变化"><a href="#哪些允许变化" class="headerlink" title="哪些允许变化"></a>哪些允许变化</h3></li>
<li>最大报文段大小在握手中，就确定了</li>
<li>窗口缩放因子在握手中，就确定了</li>
<li>接收窗口大小在根据本地的处理能力与缓存剩余空间动态调整，通过ACK带给对方当前剩余的接收窗口大小</li>
</ul>
<h2 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311173223.png" alt="tips-net-tcp-2019311173223">
RTT = 传播时间+接收端处理时间+路由器的排队时间(变化较大反应当前网络拥塞情况)</p>
<h2 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h2><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现:"></a>具体实现:</h3><p>TCP 每发送一个报文段,就对这个报文段设置一次计时器.只要计时器设置的重传时间到但还没有收到确认,就要重传这一报文段</p>
<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间:"></a>加权平均往返时间:</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h4><p>TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）,第一次测量到 RTT 样本时,RTTS 值就取为所测量到的 RTT 样本值.以后每测量到一个新的 RTT 样本,就按下式重新计算一次 RTTS：
R</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h4><p>新的 RTTS = ( 1 - α)×(旧的 RTTS)＋α(新的 RTT 样本)</p>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明:"></a>说明:</h4><p>式中,0 ≤ α＜ 1.若α很接近于零,表示 RTT 值更新较慢若选择 α 接近于1,则表示 RTT 值更新较快 RFC 2988 推荐的 α 值为 1/8,即 0.125</p>
<h3 id="超时重传时间RTO"><a href="#超时重传时间RTO" class="headerlink" title="超时重传时间RTO:"></a>超时重传时间RTO:</h3><p>RTO 应略大于上面得出的加权平均往返时间 RTTS. RFC 2988 建议使用下式计算 RTO：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO=RTTS + 4×RTTD</span><br></pre></td></tr></table></figure>

<p>RTTD 是 RTT 的偏差的加权平均值 RFC 2988 建议这样计算 RTTD.第一次测量时,RTTD 值取为测量到的 RTT 样本值的一半.在以后的测量中,则使用下式计算加权平均的 RTTD：</p>
<p><code>新的 RTTD = (1-β)×(旧的RTTD)+β×|RTTS﹣新的 RTT 样本|</code>
β是个小于 1 的系数,其推荐值是 1/4,即 0.25 在计算平均往返时间 RTT 时,只要报文段重传了,就不采用其往返时间样本</p>
<h3 id="修正的Karn算法"><a href="#修正的Karn算法" class="headerlink" title="修正的Karn算法:"></a>修正的Karn算法:</h3><p>报文段每重传一次,就把 RTO 增大一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新的 RTO= γ×(旧的 RTO)</span><br></pre></td></tr></table></figure>

<p>系数γ 的典型值是 2 当不再发生报文段的重传时,才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值</p>
<h3 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h3><ul>
<li>TCP 为每一个连接设有一个持续计时器</li>
<li>只要 TCP 连接的一方收到对方的零窗口通知,就启动持续计时器</li>
<li>若持续计时器设置的时间到期,就发送一个零窗口探测报文段(仅携带 1 字节的数据),而对方就在确认这个探测报文段时给出了现在的窗口值</li>
<li>若窗口仍然是零,则收到这个报文段的一方就重新设置持续计时器</li>
<li>若窗口不是零,则死锁的僵局就可以打破了</li>
</ul>
<h2 id="报文段的发送时机"><a href="#报文段的发送时机" class="headerlink" title="报文段的发送时机"></a>报文段的发送时机</h2><p>TCP 维持一个变量,它等于最大报文段长度 MSS.只要缓存中存放的数据达到 MSS 字节时,就组装成一个 TCP 报文段发送出去 由发送方的应用进程指明要求发送报文段,即 TCP 支持的推送(push)操作 发送方的一个计时器期限到了,这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去</p>
<h2 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h2><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段:"></a>三个阶段:</h3><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立:"></a>连接建立:</h4><h5 id="图释-4"><a href="#图释-4" class="headerlink" title="图释:"></a>图释:</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174443.jpg" alt="tips-net-tcp-2019311174443"></p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>A 的 TCP 向 B 发出连接请求报文段,其首部中的同步位 SYN = 1,并选择序号 seq = x,表明传送数据时的第一个数据字节的序号是 x</li>
<li>B 的 TCP 收到连接请求报文段后,如同意,则发回确认(B 在确认报文段中应使 SYN = 1,使 ACK = 1,其确认号ack = x﹢1,自己选择的序号 seq = y)</li>
<li>A 收到此报文段后向 B 给出确认,其 ACK = 1,确认号 ack = y﹢1(A 的 TCP 通知上层应用进程,连接已经建立,B 的 TCP 收到主机 A 的确认后,也通知其上层应用进程：TCP 连接已经建立)</li>
</ul>
<h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放:"></a>连接释放:</h4><h5 id="图释-5"><a href="#图释-5" class="headerlink" title="图释"></a>图释</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174722.jpg" alt="tips-net-tcp-2019311174722"></p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>数据传输结束后,通信的双方都可释放连接.现在 A 的应用进程先向其 TCP 发出连接释放报文段,并停止再发送数据,主动关闭 TCP 连接(A 把连接释放报文段首部的 FIN = 1,其序号seq = u,等待 B 的确认)</li>
<li>B 发出确认,确认号 ack = u＋1,而这个报文段自己的序号 seq = v(TCP 服务器进程通知高层应用进程.从 A 到 B 这个方向的连接就释放了,TCP 连接处于半关闭状态.B 若发送数据,A 仍要接收)</li>
<li>若 B 已经没有要向 A 发送的数据,其应用进程就通知 TCP 释放连接</li>
<li>A 收到连接释放报文段后,必须发出确认,在确认报文段中 ACK = 1,确认号 ack=w﹢1,自己的序号 seq = u + 1</li>
</ul>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><p>TCP 连接必须经过时间 2MSL 后才真正释放掉(2MSL 的时间的用意 — 为了保证 A 发送的最后一个 ACK 报文段能够到达 B.防止 “已失效的连接请求报文段”出现在本连接中.A 在发送完最后一个 ACK 报文段后,再经过时间 2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失.这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段)</p>
<h5 id="发现丢失确认时候的处理"><a href="#发现丢失确认时候的处理" class="headerlink" title="发现丢失确认时候的处理"></a>发现丢失确认时候的处理</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174940.png" alt="tips-net-tcp-2019311174940"></p>
<h4 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题:"></a>三个问题:</h4><ul>
<li>要使每一方能够确知对方的存在</li>
<li>要允许双方协商一些参数(如最大报文段长度,最大窗口大小,服务质量等)</li>
<li>能够对运输实体资源(如缓存大小,连接表中的项目等)进行分配</li>
</ul>
<h2 id="发送TCP请求客户端"><a href="#发送TCP请求客户端" class="headerlink" title="发送TCP请求客户端"></a>发送TCP请求客户端</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175058.png" alt="tips-net-tcp-2019311175058"></p>
<h2 id="拥塞处理相关概念"><a href="#拥塞处理相关概念" class="headerlink" title="拥塞处理相关概念"></a>拥塞处理相关概念</h2><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口:"></a>拥塞窗口:</h3><ul>
<li>含义:拥塞窗口的大小取决于网络的拥塞程度,并且动态地在变化.发送方让自己的发送窗口等于拥塞窗口.如再考虑到接收方的接收能力,则发送窗口还可能小于拥塞窗口</li>
<li>发送方控制拥塞窗口的原则:只要网络没有出现拥塞,拥塞窗口就再增大一些,以便把更多的分组发送出去.但只要网络出现拥塞,拥塞窗口就减小一些,以减少注入到网络中的分组数</li>
</ul>
<h3 id="乘法减小"><a href="#乘法减小" class="headerlink" title="乘法减小:"></a>乘法减小:</h3><p>是指不论在慢开始阶段还是拥塞避免阶段,只要出现一次超时(即出现一次网络拥塞),就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5</p>
<h3 id="加法增大"><a href="#加法增大" class="headerlink" title="加法增大:"></a>加法增大:</h3><p>是指执行拥塞避免算法后,在收到对所有报文段的确认后(即经过一个往返时间),就把拥塞窗口 cwnd增加一个 MSS 大小,使拥塞窗口缓慢增大,以防止网络过早出现拥塞</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传:"></a>快重传:</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认.这样做可以让发送方及早知道有报文段没有到达接收方,发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311175358.jpg" alt="tips-net-tcp-2019311175358"></p>
<h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复:"></a>快恢复:</h3><p>当发送端收到连续三个重复的确认时,就执行“乘法减小”算法,把慢开始门限 ssthresh 减半.但接下去不执行慢开始算法</p>
<h3 id="发送窗口的上限值"><a href="#发送窗口的上限值" class="headerlink" title="发送窗口的上限值:"></a>发送窗口的上限值:</h3><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个,即应按以下公式确定： 发送窗口的上限值   Min [rwnd, cwnd]</p>
<p>当 rwnd &lt; cwnd 时,是接收方的接收能力限制发送窗口的最大值
当 cwnd &lt; rwnd 时,则是网络的拥塞限制发送窗口的最大值</p>
<h2 id="避免拥塞具体实现"><a href="#避免拥塞具体实现" class="headerlink" title="避免拥塞具体实现"></a>避免拥塞具体实现</h2><h3 id="有滑动窗口了，为什么还要拥塞窗口"><a href="#有滑动窗口了，为什么还要拥塞窗口" class="headerlink" title="有滑动窗口了，为什么还要拥塞窗口"></a>有滑动窗口了，为什么还要拥塞窗口</h3><p>发送方与接收方之间存在多个路由器和速率较慢的链路时，一些中间路由器就必须缓存分组，并可能耗尽缓存，此时便会出现拥塞，这将严重降低了TCP连接的吞吐量，拥塞窗口就是为了防止过多的数据注入到网络中，中间路由无法消化的问题。</p>
<p>TCP的做法是引入拥塞窗口(cwnd)并策略性的调整其大小，如上文提到的发送窗口大小是取滑动窗口大小与拥塞窗口大小的最小值，这个正是用来缓解该问题，下面是拥塞窗口大小变化的策略:</p>
<h4 id="1-慢开始、拥塞控制"><a href="#1-慢开始、拥塞控制" class="headerlink" title="1. 慢开始、拥塞控制"></a>1. 慢开始、拥塞控制</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312133854.png" alt="tips-net-tcp-2019312133854">
其目的是: 拥塞发生时循序减少主机发送到网络的报文数，使得这时路由器有足够的时间消化积压的报文。</p>
<ul>
<li>当主机开发发送数据时，拥塞窗口(cwnd)被初始化为1个报文段，试探性的发送1个字节的报文</li>
<li>每收到一个ACK，拥塞窗口大小就指数的增加报文段数目(1,2,4,16…)</li>
<li>最终到达提前预设的慢开始阀值(ssthresh)，停止使用慢开始算法，改用拥塞避免算法</li>
<li>拥塞避免算法是每经过一个RTT，拥塞窗口就增加一个报文段，即改为线性的增加报文段</li>
<li>最终会出现网络拥塞，比如丢包等情况，停止拥塞避免算法，将慢开始阀值设置为目前拥塞时拥塞窗口大小的一半(但不能小于2)，并重置拥塞窗口大小为1个报文段，开始新的一轮慢开始 </li>
</ul>
<p>慢开始门限 ssthresh 的用法:</p>
<ul>
<li>当 cwnd &lt; ssthresh 时,使用慢开始算法</li>
<li>当 cwnd &gt; ssthresh 时,停止使用慢开始算法而改用拥塞避免算法</li>
<li>当 cwnd = ssthresh 时,既可使用慢开始算法,也可使用拥塞避免算法</li>
</ul>
<h4 id="2-快重传，快恢复"><a href="#2-快重传，快恢复" class="headerlink" title="2. 快重传，快恢复"></a>2. 快重传，快恢复</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134328.png" alt="tips-net-tcp-2019312134328">
其目的是: 减少因为拥塞导致的数据包丢失的重传时间，避免无用的数据到网络</p>
<p>接收方: 如果一个包丢失，后续的包继续发送针对该包的重传请求</p>
<p>发送方: 一旦收到三个一样的确认，判定为拥塞:</p>
<ul>
<li>立即重传该包</li>
<li>开始执行快恢复算法</li>
<li>快恢复是慢开始阀值设置为目前拥塞时拥塞窗口大小的一半；拥塞窗口大小设置为目前设置后的慢开始阀值的大小；执行拥塞避免算法</li>
</ul>
<h2 id="TCP窗口特殊情况"><a href="#TCP窗口特殊情况" class="headerlink" title="TCP窗口特殊情况"></a>TCP窗口特殊情况</h2><h3 id="1-Persistence-timer"><a href="#1-Persistence-timer" class="headerlink" title="1. Persistence timer"></a>1. Persistence timer</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134856.png" alt="tips-net-tcp-2019312134856">
防止丢包导致发送端停留在上次收到的接收窗口大小为0的情况:</p>
<ul>
<li>接收端B: 我的缓存已满，接收窗口为0</li>
<li>发送端A: 停止发送数据, 并启动持续计时器(Persistence timer)</li>
<li>接收端B: 消化完缓存，发送报文给发送端A，我的接收窗口大小为400，但是 这个报文丢了</li>
<li>发送端A: 计时器时间到，发送一个1字节的探测报文</li>
<li>接收端B: 重新发送，接收窗口大小为400</li>
<li>发送端A: 继续发送数据<h3 id="2-应用层每次单字节发送"><a href="#2-应用层每次单字节发送" class="headerlink" title="2. 应用层每次单字节发送"></a>2. 应用层每次单字节发送</h3>单个发送字节，然后等待一个确认，再发送一个字节，这样为一个字节添加40个字节头的做法，无疑增加了网络中许多不必要的报文，该问题TCP层的解决方案:</li>
</ul>
<p>发送方采用Nagle算法:</p>
<ul>
<li>若应用层是逐个字节把数据送到TCP，那么TCP不会逐个的发送，而是先发送第一个数据字节，然后缓存剩余的</li>
<li>在收到第一个字节的ACK获知网络情况与对方的接收窗口大小后，把缓存的剩余字节组成合适的报文发送出去</li>
<li>到达的数据达到发送窗口大小的一半或者报文段的最大长度时，立即发送</li>
</ul>
<p>接收方的做法:</p>
<ul>
<li>等待本地有足够的缓存空间容纳一个报文段，或者等到本地的缓存空间有一半空闲的时候，再通知发送端发送数据。</li>
</ul>
<h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p>说明:</p>
<ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名.状态之间的箭头表示可能发生的状态变迁</li>
<li>箭头旁边的字,表明引起这种变迁的原因,或表明发生状态变迁后又出现什么动作</li>
<li>图中有三种不同的箭头<ul>
<li>粗实线箭头表示对客户进程的正常变迁</li>
<li>粗虚线箭头表示对服务器进程的正常变迁</li>
<li>另一种细线箭头表示异常变迁</li>
</ul>
</li>
</ul>
<p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175949.png" alt="tips-net-tcp-2019311175949"></p>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><h4 id="什么是MTU-Maximum-Transmit-Unit"><a href="#什么是MTU-Maximum-Transmit-Unit" class="headerlink" title="什么是MTU(Maximum Transmit Unit)"></a>什么是MTU(Maximum Transmit Unit)</h4><p>由于以太网传输的限制，每个以太网网数据帧的大小都是落在在区间[64Bytes,1518Bytes]中的，不在区间内的一般会被视为错误的数据帧，以太网转发设备直接丢弃。而根据以太网每帧的数据构成，除去固定的部分，留给上层协议的只有Data域的1500Bytes，我们将它称为MTU。</p>
<p>以太网(Ethernet II)每帧的数据构成: 目的Mac地址(DMAC)+源Mac地址(SMAC)+类型(Type)+数据(Data)+校验(CRC) = 6Bytes(48bit)DMAC + 6Bytes(48bit)SMAC + 2Bytes(16bit)Type + 1500BytesData + 4Bytes(24bit)CRC</p>
<h4 id="MTU造成什么影响"><a href="#MTU造成什么影响" class="headerlink" title="MTU造成什么影响"></a>MTU造成什么影响</h4><p>由于一个帧放不下，如IP协议，就会对数据包进行分片处理，这就导致了原本一次可以搞定的，被分为多次，降低传输性能，不过我们可以通过在数据包包头加上DF(DonotFragment)标签来强制不被分片处理。</p>
<p>UDP协议不用关心数据的到达的有序以及正确，因此对分片无特殊要求
TCP协议相反，因此TCP协议本身的最大报文段大小MSS也受MTU影响，通常MSS是: MTU - 20Bytes(IP Header) - 20Bytes(TCP Header)
不过好在绝大多数的网络链路都是1500Bytes的MTU或者更大</p>
<h3 id="什么是MSS-Maximum-Segment-Size"><a href="#什么是MSS-Maximum-Segment-Size" class="headerlink" title="什么是MSS(Maximum Segment Size)"></a>什么是MSS(Maximum Segment Size)</h3><p>TCP的最大报文段大小，只包含TCP Payload(不包含TCP Header与TCP Option)的TCP每次能够传输的最大数据分段的大小，可以用来限制每次发送的字节数。通常大小为1460Bytes(1500BytesMTU - 20Bytes(IP Header) - 20Bytes(TCP Header))</p>
<p>MSS是在TCP建连时确定的，通讯双方会根据双方提供的MSS值，取最小的MSS作为该次连接数据传输的MSS</p>
<h3 id="什么是WS-Window-Scaling"><a href="#什么是WS-Window-Scaling" class="headerlink" title="什么是WS(Window Scaling)"></a>什么是WS(Window Scaling)</h3><p>TCP首部中表示Window Size的字段只有16位，因此按照协议，能表示的最大窗口大小是2^16-1=65535Bytes(64Kb)，因此TCP的选项字段中包含了窗口扩大因子(WS)分别用option-kind、option-length、option-data来表示，这个参数可带可不带，只有在双方都支持的情况下，才会生效。如双方的WS都是256，而后我们ACK Window size value是5，那么此时就可以表示我们的接收窗口是1280Bytes(5*256=1280)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/zhangdaisylove/article/details/47294315" target="_blank" rel="noopener">TCP的滑动窗口与拥塞窗口</a>
<a href="http://blog.chinaunix.net/uid-26275986-id-4109679.html" target="_blank" rel="noopener">计算机网络【七】：可靠传输的实现</a>
<a href="http://blog.csdn.net/cloud323/article/details/77481711" target="_blank" rel="noopener">TCP窗口控制、流控制、拥塞控制</a>
<a href="http://blog.csdn.net/hldjf/article/details/7450565" target="_blank" rel="noopener">也谈一下TCP segment of a reassembled PDU</a>
<a href="https://www.zhihu.com/question/48454744" target="_blank" rel="noopener">TCP流量控制中的滑动窗口大小</a>
<a href="https://my.oschina.net/xinxingegeya/blog/485650" target="_blank" rel="noopener">TCP 滑动窗口（发送窗口和接收窗口）</a>
<a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">TCP协议的滑动窗口具体是怎样控制流量的？</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-nat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-nat/" itemprop="url">
                  tips-net-nat
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T11:05:57+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-NAT"><a href="#1-NAT" class="headerlink" title="1.NAT"></a>1.NAT</h2><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。
这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>
<p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p>
<h3 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h3><p>是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。</p>
<h3 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h3><p>是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p>
<h3 id="端口多路复用（Port-address-Translation-PAT"><a href="#端口多路复用（Port-address-Translation-PAT" class="headerlink" title="端口多路复用（Port address Translation,PAT)"></a>端口多路复用（Port address Translation,PAT)</h3><p>是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。
ALG（Application Level Gateway），即应用程序级网关技术：传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。例如：对于FTP协议的PORT/PASV命令、DNS协议的 “A” 和 “PTR” queries命令和部分ICMP消息类型等都需要相应的ALG来支持。
如果协议数据报文中不包含地址信息，则很容易利用传统的NAT技术来完成透明的地址转换功能，通常我们使用的如下应用就可以直接利用传统的NAT技术：HTTP、TELNET、FINGER、NTP、NFS、ARCHIE、RLOGIN、RSH、RCP等。</p>
<h2 id="2-TCP长连接"><a href="#2-TCP长连接" class="headerlink" title="2.TCP长连接"></a>2.TCP长连接</h2><p>TCP连接建立后只要不明确关闭，逻辑上连接一直存在。
TCP是有保活定时器的，可以打开保活定时器来维持长连接，设置SO_KEEPALIVE才会开启，时间间隔默认7200s，也就是2h，这个默认是关闭的。</p>
<p>注意：HTTP的keepalive和TCP的用处不大一样tcp。</p>
<h2 id="3-NAT超时"><a href="#3-NAT超时" class="headerlink" title="3.NAT超时"></a>3.NAT超时</h2><p>因为 IP v4 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换(Network Address Translation，NAT)。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯。
大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。
长连接心跳间隔必须要小于NAT超时时间(aging-time)，如果超过aging-time不做心跳，TCP长连接链路就会中断，Server就无法发送Push给手机，只能等到客户端下次心跳失败后，重建连接才能取到消息。</p>
<p>因为IPv4地址不足, 或者我们想通过无线路由器上网, 我们的设备可能会处在一个NAT设备的后面, 生活中最常见的NAT设备是家用路由器.
NAT设备会在IP封包通过设备时修改源/目的IP地址. 对于家用路由器来说, 使用的是网络地址端口转换(NAPT), 它不仅改IP, 还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP. 举个例子, NAPT维护一个类似下表的NAT表
|内网地址|    外网地址|
|—|—|
|192.168.0.2:5566|    120.132.92.21:9200|
|192.168.0.3:7788|    120.132.92.21:9201|
|192.168.0.3:8888|    120.132.92.21:9202|</p>
<p>NAT设备会根据NAT表对出去和进来的数据做修改, 比如将192.168.0.3:8888发出去的封包改成120.132.92.21:9202, 外部就认为他们是在和120.132.92.21:9202通信. 同时NAT设备会将120.132.92.21:9202收到的封包的IP和端口改成192.168.0.3:8888, 再发给内网的主机, 这样内部和外部就能双向通信了, 但如果其中192.168.0.3:8888 == 120.132.92.21:9202这一映射因为某些原因被NAT设备淘汰了, 那么外部设备就无法直接与192.168.0.3:8888通信了.</p>
<p>国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断.</p>
<h2 id="4-心跳包"><a href="#4-心跳包" class="headerlink" title="4.心跳包"></a>4.心跳包</h2><ul>
<li>心跳的原因：虽然理论tcp连接后一直不断，但实际上会断网。见：比如 NAT超时，更多 影响TCP连接寿命的因素</li>
<li>心跳包的主要作用是告知对方连接端，我还活着，心还在跳。</li>
<li>心跳时长多少？
　　
现实是残酷的, 根据网上的一些说法, 中移动2/3G下, NAT超时时间为5分钟, 中国电信3G则大于28分钟, 理想的情况下, 客户端应当以略小于NAT超时时间的间隔来发送心跳包.<table>
<thead>
<tr>
<th>地区/网络</th>
<th>NAT超时时间</th>
</tr>
</thead>
<tbody><tr>
<td>中国移动3G和2G</td>
<td>5分钟</td>
</tr>
<tr>
<td>中国联通2G</td>
<td>5分钟</td>
</tr>
<tr>
<td>中国电信3G</td>
<td>大于28分钟</td>
</tr>
<tr>
<td>美国3G</td>
<td>大于28分钟</td>
</tr>
<tr>
<td>台湾3G</td>
<td>大于28分钟</td>
</tr>
</tbody></table>
</li>
</ul>
<p>wifi下, NAT超时时间都会比较长, 据说宽带的网关一般没有空闲释放机制, GCM有些时候在wifi下的心跳比在移动网络下的心跳要快, 可能是因为wifi下联网通信耗费的电量比移动网络下小</p>
<h2 id="5-心跳包和轮询的区别"><a href="#5-心跳包和轮询的区别" class="headerlink" title="5.心跳包和轮询的区别"></a>5.心跳包和轮询的区别</h2><p>心跳包和轮询看起来类似, 都是客户端主动联系服务器, 但是区别很大.</p>
<ul>
<li>轮询是为了获取数据, 而心跳是为了保活TCP连接.</li>
<li>轮询得越频繁, 获取数据就越及时, 心跳的频繁与否和数据是否及时没有直接关系</li>
<li>轮询比心跳能耗更高, 因为一次轮询需要经过TCP三次握手, 四次挥手, 单次心跳不需要建立和拆除TCP连接.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/08/tips-android-net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/08/tips-android-net/" itemprop="url">
                  Android架构之网络优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T17:13:46+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常规的网络框架设计和常用的网络优化方案。</p>
<ol>
<li>网络框架OkHttp</li>
</ol>
<ul>
<li>简洁易用的接口</li>
<li>拦截器机制，网络重试与跳转</li>
<li>连接池复用</li>
</ul>
<ol start="2">
<li>网络加速</li>
</ol>
<ul>
<li>HttpDNS与IP直连</li>
<li>连接加速：短连接复用、Http2多路复用、长连接</li>
</ul>
<ol start="3">
<li>数据压缩与序列化</li>
</ol>
<ul>
<li>Json vs ProtoBuf</li>
<li>压缩算法</li>
<li>序列化</li>
</ul>
<ol start="4">
<li>长连接技术与Mars架构</li>
</ol>
<ul>
<li>智能心跳机制</li>
<li>自动重连</li>
<li>Android跨进程实现</li>
<li>智能唤醒</li>
</ul>
<ol start="5">
<li>如何应对复杂网络</li>
</ol>
<ul>
<li>弱网</li>
<li>网络超时、振荡</li>
<li>404与DNS劫持</li>
</ul>
<ol start="6">
<li>如何保证网络数据安全</li>
</ol>
<ul>
<li>TLS协议，握手与证书</li>
<li>数据签名及校验</li>
</ul>
<p><a href="https://github.com/dhhAndroid/RxWebSocket" target="_blank" rel="noopener">https://github.com/dhhAndroid/RxWebSocket</a></p>
<h3 id="网络错误"><a href="#网络错误" class="headerlink" title="网络错误"></a>网络错误</h3><h4 id="ECONNABORTED"><a href="#ECONNABORTED" class="headerlink" title="ECONNABORTED"></a>ECONNABORTED</h4><p>该错误被描述为“software caused connection abort”，即“软件引起的连接中止”。原因在于当服务和客户进程在完成用于 TCP 连接的“三次握手”后，客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用accept。 
SocketException: Software caused connection abort: recv failed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Linux system */  </span><br><span class="line">  </span><br><span class="line">include/asm-alpha/errno.h:#define ECONNABORTED 53 /* Software caused connection </span><br><span class="line">abort */  </span><br><span class="line">include/asm-generic/errno.h:#define ECONNABORTED 103 /* Software caused </span><br><span class="line">connection abort */  </span><br><span class="line">include/asm-mips/errno.h:#define ECONNABORTED 130 /* Software caused connection </span><br><span class="line">abort */</span><br></pre></td></tr></table></figure>

<p>导致这个异常出现的根本原因可能有多个，
在服务端/客户端单方面关闭连接的情况下,另一方依然以为 tcp连接仍然建立,试图读取对方的响应数据,导致出现 Software caused connection abort: recv failed的异常. 
可能是是防火墙的原因。</p>
<h4 id="ECONNRESET"><a href="#ECONNRESET" class="headerlink" title="ECONNRESET"></a>ECONNRESET</h4><p>该错误被描述为“connection reset by peer”，即“对方复位连接”，这种情况一般发生在服务进程较客户进程提前终止。当服务进程终止时会向客户 TCP 发送 FIN 分节，客户 TCP 回应 ACK，服务 TCP 将转入 FIN_WAIT2 状态。此时如果客户进程没有处理该 FIN （如阻塞在其它调用上而没有关闭 Socket 时），则客户 TCP 将处于 CLOSE_WAIT 状态。当客户进程再次向 FIN_WAIT2 状态的服务 TCP 发送数据时，则服务 TCP 将立刻响应 RST。一般来说，这种情况还可以会引发另外的应用程序异常，客户进程在发送完数据后，往往会等待从网络IO接收数据，很典型的如 read 或 readline 调用，此时由于执行时序的原因，如果该调用发生在 RST 分节收到前执行的话，那么结果是客户进程会得到一个非预期的 EOF 错误。此时一般会输出“server terminated prematurely”－“服务器过早终止”错误。</p>
<h4 id="EPIPE"><a href="#EPIPE" class="headerlink" title="EPIPE"></a>EPIPE</h4><p>错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。</p>
<h4 id="ETIMEDOUT"><a href="#ETIMEDOUT" class="headerlink" title="ETIMEDOUT"></a>ETIMEDOUT</h4><p>错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。</p>
<h4 id="ENOPROTOOPT"><a href="#ENOPROTOOPT" class="headerlink" title="ENOPROTOOPT"></a>ENOPROTOOPT</h4><p>该错误不是一个 Socket 连接相关的错误。errno 给出该值可能由于，通过 getsockopt 系统调用来获得一个套接字的当前选项状态时，如果发现了系统不支持的选项参数就会引发该错误。
getsockopt/setsockopt(2) man page 写道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getsockopt, setsockopt -- get and set options on sockets.</span><br><span class="line"></span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int getsockopt(int socket, int level, int option_name,</span><br><span class="line">void *restrict option_value, socklen_t *restrict option_len);</span><br><span class="line"></span><br><span class="line">int setsockopt(int socket, int level, int option_name,</span><br><span class="line">const void *option_value, socklen_t option_len);</span><br><span class="line"></span><br><span class="line">Getsockopt() and setsockopt() manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost &quot;socket&quot; level.</span><br></pre></td></tr></table></figure>

<p> 此外，getsockopt 和 setsockopt 还可能引发以下错误：</p>
<p>getsockopt/setsockopt(2) man page 写道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ERRORS</span><br><span class="line"></span><br><span class="line">The getsockopt() and setsockopt() system calls will succeed unless:</span><br><span class="line"></span><br><span class="line">[EBADF] The argument socket is not a valid file descriptor.</span><br><span class="line">[EFAULT] The address pointed to by option_value is not in a valid part of the process dress space. For getsockopt(), this error may also be returned if option_len is not in a valid part of the process address space.</span><br><span class="line">[EINVAL] The option is invalid at the level indicated.</span><br><span class="line">[ENOBUFS]Insufficient memory buffers are available.</span><br><span class="line">[ENOPROTOOPT] The option is unknown at the level indicated.</span><br><span class="line">[ENOTSOCK] The argument socket is not a socket (e.g., a plain file).</span><br><span class="line"></span><br><span class="line">The setsockopt() system call will succeed unless:</span><br><span class="line"></span><br><span class="line">[EDOM] The argument option_value is out of bounds.</span><br><span class="line">[EISCONN]socket is already connected and a specified option cannot be set while this is the case.</span><br></pre></td></tr></table></figure>

<h4 id="ECONNEREFUSED"><a href="#ECONNEREFUSED" class="headerlink" title="ECONNEREFUSED"></a>ECONNEREFUSED</h4><p>A “connect failed: ECONNREFUSED (Connection refused)” most likely means that there is nothing listening on that port AND that IP address. Possible explanations include:</p>
<ul>
<li>the service has crashed or hasn’t been started,</li>
<li>your client is trying to connect using the wrong IP address or port, or</li>
<li>server access is being blocked by a firewall that is “refusing” on the server/service’s behalf. This is pretty unlikely given that normal practice (these days) is for firewalls to “blackhole” all unwanted connection attempts.</li>
<li>The server couldn’t send a response: Ensure that the backend is working properly at IP and port mentioned.</li>
<li>SSL connections are being blocked: Fix this by importing SSL certificates</li>
<li>Cookies not being sent</li>
<li>Request timeout: Change request timeout</li>
</ul>
<h3 id="The-java-net-SocketException-is-thrown-when-there-is-an-error-creating-or-accessing-a-socket-such-as-TCP-This-usually-can-be-caused-when-the-server-has-terminated-the-connection-without-properly-closing-it-so-before-getting-the-full-response-In-most-cases-this-can-be-caused-either-by-the-timeout-issue-e-g-the-response-takes-too-much-time-or-server-is-overloaded-with-the-requests-or-the-client-sent-the-SYN-but-it-didn’t-receive-ACK-acknowledgment-of-the-connection-termination-For-timeout-issues-you-can-consider-increasing-the-timeout-value"><a href="#The-java-net-SocketException-is-thrown-when-there-is-an-error-creating-or-accessing-a-socket-such-as-TCP-This-usually-can-be-caused-when-the-server-has-terminated-the-connection-without-properly-closing-it-so-before-getting-the-full-response-In-most-cases-this-can-be-caused-either-by-the-timeout-issue-e-g-the-response-takes-too-much-time-or-server-is-overloaded-with-the-requests-or-the-client-sent-the-SYN-but-it-didn’t-receive-ACK-acknowledgment-of-the-connection-termination-For-timeout-issues-you-can-consider-increasing-the-timeout-value" class="headerlink" title="The java.net.SocketException is thrown when there is an error creating or accessing a socket (such as TCP). This usually can be caused when the server has terminated the connection (without properly closing it), so before getting the full response. In most cases this can be caused either by the timeout issue (e.g. the response takes too much time or server is overloaded with the requests), or the client sent the SYN, but it didn’t receive ACK (acknowledgment of the connection termination). For timeout issues, you can consider increasing the timeout value."></a>The java.net.SocketException is thrown when there is an error creating or accessing a socket (such as TCP). This usually can be caused when the server has terminated the connection (without properly closing it), so before getting the full response. In most cases this can be caused either by the timeout issue (e.g. the response takes too much time or server is overloaded with the requests), or the client sent the SYN, but it didn’t receive ACK (acknowledgment of the connection termination). For timeout issues, you can consider increasing the timeout value.</h3><p>The Socket Exception usually comes with the specified detail message about the issue.</p>
<p>Example of detailed messages:</p>
<p>Software caused connection abort: recv failed.</p>
<p>The error indicates an attempt to send the message and the connection has been aborted by your server. If this happened while connecting to the database, this can be related to using not compatible Connector/J JDBC driver.</p>
<p>Possible solution: Make sure you’ve proper libraries/drivers in your CLASSPATH.</p>
<p>Software caused connection abort: connect.</p>
<p>This can happen when there is a problem to connect to the remote. For example due to virus-checker rejecting the remote mail requests.</p>
<p>Possible solution: Check Virus scan service whether it’s blocking the port for the outgoing requests for connections.</p>
<p>Software caused connection abort: socket write error.</p>
<p>Possible solution: Make sure you’re writing the correct length of bytes to the stream. So double check what you’re sending. See this thread.</p>
<p>Connection reset by peer: socket write error / Connection aborted by peer: socket write error</p>
<p>The application did not check whether keep-alive connection had been timed out on the server side.</p>
<p>Possible solution: Ensure that the HttpClient is non-null before reading from the connection.E13222_01</p>
<p>Connection reset by peer.</p>
<p>The connection has been terminated by the peer (server).</p>
<p>Connection reset.</p>
<p>The connection has been either terminated by the client or closed by the server end of the connection due to request with the request.</p>
<p><a href="https://stackoverflow.com/q/585599/55075" target="_blank" rel="noopener">What’s causing my java.net.SocketException: Connection reset?</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/07/tips-android-sharedpreferences/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/07/tips-android-sharedpreferences/" itemprop="url">
                  Android SharedPreference详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T12:17:40+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SharedPreferences作为一种数据持久化的方式，是处理简单的key-value类型数据时的首选。</p>
<h3 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法:"></a>一般用法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//demo是该sharedpreference对应文件名,对应的是一个xml文件,里面存放key-value格式的数据.</span><br><span class="line">SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;demo&quot;, MODE_WORLD_WRITEABLE);</span><br><span class="line">//提供了getXXX的读取数据方法</span><br><span class="line">boolean xxx = sharedPreferences.getBoolean(&quot;xxx&quot;, false);</span><br><span class="line">//通过Editor提供了putXXX系列的存储方法,调用完需要使用apply()或commit()使之生效,不同点后面介绍</span><br><span class="line">SharedPreferences.Editor edit = sharedPreferences.edit();</span><br><span class="line">edit.putBoolean(&quot;xxx&quot;, true);</span><br><span class="line">edit.apply();//使存储生效</span><br><span class="line">//edit.commit();//使存储生效</span><br></pre></td></tr></table></figure>

<p>每个SharedPreferences都对应了当前package的<code>data/data/package_name/share_prefs/</code>目录下的一个文件</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>Context.java中getSharedPreferences接口说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Retrieve and hold the contents of the preferences file &apos;name&apos;, returning</span><br><span class="line">     * a SharedPreferences through which you can retrieve and modify its</span><br><span class="line">     * values.  Only one instance of the SharedPreferences object is returned</span><br><span class="line">     * to any callers for the same name, meaning they will see each other&apos;s</span><br><span class="line">     * edits as soon as they are made.</span><br><span class="line">     *</span><br><span class="line">     * @param name Desired preferences file. If a preferences file by this name</span><br><span class="line">     * does not exist, it will be created when you retrieve an</span><br><span class="line">     * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).</span><br><span class="line">     * @param mode Operating mode.  Use 0 or &#123;@link #MODE_PRIVATE&#125; for the</span><br><span class="line">     * default operation, &#123;@link #MODE_WORLD_READABLE&#125;</span><br><span class="line">     * and &#123;@link #MODE_WORLD_WRITEABLE&#125; to control permissions.</span><br><span class="line">     *</span><br><span class="line">     * @return The single &#123;@link SharedPreferences&#125; instance that can be used</span><br><span class="line">     *         to retrieve and modify the preference values.</span><br><span class="line">     *</span><br><span class="line">     * @see #MODE_PRIVATE</span><br><span class="line">     * @see #MODE_WORLD_READABLE</span><br><span class="line">     * @see #MODE_WORLD_WRITEABLE</span><br><span class="line">     */</span><br><span class="line">    public abstract SharedPreferences getSharedPreferences(String name,</span><br><span class="line">            int mode);</span><br></pre></td></tr></table></figure>

<p>ContextImpl中getSharedPreferences实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">        SharedPreferencesImpl sp;</span><br><span class="line">        synchronized (ContextImpl.class) &#123;</span><br><span class="line">            if (sSharedPrefs == null) &#123;</span><br><span class="line">                sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String packageName = getPackageName();</span><br><span class="line">            ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</span><br><span class="line">            if (packagePrefs == null) &#123;</span><br><span class="line">                packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</span><br><span class="line">                sSharedPrefs.put(packageName, packagePrefs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // At least one application in the world actually passes in a null</span><br><span class="line">            // name.  This happened to work because when we generated the file name</span><br><span class="line">            // we would stringify it to &quot;null.xml&quot;.  Nice.</span><br><span class="line">            if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">                    Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                if (name == null) &#123;</span><br><span class="line">                    name = &quot;null&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp = packagePrefs.get(name);</span><br><span class="line">            if (sp == null) &#123;</span><br><span class="line">                File prefsFile = getSharedPrefsFile(name);</span><br><span class="line">                sp = new SharedPreferencesImpl(prefsFile, mode);</span><br><span class="line">                packagePrefs.put(name, sp);</span><br><span class="line">                return sp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            // If somebody else (some other process) changed the prefs</span><br><span class="line">            // file behind our back, we reload it.  This has been the</span><br><span class="line">            // historical (if undocumented) behavior.</span><br><span class="line">            sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">        &#125;</span><br><span class="line">        return sp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码里，我们可以看出，</p>
<ol>
<li>SharedPreferencesImpl是保存在全局个map cache里的，只会创建一次。</li>
<li>MODE_MULTI_PROCESS模式下，每次获取都会尝试去读取文件reload。当然会有一些逻辑尽量减少读取次数，比如当前是否有正在进行的读取操作，文件的修改时间和大小与上次有没有变化等。</li>
</ol>
<p>Context.java中提供了以下四种mode:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//这是默认模式，仅caller uid的进程可访问</span><br><span class="line">/**</span><br><span class="line">     * File creation mode: the default mode, where the created file can only</span><br><span class="line">     * be accessed by the calling application (or all applications sharing the</span><br><span class="line">     * same user ID).</span><br><span class="line">     * @see #MODE_WORLD_READABLE</span><br><span class="line">     * @see #MODE_WORLD_WRITEABLE</span><br><span class="line">     */</span><br><span class="line">int MODE_PRIVATE = 0x0000;</span><br><span class="line"></span><br><span class="line">//所有人可写，也就是任何应用都可修改它，这是极其危险的，因此改选项已被Deprected</span><br><span class="line">/**</span><br><span class="line">     * @deprecated Creating world-readable files is very dangerous, and likely</span><br><span class="line">     * to cause security holes in applications.  It is strongly discouraged;</span><br><span class="line">     * instead, applications should use more formal mechanism for interactions</span><br><span class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</span><br><span class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</span><br><span class="line">     * access mode will remain on a file, such as when it goes through a</span><br><span class="line">     * backup and restore.</span><br><span class="line">     * File creation mode: allow all other applications to have read access</span><br><span class="line">     * to the created file.</span><br><span class="line">     * @see #MODE_PRIVATE</span><br><span class="line">     * @see #MODE_WORLD_WRITEABLE</span><br><span class="line">     */</span><br><span class="line">int MODE_WORLD_READABLE = 0x0001; </span><br><span class="line"></span><br><span class="line">//所有人可读，这个参数同样非常危险，可能导致隐私数据泄漏</span><br><span class="line">/**</span><br><span class="line">     * @deprecated Creating world-writable files is very dangerous, and likely</span><br><span class="line">     * to cause security holes in applications.  It is strongly discouraged;</span><br><span class="line">     * instead, applications should use more formal mechanism for interactions</span><br><span class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</span><br><span class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</span><br><span class="line">     * access mode will remain on a file, such as when it goes through a</span><br><span class="line">     * backup and restore.</span><br><span class="line">     * File creation mode: allow all other applications to have write access</span><br><span class="line">     * to the created file.</span><br><span class="line">     * @see #MODE_PRIVATE</span><br><span class="line">     * @see #MODE_WORLD_READABLE</span><br><span class="line">     */</span><br><span class="line">int MODE_WORLD_READABLE = 0x0002</span><br><span class="line"></span><br><span class="line">//设置该参数后，每次获取对应的SharedPreferences时都会尝试从磁盘中读取修改过的文件 </span><br><span class="line">/**</span><br><span class="line">     * SharedPreference loading flag: when set, the file on disk will</span><br><span class="line">     * be checked for modification even if the shared preferences</span><br><span class="line">     * instance is already loaded in this process.  This behavior is</span><br><span class="line">     * sometimes desired in cases where the application has multiple</span><br><span class="line">     * processes, all writing to the same SharedPreferences file.</span><br><span class="line">     * Generally there are better forms of communication between</span><br><span class="line">     * processes, though.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This was the legacy (but undocumented) behavior in and</span><br><span class="line">     * before Gingerbread (Android 2.3) and this flag is implied when</span><br><span class="line">     * targetting such releases.  For applications targetting SDK</span><br><span class="line">     * versions &lt;em&gt;greater than&lt;/em&gt; Android 2.3, this flag must be</span><br><span class="line">     * explicitly set if desired.</span><br><span class="line">     *</span><br><span class="line">     * @see #getSharedPreferences</span><br><span class="line">     *</span><br><span class="line">     * @deprecated MODE_MULTI_PROCESS does not work reliably in</span><br><span class="line">     * some versions of Android, and furthermore does not provide any</span><br><span class="line">     * mechanism for reconciling concurrent modifications across</span><br><span class="line">     * processes.  Applications should not attempt to use it.  Instead,</span><br><span class="line">     * they should use an explicit cross-process data management</span><br><span class="line">     * approach such as &#123;@link android.content.ContentProvider ContentProvider&#125;.</span><br><span class="line">     */</span><br><span class="line">int MODE_MULTI_PROCESS = 0x0004;</span><br></pre></td></tr></table></figure>

<h4 id="MODE-MULTI-PROCESS"><a href="#MODE-MULTI-PROCESS" class="headerlink" title="MODE_MULTI_PROCESS"></a>MODE_MULTI_PROCESS</h4><p>当设置MODE_MULTI_PROCESS这个参数的时候，即使当前进程内已经创建了该SharedPreferences，仍然在每次获取的时候都会尝试从本地文件中刷新。在同一个进程中，同一个文件只有一个实例。MODE_MULTI_PROCESS的作用如上getSharedPreferences实现.这个方法先判断是否已创建SharedPreferences实例，若未创建，则先创建。之后判断mode如果为MODE_MULTI_PROCESS, 则调用startReloadIfChangeUnexpectedly()，看下其实现:
SharedPreferencesImpl.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void startReloadIfChangedUnexpectedly() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // TODO: wait for any pending writes to disk?</span><br><span class="line">            if (!hasFileChangedUnexpectedly()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            startLoadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLoaded = false;</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (SharedPreferencesImpl.this) &#123;</span><br><span class="line">                    loadFromDiskLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出MODE_MULTI_PROCESS的作用就是在每次获取SharedPreferences实例的时候尝试从磁盘中加载修改过的数据，并且读取是在异步线程中，因此一个线程的修改最终会反映到另一个线程，但不能立即反映到另一个进程，所以通过SharedPreferences无法实现多进程同步。
综合: 如果仅仅让多进程可访问同一个SharedPref文件，不需要设置MODE_MULTI_PROCESS, 如果需要实现多进程同步，必须设置这个参数，但也只能实现最终一致，无法即时同步。</p>
<p><strong>由于SharedPreference内容都会在内存里存一份，所以不要使用SharedPreference保存较大的内容，避免不必要的内存浪费。</strong></p>
<p>注意有一个锁mLoaded ,在对SharedPreference做其他操作时，都必须等待该锁释放:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            awaitLoadedLocked();</span><br><span class="line">            String v = (String)mMap.get(key);</span><br><span class="line">            return v != null ? v : defValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>写操作有两个commit apply 。 commit 是同步的，写入内存的同时会等待写入文件完成，apply是异步的，先写入内存，在异步线程里再写入文件。apply肯定要快一些,优先推荐使用apply:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Commit your preferences changes back from this Editor to the</span><br><span class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</span><br><span class="line">         * performs the requested modifications, replacing whatever is currently</span><br><span class="line">         * in the SharedPreferences.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</span><br><span class="line">         * time, the last one to call commit wins.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;If you don&apos;t care about the return value and you&apos;re</span><br><span class="line">         * using this from your application&apos;s main thread, consider</span><br><span class="line">         * using &#123;@link #apply&#125; instead.</span><br><span class="line">         *</span><br><span class="line">         * @return Returns true if the new values were successfully written</span><br><span class="line">         * to persistent storage.</span><br><span class="line">         */</span><br><span class="line">        boolean commit();</span><br><span class="line">        /**</span><br><span class="line">         * Commit your preferences changes back from this Editor to the</span><br><span class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</span><br><span class="line">         * performs the requested modifications, replacing whatever is currently</span><br><span class="line">         * in the SharedPreferences.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</span><br><span class="line">         * time, the last one to call apply wins.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out</span><br><span class="line">         * to persistent storage synchronously, &#123;@link #apply&#125;</span><br><span class="line">         * commits its changes to the in-memory</span><br><span class="line">         * &#123;@link SharedPreferences&#125; immediately but starts an</span><br><span class="line">         * asynchronous commit to disk and you won&apos;t be notified of</span><br><span class="line">         * any failures.  If another editor on this</span><br><span class="line">         * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125;</span><br><span class="line">         * while a &#123;@link #apply&#125; is still outstanding, the</span><br><span class="line">         * &#123;@link #commit&#125; will block until all async commits are</span><br><span class="line">         * completed as well as the commit itself.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within</span><br><span class="line">         * a process, it&apos;s safe to replace any instance of &#123;@link #commit&#125; with</span><br><span class="line">         * &#123;@link #apply&#125; if you were already ignoring the return value.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;You don&apos;t need to worry about Android component</span><br><span class="line">         * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt;</span><br><span class="line">         * writing to disk.  The framework makes sure in-flight disk</span><br><span class="line">         * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching</span><br><span class="line">         * states.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p class=&apos;note&apos;&gt;The SharedPreferences.Editor interface</span><br><span class="line">         * isn&apos;t expected to be implemented directly.  However, if you</span><br><span class="line">         * previously did implement it and are now getting errors</span><br><span class="line">         * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call</span><br><span class="line">         * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;.</span><br><span class="line">         */</span><br><span class="line">        void apply();</span><br></pre></td></tr></table></figure>

<p>注册/解注册sharedpreference变动监听:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Registers a callback to be invoked when a change happens to a preference.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p class=&quot;caution&quot;&gt;&lt;strong&gt;Caution:&lt;/strong&gt; The preference manager does</span><br><span class="line">     * not currently store a strong reference to the listener. You must store a</span><br><span class="line">     * strong reference to the listener, or it will be susceptible to garbage</span><br><span class="line">     * collection. We recommend you keep a reference to the listener in the</span><br><span class="line">     * instance data of an object that will exist as long as you need the</span><br><span class="line">     * listener.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param listener The callback that will run.</span><br><span class="line">     * @see #unregisterOnSharedPreferenceChangeListener</span><br><span class="line">     */</span><br><span class="line">    void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Unregisters a previous callback.</span><br><span class="line">     * </span><br><span class="line">     * @param listener The callback that should be unregistered.</span><br><span class="line">     * @see #registerOnSharedPreferenceChangeListener</span><br><span class="line">     */</span><br><span class="line">    void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</span><br></pre></td></tr></table></figure>

<h4 id="为什么不推荐使用MODE-MULTI-PROCESS"><a href="#为什么不推荐使用MODE-MULTI-PROCESS" class="headerlink" title="为什么不推荐使用MODE_MULTI_PROCESS?"></a>为什么不推荐使用MODE_MULTI_PROCESS?</h4><p>android文档已经Deprected了这个flag，并且说明不应该通过SharedPreference做进程间数据共享？这是为啥呢？从前面但分析可看到当设置这个flag后，每次获取(获取而不是初次创建)SharedPreferences实例的时候，会判断shared_pref文件是否修改过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private boolean hasFileChangedUnexpectedly() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mDiskWritesInFlight &gt; 0) &#123;</span><br><span class="line">                // If we know we caused it, it&apos;s not unexpected.</span><br><span class="line">                if (DEBUG) Log.d(TAG, &quot;disk write in flight, not unexpected.&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final StructStat stat;</span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Metadata operations don&apos;t usually count as a block guard</span><br><span class="line">             * violation, but we explicitly want this one.</span><br><span class="line">             */</span><br><span class="line">            BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">            stat = Os.stat(mFile.getPath());</span><br><span class="line">        &#125; catch (ErrnoException e) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里先判断mDiskWritesInFlight&gt;0，如果成立，说明是当前进程修改了文件，不需要重新读取。然后通过文件最后修改时间，判断文件是否修改过。如果修改了，则重新读取:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLoaded = false;</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (SharedPreferencesImpl.this) &#123;</span><br><span class="line">                    loadFromDiskLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadFromDiskLocked() &#123;</span><br><span class="line">        if (mLoaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = null;</span><br><span class="line">        StructStat stat = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            stat = Os.stat(mFile.getPath());</span><br><span class="line">            if (mFile.canRead()) &#123;</span><br><span class="line">                BufferedInputStream str = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    str = new BufferedInputStream(</span><br><span class="line">                            new FileInputStream(mFile), 16*1024);</span><br><span class="line">                    map = XmlUtils.readMapXml(str);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    IoUtils.closeQuietly(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ErrnoException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        mLoaded = true;</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            mMap = map;</span><br><span class="line">            mStatTimestamp = stat.st_mtime;</span><br><span class="line">            mStatSize = stat.st_size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里起码有3个坑！</p>
<ol>
<li>使用MODE_MULTI_PROCESS时，不要保存SharedPreference变量，必须每次都从context.getSharedPreferences 获取。如果你图方便使用变量存了下来，那么无法触发reload，有可能两个进程数据不同步。</li>
<li>前面提到过，load数据是耗时的，并且其他操作会等待该锁。这意味着很多时候获取SharedPreference数据都不得不从文件再读一遍，大大降低了内存缓存的作用。文件读写耗时也影响了性能。</li>
<li>修改数据时得用commit，保证修改时写入了文件，这样其他进程才能通过文件大小或修改时间感知到。</li>
</ol>
<p>重点是这段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (mBackupFile.exists()) &#123;</span><br><span class="line">      mFile.delete();</span><br><span class="line">      mBackupFile.renameTo(mFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新读取时，如果发现存在mBackupFile,则将原文件mFile删除，并将mBackupFile重命名为mFile。mBackupFile又是如何创建的呢？答案是在修改SharedPreferences时将内存中的数据写会磁盘时创建的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</span><br><span class="line">        // Rename the current file so it may be used as a backup during the next read</span><br><span class="line">        if (mFile.exists()) &#123;</span><br><span class="line">            if (!mBackupFile.exists()) &#123;</span><br><span class="line">                if (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                    mcr.setDiskWriteResult(false);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line">        FileUtils.sync(str);</span><br><span class="line">        str.close();</span><br><span class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</span><br><span class="line">        final StructStat stat = Os.stat(mFile.getPath());</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mStatTimestamp = stat.st_mtime;</span><br><span class="line">            mStatSize = stat.st_size;</span><br><span class="line">        &#125;</span><br><span class="line">        // Writing was successful, delete the backup file if there is one.</span><br><span class="line">        mBackupFile.delete();</span><br><span class="line">        mcr.setDiskWriteResult(true);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码只保留了核心流程，忽略了错误处理流程。可以看到，写文件的步骤大致是:</p>
<ol>
<li>将原文件重命名为mBackupFile</li>
<li>重新创建原文件mFile, 并将内容写入其中</li>
<li>删除mBackupFile</li>
</ol>
<p>所以，只有当一个进程正处于写文件的过程中的时候，如果另一个进程读文件，才会看到mBackupFile, 这时候读进程会将mBackupFile重命名为mFile, 这样读结果是，读进程只能读到修改前的文件，同时，由于mBackupFile重命名为了mFile,  所以写进程写那个文件就没有文件名引用了，因此其写入的内容无法再被任何进程访问到。所以其内容丢失了，可认为写入失败了，而SharedPreferences对这种失败情况没有任何重试机制，所以就可能出现数据丢失的情况。
回到这段的重点：为什么不推荐用MODE_MULTI_PROCESS？从前面分析可知，这种模式下，每次获取SharedPreferences都会检测文件是否改变，只要读的时候另一进程在写，就会导致写丢失。这样失败概率就会大幅度提高。反之，若不设置这个模式，则只在第一次创建SharedPreferences的时候读取，导致写失败的概率就会大幅度降低，当然，仍然存在失败的可能。</p>
<h4 id="为什么不做写失败重试？"><a href="#为什么不做写失败重试？" class="headerlink" title="为什么不做写失败重试？"></a>为什么不做写失败重试？</h4><p>为什么android不做写失败重试呢？原因是写进程并不能发现写失败的情况。难道写的过程中，目标文件被删不会抛异常吗？答案是不会。删除文件只是从文件系统中删除了一个节点信息而已，重命名也是新建了一个具有相同名称的节点信息，并把文件地址指向另一个磁盘地址而已，原来，之前的写过程仍然会成功写到原来的磁盘地址。所以目前的实现方案并不能检测到失败。</p>
<h4 id="有没有办法解决写失败呢？"><a href="#有没有办法解决写失败呢？" class="headerlink" title="有没有办法解决写失败呢？"></a>有没有办法解决写失败呢？</h4><p>个人觉得是可以做到的，读里面读那段关键操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (mBackupFile.exists()) &#123;</span><br><span class="line">      mFile.delete();</span><br><span class="line">      mBackupFile.renameTo(mFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mBackupFile存在，意味着当前正处于写读过程中，这时候是不是可以考虑直接读mBackupFile文件，而不删除mFile呢？这样读话，读取效果一样，都是读的mBackupFile，同时写进程写的mFile也不会被mBacupFile覆盖，写也就能成功了。即使通过这段代码重命名，写进程写完后发现mBackupFile不存在了，其实也能认为发生了读重命名，大可以重试一次。</p>
<h3 id="多进程使用SharedPreference方案"><a href="#多进程使用SharedPreference方案" class="headerlink" title="多进程使用SharedPreference方案"></a>多进程使用SharedPreference方案</h3><p>说简单也简单，就是依据google的建议使用ContentProvider了。我看过网上很多的例子，但总是觉得少了点什么</p>
<p>有的方案里将所有读取操作都写作静态方法，没有继承SharedPreference 。 这样做需要强制改变调用者的使用习惯，不怎么好。
大部分方案做成ContentProvider后，所有的调用都走的ContentProvider。但如果调用进程与SharedPreference 本身就是同一个进程，只用走原生的流程就行了，不用拐个弯去访问ContentProvider，减少不必要的性能损耗。</p>
<p>我这里也写了一个跨进程方案，简单介绍如下
SharedPreferenceProxy 继承SharedPreferences。其所有操作都是通过ContentProvider完成。简要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class SharedPreferenceProxy implements SharedPreferences &#123;</span><br><span class="line">@Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">        OpEntry result = getResult(OpEntry.obtainGetOperation(key).setStringValue(defValue));</span><br><span class="line">        return result == null ? defValue : result.getStringValue(defValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Editor edit() &#123;</span><br><span class="line">        return new EditorImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    private OpEntry getResult(@NonNull OpEntry input) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Bundle res = ctx.getContentResolver().call(PreferenceUtil.URI</span><br><span class="line">                    , PreferenceUtil.METHOD_QUERY_VALUE</span><br><span class="line">                    , preferName</span><br><span class="line">                    , input.getBundle());</span><br><span class="line">            return new OpEntry(res);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    public class EditorImpl implements Editor &#123;</span><br><span class="line">        private ArrayList&lt;OpEntry&gt; mModified = new ArrayList&lt;&gt;();</span><br><span class="line">        @Override</span><br><span class="line">        public Editor putString(String key, @Nullable String value) &#123;</span><br><span class="line">            OpEntry entry = OpEntry.obtainPutOperation(key).setStringValue(value);</span><br><span class="line">            return addOps(entry);</span><br><span class="line">        &#125;</span><br><span class="line">       @Override</span><br><span class="line">        public void apply() &#123;</span><br><span class="line">            Bundle intput = new Bundle();</span><br><span class="line">            intput.putParcelableArrayList(PreferenceUtil.KEY_VALUES, convertBundleList());</span><br><span class="line">            intput.putInt(OpEntry.KEY_OP_TYPE, OpEntry.OP_TYPE_APPLY);</span><br><span class="line">            try &#123;</span><br><span class="line">                ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_EIDIT_VALUE, preferName, intput);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>OpEntry只是一个对Bundle操作封装的类。
所有跨进程的操作都是通过SharedPreferenceProvider的call方法完成。SharedPreferenceProvider里会访问真正的SharedPreference</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SharedPreferenceProvider extends ContentProvider&#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, MethodProcess&gt; processerMap = new ArrayMap&lt;&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onCreate() &#123;</span><br><span class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_VALUE, methodQueryValues);</span><br><span class="line">        processerMap.put(PreferenceUtil.METHOD_CONTAIN_KEY, methodContainKey);</span><br><span class="line">        processerMap.put(PreferenceUtil.METHOD_EIDIT_VALUE, methodEditor);</span><br><span class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_PID, methodQueryPid);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;</span><br><span class="line">        MethodProcess processer = processerMap.get(method);</span><br><span class="line">        return processer == null?null:processer.process(arg, extras);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要差别的地方在这里：在调用getSharedPreferences时，会先判断caller的进程pid是否与SharedPreferenceProvider相同。如果不同，则返回SharedPreferenceProxy。如果相同，则返回ctx.getSharedPreferences。只会在第一次调用时进行判断，结果会保存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static SharedPreferences getSharedPreferences(@NonNull Context ctx, String preferName) &#123;</span><br><span class="line">        //First check if the same process</span><br><span class="line">        if (processFlag.get() == 0) &#123;</span><br><span class="line">            Bundle bundle = ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_QUERY_PID, &quot;&quot;, null);</span><br><span class="line">            int pid = 0;</span><br><span class="line">            if (bundle != null) &#123;</span><br><span class="line">                pid = bundle.getInt(PreferenceUtil.KEY_VALUES);</span><br><span class="line">            &#125;</span><br><span class="line">            //Can not get the pid, something wrong!</span><br><span class="line">            if (pid == 0) &#123;</span><br><span class="line">                return getFromLocalProcess(ctx, preferName);</span><br><span class="line">            &#125;</span><br><span class="line">            processFlag.set(Process.myPid() == pid ? 1 : -1);</span><br><span class="line">            return getSharedPreferences(ctx, preferName);</span><br><span class="line">        &#125; else if (processFlag.get() &gt; 0) &#123;</span><br><span class="line">            return getFromLocalProcess(ctx, preferName);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return getFromRemoteProcess(ctx, preferName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static SharedPreferences getFromRemoteProcess(@NonNull Context ctx, String preferName) &#123;</span><br><span class="line">        synchronized (SharedPreferenceProxy.class) &#123;</span><br><span class="line">            if (sharedPreferenceProxyMap == null) &#123;</span><br><span class="line">                sharedPreferenceProxyMap = new ArrayMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            SharedPreferenceProxy preferenceProxy = sharedPreferenceProxyMap.get(preferName);</span><br><span class="line">            if (preferenceProxy == null) &#123;</span><br><span class="line">                preferenceProxy = new SharedPreferenceProxy(ctx.getApplicationContext(), preferName);</span><br><span class="line">                sharedPreferenceProxyMap.put(preferName, preferenceProxy);</span><br><span class="line">            &#125;</span><br><span class="line">            return preferenceProxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static SharedPreferences getFromLocalProcess(@NonNull Context ctx, String preferName) &#123;</span><br><span class="line">        return ctx.getSharedPreferences(preferName, Context.MODE_PRIVATE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样，只有当调用者是正真跨进程时才走的contentProvider。对于同进程的情况，就没有必要走contentProvider了。对调用者来说，这都是透明的，只需要获取SharedPreferences就行了，不用关心获得的是SharedPreferenceProxy，还是SharedPreferenceImpl。即使你当前没有涉及到多进程使用，将所有获取SharedPreference的地方封装并替换后，对当前逻辑也没有任何影响。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/07/flutter-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/07/flutter-introduce/" itemprop="url">
                  Flutter介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T10:19:24+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Flutter是一款由Google开发的开源、跨平台的移动端开发框架，使用Flutter开发出的应用符合不同平台的原生体验，可以让应用看起来跟系统更加协调。
Flutter是一个全新的移动UI框架，它允许使用同一个代码库构建高性能的Android和iOS应用，同时它也是Google即将推出的Fuchsia操作系统的开发平台。通过自定义的Flutter引擎可以将其嵌入到其他平台，旨在帮助开发者使用一套代码开发高性能、高保真的Android和iOS应用。</p>
<h3 id="Flutter优点"><a href="#Flutter优点" class="headerlink" title="Flutter优点"></a>Flutter优点</h3><h4 id="原生性能"><a href="#原生性能" class="headerlink" title="原生性能"></a>原生性能</h4><p>Flutter会以原生的性能提供给开发者，它的开发性能非常接近传统的Native，包括渲染方式、AOT的编译方式和其他优化。</p>
<p>Flutter开发的页面跟Native没有差距。在安卓中低端机型里，基于Flutter开发出来的APP在帧率上会有更流畅的体现，内存占用也会有更低的消耗。</p>
<p><strong>渲染方式,AOT,无锁GC</strong></p>
<h4 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h4><p>Flutter因其本身的跨端性，大幅提升了传统的安卓开发速度。一般认为，前端开发的速度较快，基于Flutter，开发速度比前端更快。
<strong>压秒级,有状态的热重载</strong></p>
<h4 id="统一的应用开发体验"><a href="#统一的应用开发体验" class="headerlink" title="统一的应用开发体验"></a>统一的应用开发体验</h4><p>在跨端层面上，由于Flutter把两端的渲染机制下沉到更低的渲染层，基于统一的C++层的渲染引擎来搭建底层的UI框架，因此，Flutter会让跨端体验得到更一致的效果。
<strong>两端一致的开发方式,MD和IOS风格</strong></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>内存的问题。随着Flutter页面的堆栈变得越来越深，内存的释放并没有得到及时的释放。</li>
<li>字体的问题。不同的字体在不同的机器里渲染的效果非常不一致。</li>
<li>截图会出现黑屏的问题。</li>
<li>图片缓存的问题。跟安卓端的图片缓存是完全不同的体系。</li>
<li>它的暗黑区、适配问题，</li>
<li>私有库、中间件的适配，</li>
<li>不支持反射和序列化，</li>
<li>集成问题,怎么把Native的组件集成到Flutter体系</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg" alt="轻口味">
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">190</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </div></footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
