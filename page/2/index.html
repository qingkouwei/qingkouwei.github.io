<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/page/2/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/page/2/"/>





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-http/" itemprop="url">
                  tips-net-http
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:22:25+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-mars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-mars/" itemprop="url">
                  tips-net-mars
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:17:18+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-tcp/" itemprop="url">
                  tips-net-tcp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T16:59:43+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311171945.png" alt="tips-net-tcp-2019311171945"></p>
<p>各个段位说明:</p>
<ul>
<li>源端口和目的端口:　　各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现</li>
<li>序号:　　占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li>
<li>确认号:　　占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号</li>
<li>数据偏移/首部长度:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)</li>
<li>保留:　　占 6 位,保留为今后使用,但目前应置为 0</li>
<li>紧急URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)</li>
<li>确认ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效</li>
<li>PSH(PuSH):　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付</li>
<li>RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接</li>
<li>同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文</li>
<li>终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接</li>
<li>检验和:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部</li>
<li>紧急指针:　　占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li>
<li>选项:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]</li>
<li>填充:　　这是为了使整个首部长度是 4 字节的整数倍</li>
<li>其他选项:<ul>
<li>窗口扩大:　　占 3 字节,其中有一个字节表示移位值 S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小</li>
<li>时间戳:　　占10 字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)</li>
<li>选择确认:　　接收方收到了和前面的字节流不连续的两2字节.如果这些字节的序号都在接收窗口之内,那么接收方就先收下这些数据,但要把这些信息准确地告诉发送方,使发送方不要再重复发送这些已收到的数据</li>
</ul>
</li>
</ul>
<h2 id="数据单位"><a href="#数据单位" class="headerlink" title="数据单位"></a>数据单位</h2><p>TCP 传送的数据单位协议是 TCP 报文段(segment)</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>TCP 是面向连接的传输层协议 每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的（一对一） TCP 提供可靠交付的服务 TCP 提供全双工通信 面向字节流</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的 TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的) TCP 可把太长的数据块划分短一些再传送.TCP 也可等待积累有足够多的字节后再构成报文段发送出去 每一条 TCP 连接有两个端点 TCP 连接的端点不是主机,不是主机的IP 地址,不是应用进程,也不是传输层的协议端口.TCP 连接的端点叫做套接字(socket)或插口</p>
<h2 id="自动重传请求ARQ"><a href="#自动重传请求ARQ" class="headerlink" title="自动重传请求ARQ"></a>自动重传请求ARQ</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)</p>
<h3 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认:"></a>累积确认:</h3><ul>
<li>定义:　　接收方一般采用累积确认的方式.即不必对收到的分组逐个发送确认,而是对按序到达的最后一个分组发送确认,这样就表示：到这个分组为止的所有分组都已正确收到了</li>
<li>优点:　　容易实现,即使确认丢失也不必重传</li>
<li>缺点:　　不能向发送方反映出接收方已经正确收到的所有分组的信息<h3 id="Go-back-N-回退N"><a href="#Go-back-N-回退N" class="headerlink" title="Go-back-N(回退N):"></a>Go-back-N(回退N):</h3>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了.这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li>TCP 连接的每一端都必须设有两个窗口      一个发送窗口和一个接收窗口</li>
<li>TCP 可靠传输机制用字节的序号进行控制.TCP 所有的确认都是基于序号而不是基于报文段</li>
<li>TCP 两端的四个窗口经常处于动态变化之中</li>
<li>TCP连接的往返时间 RTT 也不是固定不变的.需要使用特定的算法估算较为合理的重传时间</li>
</ul>
<h3 id="图释"><a href="#图释" class="headerlink" title="图释"></a>图释</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117259.png" alt="tips-net-tcp-201931117259"></p>
<h2 id="发送缓存"><a href="#发送缓存" class="headerlink" title="发送缓存"></a>发送缓存</h2><h3 id="发送缓存用来暂时存放："><a href="#发送缓存用来暂时存放：" class="headerlink" title="发送缓存用来暂时存放："></a>发送缓存用来暂时存放：</h3><ul>
<li>发送应用程序传送给发送方 TCP 准备发送的数据</li>
<li>TCP 已发送出但尚未收到确认的数据<h3 id="图释-1"><a href="#图释-1" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172637.png" alt="tips-net-tcp-2019311172637"></li>
</ul>
<h2 id="接收缓存"><a href="#接收缓存" class="headerlink" title="接收缓存"></a>接收缓存</h2><h3 id="接收缓存用来暂时存放："><a href="#接收缓存用来暂时存放：" class="headerlink" title="接收缓存用来暂时存放："></a>接收缓存用来暂时存放：</h3><ul>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据<h3 id="图释-2"><a href="#图释-2" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172725.png" alt="tips-net-tcp-2019311172725"></li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口(rwnd)是用于流控的动态缩放可靠滑动的接收与发送窗口，防止发送端发送过快接收端被淹没
对应的还有拥塞窗口(rwnd),是在一个RTT内可以最多一次可发送的报文段数 — 发送方的流量控制</p>
<p>TCP是以报文段(若干字节)为单位，每一个报文段需要一次ACK确认收到，但是其带来的问题很明显，频繁的发送确认等待导致用于确认与等待的时间太长。引入窗口后，发送端只要在窗口内，便不用每次都等待ACK才发送下一个报文段，可以在发送窗口内一次连续发送几个报文段而无需等待ACK</p>
<h3 id="图释-3"><a href="#图释-3" class="headerlink" title="图释:"></a>图释:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172750.png" alt="tips-net-tcp-2019311172750"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点:"></a>特点:</h3><ul>
<li>以字节为单位的滑动窗口</li>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）<h3 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h3></li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程</li>
<li>TCP 要求接收方必须有累积确认的功能,这样可以减小传输开销</li>
</ul>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现:"></a>具体实现:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117296.png" alt="tips-net-tcp-201931117296">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172934.png" alt="tips-net-tcp-2019311172934">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172949.png" alt="tips-net-tcp-2019311172949">
<img src="http://images.wodekouwei.com/tips-net-tcp-201931117305.png" alt="tips-net-tcp-201931117305"></p>
<h3 id="发送窗口与接收窗口的关系"><a href="#发送窗口与接收窗口的关系" class="headerlink" title="发送窗口与接收窗口的关系"></a>发送窗口与接收窗口的关系</h3><p>TCP是双工协议，会话双方都可以同时接收与发送数据，因此双方都同时维护一个发送窗口与接收窗口。</p>
<ul>
<li>接收窗口大小取决于应用、系统、硬件等限制；</li>
<li>发送窗口大小取决于对方接收窗口的大小</li>
</ul>
<h3 id="窗口滑动协定"><a href="#窗口滑动协定" class="headerlink" title="窗口滑动协定"></a>窗口滑动协定</h3><ul>
<li>发送窗口只有在收到窗口内字节的ACK确认，才会滑动其左边界</li>
<li>接收窗口只有在窗口中所有的段都正确收到的情况下，才会滑动其左边界；当有字节未接收，但收到后面的字节的情况下，也会滑动，也不对后续字节确认，确保对方重传未接收字节<h3 id="哪些允许变化"><a href="#哪些允许变化" class="headerlink" title="哪些允许变化"></a>哪些允许变化</h3></li>
<li>最大报文段大小在握手中，就确定了</li>
<li>窗口缩放因子在握手中，就确定了</li>
<li>接收窗口大小在根据本地的处理能力与缓存剩余空间动态调整，通过ACK带给对方当前剩余的接收窗口大小</li>
</ul>
<h2 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311173223.png" alt="tips-net-tcp-2019311173223">
RTT = 传播时间+接收端处理时间+路由器的排队时间(变化较大反应当前网络拥塞情况)</p>
<h2 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h2><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现:"></a>具体实现:</h3><p>TCP 每发送一个报文段,就对这个报文段设置一次计时器.只要计时器设置的重传时间到但还没有收到确认,就要重传这一报文段</p>
<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间:"></a>加权平均往返时间:</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h4><p>TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）,第一次测量到 RTT 样本时,RTTS 值就取为所测量到的 RTT 样本值.以后每测量到一个新的 RTT 样本,就按下式重新计算一次 RTTS：
R</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h4><p>新的 RTTS = ( 1 - α)×(旧的 RTTS)＋α(新的 RTT 样本)</p>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明:"></a>说明:</h4><p>式中,0 ≤ α＜ 1.若α很接近于零,表示 RTT 值更新较慢若选择 α 接近于1,则表示 RTT 值更新较快 RFC 2988 推荐的 α 值为 1/8,即 0.125</p>
<h3 id="超时重传时间RTO"><a href="#超时重传时间RTO" class="headerlink" title="超时重传时间RTO:"></a>超时重传时间RTO:</h3><p>RTO 应略大于上面得出的加权平均往返时间 RTTS. RFC 2988 建议使用下式计算 RTO：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RTO=RTTS + 4×RTTD</div></pre></td></tr></table></figure></p>
<p>RTTD 是 RTT 的偏差的加权平均值 RFC 2988 建议这样计算 RTTD.第一次测量时,RTTD 值取为测量到的 RTT 样本值的一半.在以后的测量中,则使用下式计算加权平均的 RTTD：</p>
<p><code>新的 RTTD = (1-β)×(旧的RTTD)+β×|RTTS﹣新的 RTT 样本|</code>
β是个小于 1 的系数,其推荐值是 1/4,即 0.25 在计算平均往返时间 RTT 时,只要报文段重传了,就不采用其往返时间样本</p>
<h3 id="修正的Karn算法"><a href="#修正的Karn算法" class="headerlink" title="修正的Karn算法:"></a>修正的Karn算法:</h3><p>报文段每重传一次,就把 RTO 增大一些：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">新的 RTO= γ×(旧的 RTO)</div></pre></td></tr></table></figure></p>
<p>系数γ 的典型值是 2 当不再发生报文段的重传时,才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值</p>
<h3 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h3><ul>
<li>TCP 为每一个连接设有一个持续计时器</li>
<li>只要 TCP 连接的一方收到对方的零窗口通知,就启动持续计时器</li>
<li>若持续计时器设置的时间到期,就发送一个零窗口探测报文段(仅携带 1 字节的数据),而对方就在确认这个探测报文段时给出了现在的窗口值</li>
<li>若窗口仍然是零,则收到这个报文段的一方就重新设置持续计时器</li>
<li>若窗口不是零,则死锁的僵局就可以打破了</li>
</ul>
<h2 id="报文段的发送时机"><a href="#报文段的发送时机" class="headerlink" title="报文段的发送时机"></a>报文段的发送时机</h2><p>TCP 维持一个变量,它等于最大报文段长度 MSS.只要缓存中存放的数据达到 MSS 字节时,就组装成一个 TCP 报文段发送出去 由发送方的应用进程指明要求发送报文段,即 TCP 支持的推送(push)操作 发送方的一个计时器期限到了,这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去</p>
<h2 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h2><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段:"></a>三个阶段:</h3><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立:"></a>连接建立:</h4><h5 id="图释-4"><a href="#图释-4" class="headerlink" title="图释:"></a>图释:</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174443.jpg" alt="tips-net-tcp-2019311174443"></p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>A 的 TCP 向 B 发出连接请求报文段,其首部中的同步位 SYN = 1,并选择序号 seq = x,表明传送数据时的第一个数据字节的序号是 x</li>
<li>B 的 TCP 收到连接请求报文段后,如同意,则发回确认(B 在确认报文段中应使 SYN = 1,使 ACK = 1,其确认号ack = x﹢1,自己选择的序号 seq = y)</li>
<li>A 收到此报文段后向 B 给出确认,其 ACK = 1,确认号 ack = y﹢1(A 的 TCP 通知上层应用进程,连接已经建立,B 的 TCP 收到主机 A 的确认后,也通知其上层应用进程：TCP 连接已经建立)</li>
</ul>
<h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放:"></a>连接释放:</h4><h5 id="图释-5"><a href="#图释-5" class="headerlink" title="图释"></a>图释</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174722.jpg" alt="tips-net-tcp-2019311174722"></p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>数据传输结束后,通信的双方都可释放连接.现在 A 的应用进程先向其 TCP 发出连接释放报文段,并停止再发送数据,主动关闭 TCP 连接(A 把连接释放报文段首部的 FIN = 1,其序号seq = u,等待 B 的确认)</li>
<li>B 发出确认,确认号 ack = u＋1,而这个报文段自己的序号 seq = v(TCP 服务器进程通知高层应用进程.从 A 到 B 这个方向的连接就释放了,TCP 连接处于半关闭状态.B 若发送数据,A 仍要接收)</li>
<li>若 B 已经没有要向 A 发送的数据,其应用进程就通知 TCP 释放连接</li>
<li>A 收到连接释放报文段后,必须发出确认,在确认报文段中 ACK = 1,确认号 ack=w﹢1,自己的序号 seq = u + 1</li>
</ul>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><p>TCP 连接必须经过时间 2MSL 后才真正释放掉(2MSL 的时间的用意 — 为了保证 A 发送的最后一个 ACK 报文段能够到达 B.防止 “已失效的连接请求报文段”出现在本连接中.A 在发送完最后一个 ACK 报文段后,再经过时间 2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失.这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段)</p>
<h5 id="发现丢失确认时候的处理"><a href="#发现丢失确认时候的处理" class="headerlink" title="发现丢失确认时候的处理"></a>发现丢失确认时候的处理</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174940.png" alt="tips-net-tcp-2019311174940"></p>
<h4 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题:"></a>三个问题:</h4><ul>
<li>要使每一方能够确知对方的存在</li>
<li>要允许双方协商一些参数(如最大报文段长度,最大窗口大小,服务质量等)</li>
<li>能够对运输实体资源(如缓存大小,连接表中的项目等)进行分配</li>
</ul>
<h2 id="发送TCP请求客户端"><a href="#发送TCP请求客户端" class="headerlink" title="发送TCP请求客户端"></a>发送TCP请求客户端</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175058.png" alt="tips-net-tcp-2019311175058"></p>
<h2 id="拥塞处理相关概念"><a href="#拥塞处理相关概念" class="headerlink" title="拥塞处理相关概念"></a>拥塞处理相关概念</h2><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口:"></a>拥塞窗口:</h3><ul>
<li>含义:拥塞窗口的大小取决于网络的拥塞程度,并且动态地在变化.发送方让自己的发送窗口等于拥塞窗口.如再考虑到接收方的接收能力,则发送窗口还可能小于拥塞窗口</li>
<li>发送方控制拥塞窗口的原则:只要网络没有出现拥塞,拥塞窗口就再增大一些,以便把更多的分组发送出去.但只要网络出现拥塞,拥塞窗口就减小一些,以减少注入到网络中的分组数</li>
</ul>
<h3 id="乘法减小"><a href="#乘法减小" class="headerlink" title="乘法减小:"></a>乘法减小:</h3><p>是指不论在慢开始阶段还是拥塞避免阶段,只要出现一次超时(即出现一次网络拥塞),就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5</p>
<h3 id="加法增大"><a href="#加法增大" class="headerlink" title="加法增大:"></a>加法增大:</h3><p>是指执行拥塞避免算法后,在收到对所有报文段的确认后(即经过一个往返时间),就把拥塞窗口 cwnd增加一个 MSS 大小,使拥塞窗口缓慢增大,以防止网络过早出现拥塞</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传:"></a>快重传:</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认.这样做可以让发送方及早知道有报文段没有到达接收方,发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311175358.jpg" alt="tips-net-tcp-2019311175358"></p>
<h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复:"></a>快恢复:</h3><p>当发送端收到连续三个重复的确认时,就执行“乘法减小”算法,把慢开始门限 ssthresh 减半.但接下去不执行慢开始算法</p>
<h3 id="发送窗口的上限值"><a href="#发送窗口的上限值" class="headerlink" title="发送窗口的上限值:"></a>发送窗口的上限值:</h3><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个,即应按以下公式确定： 发送窗口的上限值   Min [rwnd, cwnd]</p>
<p>当 rwnd &lt; cwnd 时,是接收方的接收能力限制发送窗口的最大值
当 cwnd &lt; rwnd 时,则是网络的拥塞限制发送窗口的最大值</p>
<h2 id="避免拥塞具体实现"><a href="#避免拥塞具体实现" class="headerlink" title="避免拥塞具体实现"></a>避免拥塞具体实现</h2><h3 id="有滑动窗口了，为什么还要拥塞窗口"><a href="#有滑动窗口了，为什么还要拥塞窗口" class="headerlink" title="有滑动窗口了，为什么还要拥塞窗口"></a>有滑动窗口了，为什么还要拥塞窗口</h3><p>发送方与接收方之间存在多个路由器和速率较慢的链路时，一些中间路由器就必须缓存分组，并可能耗尽缓存，此时便会出现拥塞，这将严重降低了TCP连接的吞吐量，拥塞窗口就是为了防止过多的数据注入到网络中，中间路由无法消化的问题。</p>
<p>TCP的做法是引入拥塞窗口(cwnd)并策略性的调整其大小，如上文提到的发送窗口大小是取滑动窗口大小与拥塞窗口大小的最小值，这个正是用来缓解该问题，下面是拥塞窗口大小变化的策略:</p>
<h4 id="1-慢开始、拥塞控制"><a href="#1-慢开始、拥塞控制" class="headerlink" title="1. 慢开始、拥塞控制"></a>1. 慢开始、拥塞控制</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312133854.png" alt="tips-net-tcp-2019312133854">
其目的是: 拥塞发生时循序减少主机发送到网络的报文数，使得这时路由器有足够的时间消化积压的报文。</p>
<ul>
<li>当主机开发发送数据时，拥塞窗口(cwnd)被初始化为1个报文段，试探性的发送1个字节的报文</li>
<li>每收到一个ACK，拥塞窗口大小就指数的增加报文段数目(1,2,4,16…)</li>
<li>最终到达提前预设的慢开始阀值(ssthresh)，停止使用慢开始算法，改用拥塞避免算法</li>
<li>拥塞避免算法是每经过一个RTT，拥塞窗口就增加一个报文段，即改为线性的增加报文段</li>
<li>最终会出现网络拥塞，比如丢包等情况，停止拥塞避免算法，将慢开始阀值设置为目前拥塞时拥塞窗口大小的一半(但不能小于2)，并重置拥塞窗口大小为1个报文段，开始新的一轮慢开始 </li>
</ul>
<p>慢开始门限 ssthresh 的用法:</p>
<ul>
<li>当 cwnd &lt; ssthresh 时,使用慢开始算法</li>
<li>当 cwnd &gt; ssthresh 时,停止使用慢开始算法而改用拥塞避免算法</li>
<li>当 cwnd = ssthresh 时,既可使用慢开始算法,也可使用拥塞避免算法</li>
</ul>
<h4 id="2-快重传，快恢复"><a href="#2-快重传，快恢复" class="headerlink" title="2. 快重传，快恢复"></a>2. 快重传，快恢复</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134328.png" alt="tips-net-tcp-2019312134328">
其目的是: 减少因为拥塞导致的数据包丢失的重传时间，避免无用的数据到网络</p>
<p>接收方: 如果一个包丢失，后续的包继续发送针对该包的重传请求</p>
<p>发送方: 一旦收到三个一样的确认，判定为拥塞:</p>
<ul>
<li>立即重传该包</li>
<li>开始执行快恢复算法</li>
<li>快恢复是慢开始阀值设置为目前拥塞时拥塞窗口大小的一半；拥塞窗口大小设置为目前设置后的慢开始阀值的大小；执行拥塞避免算法</li>
</ul>
<h2 id="TCP窗口特殊情况"><a href="#TCP窗口特殊情况" class="headerlink" title="TCP窗口特殊情况"></a>TCP窗口特殊情况</h2><h3 id="1-Persistence-timer"><a href="#1-Persistence-timer" class="headerlink" title="1. Persistence timer"></a>1. Persistence timer</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134856.png" alt="tips-net-tcp-2019312134856">
防止丢包导致发送端停留在上次收到的接收窗口大小为0的情况:</p>
<ul>
<li>接收端B: 我的缓存已满，接收窗口为0</li>
<li>发送端A: 停止发送数据, 并启动持续计时器(Persistence timer)</li>
<li>接收端B: 消化完缓存，发送报文给发送端A，我的接收窗口大小为400，但是 这个报文丢了</li>
<li>发送端A: 计时器时间到，发送一个1字节的探测报文</li>
<li>接收端B: 重新发送，接收窗口大小为400</li>
<li>发送端A: 继续发送数据<h3 id="2-应用层每次单字节发送"><a href="#2-应用层每次单字节发送" class="headerlink" title="2. 应用层每次单字节发送"></a>2. 应用层每次单字节发送</h3>单个发送字节，然后等待一个确认，再发送一个字节，这样为一个字节添加40个字节头的做法，无疑增加了网络中许多不必要的报文，该问题TCP层的解决方案:</li>
</ul>
<p>发送方采用Nagle算法:</p>
<ul>
<li>若应用层是逐个字节把数据送到TCP，那么TCP不会逐个的发送，而是先发送第一个数据字节，然后缓存剩余的</li>
<li>在收到第一个字节的ACK获知网络情况与对方的接收窗口大小后，把缓存的剩余字节组成合适的报文发送出去</li>
<li>到达的数据达到发送窗口大小的一半或者报文段的最大长度时，立即发送</li>
</ul>
<p>接收方的做法:</p>
<ul>
<li>等待本地有足够的缓存空间容纳一个报文段，或者等到本地的缓存空间有一半空闲的时候，再通知发送端发送数据。</li>
</ul>
<h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p>说明:</p>
<ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名.状态之间的箭头表示可能发生的状态变迁</li>
<li>箭头旁边的字,表明引起这种变迁的原因,或表明发生状态变迁后又出现什么动作</li>
<li>图中有三种不同的箭头<ul>
<li>粗实线箭头表示对客户进程的正常变迁</li>
<li>粗虚线箭头表示对服务器进程的正常变迁</li>
<li>另一种细线箭头表示异常变迁</li>
</ul>
</li>
</ul>
<p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175949.png" alt="tips-net-tcp-2019311175949"></p>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><h4 id="什么是MTU-Maximum-Transmit-Unit"><a href="#什么是MTU-Maximum-Transmit-Unit" class="headerlink" title="什么是MTU(Maximum Transmit Unit)"></a>什么是MTU(Maximum Transmit Unit)</h4><p>由于以太网传输的限制，每个以太网网数据帧的大小都是落在在区间[64Bytes,1518Bytes]中的，不在区间内的一般会被视为错误的数据帧，以太网转发设备直接丢弃。而根据以太网每帧的数据构成，除去固定的部分，留给上层协议的只有Data域的1500Bytes，我们将它称为MTU。</p>
<p>以太网(Ethernet II)每帧的数据构成: 目的Mac地址(DMAC)+源Mac地址(SMAC)+类型(Type)+数据(Data)+校验(CRC) = 6Bytes(48bit)DMAC + 6Bytes(48bit)SMAC + 2Bytes(16bit)Type + 1500BytesData + 4Bytes(24bit)CRC</p>
<h4 id="MTU造成什么影响"><a href="#MTU造成什么影响" class="headerlink" title="MTU造成什么影响"></a>MTU造成什么影响</h4><p>由于一个帧放不下，如IP协议，就会对数据包进行分片处理，这就导致了原本一次可以搞定的，被分为多次，降低传输性能，不过我们可以通过在数据包包头加上DF(DonotFragment)标签来强制不被分片处理。</p>
<p>UDP协议不用关心数据的到达的有序以及正确，因此对分片无特殊要求
TCP协议相反，因此TCP协议本身的最大报文段大小MSS也受MTU影响，通常MSS是: MTU - 20Bytes(IP Header) - 20Bytes(TCP Header)
不过好在绝大多数的网络链路都是1500Bytes的MTU或者更大</p>
<h3 id="什么是MSS-Maximum-Segment-Size"><a href="#什么是MSS-Maximum-Segment-Size" class="headerlink" title="什么是MSS(Maximum Segment Size)"></a>什么是MSS(Maximum Segment Size)</h3><p>TCP的最大报文段大小，只包含TCP Payload(不包含TCP Header与TCP Option)的TCP每次能够传输的最大数据分段的大小，可以用来限制每次发送的字节数。通常大小为1460Bytes(1500BytesMTU - 20Bytes(IP Header) - 20Bytes(TCP Header))</p>
<p>MSS是在TCP建连时确定的，通讯双方会根据双方提供的MSS值，取最小的MSS作为该次连接数据传输的MSS</p>
<h3 id="什么是WS-Window-Scaling"><a href="#什么是WS-Window-Scaling" class="headerlink" title="什么是WS(Window Scaling)"></a>什么是WS(Window Scaling)</h3><p>TCP首部中表示Window Size的字段只有16位，因此按照协议，能表示的最大窗口大小是2^16-1=65535Bytes(64Kb)，因此TCP的选项字段中包含了窗口扩大因子(WS)分别用option-kind、option-length、option-data来表示，这个参数可带可不带，只有在双方都支持的情况下，才会生效。如双方的WS都是256，而后我们ACK Window size value是5，那么此时就可以表示我们的接收窗口是1280Bytes(5*256=1280)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/zhangdaisylove/article/details/47294315" target="_blank" rel="external">TCP的滑动窗口与拥塞窗口</a>
<a href="http://blog.chinaunix.net/uid-26275986-id-4109679.html" target="_blank" rel="external">计算机网络【七】：可靠传输的实现</a>
<a href="http://blog.csdn.net/cloud323/article/details/77481711" target="_blank" rel="external">TCP窗口控制、流控制、拥塞控制</a>
<a href="http://blog.csdn.net/hldjf/article/details/7450565" target="_blank" rel="external">也谈一下TCP segment of a reassembled PDU</a>
<a href="https://www.zhihu.com/question/48454744" target="_blank" rel="external">TCP流量控制中的滑动窗口大小</a>
<a href="https://my.oschina.net/xinxingegeya/blog/485650" target="_blank" rel="external">TCP 滑动窗口（发送窗口和接收窗口）</a>
<a href="https://www.zhihu.com/question/32255109" target="_blank" rel="external">TCP协议的滑动窗口具体是怎样控制流量的？</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-nat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-nat/" itemprop="url">
                  tips-net-nat
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T11:05:57+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-NAT"><a href="#1-NAT" class="headerlink" title="1.NAT"></a>1.NAT</h2><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。
这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>
<p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p>
<h3 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h3><p>是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。</p>
<h3 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h3><p>是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p>
<h3 id="端口多路复用（Port-address-Translation-PAT"><a href="#端口多路复用（Port-address-Translation-PAT" class="headerlink" title="端口多路复用（Port address Translation,PAT)"></a>端口多路复用（Port address Translation,PAT)</h3><p>是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。
ALG（Application Level Gateway），即应用程序级网关技术：传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。例如：对于FTP协议的PORT/PASV命令、DNS协议的 “A” 和 “PTR” queries命令和部分ICMP消息类型等都需要相应的ALG来支持。
如果协议数据报文中不包含地址信息，则很容易利用传统的NAT技术来完成透明的地址转换功能，通常我们使用的如下应用就可以直接利用传统的NAT技术：HTTP、TELNET、FINGER、NTP、NFS、ARCHIE、RLOGIN、RSH、RCP等。</p>
<h2 id="2-TCP长连接"><a href="#2-TCP长连接" class="headerlink" title="2.TCP长连接"></a>2.TCP长连接</h2><p>TCP连接建立后只要不明确关闭，逻辑上连接一直存在。
TCP是有保活定时器的，可以打开保活定时器来维持长连接，设置SO_KEEPALIVE才会开启，时间间隔默认7200s，也就是2h，这个默认是关闭的。</p>
<p>注意：HTTP的keepalive和TCP的用处不大一样tcp。</p>
<h2 id="3-NAT超时"><a href="#3-NAT超时" class="headerlink" title="3.NAT超时"></a>3.NAT超时</h2><p>因为 IP v4 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换(Network Address Translation，NAT)。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯。
大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。
长连接心跳间隔必须要小于NAT超时时间(aging-time)，如果超过aging-time不做心跳，TCP长连接链路就会中断，Server就无法发送Push给手机，只能等到客户端下次心跳失败后，重建连接才能取到消息。</p>
<p>因为IPv4地址不足, 或者我们想通过无线路由器上网, 我们的设备可能会处在一个NAT设备的后面, 生活中最常见的NAT设备是家用路由器.
NAT设备会在IP封包通过设备时修改源/目的IP地址. 对于家用路由器来说, 使用的是网络地址端口转换(NAPT), 它不仅改IP, 还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP. 举个例子, NAPT维护一个类似下表的NAT表
|内网地址|    外网地址|
|—|—|
|192.168.0.2:5566|    120.132.92.21:9200|
|192.168.0.3:7788|    120.132.92.21:9201|
|192.168.0.3:8888|    120.132.92.21:9202|</p>
<p>NAT设备会根据NAT表对出去和进来的数据做修改, 比如将192.168.0.3:8888发出去的封包改成120.132.92.21:9202, 外部就认为他们是在和120.132.92.21:9202通信. 同时NAT设备会将120.132.92.21:9202收到的封包的IP和端口改成192.168.0.3:8888, 再发给内网的主机, 这样内部和外部就能双向通信了, 但如果其中192.168.0.3:8888 == 120.132.92.21:9202这一映射因为某些原因被NAT设备淘汰了, 那么外部设备就无法直接与192.168.0.3:8888通信了.</p>
<p>国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断.</p>
<h2 id="4-心跳包"><a href="#4-心跳包" class="headerlink" title="4.心跳包"></a>4.心跳包</h2><ul>
<li>心跳的原因：虽然理论tcp连接后一直不断，但实际上会断网。见：比如 NAT超时，更多 影响TCP连接寿命的因素</li>
<li>心跳包的主要作用是告知对方连接端，我还活着，心还在跳。</li>
<li>心跳时长多少？
　　
现实是残酷的, 根据网上的一些说法, 中移动2/3G下, NAT超时时间为5分钟, 中国电信3G则大于28分钟, 理想的情况下, 客户端应当以略小于NAT超时时间的间隔来发送心跳包.
|地区/网络|NAT超时时间|
|—|—|
|中国移动3G和2G|5分钟|
|中国联通2G|5分钟|
|中国电信3G|大于28分钟|
|美国3G|大于28分钟|
|台湾3G|大于28分钟|</li>
</ul>
<p>wifi下, NAT超时时间都会比较长, 据说宽带的网关一般没有空闲释放机制, GCM有些时候在wifi下的心跳比在移动网络下的心跳要快, 可能是因为wifi下联网通信耗费的电量比移动网络下小</p>
<h2 id="5-心跳包和轮询的区别"><a href="#5-心跳包和轮询的区别" class="headerlink" title="5.心跳包和轮询的区别"></a>5.心跳包和轮询的区别</h2><p>心跳包和轮询看起来类似, 都是客户端主动联系服务器, 但是区别很大.</p>
<ul>
<li>轮询是为了获取数据, 而心跳是为了保活TCP连接.</li>
<li>轮询得越频繁, 获取数据就越及时, 心跳的频繁与否和数据是否及时没有直接关系</li>
<li>轮询比心跳能耗更高, 因为一次轮询需要经过TCP三次握手, 四次挥手, 单次心跳不需要建立和拆除TCP连接.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/08/tips-android-net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/08/tips-android-net/" itemprop="url">
                  Android架构之网络优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T17:13:46+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常规的网络框架设计和常用的网络优化方案。</p>
<ol>
<li>网络框架OkHttp</li>
</ol>
<ul>
<li>简洁易用的接口</li>
<li>拦截器机制，网络重试与跳转</li>
<li>连接池复用</li>
</ul>
<ol>
<li>网络加速</li>
</ol>
<ul>
<li>HttpDNS与IP直连</li>
<li>连接加速：短连接复用、Http2多路复用、长连接</li>
</ul>
<ol>
<li>数据压缩与序列化</li>
</ol>
<ul>
<li>Json vs ProtoBuf</li>
<li>压缩算法</li>
<li>序列化</li>
</ul>
<ol>
<li>长连接技术与Mars架构</li>
</ol>
<ul>
<li>智能心跳机制</li>
<li>自动重连</li>
<li>Android跨进程实现</li>
<li>智能唤醒</li>
</ul>
<ol>
<li>如何应对复杂网络</li>
</ol>
<ul>
<li>弱网</li>
<li>网络超时、振荡</li>
<li>404与DNS劫持</li>
</ul>
<ol>
<li>如何保证网络数据安全</li>
</ol>
<ul>
<li>TLS协议，握手与证书</li>
<li>数据签名及校验</li>
</ul>
<p><a href="https://github.com/dhhAndroid/RxWebSocket" target="_blank" rel="external">https://github.com/dhhAndroid/RxWebSocket</a></p>
<h3 id="网络错误"><a href="#网络错误" class="headerlink" title="网络错误"></a>网络错误</h3><h4 id="ECONNABORTED"><a href="#ECONNABORTED" class="headerlink" title="ECONNABORTED"></a>ECONNABORTED</h4><p>该错误被描述为“software caused connection abort”，即“软件引起的连接中止”。原因在于当服务和客户进程在完成用于 TCP 连接的“三次握手”后，客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用accept。 
SocketException: Software caused connection abort: recv failed
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Linux system */  </div><div class="line">  </div><div class="line">include/asm-alpha/errno.h:#define ECONNABORTED 53 /* Software caused connection </div><div class="line">abort */  </div><div class="line">include/asm-generic/errno.h:#define ECONNABORTED 103 /* Software caused </div><div class="line">connection abort */  </div><div class="line">include/asm-mips/errno.h:#define ECONNABORTED 130 /* Software caused connection </div><div class="line">abort */</div></pre></td></tr></table></figure></p>
<p>导致这个异常出现的根本原因可能有多个，
在服务端/客户端单方面关闭连接的情况下,另一方依然以为 tcp连接仍然建立,试图读取对方的响应数据,导致出现 Software caused connection abort: recv failed的异常. 
可能是是防火墙的原因。</p>
<h4 id="ECONNRESET"><a href="#ECONNRESET" class="headerlink" title="ECONNRESET"></a>ECONNRESET</h4><p>该错误被描述为“connection reset by peer”，即“对方复位连接”，这种情况一般发生在服务进程较客户进程提前终止。当服务进程终止时会向客户 TCP 发送 FIN 分节，客户 TCP 回应 ACK，服务 TCP 将转入 FIN_WAIT2 状态。此时如果客户进程没有处理该 FIN （如阻塞在其它调用上而没有关闭 Socket 时），则客户 TCP 将处于 CLOSE_WAIT 状态。当客户进程再次向 FIN_WAIT2 状态的服务 TCP 发送数据时，则服务 TCP 将立刻响应 RST。一般来说，这种情况还可以会引发另外的应用程序异常，客户进程在发送完数据后，往往会等待从网络IO接收数据，很典型的如 read 或 readline 调用，此时由于执行时序的原因，如果该调用发生在 RST 分节收到前执行的话，那么结果是客户进程会得到一个非预期的 EOF 错误。此时一般会输出“server terminated prematurely”－“服务器过早终止”错误。</p>
<h4 id="EPIPE"><a href="#EPIPE" class="headerlink" title="EPIPE"></a>EPIPE</h4><p>错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。</p>
<h4 id="ETIMEDOUT"><a href="#ETIMEDOUT" class="headerlink" title="ETIMEDOUT"></a>ETIMEDOUT</h4><p>错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。</p>
<h4 id="ENOPROTOOPT"><a href="#ENOPROTOOPT" class="headerlink" title="ENOPROTOOPT"></a>ENOPROTOOPT</h4><p>该错误不是一个 Socket 连接相关的错误。errno 给出该值可能由于，通过 getsockopt 系统调用来获得一个套接字的当前选项状态时，如果发现了系统不支持的选项参数就会引发该错误。
getsockopt/setsockopt(2) man page 写道
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">getsockopt, setsockopt -- get and set options on sockets.</div><div class="line"></div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">int getsockopt(int socket, int level, int option_name,</div><div class="line">void *restrict option_value, socklen_t *restrict option_len);</div><div class="line"></div><div class="line">int setsockopt(int socket, int level, int option_name,</div><div class="line">const void *option_value, socklen_t option_len);</div><div class="line"></div><div class="line">Getsockopt() and setsockopt() manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost &quot;socket&quot; level.</div></pre></td></tr></table></figure></p>
<p> 此外，getsockopt 和 setsockopt 还可能引发以下错误：</p>
<p>getsockopt/setsockopt(2) man page 写道
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ERRORS</div><div class="line"></div><div class="line">The getsockopt() and setsockopt() system calls will succeed unless:</div><div class="line"></div><div class="line">[EBADF] The argument socket is not a valid file descriptor.</div><div class="line">[EFAULT] The address pointed to by option_value is not in a valid part of the process dress space. For getsockopt(), this error may also be returned if option_len is not in a valid part of the process address space.</div><div class="line">[EINVAL] The option is invalid at the level indicated.</div><div class="line">[ENOBUFS]Insufficient memory buffers are available.</div><div class="line">[ENOPROTOOPT] The option is unknown at the level indicated.</div><div class="line">[ENOTSOCK] The argument socket is not a socket (e.g., a plain file).</div><div class="line"></div><div class="line">The setsockopt() system call will succeed unless:</div><div class="line"></div><div class="line">[EDOM] The argument option_value is out of bounds.</div><div class="line">[EISCONN]socket is already connected and a specified option cannot be set while this is the case.</div></pre></td></tr></table></figure></p>
<h4 id="ECONNEREFUSED"><a href="#ECONNEREFUSED" class="headerlink" title="ECONNEREFUSED"></a>ECONNEREFUSED</h4><p>A “connect failed: ECONNREFUSED (Connection refused)” most likely means that there is nothing listening on that port AND that IP address. Possible explanations include:</p>
<ul>
<li>the service has crashed or hasn’t been started,</li>
<li>your client is trying to connect using the wrong IP address or port, or</li>
<li>server access is being blocked by a firewall that is “refusing” on the server/service’s behalf. This is pretty unlikely given that normal practice (these days) is for firewalls to “blackhole” all unwanted connection attempts.</li>
<li>The server couldn’t send a response: Ensure that the backend is working properly at IP and port mentioned.</li>
<li>SSL connections are being blocked: Fix this by importing SSL certificates</li>
<li>Cookies not being sent</li>
<li>Request timeout: Change request timeout</li>
</ul>
<h3 id="The-java-net-SocketException-is-thrown-when-there-is-an-error-creating-or-accessing-a-socket-such-as-TCP-This-usually-can-be-caused-when-the-server-has-terminated-the-connection-without-properly-closing-it-so-before-getting-the-full-response-In-most-cases-this-can-be-caused-either-by-the-timeout-issue-e-g-the-response-takes-too-much-time-or-server-is-overloaded-with-the-requests-or-the-client-sent-the-SYN-but-it-didn’t-receive-ACK-acknowledgment-of-the-connection-termination-For-timeout-issues-you-can-consider-increasing-the-timeout-value"><a href="#The-java-net-SocketException-is-thrown-when-there-is-an-error-creating-or-accessing-a-socket-such-as-TCP-This-usually-can-be-caused-when-the-server-has-terminated-the-connection-without-properly-closing-it-so-before-getting-the-full-response-In-most-cases-this-can-be-caused-either-by-the-timeout-issue-e-g-the-response-takes-too-much-time-or-server-is-overloaded-with-the-requests-or-the-client-sent-the-SYN-but-it-didn’t-receive-ACK-acknowledgment-of-the-connection-termination-For-timeout-issues-you-can-consider-increasing-the-timeout-value" class="headerlink" title="The java.net.SocketException is thrown when there is an error creating or accessing a socket (such as TCP). This usually can be caused when the server has terminated the connection (without properly closing it), so before getting the full response. In most cases this can be caused either by the timeout issue (e.g. the response takes too much time or server is overloaded with the requests), or the client sent the SYN, but it didn’t receive ACK (acknowledgment of the connection termination). For timeout issues, you can consider increasing the timeout value."></a>The java.net.SocketException is thrown when there is an error creating or accessing a socket (such as TCP). This usually can be caused when the server has terminated the connection (without properly closing it), so before getting the full response. In most cases this can be caused either by the timeout issue (e.g. the response takes too much time or server is overloaded with the requests), or the client sent the SYN, but it didn’t receive ACK (acknowledgment of the connection termination). For timeout issues, you can consider increasing the timeout value.</h3><p>The Socket Exception usually comes with the specified detail message about the issue.</p>
<p>Example of detailed messages:</p>
<p>Software caused connection abort: recv failed.</p>
<p>The error indicates an attempt to send the message and the connection has been aborted by your server. If this happened while connecting to the database, this can be related to using not compatible Connector/J JDBC driver.</p>
<p>Possible solution: Make sure you’ve proper libraries/drivers in your CLASSPATH.</p>
<p>Software caused connection abort: connect.</p>
<p>This can happen when there is a problem to connect to the remote. For example due to virus-checker rejecting the remote mail requests.</p>
<p>Possible solution: Check Virus scan service whether it’s blocking the port for the outgoing requests for connections.</p>
<p>Software caused connection abort: socket write error.</p>
<p>Possible solution: Make sure you’re writing the correct length of bytes to the stream. So double check what you’re sending. See this thread.</p>
<p>Connection reset by peer: socket write error / Connection aborted by peer: socket write error</p>
<p>The application did not check whether keep-alive connection had been timed out on the server side.</p>
<p>Possible solution: Ensure that the HttpClient is non-null before reading from the connection.E13222_01</p>
<p>Connection reset by peer.</p>
<p>The connection has been terminated by the peer (server).</p>
<p>Connection reset.</p>
<p>The connection has been either terminated by the client or closed by the server end of the connection due to request with the request.</p>
<p><a href="https://stackoverflow.com/q/585599/55075" target="_blank" rel="external">What’s causing my java.net.SocketException: Connection reset?</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/07/tips-android-sharedpreferences/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/07/tips-android-sharedpreferences/" itemprop="url">
                  Android SharedPreference详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T12:17:40+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SharedPreferences作为一种数据持久化的方式，是处理简单的key-value类型数据时的首选。</p>
<h3 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法:"></a>一般用法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//demo是该sharedpreference对应文件名,对应的是一个xml文件,里面存放key-value格式的数据.</div><div class="line">SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;demo&quot;, MODE_WORLD_WRITEABLE);</div><div class="line">//提供了getXXX的读取数据方法</div><div class="line">boolean xxx = sharedPreferences.getBoolean(&quot;xxx&quot;, false);</div><div class="line">//通过Editor提供了putXXX系列的存储方法,调用完需要使用apply()或commit()使之生效,不同点后面介绍</div><div class="line">SharedPreferences.Editor edit = sharedPreferences.edit();</div><div class="line">edit.putBoolean(&quot;xxx&quot;, true);</div><div class="line">edit.apply();//使存储生效</div><div class="line">//edit.commit();//使存储生效</div></pre></td></tr></table></figure>
<p>每个SharedPreferences都对应了当前package的<code>data/data/package_name/share_prefs/</code>目录下的一个文件</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>Context.java中getSharedPreferences接口说明:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Retrieve and hold the contents of the preferences file &apos;name&apos;, returning</div><div class="line">     * a SharedPreferences through which you can retrieve and modify its</div><div class="line">     * values.  Only one instance of the SharedPreferences object is returned</div><div class="line">     * to any callers for the same name, meaning they will see each other&apos;s</div><div class="line">     * edits as soon as they are made.</div><div class="line">     *</div><div class="line">     * @param name Desired preferences file. If a preferences file by this name</div><div class="line">     * does not exist, it will be created when you retrieve an</div><div class="line">     * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).</div><div class="line">     * @param mode Operating mode.  Use 0 or &#123;@link #MODE_PRIVATE&#125; for the</div><div class="line">     * default operation, &#123;@link #MODE_WORLD_READABLE&#125;</div><div class="line">     * and &#123;@link #MODE_WORLD_WRITEABLE&#125; to control permissions.</div><div class="line">     *</div><div class="line">     * @return The single &#123;@link SharedPreferences&#125; instance that can be used</div><div class="line">     *         to retrieve and modify the preference values.</div><div class="line">     *</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">    public abstract SharedPreferences getSharedPreferences(String name,</div><div class="line">            int mode);</div></pre></td></tr></table></figure></p>
<p>ContextImpl中getSharedPreferences实现:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public SharedPreferences getSharedPreferences(String name, int mode) &#123;</div><div class="line">        SharedPreferencesImpl sp;</div><div class="line">        synchronized (ContextImpl.class) &#123;</div><div class="line">            if (sSharedPrefs == null) &#123;</div><div class="line">                sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String packageName = getPackageName();</div><div class="line">            ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</div><div class="line">            if (packagePrefs == null) &#123;</div><div class="line">                packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</div><div class="line">                sSharedPrefs.put(packageName, packagePrefs);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // At least one application in the world actually passes in a null</div><div class="line">            // name.  This happened to work because when we generated the file name</div><div class="line">            // we would stringify it to &quot;null.xml&quot;.  Nice.</div><div class="line">            if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">                    Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">                if (name == null) &#123;</div><div class="line">                    name = &quot;null&quot;;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sp = packagePrefs.get(name);</div><div class="line">            if (sp == null) &#123;</div><div class="line">                File prefsFile = getSharedPrefsFile(name);</div><div class="line">                sp = new SharedPreferencesImpl(prefsFile, mode);</div><div class="line">                packagePrefs.put(name, sp);</div><div class="line">                return sp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">            // If somebody else (some other process) changed the prefs</div><div class="line">            // file behind our back, we reload it.  This has been the</div><div class="line">            // historical (if undocumented) behavior.</div><div class="line">            sp.startReloadIfChangedUnexpectedly();</div><div class="line">        &#125;</div><div class="line">        return sp;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码里，我们可以看出，</p>
<ol>
<li>SharedPreferencesImpl是保存在全局个map cache里的，只会创建一次。</li>
<li>MODE_MULTI_PROCESS模式下，每次获取都会尝试去读取文件reload。当然会有一些逻辑尽量减少读取次数，比如当前是否有正在进行的读取操作，文件的修改时间和大小与上次有没有变化等。</li>
</ol>
<p>Context.java中提供了以下四种mode:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">//这是默认模式，仅caller uid的进程可访问</div><div class="line">/**</div><div class="line">     * File creation mode: the default mode, where the created file can only</div><div class="line">     * be accessed by the calling application (or all applications sharing the</div><div class="line">     * same user ID).</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">int MODE_PRIVATE = 0x0000;</div><div class="line"></div><div class="line">//所有人可写，也就是任何应用都可修改它，这是极其危险的，因此改选项已被Deprected</div><div class="line">/**</div><div class="line">     * @deprecated Creating world-readable files is very dangerous, and likely</div><div class="line">     * to cause security holes in applications.  It is strongly discouraged;</div><div class="line">     * instead, applications should use more formal mechanism for interactions</div><div class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</div><div class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</div><div class="line">     * access mode will remain on a file, such as when it goes through a</div><div class="line">     * backup and restore.</div><div class="line">     * File creation mode: allow all other applications to have read access</div><div class="line">     * to the created file.</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">int MODE_WORLD_READABLE = 0x0001; </div><div class="line"></div><div class="line">//所有人可读，这个参数同样非常危险，可能导致隐私数据泄漏</div><div class="line">/**</div><div class="line">     * @deprecated Creating world-writable files is very dangerous, and likely</div><div class="line">     * to cause security holes in applications.  It is strongly discouraged;</div><div class="line">     * instead, applications should use more formal mechanism for interactions</div><div class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</div><div class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</div><div class="line">     * access mode will remain on a file, such as when it goes through a</div><div class="line">     * backup and restore.</div><div class="line">     * File creation mode: allow all other applications to have write access</div><div class="line">     * to the created file.</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     */</div><div class="line">int MODE_WORLD_READABLE = 0x0002</div><div class="line"></div><div class="line">//设置该参数后，每次获取对应的SharedPreferences时都会尝试从磁盘中读取修改过的文件 </div><div class="line">/**</div><div class="line">     * SharedPreference loading flag: when set, the file on disk will</div><div class="line">     * be checked for modification even if the shared preferences</div><div class="line">     * instance is already loaded in this process.  This behavior is</div><div class="line">     * sometimes desired in cases where the application has multiple</div><div class="line">     * processes, all writing to the same SharedPreferences file.</div><div class="line">     * Generally there are better forms of communication between</div><div class="line">     * processes, though.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;This was the legacy (but undocumented) behavior in and</div><div class="line">     * before Gingerbread (Android 2.3) and this flag is implied when</div><div class="line">     * targetting such releases.  For applications targetting SDK</div><div class="line">     * versions &lt;em&gt;greater than&lt;/em&gt; Android 2.3, this flag must be</div><div class="line">     * explicitly set if desired.</div><div class="line">     *</div><div class="line">     * @see #getSharedPreferences</div><div class="line">     *</div><div class="line">     * @deprecated MODE_MULTI_PROCESS does not work reliably in</div><div class="line">     * some versions of Android, and furthermore does not provide any</div><div class="line">     * mechanism for reconciling concurrent modifications across</div><div class="line">     * processes.  Applications should not attempt to use it.  Instead,</div><div class="line">     * they should use an explicit cross-process data management</div><div class="line">     * approach such as &#123;@link android.content.ContentProvider ContentProvider&#125;.</div><div class="line">     */</div><div class="line">int MODE_MULTI_PROCESS = 0x0004;</div></pre></td></tr></table></figure></p>
<h4 id="MODE-MULTI-PROCESS"><a href="#MODE-MULTI-PROCESS" class="headerlink" title="MODE_MULTI_PROCESS"></a>MODE_MULTI_PROCESS</h4><p>当设置MODE_MULTI_PROCESS这个参数的时候，即使当前进程内已经创建了该SharedPreferences，仍然在每次获取的时候都会尝试从本地文件中刷新。在同一个进程中，同一个文件只有一个实例。MODE_MULTI_PROCESS的作用如上getSharedPreferences实现.这个方法先判断是否已创建SharedPreferences实例，若未创建，则先创建。之后判断mode如果为MODE_MULTI_PROCESS, 则调用startReloadIfChangeUnexpectedly()，看下其实现:
SharedPreferencesImpl.java
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void startReloadIfChangedUnexpectedly() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            // TODO: wait for any pending writes to disk?</div><div class="line">            if (!hasFileChangedUnexpectedly()) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            startLoadFromDisk();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mLoaded = false;</div><div class="line">        &#125;</div><div class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    loadFromDiskLocked();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出MODE_MULTI_PROCESS的作用就是在每次获取SharedPreferences实例的时候尝试从磁盘中加载修改过的数据，并且读取是在异步线程中，因此一个线程的修改最终会反映到另一个线程，但不能立即反映到另一个进程，所以通过SharedPreferences无法实现多进程同步。
综合: 如果仅仅让多进程可访问同一个SharedPref文件，不需要设置MODE_MULTI_PROCESS, 如果需要实现多进程同步，必须设置这个参数，但也只能实现最终一致，无法即时同步。</p>
<p><strong>由于SharedPreference内容都会在内存里存一份，所以不要使用SharedPreference保存较大的内容，避免不必要的内存浪费。</strong></p>
<p>注意有一个锁mLoaded ,在对SharedPreference做其他操作时，都必须等待该锁释放:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Nullable</div><div class="line">    public String getString(String key, @Nullable String defValue) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            awaitLoadedLocked();</div><div class="line">            String v = (String)mMap.get(key);</div><div class="line">            return v != null ? v : defValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>写操作有两个commit apply 。 commit 是同步的，写入内存的同时会等待写入文件完成，apply是异步的，先写入内存，在异步线程里再写入文件。apply肯定要快一些,优先推荐使用apply:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">         * Commit your preferences changes back from this Editor to the</div><div class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line">         * performs the requested modifications, replacing whatever is currently</div><div class="line">         * in the SharedPreferences.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line">         * time, the last one to call commit wins.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;If you don&apos;t care about the return value and you&apos;re</div><div class="line">         * using this from your application&apos;s main thread, consider</div><div class="line">         * using &#123;@link #apply&#125; instead.</div><div class="line">         *</div><div class="line">         * @return Returns true if the new values were successfully written</div><div class="line">         * to persistent storage.</div><div class="line">         */</div><div class="line">        boolean commit();</div><div class="line">        /**</div><div class="line">         * Commit your preferences changes back from this Editor to the</div><div class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line">         * performs the requested modifications, replacing whatever is currently</div><div class="line">         * in the SharedPreferences.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line">         * time, the last one to call apply wins.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out</div><div class="line">         * to persistent storage synchronously, &#123;@link #apply&#125;</div><div class="line">         * commits its changes to the in-memory</div><div class="line">         * &#123;@link SharedPreferences&#125; immediately but starts an</div><div class="line">         * asynchronous commit to disk and you won&apos;t be notified of</div><div class="line">         * any failures.  If another editor on this</div><div class="line">         * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125;</div><div class="line">         * while a &#123;@link #apply&#125; is still outstanding, the</div><div class="line">         * &#123;@link #commit&#125; will block until all async commits are</div><div class="line">         * completed as well as the commit itself.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within</div><div class="line">         * a process, it&apos;s safe to replace any instance of &#123;@link #commit&#125; with</div><div class="line">         * &#123;@link #apply&#125; if you were already ignoring the return value.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;You don&apos;t need to worry about Android component</div><div class="line">         * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt;</div><div class="line">         * writing to disk.  The framework makes sure in-flight disk</div><div class="line">         * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching</div><div class="line">         * states.</div><div class="line">         *</div><div class="line">         * &lt;p class=&apos;note&apos;&gt;The SharedPreferences.Editor interface</div><div class="line">         * isn&apos;t expected to be implemented directly.  However, if you</div><div class="line">         * previously did implement it and are now getting errors</div><div class="line">         * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call</div><div class="line">         * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;.</div><div class="line">         */</div><div class="line">        void apply();</div></pre></td></tr></table></figure></p>
<p>注册/解注册sharedpreference变动监听:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Registers a callback to be invoked when a change happens to a preference.</div><div class="line">     *</div><div class="line">     * &lt;p class=&quot;caution&quot;&gt;&lt;strong&gt;Caution:&lt;/strong&gt; The preference manager does</div><div class="line">     * not currently store a strong reference to the listener. You must store a</div><div class="line">     * strong reference to the listener, or it will be susceptible to garbage</div><div class="line">     * collection. We recommend you keep a reference to the listener in the</div><div class="line">     * instance data of an object that will exist as long as you need the</div><div class="line">     * listener.&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param listener The callback that will run.</div><div class="line">     * @see #unregisterOnSharedPreferenceChangeListener</div><div class="line">     */</div><div class="line">    void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Unregisters a previous callback.</div><div class="line">     * </div><div class="line">     * @param listener The callback that should be unregistered.</div><div class="line">     * @see #registerOnSharedPreferenceChangeListener</div><div class="line">     */</div><div class="line">    void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</div></pre></td></tr></table></figure></p>
<h4 id="为什么不推荐使用MODE-MULTI-PROCESS"><a href="#为什么不推荐使用MODE-MULTI-PROCESS" class="headerlink" title="为什么不推荐使用MODE_MULTI_PROCESS?"></a>为什么不推荐使用MODE_MULTI_PROCESS?</h4><p>android文档已经Deprected了这个flag，并且说明不应该通过SharedPreference做进程间数据共享？这是为啥呢？从前面但分析可看到当设置这个flag后，每次获取(获取而不是初次创建)SharedPreferences实例的时候，会判断shared_pref文件是否修改过:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private boolean hasFileChangedUnexpectedly() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mDiskWritesInFlight &gt; 0) &#123;</div><div class="line">                // If we know we caused it, it&apos;s not unexpected.</div><div class="line">                if (DEBUG) Log.d(TAG, &quot;disk write in flight, not unexpected.&quot;);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final StructStat stat;</div><div class="line">        try &#123;</div><div class="line">            /*</div><div class="line">             * Metadata operations don&apos;t usually count as a block guard</div><div class="line">             * violation, but we explicitly want this one.</div><div class="line">             */</div><div class="line">            BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">            stat = Os.stat(mFile.getPath());</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里先判断mDiskWritesInFlight&gt;0，如果成立，说明是当前进程修改了文件，不需要重新读取。然后通过文件最后修改时间，判断文件是否修改过。如果修改了，则重新读取:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mLoaded = false;</div><div class="line">        &#125;</div><div class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    loadFromDiskLocked();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void loadFromDiskLocked() &#123;</div><div class="line">        if (mLoaded) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (mBackupFile.exists()) &#123;</div><div class="line">            mFile.delete();</div><div class="line">            mBackupFile.renameTo(mFile);</div><div class="line">        &#125;</div><div class="line">        Map map = null;</div><div class="line">        StructStat stat = null;</div><div class="line">        try &#123;</div><div class="line">            stat = Os.stat(mFile.getPath());</div><div class="line">            if (mFile.canRead()) &#123;</div><div class="line">                BufferedInputStream str = null;</div><div class="line">                try &#123;</div><div class="line">                    str = new BufferedInputStream(</div><div class="line">                            new FileInputStream(mFile), 16*1024);</div><div class="line">                    map = XmlUtils.readMapXml(str);</div><div class="line">                &#125; finally &#123;</div><div class="line">                    IoUtils.closeQuietly(str);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">        &#125;</div><div class="line">        mLoaded = true;</div><div class="line">        if (map != null) &#123;</div><div class="line">            mMap = map;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125; else &#123;</div><div class="line">            mMap = new HashMap&lt;String, Object&gt;();</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里起码有3个坑！</p>
<ol>
<li>使用MODE_MULTI_PROCESS时，不要保存SharedPreference变量，必须每次都从context.getSharedPreferences 获取。如果你图方便使用变量存了下来，那么无法触发reload，有可能两个进程数据不同步。</li>
<li>前面提到过，load数据是耗时的，并且其他操作会等待该锁。这意味着很多时候获取SharedPreference数据都不得不从文件再读一遍，大大降低了内存缓存的作用。文件读写耗时也影响了性能。</li>
<li>修改数据时得用commit，保证修改时写入了文件，这样其他进程才能通过文件大小或修改时间感知到。</li>
</ol>
<p>重点是这段:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mBackupFile.exists()) &#123;</div><div class="line">      mFile.delete();</div><div class="line">      mBackupFile.renameTo(mFile);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新读取时，如果发现存在mBackupFile,则将原文件mFile删除，并将mBackupFile重命名为mFile。mBackupFile又是如何创建的呢？答案是在修改SharedPreferences时将内存中的数据写会磁盘时创建的:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">        // Rename the current file so it may be used as a backup during the next read</div><div class="line">        if (mFile.exists()) &#123;</div><div class="line">            if (!mBackupFile.exists()) &#123;</div><div class="line">                if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                    mcr.setDiskWriteResult(false);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                mFile.delete();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        final StructStat stat = Os.stat(mFile.getPath());</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        mcr.setDiskWriteResult(true);</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码只保留了核心流程，忽略了错误处理流程。可以看到，写文件的步骤大致是:</p>
<ol>
<li>将原文件重命名为mBackupFile</li>
<li>重新创建原文件mFile, 并将内容写入其中</li>
<li>删除mBackupFile</li>
</ol>
<p>所以，只有当一个进程正处于写文件的过程中的时候，如果另一个进程读文件，才会看到mBackupFile, 这时候读进程会将mBackupFile重命名为mFile, 这样读结果是，读进程只能读到修改前的文件，同时，由于mBackupFile重命名为了mFile,  所以写进程写那个文件就没有文件名引用了，因此其写入的内容无法再被任何进程访问到。所以其内容丢失了，可认为写入失败了，而SharedPreferences对这种失败情况没有任何重试机制，所以就可能出现数据丢失的情况。
回到这段的重点：为什么不推荐用MODE_MULTI_PROCESS？从前面分析可知，这种模式下，每次获取SharedPreferences都会检测文件是否改变，只要读的时候另一进程在写，就会导致写丢失。这样失败概率就会大幅度提高。反之，若不设置这个模式，则只在第一次创建SharedPreferences的时候读取，导致写失败的概率就会大幅度降低，当然，仍然存在失败的可能。</p>
<h4 id="为什么不做写失败重试？"><a href="#为什么不做写失败重试？" class="headerlink" title="为什么不做写失败重试？"></a>为什么不做写失败重试？</h4><p>为什么android不做写失败重试呢？原因是写进程并不能发现写失败的情况。难道写的过程中，目标文件被删不会抛异常吗？答案是不会。删除文件只是从文件系统中删除了一个节点信息而已，重命名也是新建了一个具有相同名称的节点信息，并把文件地址指向另一个磁盘地址而已，原来，之前的写过程仍然会成功写到原来的磁盘地址。所以目前的实现方案并不能检测到失败。</p>
<h4 id="有没有办法解决写失败呢？"><a href="#有没有办法解决写失败呢？" class="headerlink" title="有没有办法解决写失败呢？"></a>有没有办法解决写失败呢？</h4><p>个人觉得是可以做到的，读里面读那段关键操作:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mBackupFile.exists()) &#123;</div><div class="line">      mFile.delete();</div><div class="line">      mBackupFile.renameTo(mFile);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mBackupFile存在，意味着当前正处于写读过程中，这时候是不是可以考虑直接读mBackupFile文件，而不删除mFile呢？这样读话，读取效果一样，都是读的mBackupFile，同时写进程写的mFile也不会被mBacupFile覆盖，写也就能成功了。即使通过这段代码重命名，写进程写完后发现mBackupFile不存在了，其实也能认为发生了读重命名，大可以重试一次。</p>
<h3 id="多进程使用SharedPreference方案"><a href="#多进程使用SharedPreference方案" class="headerlink" title="多进程使用SharedPreference方案"></a>多进程使用SharedPreference方案</h3><p>说简单也简单，就是依据google的建议使用ContentProvider了。我看过网上很多的例子，但总是觉得少了点什么</p>
<p>有的方案里将所有读取操作都写作静态方法，没有继承SharedPreference 。 这样做需要强制改变调用者的使用习惯，不怎么好。
大部分方案做成ContentProvider后，所有的调用都走的ContentProvider。但如果调用进程与SharedPreference 本身就是同一个进程，只用走原生的流程就行了，不用拐个弯去访问ContentProvider，减少不必要的性能损耗。</p>
<p>我这里也写了一个跨进程方案，简单介绍如下
SharedPreferenceProxy 继承SharedPreferences。其所有操作都是通过ContentProvider完成。简要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class SharedPreferenceProxy implements SharedPreferences &#123;</div><div class="line">@Nullable</div><div class="line">    @Override</div><div class="line">    public String getString(String key, @Nullable String defValue) &#123;</div><div class="line">        OpEntry result = getResult(OpEntry.obtainGetOperation(key).setStringValue(defValue));</div><div class="line">        return result == null ? defValue : result.getStringValue(defValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Editor edit() &#123;</div><div class="line">        return new EditorImpl();</div><div class="line">    &#125;</div><div class="line">    private OpEntry getResult(@NonNull OpEntry input) &#123;</div><div class="line">        try &#123;</div><div class="line">            Bundle res = ctx.getContentResolver().call(PreferenceUtil.URI</div><div class="line">                    , PreferenceUtil.METHOD_QUERY_VALUE</div><div class="line">                    , preferName</div><div class="line">                    , input.getBundle());</div><div class="line">            return new OpEntry(res);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">...</div><div class="line"></div><div class="line">    public class EditorImpl implements Editor &#123;</div><div class="line">        private ArrayList&lt;OpEntry&gt; mModified = new ArrayList&lt;&gt;();</div><div class="line">        @Override</div><div class="line">        public Editor putString(String key, @Nullable String value) &#123;</div><div class="line">            OpEntry entry = OpEntry.obtainPutOperation(key).setStringValue(value);</div><div class="line">            return addOps(entry);</div><div class="line">        &#125;</div><div class="line">       @Override</div><div class="line">        public void apply() &#123;</div><div class="line">            Bundle intput = new Bundle();</div><div class="line">            intput.putParcelableArrayList(PreferenceUtil.KEY_VALUES, convertBundleList());</div><div class="line">            intput.putInt(OpEntry.KEY_OP_TYPE, OpEntry.OP_TYPE_APPLY);</div><div class="line">            try &#123;</div><div class="line">                ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_EIDIT_VALUE, preferName, intput);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">...</div><div class="line">        &#125;</div><div class="line">...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>OpEntry只是一个对Bundle操作封装的类。
所有跨进程的操作都是通过SharedPreferenceProvider的call方法完成。SharedPreferenceProvider里会访问真正的SharedPreference
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SharedPreferenceProvider extends ContentProvider&#123;</div><div class="line"></div><div class="line">    private Map&lt;String, MethodProcess&gt; processerMap = new ArrayMap&lt;&gt;();</div><div class="line">    @Override</div><div class="line">    public boolean onCreate() &#123;</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_VALUE, methodQueryValues);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_CONTAIN_KEY, methodContainKey);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_EIDIT_VALUE, methodEditor);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_PID, methodQueryPid);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;</div><div class="line">        MethodProcess processer = processerMap.get(method);</div><div class="line">        return processer == null?null:processer.process(arg, extras);</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重要差别的地方在这里：在调用getSharedPreferences时，会先判断caller的进程pid是否与SharedPreferenceProvider相同。如果不同，则返回SharedPreferenceProxy。如果相同，则返回ctx.getSharedPreferences。只会在第一次调用时进行判断，结果会保存起来。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public static SharedPreferences getSharedPreferences(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        //First check if the same process</div><div class="line">        if (processFlag.get() == 0) &#123;</div><div class="line">            Bundle bundle = ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_QUERY_PID, &quot;&quot;, null);</div><div class="line">            int pid = 0;</div><div class="line">            if (bundle != null) &#123;</div><div class="line">                pid = bundle.getInt(PreferenceUtil.KEY_VALUES);</div><div class="line">            &#125;</div><div class="line">            //Can not get the pid, something wrong!</div><div class="line">            if (pid == 0) &#123;</div><div class="line">                return getFromLocalProcess(ctx, preferName);</div><div class="line">            &#125;</div><div class="line">            processFlag.set(Process.myPid() == pid ? 1 : -1);</div><div class="line">            return getSharedPreferences(ctx, preferName);</div><div class="line">        &#125; else if (processFlag.get() &gt; 0) &#123;</div><div class="line">            return getFromLocalProcess(ctx, preferName);</div><div class="line">        &#125; else &#123;</div><div class="line">            return getFromRemoteProcess(ctx, preferName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private static SharedPreferences getFromRemoteProcess(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        synchronized (SharedPreferenceProxy.class) &#123;</div><div class="line">            if (sharedPreferenceProxyMap == null) &#123;</div><div class="line">                sharedPreferenceProxyMap = new ArrayMap&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            SharedPreferenceProxy preferenceProxy = sharedPreferenceProxyMap.get(preferName);</div><div class="line">            if (preferenceProxy == null) &#123;</div><div class="line">                preferenceProxy = new SharedPreferenceProxy(ctx.getApplicationContext(), preferName);</div><div class="line">                sharedPreferenceProxyMap.put(preferName, preferenceProxy);</div><div class="line">            &#125;</div><div class="line">            return preferenceProxy;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static SharedPreferences getFromLocalProcess(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        return ctx.getSharedPreferences(preferName, Context.MODE_PRIVATE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样，只有当调用者是正真跨进程时才走的contentProvider。对于同进程的情况，就没有必要走contentProvider了。对调用者来说，这都是透明的，只需要获取SharedPreferences就行了，不用关心获得的是SharedPreferenceProxy，还是SharedPreferenceImpl。即使你当前没有涉及到多进程使用，将所有获取SharedPreference的地方封装并替换后，对当前逻辑也没有任何影响。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/07/flutter-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/07/flutter-introduce/" itemprop="url">
                  Flutter介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T10:19:24+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Flutter是一款由Google开发的开源、跨平台的移动端开发框架，使用Flutter开发出的应用符合不同平台的原生体验，可以让应用看起来跟系统更加协调。
Flutter是一个全新的移动UI框架，它允许使用同一个代码库构建高性能的Android和iOS应用，同时它也是Google即将推出的Fuchsia操作系统的开发平台。通过自定义的Flutter引擎可以将其嵌入到其他平台，旨在帮助开发者使用一套代码开发高性能、高保真的Android和iOS应用。</p>
<h3 id="Flutter优点"><a href="#Flutter优点" class="headerlink" title="Flutter优点"></a>Flutter优点</h3><h4 id="原生性能"><a href="#原生性能" class="headerlink" title="原生性能"></a>原生性能</h4><p>Flutter会以原生的性能提供给开发者，它的开发性能非常接近传统的Native，包括渲染方式、AOT的编译方式和其他优化。</p>
<p>Flutter开发的页面跟Native没有差距。在安卓中低端机型里，基于Flutter开发出来的APP在帧率上会有更流畅的体现，内存占用也会有更低的消耗。</p>
<p><strong>渲染方式,AOT,无锁GC</strong></p>
<h4 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h4><p>Flutter因其本身的跨端性，大幅提升了传统的安卓开发速度。一般认为，前端开发的速度较快，基于Flutter，开发速度比前端更快。
<strong>压秒级,有状态的热重载</strong></p>
<h4 id="统一的应用开发体验"><a href="#统一的应用开发体验" class="headerlink" title="统一的应用开发体验"></a>统一的应用开发体验</h4><p>在跨端层面上，由于Flutter把两端的渲染机制下沉到更低的渲染层，基于统一的C++层的渲染引擎来搭建底层的UI框架，因此，Flutter会让跨端体验得到更一致的效果。
<strong>两端一致的开发方式,MD和IOS风格</strong></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>内存的问题。随着Flutter页面的堆栈变得越来越深，内存的释放并没有得到及时的释放。</li>
<li>字体的问题。不同的字体在不同的机器里渲染的效果非常不一致。</li>
<li>截图会出现黑屏的问题。</li>
<li>图片缓存的问题。跟安卓端的图片缓存是完全不同的体系。</li>
<li>它的暗黑区、适配问题，</li>
<li>私有库、中间件的适配，</li>
<li>不支持反射和序列化，</li>
<li>集成问题,怎么把Native的组件集成到Flutter体系</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/05/tips-android-targetsdkversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/05/tips-android-targetsdkversion/" itemprop="url">
                  应用targetSdkVersion升级指导
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T16:00:20+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应电信终端产业协会（TAF）发布的《移动应用软件高 API 等级预置与分发自律公约》（以下简称《公约》）要求：截止到2019年5月1日所有新发布的应用 API 必须为26或更高，2019年8月1日现有应用 API 必须升级为26或更高。《公约》发布至今得到了国内主流互联网及终端制造企业的积极响应。</p>
<ul>
<li>对应用开发者来说，不按时更新Target SDK版本的应用，应用市场将采取强制下架的策略，已上架应用将无法更新。</li>
<li>对用户来说，未适配Android M或更高版本的应用安装在Android M或更高版本时，会默认授予申请的所有权限，且应用运行时无弹框授权提示。其中包括通讯录、电话、短信、通讯记录、位置、麦克风、相机等危险权限，导致用户在不知情的情况下泄露隐私信息，对用户个人信息安全造成危害。</li>
</ul>
<p><strong>应用targetSdkVersion升级流程</strong>
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935161819.jpg" alt="tips-android-targetsdkversion-201935161819"></p>
<h2 id="targetSdkVersion-相关变更介绍"><a href="#targetSdkVersion-相关变更介绍" class="headerlink" title="targetSdkVersion 相关变更介绍"></a>targetSdkVersion 相关变更介绍</h2><h3 id="Android5-x（22-19）及以下版本变更"><a href="#Android5-x（22-19）及以下版本变更" class="headerlink" title="Android5.x（22-19）及以下版本变更"></a>Android5.x（22-19）及以下版本变更</h3><p><img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935184537.jpg" alt="tips-android-targetsdkversion-201935184537"></p>
<h3 id="Android6-0变更"><a href="#Android6-0变更" class="headerlink" title="Android6.0变更"></a>Android6.0变更</h3><h4 id="（一）相关变更"><a href="#（一）相关变更" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><p><strong>运行时权限</strong></p>
<p>此版本引入了一种新的权限模式，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，为安装的应用分别授予或撤销权限，同时为开发者精简了安装和自动更新过程。</p>
<p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。确定应用是否已被授予权限，可调用新增的 checkSelfPermission() 方法。请求权限，可调用新增的 requestPermissions() 方法。具体参考：</p>
<p><a href="https://developer.android.google.cn/training/permissions/requesting" target="_blank" rel="external">https://developer.android.google.cn/training/permissions/requesting</a></p>
<p>####（二）适配指导</p>
<p>• 解释需要权限的原因：系统在开发者调用 requestPermissions() 时显示的权限对话框将说明应用需要的权限，但不会解释为何需要这些权限。某些情况下，用户可能会感到困惑，因此，建议在调用 requestPermissions() 之前向用户解释应用需要相应权限的原因。</p>
<ul>
<li>仅申请应用真正需要的权限</li>
<li>如果应用在启动之后一次要求用户提供多项权限，用户可能会感到无所适从并因此退出应用 。建议开发者应根据需要请求权限，对于某一些权限应用可以在真正需要使用的时候再尝试申请用户动态授权。</li>
</ul>
<h3 id="Android7-0"><a href="#Android7-0" class="headerlink" title="Android7.0"></a>Android7.0</h3><h4 id="（一）相关变更-1"><a href="#（一）相关变更-1" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><h5 id="1-系统禁止链接到非-NDK-库"><a href="#1-系统禁止链接到非-NDK-库" class="headerlink" title="1.系统禁止链接到非 NDK 库"></a>1.系统禁止链接到非 NDK 库</h5><p>从 Android 7.0 开始，系统将阻止应用动态链接非公开 NDK 库，原因为NDK 库可能会导致应用崩溃，此行为变更主要目的在为跨平台更新和不同设备提供统一的应用体验。即使应用中的代码不会链接私有库，但第三方静态库可能会进行链接，因此建议所有开发者都需进行相应检查，确保应用不会在运行 Android 7.0 的设备上崩溃。如果应用使用的是原生代码，则只能使用公开 NDK API。（<a href="https://developer.android.com/ndk/guides/stable_apis）" target="_blank" rel="external">https://developer.android.com/ndk/guides/stable_apis）</a></p>
<h5 id="2-低电耗模式DOZE（系统状态）"><a href="#2-低电耗模式DOZE（系统状态）" class="headerlink" title="2.低电耗模式DOZE（系统状态）"></a>2.低电耗模式DOZE（系统状态）</h5><p>进入条件：灭屏、未充电、静止持续1小时
退出条件：亮屏或移动或充电</p>
<p>限制资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停应用的Sync任务</li>
<li>暂停应用的JobScheduler任务</li>
<li>忽略应用的wakelocks</li>
<li>标准Alarm推迟到维护窗口</li>
<li>不执行wifi扫描</li>
</ul>
<h5 id="3-低电耗模式Lite-Idle（系统状态）"><a href="#3-低电耗模式Lite-Idle（系统状态）" class="headerlink" title="3.低电耗模式Lite Idle（系统状态）"></a>3.低电耗模式Lite Idle（系统状态）</h5><p>进入条件：灭屏、未充电持续5分钟(Android P调整为3分钟）
退出条件：亮屏或充电
限制资源</p>
<ul>
<li>限制应用访问网络。</li>
<li>暂停应用运行Sync任务 。</li>
<li>暂停应用运行JobScheduler任务。</li>
</ul>
<h5 id="4-AppStandby模式（应用状态）"><a href="#4-AppStandby模式（应用状态）" class="headerlink" title="4.AppStandby模式（应用状态）"></a>4.AppStandby模式（应用状态）</h5><p>进入AppIdle条件：应用后台空闲总时间&gt;48小时且亮屏后台空闲时间 &gt; 12小时
排除&amp;退出条件：前台应用、有前台服务的应用、通知栏或锁屏通知消息的应用或进行充电
不限制的应用：系统应用UID&lt;10000的，Persist常驻应用，电池优化白名单，系统关联的其他应用
限制的资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停执行应用的Sync任务</li>
<li>暂停执行应用的JobScheduler任务</li>
</ul>
<h5 id="5-App-Standby-Bucket-应用待机分组模式-Android-P特性）"><a href="#5-App-Standby-Bucket-应用待机分组模式-Android-P特性）" class="headerlink" title="5.App Standby Bucket 应用待机分组模式( Android P特性）"></a>5.App Standby Bucket 应用待机分组模式( Android P特性）</h5><p>应用待机分组模式是在Doze模式未生效时（亮屏或刚刚灭屏时），对运行在后台的用户不可感知应用的耗电管控扩展。</p>
<h4 id="（二）适配指导"><a href="#（二）适配指导" class="headerlink" title="（二）适配指导"></a>（二）适配指导</h4><p>低电耗模式和应用待机模式适配指导如下：</p>
<p>• 前台服务</p>
<p>应用需要在后台访问网络或者使用CPU时可以通过此方式。</p>
<p>• Doze白名单</p>
<p>查询应用是不是再doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PowerManager powerManager = (PowerManager)getSystemService(POWER_SERVICE);</div><div class="line">boolean hasIgnored = powerManager.isIgnoringBatteryOptimizations(activity.getPackageName());</div></pre></td></tr></table></figure></p>
<p>向用户申请授权添加doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);</div><div class="line">intent.setData(Uri.parse(&quot;package:&quot;+activity.getPackageName()));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<h3 id="Android8-0-变更"><a href="#Android8-0-变更" class="headerlink" title="Android8.0 变更"></a>Android8.0 变更</h3><h4 id="1-后台服务限制"><a href="#1-后台服务限制" class="headerlink" title="1.后台服务限制"></a>1.后台服务限制</h4><h5 id="①哪些应用会受到后台服务限制？"><a href="#①哪些应用会受到后台服务限制？" class="headerlink" title="①哪些应用会受到后台服务限制？"></a>①哪些应用会受到后台服务限制？</h5><ul>
<li>TargetSDK&gt;=26的应用</li>
<li>TargetSDK&lt;26且被用户主动设置为限制后台活动的应用（华为EMUI8.x未提供配置）</li>
</ul>
<p>注意：Doze 白名单中的应用不受限制（用户可以设置，手机管家配置有默认值白名单）</p>
<h5 id="②前台如何定义？"><a href="#②前台如何定义？" class="headerlink" title="②前台如何定义？"></a>②前台如何定义？</h5><ul>
<li>前台有可见 Activity</li>
<li>前台服务可以后台播放</li>
<li>绑定服务的情况<h5 id="③后台服务限制，限制了哪些行为？"><a href="#③后台服务限制，限制了哪些行为？" class="headerlink" title="③后台服务限制，限制了哪些行为？"></a>③后台服务限制，限制了哪些行为？</h5></li>
<li>应用进入 uidldle 后，会被调用 Service.stopself()</li>
<li>应用进入 uidldle 后，不允许通过 startService启动服务</li>
<li>应用进程仍然存在，JobScheduler、Alarm、广播等均能触发</li>
<li>广播接收线程处理短暂业务，无法拉起后台服务</li>
<li>非安卓组件线程 CPU 超标时，谷歌原生机制会强制kill进程<h5 id="④临时白名单机制"><a href="#④临时白名单机制" class="headerlink" title="④临时白名单机制"></a>④临时白名单机制</h5>系统调用应用时，少量场景会将应用添加到临时白名单（有效时间30秒~300秒）：</li>
<li>处理高优先级 FCM 消息</li>
<li>接收短信彩信</li>
<li>用户点击通知栏，执行 PendingIntent<h5 id="⑤用户设置限制后台活动之后的影响（Android-P优化）"><a href="#⑤用户设置限制后台活动之后的影响（Android-P优化）" class="headerlink" title="⑤用户设置限制后台活动之后的影响（Android P优化）"></a>⑤用户设置限制后台活动之后的影响（Android P优化）</h5></li>
<li>应用退后台，1分钟就会被停止 Service（包括正在执行的前台任务）</li>
<li>限制访问网络</li>
<li>限制 Alarm 触发</li>
<li>限制 JobScheduler 执行</li>
</ul>
<h4 id="2-广播限制"><a href="#2-广播限制" class="headerlink" title="2.广播限制"></a>2.广播限制</h4><p>Android 8.0 的应用无法继续在其清单中为隐式广播注册广播接收器,但也存在例外情况：</p>
<ul>
<li>应用可以继续在清单中注册显式广播</li>
<li>应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注 册接收器</li>
<li>需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用 ，而不会发送至设备上的所有应用</li>
<li>白名单豁免隐式广播的列表：<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="external">https://developer.android.com/guide/components/broadcast-exceptions</a></li>
</ul>
<p>后台执行限制的适配建议</p>
<ul>
<li>使用 JobScheduler 代替</li>
<li>增加前台服务</li>
<li>加 Doze 白名单（不推荐）</li>
</ul>
<h4 id="3-最大屏幕纵横比"><a href="#3-最大屏幕纵横比" class="headerlink" title="3.最大屏幕纵横比"></a>3.最大屏幕纵横比</h4><p>以 Android 7.1（API 级别 25）或更低版本为目标平台中应用默认的最大屏幕纵横比为1.86。针对 Android 8.0 或更高版本的应用没有默认的最大纵横比，如需设置请在应用 androidmanifest 文件定义 maxAspectRatio 属性（注意：如果应用没有显示申明不支持 resizeableActivity，系统将会忽略应用设置的 maxAspectRatio属性）</p>
<h4 id="4-其他变更"><a href="#4-其他变更" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>提醒窗口</td>
<td>使用SYSTEM_ALERT_WINDOW权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口:TYPE_PHONE,TYPE_PRIORITY_PHONE,TYPE_SYSTEM_ALERT,TYPE_SYSTEM_OVERLAY,TYPE_SYSTEM_ERROR,应用必须使用名为TYPE_APPLICATION_OVERLAY的新窗口类型</td>
</tr>
<tr>
<td>权限</td>
<td>在Android8.0之前,如果应用在运行时请求权限并且被授予该权限,系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用.对于针对8.0的应用,此行为已被纠正.系统只会授予应用明确请求的权限.然而,一旦用户为应用授予某个权限,则所有后续对该权限组中权限的请求都被自动批准.建议应用在使用所有的敏感权限之前,都先判断一下权限是否已经被授予,如果没有授予需要申请动态权限.</td>
</tr>
<tr>
<td>Linker</td>
<td>O版本在linker中新增加检查就是在load之前检测一下需要加载的section的权限,被加载的段不允许同事具有E(可执行)和W(可写)权限.如果有这样的段,则linker报错</td>
</tr>
<tr>
<td>Build.SERIAL弃用</td>
<td>需要知道硬件序列号的应用应改为使用新的Build.getSerial()函数,该函数要求具有READ_PHONE_STATE权限</td>
</tr>
</tbody>
</table>
<h3 id="Android9-0-变更"><a href="#Android9-0-变更" class="headerlink" title="Android9.0 变更"></a>Android9.0 变更</h3><h4 id="1-非SDK管控"><a href="#1-非SDK管控" class="headerlink" title="1.非SDK管控"></a>1.非SDK管控</h4><table>
<thead>
<tr>
<th>名单类型</th>
<th>影响</th>
<th>名单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浅灰名单</td>
<td>targetSDK&gt;=P时,警告</td>
<td>已有应用在使用非SDK接口,仍然可以继续使用</td>
</tr>
<tr>
<td>深灰名单</td>
<td>targetSDK<p时,警告;>=时,不允许调用</p时,警告;></td>
<td>应用可能还在使用</td>
</tr>
<tr>
<td>黑名单</td>
<td>所有三方应用不允许调用</td>
<td>灰名单(深灰+浅灰)之外的其他所有非SDK接口都会被添加到黑名单,应用发现有使用黑名单的接口需要马上整改,或者反馈给谷歌申请加灰名单</td>
</tr>
</tbody>
</table>
<p>使用谷歌提供的非 SDK 扫描工具查看应用使用的深灰名单和黑名单非 SDK 接口： <a href="https://android.googlesource.com/platform/prebuilts/runtime/+/" target="_blank" rel="external">https://android.googlesource.com/platform/prebuilts/runtime/+/</a> master/appcompat/</p>
<h4 id="2-Apache-HTTP-客户端弃用"><a href="#2-Apache-HTTP-客户端弃用" class="headerlink" title="2. Apache HTTP 客户端弃用"></a>2. Apache HTTP 客户端弃用</h4><p>默认情况下该内容库已从 bootclasspath 中移除且不可用于应用，应用不能使用系统的 classloader 加载 org.apache.http.* 库，否则会抛 NoClassDefFoundError。</p>
<p>适配建议</p>
<ul>
<li>方法一：如果要继续使用 Apache HTTP 客户端，以 Android 9.0及更高版本为目标的应用可以向其 AndroidManifest.xml 添加以下内容：<code>&lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot;/&gt;</code></li>
<li>方法二：如果必须要继续使用 Apache HTTP 客户端，开发者可以将 org.apache.http.legacy库打包进自己的apk。</li>
<li>推荐方法：使用 HttpURLConnection 类替代 apache-http</li>
</ul>
<h4 id="3-内联方法不允许跨dex"><a href="#3-内联方法不允许跨dex" class="headerlink" title="3.内联方法不允许跨dex"></a>3.内联方法不允许跨dex</h4><p>Google 在 Android P 新增检测：如果调用某个 inline 方法的类与 inline 方法所在的类由不同的 classloader 加载，就会主动发起 abort（inline不允许跨dex文件）导致应用 crash。
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935181033.jpg" alt="tips-android-targetsdkversion-201935181033"></p>
<h5 id="兼容性影响"><a href="#兼容性影响" class="headerlink" title="兼容性影响"></a>兼容性影响</h5><p>对使用插件和热修复的应用有很大影响，需要重点测试。</p>
<h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><ul>
<li>启动应用，构造热修复场景，在 app 侧触发热修复</li>
<li><code>adb shell cmd package compile -m speed -f my-package 应用包名 (inline编译)</code></li>
<li>重启应用，检查是否会出现闪退问题</li>
</ul>
<h5 id="适配建议"><a href="#适配建议" class="headerlink" title="适配建议"></a>适配建议</h5><ul>
<li>尽量避免使用不同的 classloader 加载相关的类。</li>
<li>如果一定要这样做的话，需要避免内联，比如在函数里面加 try catch， 这样 compiler就不会将这个函数 inline。</li>
</ul>
<h4 id="4-其他变更-1"><a href="#4-其他变更-1" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>前台服务</td>
<td>使用前台服务的应用必须请求FOREGROUND_SERVICE权限.这是普通权限,因此,系统会自动为请求权限的应用授予此权限.如果针对Android9或更高版本的应用尝试创建一个前台服务且未请求FOREGROUND_SERVICE,则系统会引发SecurityException.</td>
</tr>
<tr>
<td>DNS隐私</td>
<td>应用应采用私有DNS API.具体而言,当系统解析程序正在执行DNS-over-TLS时,应用应确保任何内置DNS客户端均使用加密的DNS查找和系统相同的主机名,或停用它而改用系统解析程序</td>
</tr>
<tr>
<td>默认情况下启用网络传输层安全协议(TLS)</td>
<td>默认情况下isCleartextTrafficPermitted()函数返回false.如果您的应用需要为特定域名启动明文,您必须在应用的网络安全性配置中针对这些域名将cleartextTrafficPermitted显式设置为true</td>
</tr>
<tr>
<td>webview数据目录不允许共享</td>
<td>应用无法再让多个进程公用同一个WebView数据目录.如果应用中的多个进程需要访问同一网络数据,您需要自行在这些进程之间复制数据.例如,您可以调用getCookie()和setCooki(),在不同进程之间手动传输Cookie数据</td>
</tr>
<tr>
<td>以应用为单位的SELinux域名</td>
<td>应用的私有数据只能由该应用访问.要与其他应用共享文件,请使用contentprovider</td>
</tr>
</tbody>
</table>
<p>其他的变更和非 TargetSdkVersion 相关的变更以及新特性，可以在谷歌开发者网站查阅：<a href="https://developer.android.google.cn/about/versions/oreo/" target="_blank" rel="external">https://developer.android.google.cn/about/versions/oreo/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/05/tips-android-system-load/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/05/tips-android-system-load/" itemprop="url">
                  Android启动过程深入解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T14:11:16+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>A当按下Android设备电源键时究竟发生了什么？</li>
<li>Android的启动过程是怎么样的？</li>
<li>A什么是Linux内核？</li>
<li>A桌面系统linux内核与Android系统linux内核有什么区别？</li>
<li>A什么是引导装载程序？</li>
<li>A什么是Zygote？</li>
<li>A什么是X86以及ARM linux？</li>
<li>A什么是init.rc?</li>
<li>A什么是系统服务？
当我们想到Android启动过程时，脑海中总是冒出很多疑问。本文将介绍Android的启动过程，希望能帮助你找到上面这些问题的答案。</li>
</ul>
<p>Android是一个基于Linux的开源操作系统。x86（x86是一系列的基于intel 8086 CPU的计算机微处理器指令集架构）是linux内核部署最常见的系统。然而，所有的Android设备都是运行在ARM处理器（ARM 源自进阶精简指令集机器，源自ARM架构）上，除了英特尔的Xolo设备(<a href="http://xolo.in/xolo-x900-features)。Xolo来源自凌动1.6GHz" target="_blank" rel="external">http://xolo.in/xolo-x900-features)。Xolo来源自凌动1.6GHz</a> x86处理器。Android设备或者嵌入设备或者基于linux的ARM设备的启动过程与桌面版本相比稍微有些差别。这篇文章中，我将解释Android设备的启动过程。<a href="http://www.ibm.com/developerworks/linux/library/l-linuxboot/" target="_blank" rel="external">深入linux启动</a>过程是一篇讲桌面linux启动过程的好文。</p>
<p>当你按下电源开关后Android设备执行了以下步骤。</p>
<p><img src="http://images.wodekouwei.com/tips-android-system-load-201935141326.png" alt="tips-android-system-load-201935141326"></p>
<h3 id="第一步：启动电源以及系统启动"><a href="#第一步：启动电源以及系统启动" class="headerlink" title="第一步：启动电源以及系统启动"></a>第一步：启动电源以及系统启动</h3><p>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。</p>
<h3 id="第二步：引导程序"><a href="#第二步：引导程序" class="headerlink" title="第二步：引导程序"></a>第二步：引导程序</h3><p>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如<a href="http://ecos.sourceware.org/redboot/" target="_blank" rel="external">redboot</a>、<a href="http://www.denx.de/wiki/U-Boot" target="_blank" rel="external">uboot</a>、<a href="http://wiki.openmoko.org/wiki/Qi" target="_blank" rel="external">qi bootloader</a>或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。</p>
<p>引导程序分两个阶段执行。第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。</p>
<p>Android引导程序可以在<code>\bootable\bootloader\legacy\usbloader</code>找到。
传统的加载器包含的个文件，需要在这里说明：</p>
<ul>
<li>init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；</li>
<li>main.c初始化硬件（闹钟、主板、键盘、控制台），创建linux标签。
更多关于Android引导程序的可以在<a href="https://motorola-global-portal.custhelp.com/app/answers/detail/a_id/86208/~/bootloader-frequently-asked-questions" target="_blank" rel="external">这里</a>了解。</li>
</ul>
<h3 id="第三步：内核"><a href="#第三步：内核" class="headerlink" title="第三步：内核"></a>第三步：内核</h3><p>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p>
<h3 id="第四步：init进程"><a href="#第四步：init进程" class="headerlink" title="第四步：init进程"></a>第四步：init进程</h3><p>init是第一个进程，我们可以说它是root进程或者说有进程的父进程。init进程有两个责任，一是挂载目录，比如/sys、/dev、/proc，二是运行init.rc脚本。</p>
<p>init进程可以在/system/core/init找到。
init.rc文件可以在/system/core/rootdir/init.rc找到。
readme.txt可以在/system/core/init/readme.txt找到。
对于init.rc文件，Android中有特定的格式以及规则。在Android中，我们叫做Android初始化语言。
Android初始化语言由四大类型的声明组成，即Actions（动作）、Commands（命令）、Services（服务）、以及Options（选项）。</p>
<h4 id="Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。"><a href="#Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。" class="headerlink" title="Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。"></a>Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。</h4><p>语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; html-script: false ]</div><div class="line">    on &amp;lt;trigger&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div></pre></td></tr></table></figure></p>
<h4 id="Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。"><a href="#Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。" class="headerlink" title="Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。"></a>Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。</h4><p>语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; html-script: false ]</div><div class="line">service &amp;lt;name&amp;gt; &amp;lt;pathname&amp;gt; [&amp;lt;argument&amp;gt;]*</div><div class="line">    &amp;lt;option&amp;gt;</div><div class="line">    &amp;lt;option&amp;gt;</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h4 id="Options（选项）"><a href="#Options（选项）" class="headerlink" title="Options（选项）"></a>Options（选项）</h4><p>选项是对服务的描述。它们影响init进程如何以及何时启动服务。
咱们来看看默认的init.rc文件。这里我只列出了主要的事件以及服务。
Table
|—|—|
|Action/Service|    描述|
|on early-init    |设置init进程以及它创建的子进程的优先级，设置init进程的安全环境|
|on init    |设置全局环境，为cpu accounting创建cgroup(资源控制)挂载点|
|on fs    |挂载mtd分区|
|on post-fs    |改变系统目录的访问权限|
|on post-fs-data    |改变/data目录以及它的子目录的访问权限|
|on boot    |基本网络的初始化，内存管理等等|
|service servicemanager    |启动系统管理器管理所有的本地服务，比如位置、音频、Shared preference等等…|
|service zygote    |启动zygote作为应用进程|
在这个阶段你可以在设备的屏幕上看到“Android”logo了。</p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>在Java中，我们知道不同的虚拟机实例会为不同的应用分配不同的内存。假如Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。Zygote是一个虚拟器进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是Android SDK或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。</p>
<p>Zygote加载进程</p>
<ol>
<li>加载ZygoteInit类，源代码：<code>/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></li>
<li>registerZygoteSocket()为zygote命令连接注册一个服务器套接字。</li>
<li>preloadClassed “preloaded-classes”是一个简单的包含一系列需要预加载类的文本文件，你可以在<android source="">/frameworks/base找到“preloaded-classes”文件。</android></li>
<li>preloadResources() preloadResources也意味着本地主题、布局以及android.R文件中包含的所有东西都会用这个方法加载。
在这个阶段，你可以看到启动动画。</li>
</ol>
<h3 id="第六步：系统服务或服务"><a href="#第六步：系统服务或服务" class="headerlink" title="第六步：系统服务或服务"></a>第六步：系统服务或服务</h3><p>完成了上面几步之后，运行环境请求Zygote运行系统服务。系统服务同时使用native以及java编写，系统服务可以认为是一个进程。同一个系统服务在Android SDK可以以System Services形式获得。系统服务包含了所有的System Services。</p>
<p>Zygote创建新的进程去启动系统服务。你可以在ZygoteInit类的”startSystemServer”方法中找到源代码。</p>
<p>核心服务：</p>
<ol>
<li>启动电源管理器；</li>
<li>创建Activity管理器；</li>
<li>启动电话注册；</li>
<li>启动包管理器；</li>
<li>设置Activity管理服务为系统进程；</li>
<li>启动上下文管理器；</li>
<li>启动系统Context Providers；</li>
<li>启动电池服务；</li>
<li>启动定时管理器；</li>
<li>启动传感服务；</li>
<li>启动窗口管理器；</li>
<li>启动蓝牙服务；</li>
<li>启动挂载服务</li>
</ol>
<p>其他服务：</p>
<ol>
<li>启动状态栏服务；</li>
<li>启动硬件服务；</li>
<li>启动网络状态服务；</li>
<li>启动网络连接服务；</li>
<li>启动通知管理器；</li>
<li>启动设备存储监视服务；</li>
<li>启动定位管理器；</li>
<li>启动搜索服务；</li>
<li>启动剪切板服务；</li>
<li>启动登记服务；</li>
<li>启动壁纸服务；</li>
<li>启动音频服务；</li>
<li>启动耳机监听；</li>
<li>启动AdbSettingsObserver（处理adb命令）。</li>
</ol>
<h3 id="第七步：引导完成"><a href="#第七步：引导完成" class="headerlink" title="第七步：引导完成"></a>第七步：引导完成</h3><p>一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/05/tips-solution-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/05/tips-solution-2/" itemprop="url">
                  解决方案之美团APP对Crash的治理之路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T10:06:36+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Crash率是衡量一款APP质量好坏的重要指标之一，不仅会影响用户体验，也可能影响用户存量。一旦出现问题，可能会给企业带来严重损失。</p>
<p>本文由美团技术专家谌天洲分享美团APP Crash率从千分之一到万分之一治理过程中所做的大量实践工作。</p>
<h3 id="美团Crash治理背景"><a href="#美团Crash治理背景" class="headerlink" title="美团Crash治理背景"></a>美团Crash治理背景</h3><p>美团作为一个平台化的APP，背后有20+团队设计和30+业务。</p>
<p>在Crash治理过程中面对的挑战有三项：体量大、迭代快和日活高。这三项挑战带来的直接影响是沟通成本上升和防范难度加大。因此在实际治理过程，主要围绕基础能力、治理效率两个层面进行探索和优化建设。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223013.jpg" alt="tips-solution-2-201935223013"></p>
<h4 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h4><p>Crash治理的基础能力主要体现在三个层面：能发现、能定位和能修复。</p>
<p>在发现能力层面，美团有一套异常监控退出系统，可发现除Java&amp;JNI Crash&amp;ANR以外其他类型的异常退出。在定位能力层面，有可提供内存泄漏路径及OOM时的内存快照的内存监控体系，有可提供线程现场及任务现场的线程管控体系。除此以外，还有动态日志系统提供额外的方法调用链及参数信息。</p>
<h4 id="内存监控体系"><a href="#内存监控体系" class="headerlink" title="内存监控体系"></a>内存监控体系</h4><p>内存问题最典型的呈现形式是OOM，其中80%通过Leak监控系统发现预防，另外20%的内存问题，对于大体量APP需要从全局对内存资源问题进行监控和调查分析。</p>
<p>美团的内存监控体系分为线下和线上两个场景。线下通过Leak监控系统能预防发现80%的OOM问题，线上建立随时获取OOM内存现场的监控能力
<img src="http://images.wodekouwei.com/tips-solution-2-201935223125.jpg" alt="tips-solution-2-201935223125"></p>
<h4 id="动态日志"><a href="#动态日志" class="headerlink" title="动态日志"></a>动态日志</h4><p>美团APP经常会遇到用户个性化的使用场景无法复现和定位的问题。对此，美团提出了一套动态日志系统——</p>
<p>在编译期对应用代码通过插桩实现代理，运行期同步记录，出现异常时可主动触发上报，也可以由服务端主动回捞。基于插桩实现的代理逻辑，可实施获取原方法执行时的方法名、入参和返回值信息，再将这些信息序列化后存储到数据库，由此可在必要的时候获取到较完善的方法调用栈历史，进而定位问题。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223215.jpg" alt="tips-solution-2-201935223215">
<img src="http://images.wodekouwei.com/tips-solution-2-201935223229.jpg" alt="tips-solution-2-201935223229"></p>
<h4 id="修复能力"><a href="#修复能力" class="headerlink" title="修复能力"></a>修复能力</h4><p>在修复能力层面，美团APP一度深受机型多、系统杂带来的framework层的问题困扰。此外，美团APP也经常会遇到常规日志体系无法覆盖的接口问题。</p>
<p>针对这两类问题，参考热修复的方法替换原理，开发并完善了一套小工具——“Graft”。它的基本原理是在native层通过方法替换实现对Java层方法的hook和代理，进而在Java层实现方法代理和方法替换。</p>
<p>这套工具可以动态代理或替换几乎所有Java层的方法（包括framework层），使得美团APP的修复能力从自有代码和第三方代码有效覆盖到framework层。</p>
<p><img src="http://images.wodekouwei.com/tips-solution-2-201935223340.jpg" alt="tips-solution-2-201935223340">
<img src="http://images.wodekouwei.com/tips-solution-2-201935223353.jpg" alt="tips-solution-2-201935223353"></p>
<h4 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h4><p>为了提高治理效率，实际治理过程逐渐形成PR检查流程、自动检查平台和Crash平台三大流程和平台。</p>
<p>PR检查流程主要针对PR阶段进行代码规范性检查、代码准入检查和稳定性案例检查；自动检查平台针对以往案例进行定制化防范检查。Crash平台是整个稳定性治理的核心，在建设的考量中主要遵循规范化、流程化、自动化，它主要涵盖接入管控、聚合策略、频道工单、报警系统、基础工具、模块覆盖，可以通过强大的复用能力快速接入并管理几乎所有稳定性相关的问题。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223433.jpg" alt="tips-solution-2-201935223433"></p>
<h3 id="Crash平台"><a href="#Crash平台" class="headerlink" title="Crash平台"></a>Crash平台</h3><p>Crash平台是整个稳定性治理的核心，在建设的考量中主要遵循规范化、流程化、自动化，它主要涵盖接入管控、聚合策略、频道工单、报警系统、基础工具、模块覆盖，可以通过强大的复用能力快速接入并管理几乎所有稳定性相关的问题。</p>
<p>在PR阶段，PR检查流程可自动识别出增量代码是否被现有体系覆盖，并通过Crash平台的接入管控系统督促增量代码的责任人完善基本信息、频道信息、聚合配合及自动工单配置等等。</p>
<p>在开发或全量过程中一旦发现异常，Crash平台会自动完成堆栈聚合、频道识别、报警评估及工单跟踪等工作。</p>
<p><img src="http://images.wodekouwei.com/tips-solution-2-201935223539.jpg" alt="tips-solution-2-201935223539">
<img src="http://images.wodekouwei.com/tips-solution-2-20193522365.jpg" alt="tips-solution-2-20193522365"></p>
<p>Crash率是APP最重要的指标之一，谌天洲建议开发者建立解决Crash的长效机制，找到最合理的解决方案。随着版本的不断迭代，Crash治理之路才能离目标越来越近。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">167</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
