<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/page/2/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/page/2/"/>





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/31/tips-android-application-recent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/tips-android-application-recent/" itemprop="url">
                  最近应用杀掉进程application不销毁问题探讨
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T20:15:34+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>建雨在芝士圈应用的application中使用了全局静态变量标志是否正在录制中,开启直播后将该变量设置为录制中,录制中一些操作将被屏蔽.但是对某些手机(如htc d816)当从”最近应用”杀掉进程后有时候application不被回收,该状态变量无法通过application的onCreate中重新初始化,同时通知栏也未消失.在<a href="http://www.jianshu.com/p/169bd25ce96e" target="_blank" rel="external">Android 应用被杀后Notification不取消问题及应用深杀和浅杀时Service生命周期情况</a>探讨中找到service的<strong>onTaskRemoved</strong>方法可以监听到应用被从最近应用中移除.</p>
<p>关于&lt;<android 应用被杀后notification不取消问题及应用深杀和浅杀时service生命周期情况="">&gt;摘要:
目中有如下需求：后台service进行导入操作，要更新Notification。当运行系统清理使应用被杀时，Notification无法取消，仍然在通知栏显示。为解决这个问题进行了如下探索：</android></p>
<p>首先想到利用service的startForeground()来更新通知栏，这样当应用被杀掉时候Notification可以一起被去掉。但针对项目的需求：service可以同时导入多个文件，并且会对应显示多个通知。这种情况下用service.startForeground()更新通知栏时候，当应用被杀时候之后cancel掉最后一次调用startForeground对应id的Notification，而其他通知仍然不能被取消。</p>
<p>继续探索用其他方式取消通知栏：在进程被杀掉的时候，会调用service的哪些生命周期函数呢？service的onDestroy()方法只有在调用Context的stopService()或Service的stopSelf()后才会被调用，在应用被杀时候Service的onDestroy()不会被执行。</p>
<p>我们发现service的 onTaskRemoved()方法，该方法何时被调用呢？方法的注释说明是这么写的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* This is called if the service is currently running and the user has</div><div class="line">* removed a task that comes from the service&apos;s application.  If you have</div><div class="line">* set &#123;@linkandroid.content.pm.ServiceInfo#FLAG_STOP_WITH_TASK ServiceInfo.FLAG_STOP_WITH_TASK&#125;</div><div class="line">* then you will not receive this callback; instead, the service will simply</div><div class="line">* be stopped.</div><div class="line">*</div><div class="line">*@paramrootIntentThe original root Intent that was used to launch</div><div class="line">* the task that is being removed.</div><div class="line">*/</div><div class="line"></div><div class="line">public void onTaskRemoved(Intent rootIntent) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释表明onTaskRemoved()方法在当用户移除应用的一个Task栈时被调用。也就是当用户在最近任务界面把该应用的一个task划掉时，或者在最近任务界面进行清理时。这两种情况下onTaskRemoved()都会被调用，但在大多Android机型上，这两种情况有所不同：第一种情况即应用被浅杀(用户只划掉这一个Task)，该Task栈会被清理，但如果有后台service在运行，该应用的进程不会被杀掉，后台service仍然在运行。第二种即应用被深杀(用户在最近任务界面直接按清理按钮)，该应用的进程会被直接杀掉，后台的service当然也停止了。对于不同的手机品牌和机型在最近任务进行各种清理时过程可能不太一样，但应用浅杀和深杀对于所有Android手机都是有普遍意义的。</p>
<p>下面我们分析在应用被浅杀和被深杀以及先浅杀再深杀后的生命周期：</p>
<p>浅杀：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">04-21 17:55:13.733 8264-8264/com.qintong.test D/qintong: vCardService onTaskRemoved.</div></pre></td></tr></table></figure></p>
<p>深杀：
会出现两种情况：
(a).
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">04-26 16:20:00.349 32674-32674/? D/qintong: Service onTaskRemoved.</div><div class="line">04-26 16:21:01.621 2936-2936/? D/qintong: Service is being created.</div><div class="line">04-26 16:21:01.628 2936-2936/? D/qintong: Service onStartCommand.</div></pre></td></tr></table></figure></p>
<p>(b).
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">04-21 17:59:58.397 8264-8264/com.qintong.test D/qintong: Service onCreate.</div><div class="line">04-21 17:59:58.404 8264-8264/com.qintong.test D/qintong: Service onTaskRemoved.</div></pre></td></tr></table></figure></p>
<p>浅杀＋深杀 （service 的 onStartCommand 返回 STICKY）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">04-21 18:05:12.717 8264-8264/com.qintong.test D/qintong: Service onTaskRemoved.</div><div class="line">04-21 18:05:29.214 9207-9207/com.qintong.test D/qintong: Service onCreate.</div><div class="line">04-21 18:05:29.223 9207-9207/com.qintong.test D/qintong: Service onStartCommand.</div></pre></td></tr></table></figure></p>
<p>我们来分析这几种情况：
(1).浅杀时:应用进程没被杀掉，service仍然在执行，service的onTaskRemoved()立即被调用。</p>
<p>(2).深杀时：有两种情况：第一种情况是深杀后直接调用onTaskRemoved()且service停止，过段时间后service重启调用其onCreate()和onStartCommand()。第二种是应用的进程被杀掉，过一会后service的onCreate()方法被调用，紧接着onTaskRemoved()被调用。由于被深杀后应用的进程立刻停止了，所以service的onTaskRemoved()无法被立即调用。而过若干秒后，service重启，onCreate()被调用，紧接着onTaskRemoved()被调用。而这里service的其他方法并没有被调用，即使onStartCommand()返回STICKY，service重启后onStartCommand()方法也没有被调用。</p>
<p>(3).浅杀+深杀时(service 的 onStartCommand 返回 STICKY)：onTaskRemoved()立刻被调用(浅杀后)，深杀后过段时间onCreate()和onStartCommand()相继被调用。执行浅杀Task被清理，应用的进程还在，onTaskRemoved()被调用，过程与(1)一样。再执行深杀：由于该应用的Task栈已经没有了，所有再深杀onTaskRemoved()不会再被调用，深杀后service停止。而由于实验时候onStartCommand()返回STICKY，所有service过段时间会被再次启动，执行了onCreate()方法和onStartCommand()方法。</p>
<p>所以综上所述，service的onTaskRemoved()在应用浅杀后会被立即调用而在service被深杀后，会直接调用onTaskRemoved或service会被重启并调用onTaskRemoved()。</p>
<p>回到我们的问题：应用被杀后，如何取消Notification：
我们先看最后的解决方案，在来分析为何能work。
service的代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onCreate() &#123;</div><div class="line">  super.onCreate();</div><div class="line">  mBinder=newMyBinder();</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService is being created.&quot;);</div><div class="line">  mNotificationManager= ((NotificationManager)getSystemService(NOTIFICATION_SERVICE));</div><div class="line">  initExporterParams();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public int onStartCommand(Intent intent, intflags, intid) &#123;</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService onStartCommand.&quot;);</div><div class="line">  mNotificationManager.cancelAll();</div><div class="line">  return START_STICKY;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onTaskRemoved(Intent rootIntent) &#123;</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService onTaskRemoved.&quot;);</div><div class="line">  mNotificationManager.cancelAll();</div><div class="line">  super.onTaskRemoved(rootIntent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上代码，在浅杀时候：只执行onTaskRemoved()，通知被取消，但service仍然在运行，所以还会继续发通知，正常运行。
深杀时：第一种情况直接调用onTaskRemoved()且service停止，通知被取消。第二种情况，进程被杀掉，几秒后service重启，onCreate() -&gt; onTaskRemoved()，运行结果就是深杀后过几秒后Notification被取消。
浅杀+深杀时：浅杀后onTaskRemoved()被调用，service仍在运行，通知仍然在更新。深杀时，onCreate() -&gt; onStartCommand()，在onStartCommand()时候取消通知。
另外，mNotificationManager.cancelAll()会清除应用的所有通知，如果应用想保留和该service无关其他通知，可以调用mNotificationManager.cancel(String tag, int id)或cancel(int id)清除指定通知。
当然，还可以有另一种方式：浅杀时后就把service后台执行的任务停止，并清理notification，我们可以根据需求来选择。</p>
<p>补充：
疑问：1.为啥有时候深杀不立即调用onTaskRemoved()，而是在重启之后调用的呢？
stackoverflow上的答复:<a href="https://stackoverflow.com/questions/32224233/ontaskremoved-called-after-oncreate-in-started-service-on-swipe-out-from-recent/41506752" target="_blank" rel="external">https://stackoverflow.com/questions/32224233/ontaskremoved-called-after-oncreate-in-started-service-on-swipe-out-from-recent/41506752</a>
大意是service执行较重UI操作时候service不会立即停止，而新的service会启动。不太确定这个解释的正确性……</p>
<blockquote>
<p>Calling onTaskRemoved of the running service(when app gets swiped out from recent apps) will be generally delayed if we are performing any heavy UI related stuff or broadcasting messages to receivers in service.
E.g , Assume you are downloading the file of size 50MB from web server, so from web server everytime you are reading 1024bytes of stream data as buffer and that data you are writing to a file in device.
Meanwhile you are updating the progress to the UI thread which means every KB you are updating to the UI thread, this will cause the application to freeze.
So in between if you swipe-out from recent app list , then the system will try to stop the service but since the service is in-contact with the UI thread, the system will be unable to stop that service, but it will create new service eventhough the old service is not yet stopped.
Once old service finishes the communication with the UI thread then onTaskRemoved() gets called and the old service will be stopped. The new service will be running in the background.
2.为何servive.startForeground()添加的Notification可以在service被杀死后去掉呢？我们分析源码：ActiveServices中killServicesLocked()-&gt;scheduleServiceRestartLocked()中调用了r.cancelNotification()，清除了notification:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public void cancelNotification() &#123;</div><div class="line">        if (foregroundId != 0) &#123;</div><div class="line">            // Do asynchronous communication with notification manager to</div><div class="line">            // avoid deadlocks.</div><div class="line">            final String localPackageName = packageName;</div><div class="line">            final int localForegroundId = foregroundId;</div><div class="line">            ams.mHandler.post(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    INotificationManager inm = NotificationManager.getService();</div><div class="line">                    if (inm == null) &#123;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                    try &#123;</div><div class="line">                        inm.cancelNotificationWithTag(localPackageName, null,</div><div class="line">                                localForegroundId, userId);</div><div class="line">                    &#125; catch (RuntimeException e) &#123;</div><div class="line">                        Slog.w(TAG, &quot;Error canceling notification for service&quot;, e);</div><div class="line">                    &#125; catch (RemoteException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/31/l-c-dllist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/l-c-dllist/" itemprop="url">
                  (转)转使用C语言实现"泛型"链表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T20:13:42+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看到这个标题，你可能非常惊讶，C语言也能实现泛型链表？我们知道链表是我们非常常用的数据结构，但是在C中却没有像C++中的STL那样有一个list的模板类，那么我们是否可以用C语言实现一个像STL中的list那样的泛型链表呢？答案是肯定的。下面就以本人的一个用C语言设计的链表为例子，来分析说明一下本人的设计和实现要点，希望能给你一点有用的帮助。</p>
<h3 id="一、所用的链表类型的选择"><a href="#一、所用的链表类型的选择" class="headerlink" title="一、所用的链表类型的选择"></a>一、所用的链表类型的选择</h3><p>我们知道，链表也有非常多的类型，包括单链表、单循环链表、双链表、双向循环链表等。在我的设计中，我的链表使用的类型是双向循环链表，并带一个不保存真实数据的头结点。其原因如下：
1）单链表由于不能从后继定位到前驱，在操作时较为不方便
2）双链表虽然能方便找到前驱，但是如果总是在其尾部插入或删除结点，为了定位的方便和操作的统一（所有的删除和插入操作，都跟在中间插入删除结点的操作一样），还要为其增加一个尾结点，并且程序还要保存一个指向这个尾结点的指针，并管理这个指针，从而增加程序的复杂性。而使用带头结点的循环双向链表，就能方便的定位（其上一个元素为链表的最后一个元素，其下一个元素为链表的第0个元素），并使所有的插入和删除的操作统一，因为头结点也是尾结点。注：结点的下标从0开始，头结点不算入下标值。
3）接口的使用与C++中stl中list和泛型算法的使用大致相同。</p>
<h3 id="二、list类型的定义"><a href="#二、list类型的定义" class="headerlink" title="二、list类型的定义"></a>二、list类型的定义</h3><p>为了让大家一睹为快，下面就给出这个用C语言实现的“泛型”的定义，再来说明，我这样设计的原因及要点，其定义如下：
其定义在文件list_v2.c中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef struct node  </div><div class="line">&#123;  </div><div class="line">    //循环双链表的结点结构  </div><div class="line">    void* data;//数据域指针  </div><div class="line">    struct node *next;//指向当前结点的下一结点  </div><div class="line">    struct node *last;//指向当前结点的上一结点  </div><div class="line">&#125;Node;  </div><div class="line"></div><div class="line">struct list  </div><div class="line">&#123;  </div><div class="line">    struct node *head;//头指针，指向头结点  </div><div class="line">    int data_size;//链表对应的数据所占内存的大小  </div><div class="line">    int length;//链表list的长度  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其声明在文件list_v2.h中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">//泛型循环双链表，带头结点，结点下标从0开始，头结点不计入下标值  </div><div class="line"></div><div class="line"></div><div class="line">//定义结点指针Node*为List类型的迭代器  </div><div class="line">typedef struct node* Iterator;  </div><div class="line"></div><div class="line"></div><div class="line">//List类型的定义  </div><div class="line">typedef struct list* List;  </div><div class="line"></div><div class="line"></div><div class="line">//初始化链表,数据域所占内存的大小由data_size给出  </div><div class="line">int InitList(List *list, int data_size);  </div><div class="line"></div><div class="line"></div><div class="line">//把data的内容插入到链表list的末尾  </div><div class="line">//assign指定数据data间的赋值方法  </div><div class="line">Iterator Append(List list, void *data,  </div><div class="line">                void (*assign)(void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//把data的内容插入到链表的迭代器it_before的前面  </div><div class="line">//assign指定数据data间的赋值方法  </div><div class="line">Iterator Insert(List list, void *data, Iterator it_before,  </div><div class="line">                void (*assign)(void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//把链表A中迭代器it_a指向的结点移动到链表B中迭代器it_b_befroe的前面  </div><div class="line">Iterator MoveFromAtoB(List A, Iterator it_a,  </div><div class="line">                      List B, Iterator it_b_before);  </div><div class="line"></div><div class="line"></div><div class="line">//删除链表list中迭代器it指向的结点  </div><div class="line">int Remove(List list, Iterator it);  </div><div class="line"></div><div class="line"></div><div class="line">//删除链表list的第0个结点，下标从0开始  </div><div class="line">int RemoveFirst(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//删除链表list的最后一个结点  </div><div class="line">int RemoveLast(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//返回list中第index个数据的指针  </div><div class="line">void* At(List list, int index);  </div><div class="line"></div><div class="line"></div><div class="line">//在begin和end之间查找符合condition的第一个元素，  </div><div class="line">//比较函数由condition指向,比较的值由data指向  </div><div class="line">//当第一个参数的值小于第二个参数的值时，返回1，否则返回0  </div><div class="line">//根据condition函数的不同，可以查找第一个相等、大于或小于data的值  </div><div class="line">Iterator FindFirst(Iterator begin, Iterator end, void *data,  </div><div class="line">                       int (*condition)(const void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//查找list中第一个与data相等的元素的下标，  </div><div class="line">//equal函数，当第一个参数与第二个参数的值相等时，返回1，否则返回0  </div><div class="line">int IndexOf(List list, void *data,  </div><div class="line">            int (*equal)(const void*,const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//查找在begin和end之间的最小值，比较函数由less指向  </div><div class="line">//当第一个参数的值小于第二个参数的值时，返回1，否则返回0  </div><div class="line">Iterator GetMin(Iterator begin, Iterator end,  </div><div class="line">                int (*less)(const void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//查找在begin和end之间的最大值，比较函数由large指向  </div><div class="line">//当第一个参数的值大于第二个参数的值时，返回1，否则返回0  </div><div class="line">Iterator GetMax(Iterator begin, Iterator end,  </div><div class="line">                int (*large)(const void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//获取list的长度  </div><div class="line">int GetLength(List list);  </div><div class="line">//若list为空链表，则返回1，否则返回0  </div><div class="line">int IsEmpty(List list);  </div><div class="line">//销毁list  </div><div class="line">void DestroyList(List *list);  </div><div class="line"></div><div class="line"></div><div class="line">//获得list的首迭代器  </div><div class="line">Iterator Begin(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//获得list的尾迭代器，指向最后一个元素的下一个位置  </div><div class="line">Iterator End(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//使it指向下一个位置，并返回指向下一个位置后的迭代器  </div><div class="line">Iterator Next(Iterator *it);  </div><div class="line"></div><div class="line"></div><div class="line">//使it指向上一个位置，并返回指向上一个位置后的迭代器  </div><div class="line">Iterator Last(Iterator *it);  </div><div class="line"></div><div class="line"></div><div class="line">//通过迭代器it获得数据，相当于*p  </div><div class="line">void* GetData(Iterator it);  </div><div class="line"></div><div class="line"></div><div class="line">//获取当前迭代器的下一个迭代器，注意，并不改变当前迭代器  </div><div class="line">Iterator GetNext(Iterator it);  </div><div class="line"></div><div class="line"></div><div class="line">//获取当前迭代器的上一个迭代器，注意，并不改变当前迭代器  </div><div class="line">Iterator GetLast(Iterator it);</div></pre></td></tr></table></figure></p>
<h3 id="三、如何实现隐藏链表的成员变量（即封装）"><a href="#三、如何实现隐藏链表的成员变量（即封装）" class="headerlink" title="三、如何实现隐藏链表的成员变量（即封装）"></a>三、如何实现隐藏链表的成员变量（即封装）</h3><p>首先，我们为什么需要封装呢？我觉得封装主要有三大好处。</p>
<ol>
<li>隔离变化，在程序中需要封装的通常是程序中最容易发生变化的地方，例如成员变量等，我们可以把它们封装起来，从而让它们的变化不会影响到系统的其他部分，也就是说，封装的是变化。</li>
<li>降低复杂度，因为我们把一个对象是如何实现的等细节封装起来，只留给用户一个最小依赖的接口，从而让系统变量简单明了，在一定程度降低了系统的复杂性，方便了用户的使用。</li>
<li>让用户只能按照我们设计好的接口来操作一个对象或类型，而不能自己直接对一个对象进行操作，从而减少了用户的误操作，提高了系统的稳定性。</li>
</ol>
<p>在面向对象的设计中，如果我们想要隐藏一个类的成员变量，我们可以把这些成员变量声明为私有的，而在C语言中，我们可以怎么实现呢？其实其实现是很简单的，我们在C语言中，当我们要使用一个自己定义的类型或函数时，我们会把声明它的头文件包含（include）过来，只要我们在文件中只声明其类型是一个结构体，而把它的实现写在.c文件中即可。</p>
<p>在本例子中，我把<code>struct list</code>和<code>struct node</code>定义在.c文件中，而在头文件中，只声明其指针类型，即<code>typedef struct node* Iterator</code>和<code>typedef struct list* List;</code>当我们要使用该类型时，只需要在所在的文件中，include该头文件即可。因为在编译时，编译器只要知道List和Iterator是一个指针类型就能知道其所占的内存大小，也就能为其分配内存，所以能够编译成功。而又因为该头文件中并没有该类型（struct list和struct node）的定义，所以我们在使用该类型时，只能通过我们提供的接口来操作对象。例如，我们并不能使用<code>List list; list-&gt;data</code>等等的操作，而只能通过已定义的接口GetData来获得。</p>
<p>###四、如何实现泛型
泛型，第一时间想起的可能是模板，但是在C语言中却没有这个东西。但是C语言中却有一个可以指向任何类型，在使用时，再根据具体的指针类型进行类型转换的指针类型，它就是<code>void*</code>。</p>
<p>为什么void<em>可以指向任何类型的数据？这还得从C语言对于数据类型的处理方式来说明。在C语言中，我们使用<code>malloc</code>等函数来申请内存，而从内存的角度来看，数据是没有类型的，它们都是一串的0或1，而程序则根据不同的类型来解释这个内存单元中的数据的意义，例如对于内存中的数据，<code>FFFFFFFF</code>，如果它是一个有符号整型数据，它代表的是<code>-1</code>，而如果它是一个无符号整型数据，它代表的则是<code>2^32-1</code>。进一步说，如果你用一个<code>int</code>的指针变量p指向该内存，则</em>p就是-1，如果你用<code>unsigned int</code>的指针<code>p</code>指向该内存，则<code>*p = 2^32-1</code>。</p>
<p>而我们使用<code>malloc</code>等函数时，也只需要说明申请的内存的大小即可，也不用说明申请的内存空间所存放的数据的类型，例如，我们申请一块内存空间来存放一个整型数据，则只需要<code>malloc(sizeof(int))</code>，即可，当然你完全可以把它当作一个具有4个单位的char数组来使用。所以我们可以使用void指针来指向我们申请的内存，申请内存的大小由链表中的成员data_size定义，它也是真正的data所占的内存大小。</p>
<h3 id="五、为什么需要赋值函数指针assign"><a href="#五、为什么需要赋值函数指针assign" class="headerlink" title="五、为什么需要赋值函数指针assign"></a>五、为什么需要赋值函数指针assign</h3><p>这里来说明一下，该链表的数据的插入方式，我们的插入方式是，新建一个结点，把data指向的数据复制到结点中，并把该结点插入到链表中。插入的函数定义如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Iterator Insert(List list, void *data, Iterator it_before,</div><div class="line">                void (*assign)(void*, const void*));</div></pre></td></tr></table></figure></p>
<p>从上面的解说中，我们可以看到链表中的成员data_size指示了链表中的数据所占的内存大小，那我们们就可以使用函数memcpy把data指向的数据复制到新建的结点的data所指向的内存即可。为什么还需要一个函数指针assign，来指向一个定义数据之间如何赋值的函数呢？其实这和面向对象语言中常说到的深复制和浅复制有关。</p>
<p>注：memcpy函数的原型为：<code>void * memcpy ( void * destination, const void * source, size_t num );</code></p>
<p>试想一下，假如你的链表的数据类型不是int型等基本类型，也不是不含有指针的结构体，而是一个这样的结构体，例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct student  </div><div class="line">&#123;  </div><div class="line">    char *name;  </div><div class="line">    char *no;  </div><div class="line">    int age;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>学生的姓名和学号都是能过动态分配内存而来的，并由student结构体中的name和no指针指向，那么当我们使用memcpy时，只能复制其指针，而不能复制其指向的数据，这样在很多情况下都会带来一定的问题。这个跟在C++中什么时候需要自己定义复制构造函数的情况类似。因为这种情况下，默认的复制构造函数并不能满足我们的需要，只能自己定义复制构造函数。</p>
<p>所以在插入一个结点时，需要assign函数指针的原理与C++中自己定义复制构造函数的原理一样。它用于定义如何根据一个已有的对象生成一个该对象的拷贝对象。当然，可能在大多数的情况下，我们需要用到的数据类型都没有包含指针，所以在Insert函数的实现中，其实我也是有用到memcpy函数的，就是当assign为NULL时，就使用memcpy函数进行数据对象间的赋值，它其实就相当于C++中的默认复制构造函数或默认赋值操作函数。assign为NULL表示使用默认的逐位复制方式，即浅复制。</p>
<h3 id="六、为什么不用typedef"><a href="#六、为什么不用typedef" class="headerlink" title="六、为什么不用typedef"></a>六、为什么不用typedef</h3><p>对于这个问题，其实很好回答。很多人实现一个通用链表是这样实现的，它们把node结构的实现如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct node  </div><div class="line">&#123;  </div><div class="line">    //循环双链表的结点结构  </div><div class="line">    DataType data;//数据域指针  </div><div class="line">    struct node *next;//指向当前结点的下一结点  </div><div class="line">    struct node *last;//指向当前结点的上一结点  </div><div class="line">&#125;Node;</div></pre></td></tr></table></figure></p>
<p>然后，当需要使用整型的链表时，就把DataType用typedef为int。其实这样做的一个最大的缺陷就是一个程序中只能存在着一个数据类型的链表，例如，如果我需要一个int型的链表和一个float型的链表，那么该把DataType定义为int呢还是float呢？所以这种看似可行的方式，其实只是虚有其表，在现象中是行不能的，虽然不少的数据结构的书都是这样实现的，但是它却没有什么实用价值。</p>
<p>而其本质的原因是把结点的数据域的数据类型与某一种特定的数据类型DataType绑定在一起，从而让链表不能独立地变化。</p>
<h3 id="七、为什么只把结点的指针定义为Iterator"><a href="#七、为什么只把结点的指针定义为Iterator" class="headerlink" title="七、为什么只把结点的指针定义为Iterator"></a>七、为什么只把结点的指针定义为Iterator</h3><p>在C++中iterator是一个类，为什么在这里，我只把结点的指针声明为一个Iterator呢？其实受STL的影响，我在一开始时，也是把Iterator实现为一个结构体，它只有一个数据成员，就是一个指向Node的指针。但在后来的实践中，发现其实并没有必要。在C++中为什么把iterator定义为一个类，是为了重载*，-&gt;等运行符，让iterator使用起来跟普通的指针一样。但是在C语言中，并没有重载运行符的做法，所以直接把Ierator声明为一个Node的指针最为方便、直接和好用，所有的比较运算都可以直接进行，而无需要借助函数。而把它声明为一个结构体反而麻烦、累赘。</p>
<h3 id="八、为什么查找需要两个Iterator"><a href="#八、为什么查找需要两个Iterator" class="headerlink" title="八、为什么查找需要两个Iterator"></a>八、为什么查找需要两个Iterator</h3><p>其实这是参考了STL中的泛型算法的思想。而且本人觉得这是一种比较好的实现。为什么FindFirst的函数原型不是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iterator FindFirst(List list,  int (*condition)(const void*, const void*));</div></pre></td></tr></table></figure></p>
<p>而是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iterator FindFirst(Iterator begin, Iterator end, void *data,int (*condition)(const void*, const void*));</div></pre></td></tr></table></figure></p>
<p>们可以试想一下，这个链表的为char链表，链表的元素为ABCBCBC，我们要在链表中找出所有的B，如果查找算法是使用第一种定义的话，它只能找出第一个B，而后面的两个B就无能为力了，而第二种定义，则可以通过循环改变其始末迭代器来在不同的序列段间查找目标字符B的位置。</p>
<blockquote>
<p>转自<a href="http://blog.csdn.net/ljianhui/article/details/18748657" target="_blank" rel="external">使用C语言实现“泛型”链表</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/31/l-kotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/l-kotlin/" itemprop="url">
                  Kotlin语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T20:13:42+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;chaychan&quot;</div><div class="line">println(str1 == str2)</div></pre></td></tr></table></figure>
<p>比较两个字符串，如果两个字符串的内容一致，在Java中使用 str1 == str2 时，是比较两个字符串的地址值，很清楚两个字符串的地址不一样，返回false，但是在kotlin中，则不是如此，比较的只是字符串的内容，而===相当于Java中的==，用来比较引用对象, 上述代码返回的是true。</p>
<p><strong>equal函数</strong></p>
<ol>
<li><code>equals(str:String)</code></li>
</ol>
<p>方法中的参数是与之对比的字符串，默认不忽略大小写，即大小写敏感，比如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;ChayChan&quot;</div><div class="line">println(str1.equals(str2))</div></pre></td></tr></table></figure></p>
<p>打印结果为false，因为不忽略大小写的话，两个字符串内容对比是不一致的，所以返回false。</p>
<ol>
<li><code>equals(str:String,ignoreCase:Boolean)</code>
方法中有两个参数，第一个参数是与之对比的字符串，第二个参数是布尔类型的值，是否忽略大小写，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;ChayChan&quot;</div><div class="line">println(str1.equals(str2,true))</div></pre></td></tr></table></figure>
</li>
</ol>
<p>返回结果为true。</p>
<h3 id="源码优化分析"><a href="#源码优化分析" class="headerlink" title="源码优化分析"></a>源码优化分析</h3><p><a href="https://github.com/googlesamples/android-architecture/tree/dev-todo-mvp-kotlin/" target="_blank" rel="external">源码</a></p>
<h4 id="1-Lateinit"><a href="#1-Lateinit" class="headerlink" title="1.Lateinit"></a>1.Lateinit</h4><p>在View声明阶段，都会需要使用lateinit来延迟声明变量。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class TaskActivity : AppCompatActivity()&#123;</div><div class="line">  private val CURRENT_FILTERING_KEY = &quot;CURRENT_FILTERING_KEY&quot;;</div><div class="line">  private lateinit var drawerLayout : DrawerLayout</div><div class="line">  private lateinit var tasksPresenter:TasksPresenter</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>kotlin中延迟声明还包括lazy的方式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val name:String by lazy &#123;&quot;cangwang&quot;&#125;</div><div class="line">lateinit var drawLayout:drawLayout</div></pre></td></tr></table></figure></p>
<p>区别在于:</p>
<ol>
<li>.lazy{}只能用再val类型,lateinit只能用在var类型</li>
<li>.lateinit不能用在可空的属性上和java的基本类型上<code>lateinit var name:String</code>会报错</li>
<li>.lateinit可以在任何位置初始化并且可以初始化多次,因为其衔接var变量.而lazy在第一次被调用时就被初始化,其衔接的是val常量,想要被改变只能重新定义</li>
</ol>
<h4 id="2-findViewById"><a href="#2-findViewById" class="headerlink" title="2.findViewById"></a>2.findViewById</h4><p>Api26前:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public View findViewById(@IdRes int id)&#123;</div><div class="line">  return getDelegate().findViewById(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Api26之后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;TypeParameterUnusedInFormals&quot;)</div><div class="line">@Override</div><div class="line">public &lt;T extends View&gt; T indViewById(@IdRes int id)&#123;</div><div class="line">  return getDelegate().findViewById(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="五个kotlin-Standard-kt里面的函数-apply-with-let-run-also"><a href="#五个kotlin-Standard-kt里面的函数-apply-with-let-run-also" class="headerlink" title="五个kotlin Standard.kt里面的函数:apply,with,let,run,also"></a>五个kotlin Standard.kt里面的函数:apply,with,let,run,also</h4><ol>
<li>apply作用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setSupportActionBar(findViewById&lt;Toolbar&gt;(R.id.toolbar))</div><div class="line">supportActionBar?.apply&#123;</div><div class="line">  setDisplayHomeAsUpEnabled(true)</div><div class="line">  setDisplayShowHomeEnabled(true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在函数内可以通过this指代该对象,返回值为该对象自己</p>
<ol>
<li>with函数
将某对象作为函数的参数,在函数内可以通过this指代该对象.返回值为函数块的最后一行或指定return表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">override fun getView(i:Int,view:View?,viewGroup:ViewGroup):View&#123;</div><div class="line">  val rowView=Vview?:LayoutInflater.from(viewGroup.context).inflate(R.layout.task_item,viewGroup,false)</div><div class="line">  val task = getItem(i)</div><div class="line">  with(rowView.findViewById&lt;TextView&gt;(R.id.title))&#123;</div><div class="line">    text = task.titleForList</div><div class="line">  &#125;</div><div class="line">  with(rowView.findViewById&lt;CheckBox&gt;(R.id.complete))&#123;</div><div class="line">    isChecked=task.isCompleted</div><div class="line">    rowView.setBackgroundDrawable(...)</div><div class="line">    setOnClickListener&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-lat函数"><a href="#3-lat函数" class="headerlink" title="3.lat函数"></a>3.lat函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private fun showMessage(message:String)&#123;</div><div class="line">  view?.let&#123;</div><div class="line">    Snackbar.make(it,message,Snackbar.LENGTH_LONG).show()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将对象作为函数参数,在函数块内可以通过it指代该对象.返回值为函数块的最后一行或指定return表达式</p>
<h4 id="4-run函数"><a href="#4-run函数" class="headerlink" title="4. run函数"></a>4. run函数</h4><p>其有两种表达式:</p>
<ul>
<li>第一种无参数输入</li>
<li>第二种会将对象本身this给函数调用
返回值为函数块最后一行,或者指定return表达式</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>单例对象是使用Object申明
Kotlin没有静态属性和方法,需要使用单例对象来实现类似的功能.</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>相当于java中定义的数据bean类,其可以直接在属性之后编写get和set方法</p>
<h3 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a><code>@JvmOverloads</code></h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/31/tool-as3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/tool-as3/" itemprop="url">
                  tool-as3
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T19:47:42+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AndroidStudio3-0新特性"><a href="#AndroidStudio3-0新特性" class="headerlink" title="AndroidStudio3.0新特性"></a>AndroidStudio3.0新特性</h3><h4 id="支持Java8语言"><a href="#支持Java8语言" class="headerlink" title="支持Java8语言"></a>支持Java8语言</h4><p>由于AS3.0默认支持Java8语言，所以我们就可以移除build.gradle里面的jackOptions了
<del>jackOptions { true }</del></p>
<p>然后可以在build.gradle配置为Java8
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">  ...</div><div class="line">  compileOptions &#123;</div><div class="line">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">    targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果对Java8的一些特性存在问题,我们也可以在gradle.properties里面禁用Java8
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android.enableDesugar=false</div></pre></td></tr></table></figure></p>
<h4 id="配置产品渠道"><a href="#配置产品渠道" class="headerlink" title="配置产品渠道"></a>配置产品渠道</h4><p>AS3.0以前我们常用productFlavors配置不同的渠道包，比如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">        dev&#123;</div><div class="line">            applicationIdSuffix &quot;.dev&quot;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        prod  &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>AS3.0得新增flavorDimensions的配置，主要有以下 12 个构建变体：
构建变体：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[minApi24, minApi23, minApi21][Demo, Full][Debug, Release]</div></pre></td></tr></table></figure></p>
<p>对应 APK：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk</div></pre></td></tr></table></figure></p>
<p>比如这里创建一个构建方式
首先得在defaultConfig通过flavorDimensions配置构建变体，如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">       ...</div><div class="line">        flavorDimensions &quot;debug&quot;,&quot;release&quot;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后productFlavors的配置就可以如下:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">        demo &#123;</div><div class="line">            dimension &quot;debug&quot;</div><div class="line">            applicationIdSuffix &quot;.demo&quot;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">        prod  &#123;</div><div class="line">            dimension &quot;release&quot;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="改进的Android插件"><a href="#改进的Android插件" class="headerlink" title="改进的Android插件"></a>改进的Android插件</h4><ul>
<li>优化了多 module 的项目并行编译运行更详细Task的展示
构建变体的从属管理，比如上文的Flavors Dimensions配置新 api ，implementation依赖（替代compile ），compileOnly（替代provided）和runtimeOnly（替代 apk）</li>
<li>通过增量编译 优化多dex的app构建速度</li>
<li>优化了AAPT2增量资源化处理。如果要启用AAPT2,在gradle.properties文件添加代码：<code>android.enableAapt2=true</code></li>
<li>支持java8语言</li>
<li>增加测试工具，可通过dependencies依赖使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies&#123;</div><div class="line">        androidTestUtil“com.linkedin.testbutler：测试管家应用：1.3.0@apk”</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常见出错总结"><a href="#常见出错总结" class="headerlink" title="常见出错总结"></a>常见出错总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:Cause: getMainOutputFile is no longer supported.  Use getOutputFileName if you need to determine the file name of the output.</div></pre></td></tr></table></figure>
<p>或
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:Not valid.</div></pre></td></tr></table></figure></p>
<p>主要是AndResGuard1.2.3版本还没有兼容AS3.0
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:All flavors must now belong to a named flavor dimension. The flavor &apos;prod&apos; is not assigned to a flavor dimension. Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html</div></pre></td></tr></table></figure></p>
<p>AS3.0需要通过flavorDimensions来配置产品渠道，详细看上文。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/17/tips-candcpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/17/tips-candcpp/" itemprop="url">
                  C/CPP中的编程技巧及其概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-17T11:25:05+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="C-Language"><a href="#C-Language" class="headerlink" title="C Language"></a>C Language</h3><h4 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h4><p>size_t的全称应该是size type，就是说“一种用来记录大小的数据类型”。属于C99标准，它所定义的变量可以进行加减乘除运算。因此函数中表示数据大小的变量，推荐使用这个类型！例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int xxx(voidvoid *p, size_t len);</div></pre></td></tr></table></figure></p>
<h4 id="指针的指针（双重指针）的作用："><a href="#指针的指针（双重指针）的作用：" class="headerlink" title="指针的指针（双重指针）的作用："></a>指针的指针（双重指针）的作用：</h4><ol>
<li>用来传递需要修改的指针参数到函数中；</li>
<li>用来动态生成多维数组；</li>
<li>多用于指针交换，可以避免数据复制，提升系统的性能，同时还可以让函数修改指针，例如扩充其大小，指向等一般指针的指针用作参数，大多用在需要函数改变指针(重新引用变量)而又不能通过返回值传递(例如返回值用于传递其他结果)时。</li>
</ol>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>以空间换时间。</p>
<h4 id="backtrace函数追踪函数调用堆栈以及定位段错误"><a href="#backtrace函数追踪函数调用堆栈以及定位段错误" class="headerlink" title="backtrace函数追踪函数调用堆栈以及定位段错误"></a>backtrace函数追踪函数调用堆栈以及定位段错误</h4><p>一般察看函数运行时堆栈的方法是使用GDB（bt命令）之类的外部调试器,但是,有些时候为了分析程序的BUG,(主要针对长时间运行程序的分析),在程序出错时打印出函数的调用堆栈是非常有用的</p>
<h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><h4 id="显示限定数组实参的原始个数"><a href="#显示限定数组实参的原始个数" class="headerlink" title="显示限定数组实参的原始个数"></a>显示限定数组实参的原始个数</h4><p>数组在作为函数参数传递时会退化为指针：</p>
<blockquote>
<p>A declaration of a parameter as “array of type” shall be adjusted to “qualified pointer to type”.</p>
</blockquote>
<p>以及前面已经提到的：</p>
<blockquote>
<p>int x[3][5];Here x is a 3 × 5 array of integers. When x appears in an expression, it is converted to a pointer to (the first of three) five-membered arrays of integers.</p>
</blockquote>
<p>这意味着数组作为参数传递时会丢失边界(C/C++的原生数组本来也就没有边界检查…)。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void funcA(int x[10])&#123;&#125;</div><div class="line">// Equivalent to</div><div class="line">void funcB(int *x)&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其对应的中间代码为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">; Function Attrs: nounwind uwtable</div><div class="line">define void @_Z5funcAPi(i32*) #4 &#123;</div><div class="line">  %2 = alloca i32*, align 8</div><div class="line">  store i32* %0, i32** %2, align 8</div><div class="line">  ret void</div><div class="line">&#125;</div><div class="line">; Function Attrs: nounwind uwtable</div><div class="line">define void @_Z5funcBPi(i32*) #4 &#123;</div><div class="line">  %2 = alloca i32*, align 8</div><div class="line">  store i32* %0, i32** %2, align 8</div><div class="line">  ret void</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果数组边界的精确数值非常重要，并且希望函数只接收含有特定数量的元素的数组，可以使用引用形参：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void funcC(int (&amp;x)[10])&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其中间代码为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">; Function Attrs: nounwind uwtable</div><div class="line">define void @_Z5funcCRA10_i([10 x i32]* dereferenceable(40)) #4 &#123;</div><div class="line">  %2 = alloca [10 x i32]*, align 8</div><div class="line">  store [10 x i32]* %0, [10 x i32]** %2, align 8</div><div class="line">  ret void</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们使用数组元素个数不等于10的数组传递给funcC,会导致编译错误：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// note: candidate function not viable: no known conversion from &apos;int [11]&apos; to &apos;int (&amp;)[10]&apos; for 1st argument.</div><div class="line">void funcC(int (&amp;x)[10])&#123;&#125;</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  int x[11]=&#123;0,1,2,3,4,5,6,7,8,9,10&#125;;</div><div class="line">  // error: no matching function for call to &apos;funcC&apos;.</div><div class="line">  funcC(x);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用函数模板参数来指定函数接收参数的数组大小：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;int arrSize&gt;</div><div class="line">void funcA(int x[arrSize])&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>使用时：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x[12]</div><div class="line">funcA&lt;12&gt;(x); // OK</div><div class="line">funcA&lt;13&gt;(x); //ERROR</div></pre></td></tr></table></figure></p>
<h4 id="启用编译器的改变符号的隐式类型转换警告"><a href="#启用编译器的改变符号的隐式类型转换警告" class="headerlink" title="启用编译器的改变符号的隐式类型转换警告"></a>启用编译器的改变符号的隐式类型转换警告</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if((unsigned int)4&lt;(unsigned int)(int)-1)&#123;</div><div class="line">  cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;</div><div class="line">&#125;else&#123;</div><div class="line">  cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>if中的那段表达式是为true的(输出yes)，而且编译时也不会发出警告。
虽然我们指定了(int)-1，但是当将unsigned int和int比较时会发生隐式转换。即：</p>
<blockquote>
<p>The usual arithmetic conversions are performed on operands of arithmetic or enumeration type.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((unsigned int)4&lt;(unsigned)(int)-1)==true</div></pre></td></tr></table></figure></p>
<p>Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless -Wsign-conversion is explicitly enabled.</p>
</blockquote>
<p>通过启用-Wsign-conversion就可以看到警告了(建议开启)。
该参数的作用为：</p>
<blockquote>
<p>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by -Wconversion.</p>
</blockquote>
<h4 id="断言-assert"><a href="#断言-assert" class="headerlink" title="断言(assert)"></a>断言(assert)</h4><p>assert Defined in header(c++)/(C)</p>
<blockquote>
<p>If NDEBUG is defined as a macro name at the point in the source code where <assert.h> is included, then assert does nothing.
If NDEBUG is not defined, then assert checks if its argument (which must have scalar type) compares equal to zero.</assert.h></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef NDEBUG</div><div class="line">#define assert(condition) ((void)0)</div><div class="line">#else</div><div class="line">#define assert(condition) /*implementation defined*/</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>assert只在Debug模式中有效，使用release模assert什么都不做了。
因为在VC++里面，release会在全局定义NDEBUG
下面的代码在VS中使用debug和release模式分别编译并输入&gt;100的数，会有不一样的结果(release不会)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">bool func(int x) &#123;</div><div class="line">  if (x &gt; 100) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">int main(void) &#123;</div><div class="line">  int i;</div><div class="line">  cin &gt;&gt; i;</div><div class="line">  assert(func(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="无效的引用"><a href="#无效的引用" class="headerlink" title="无效的引用"></a>无效的引用</h4><p>通常情况下我们创建的引用就是有效的，但是也可以人为因素使坏…
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">char* ident(char *p) &#123; return p; &#125;</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  char&amp; r &#123;*ident(nullptr)&#125;;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是UB的行为。</p>
<blockquote>
<p>in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the “object” obtained by indirection through a null pointer,which causes undefined behavior.</p>
</blockquote>
<h4 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void f(int(&amp;r)[4])&#123;</div><div class="line">  cout&lt;&lt;sizeof(r)&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">void g(void)&#123;</div><div class="line">  int a[]=&#123;1,2,3,4&#125;;</div><div class="line">  f(a); // OK</div><div class="line">  int b[]=&#123;1,2,3&#125;;</div><div class="line">  f(b); // 错误，元素个数有误</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于数组引用类型的从参数来说，元素个数也是其类型的一部分。通常只有在模板中才会使用数组引用，此时数组的引用可以通过推断得到。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template&lt;class T,int N&gt;</div><div class="line">void f(T(&amp;r)[N])&#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">int a1[10];</div><div class="line">double a2[100];</div><div class="line">void g()&#123;</div><div class="line">  f(a1);  // T是int，N是10</div><div class="line">  f(a2);  // T是double，N是100</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么做的后果是调用f()所用的不同类型的数组有多少个，对应定义的函数有多少个。</p>
<h4 id="忽略函数参数的顶层const"><a href="#忽略函数参数的顶层const" class="headerlink" title="忽略函数参数的顶层const"></a>忽略函数参数的顶层const</h4><p>为了与C语言兼容，在C++中会自动忽略参数类型的顶层const。</p>
<p>例如下面的函数在C++会报重定义错误，而不是重载：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 类型是int(int)</div><div class="line">int f(int x)&#123;&#125;</div><div class="line">// error: redefinition of &apos;f&apos;</div><div class="line">// 类型是int(int)</div><div class="line">int f(const int x)&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>不论对于哪种情况，允许修改实参也好，不允许修改实参也好，它都只是函数调用者提供的实参的一个副本。因此调用过程不会破坏调用上下文的数据安全性。</p>
<h4 id="char作为数组下标时当心unsigned-signed"><a href="#char作为数组下标时当心unsigned-signed" class="headerlink" title="char作为数组下标时当心unsigned/signed"></a>char作为数组下标时当心unsigned/signed</h4><p>当char类型用作数组下标时，一定要先转unsigned char（因为char通常是有符号的(依赖实现定义)）。不能直接转int或unsigned int，会数组下标越界。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void) &#123;</div><div class="line">  char ch=-1;</div><div class="line">    printf(&quot;%d %u %d&quot;, (int)ch, (unsigned)ch, (unsigned char)ch);</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line">// output</div><div class="line">// -1 4294967295 255</div></pre></td></tr></table></figure></p>
<h4 id="struct-tag-5-float"><a href="#struct-tag-5-float" class="headerlink" title="struct tag (*[5])(float)"></a><code>struct tag (*[5])(float)</code></h4><p>The type designated as <code>struct tag (*[5])(float)</code> has type ‘‘array of pointer to function returning struct tag’’. The array has length five and the function has a single parameter of type float. Its type category is array.</p>
<h4 id="new一个指针数组"><a href="#new一个指针数组" class="headerlink" title="new一个指针数组"></a>new一个指针数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int TEN=10;</div><div class="line">auto A=new (void(*[TEN])(void));</div><div class="line">delete[] A;</div></pre></td></tr></table></figure>
<h4 id="底层-Low-Level-const和顶层-Top-Level-const"><a href="#底层-Low-Level-const和顶层-Top-Level-const" class="headerlink" title="底层(Low-Level)const和顶层(Top-Level)const"></a>底层(Low-Level)const和顶层(Top-Level)const</h4><ul>
<li><strong>底层const(Low-Level const)</strong>:表示指针所指的对象是一个常量。</li>
<li><strong>顶层const(Top-Level const)</strong>:表示指针本身是个常量。顶层const可以表示任意的对象是常量，这对于任何数据类型都适用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int ival=0;</div><div class="line">int *const ivalp_1=&amp;ival; // 不能改变ivalp_1的值，这是一个顶层const</div><div class="line">const int ci=42;  // 不能改变ci的值，这是一个顶层const</div><div class="line">const int *ivalp_2=&amp;ci;;  // 允许改变ivalp_2的值，这是一个底层const</div><div class="line">const int *const ivalp_3=ivalp_2; //靠右的是顶层const，靠左的是底层const</div><div class="line">const int &amp;ref=ci;  // 用于声明引用的const都是底层const</div></pre></td></tr></table></figure>
</li>
</ul>
<p>其实我有一个简单的区分的方法：看const修饰的右边是什么。</p>
<ul>
<li>对于<code>int const *x=std::nullput;</code>，const修饰的是<em>x，因为x是指针，我们就暂且把此处的</em>x当做解引用来看，他就代表x所指向的对象，则它就是底层const。</li>
<li>反之亦然，<code>int * const x=std::nullptr;</code>，因为const修饰的是指针x，所以它就是顶层const。</li>
</ul>
<h4 id="在构造函数中传递this指针的危害"><a href="#在构造函数中传递this指针的危害" class="headerlink" title="在构造函数中传递this指针的危害"></a>在构造函数中传递this指针的危害</h4><p>如果我们在构造函数中将this指针传递给其它的函数，有可能会引发这样的问题：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct C;</div><div class="line">void no_opt(C*);</div><div class="line">struct C &#123;</div><div class="line">	int c;</div><div class="line">	C() : c(0) &#123; no_opt(this); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>看起来上面的代码似乎没什么问题，但是我们构造一个const C的时候，有可能会出现这样的问题：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const C cobj;</div><div class="line">void no_opt(C* cptr) &#123;</div><div class="line">	int i = cobj.c * 100; // value of cobj.c is unspecified</div><div class="line">	cout&lt;&lt;i&lt;&lt;endl;</div><div class="line">	cout &lt;&lt; cobj.c * 100 // value of cobj.c is unspecified</div><div class="line">	&lt;&lt; &apos;\n&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码会编译通过并可以在no_opt中修改常量对象cobj的成员i的值。
在一个常量对象构造的时候将其this指针传递给其他函数，这意味着我们可以修改该常量中的对象的值，这是不合乎标准的。</p>
<blockquote>
<p>During the construction of a const object, if the value of the object or any of its subobjects is accessed through a glvalue that is not obtained, directly or indirectly, from the constructor’s this pointer, the value of the object or subobject thus obtained is unspecified.</p>
</blockquote>
<p>所以还是不要在构造函数中写将this指针传递出类外的东西(最好还是只初始化数据成员吧)…</p>
<h4 id="获取当前执行程序的绝对路径"><a href="#获取当前执行程序的绝对路径" class="headerlink" title="获取当前执行程序的绝对路径"></a>获取当前执行程序的绝对路径</h4><p>有两种方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;direct.h&gt;</div><div class="line">char buffer[MAXPATH];</div><div class="line">getcwd(buffer, MAXPATH);</div><div class="line">cout&lt;&lt;buffer&lt;&lt;endl;</div></pre></td></tr></table></figure></p>
<p>这种方法有一个弊端：如果将可执行程序添加至系统的PATH路径，则获取到的是在某个目录执行时该目录的路径。</p>
<p>另一种方法是通过Windows API来获取：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const string getTheProgramAbsPath(void)&#123;</div><div class="line">    TCHAR exeFullPath[MAX_PATH]; // MAX_PATH在WINDEF.h中定义了，等于260</div><div class="line">    memset(exeFullPath,0,MAX_PATH);</div><div class="line">    GetModuleFileName(NULL,exeFullPath,MAX_PATH);</div><div class="line">    return &#123;exeFullPath&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在此种方式下不论是否将该程序添加至系统的PATH路径以及在何处执行，都会获取该可执行程序在系统中存放的绝对路径。</p>
<h4 id="一个奇葩的using用法"><a href="#一个奇葩的using用法" class="headerlink" title="一个奇葩的using用法"></a>一个奇葩的using用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">using foofunc=void(int);</div><div class="line">foofunc foo;</div><div class="line">int main()&#123;</div><div class="line">  foo(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码里：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foofunc foo;</div></pre></td></tr></table></figure></p>
<p>是声明一个函数foo，可以看一下目标文件中的符号信息(省去无关细节)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ clang++ -c testusing.cc -o testusing.o -std=c++11</div><div class="line">$ llvm-nm testusing.o</div><div class="line">-------- U _Z3fooi</div><div class="line">-------- U __main</div><div class="line">-------- U atexit</div><div class="line">00000050 T main</div></pre></td></tr></table></figure></p>
<p>通过gcc工具链中的c++filt可以还原目标文件中的符号：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ c++filt _Z3fooi</div><div class="line">foo(int)</div></pre></td></tr></table></figure></p>
<p>但是并没有定义，直接链接会产生未定义错误。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int x=123;</div><div class="line">int &amp;&amp;y=x+1;</div></pre></td></tr></table></figure>
<p>其IR代码为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 使用值123初始化x</div><div class="line">%2 = alloca i32, align 4</div><div class="line">store i32 123, i32* %2, align 4</div><div class="line"># y</div><div class="line">%3 = alloca i32*, align 8</div><div class="line"># 存放x+1产生的临时对象</div><div class="line">%4 = alloca i32, align 4</div><div class="line"># 计算x+1</div><div class="line">%5 = load i32, i32* %2, align 4</div><div class="line">%6 = add nsw i32 %5, 1</div><div class="line"># x+1 产生一个临时值，该临时值为%4</div><div class="line">store i32 %6, i32* %4, align 4</div><div class="line"># 将该临时值的地址绑定到%3(y)</div><div class="line">store i32* %4, i32** %3, align 8</div></pre></td></tr></table></figure></p>
<p>从而实现非拷贝行为，其行为类似于将一个对象的地址赋值给一个指针。
其实右值引用的作用就是给临时对象续命——将引用绑定到一个临时对象，不会带来额外的拷贝操作。
实现同样续命行为的还有<code>const T&amp;</code>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int x=123;</div><div class="line">const int &amp;y=x+1;</div></pre></td></tr></table></figure></p>
<p>和上面的示例在LLVM下会产生一模一样的IR代码。</p>
<h4 id="一个数组名字例子"><a href="#一个数组名字例子" class="headerlink" title="一个数组名字例子"></a>一个数组名字例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a[]=&#123;1,2,3,4,5&#125;;</div><div class="line">int *p=(int*)(&amp;a+1);</div><div class="line">printf(&quot;%d,%d\n&quot;,*(a+1),*(p-1));</div><div class="line">// output: 2,5</div></pre></td></tr></table></figure>
<h4 id="到底有几种传参方式"><a href="#到底有几种传参方式" class="headerlink" title="到底有几种传参方式"></a>到底有几种传参方式</h4><p>大多数人都觉得在C++函数中有以下三种传参方式：</p>
<ul>
<li>传值(by value)：形参的值是实参的拷；</li>
<li>传引用(by reference)：形参是实参的别名；</li>
<li>传指针(by pointer)：传递指向对象的指针给形参；
实际上，C++中只有两种传参方式：传值、传引用。
因为传指针(by pointer)也是传值的一种，形参的值也只是实参的一份拷贝，只是形参和实参都是指针而已。
在C++之父的著作：《The C++ Programming Language 4th》中写道：<blockquote>
<p>Unless a formal argument(parameter) is a reference, a copy of the actual argument is passed to the function.</p>
</blockquote>
</li>
</ul>
<p>传指针(by value)只是一种利用指针的性质来实现防止拷贝带来开销的一种技巧，而不是一种传参方式。</p>
<h4 id="定义拷贝-赋值与析构函数的三大法则"><a href="#定义拷贝-赋值与析构函数的三大法则" class="headerlink" title="定义拷贝/赋值与析构函数的三大法则"></a>定义拷贝/赋值与析构函数的三大法则</h4><blockquote>
<p>如果一个类需要自定义的拷贝构造函数、拷贝赋值操作符、析构函数中的任何一个，那么他往往同时需要三者。</p>
</blockquote>
<p>因为编译器生成的隐式定义的copy constructor和operator=语义是逐成员拷贝(memberwise)的，所以如果编译器生成的操作不能够满足类的拷贝需求(比如类成员是具有管理某种资源的句柄)，使用编译器的隐式定义会具有浅拷贝，导致两个对象进入某种共享状态。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  A():memory(nullptr)&#123;&#125;</div><div class="line">  void getMemory(std::size_t memSize)&#123;</div><div class="line">    memory=(char*)malloc(memSize);</div><div class="line">  &#125;</div><div class="line">  ~A()&#123; free(memory); &#125;</div><div class="line">private:</div><div class="line">  char* memory;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  A x;</div><div class="line">  x.getMemory(12);</div><div class="line">  A y;</div><div class="line">  y=x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用编译器生成的语义会使对象x和y内部共享一块内存，所以需要用户自己定义拷贝构造和拷贝赋值操作符，同样的原因，因为类成员持有某种资源，也需要用户自定义一个析构函数。</p>
<h4 id="引用的实现"><a href="#引用的实现" class="headerlink" title="引用的实现"></a>引用的实现</h4><p>C++标准中是这么解释引用的:</p>
<blockquote>
<p>[ISO/IEC 14882:2014 §8.3.2]A reference can be thought of as a name of an object.</p>
</blockquote>
<p>但是标准中并没有要求应该如何实现引用这一行为(这一点标准中比比皆是)，不过多数编译器底层都是使用指针来实现的。
看下列代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a=123;</div><div class="line">int &amp;ra=a;</div><div class="line">int *pc=&amp;a;</div></pre></td></tr></table></figure></p>
<p>然后将其编译为LLVM-IR来看编译器的实际行为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">%2 = alloca i32, align 4</div><div class="line">%3 = alloca i32*, align 8</div><div class="line">%4 = alloca i32*, align 8</div><div class="line">store i32 123, i32* %2, align 4</div><div class="line">store i32* %2, i32** %3, align 8</div><div class="line">store i32* %2, i32** %4, align 8</div></pre></td></tr></table></figure></p>
<p>可以看到，指针和引用在经过编译器之后具有了完全相同的行为。</p>
<h4 id="适当使用编译器生成操作"><a href="#适当使用编译器生成操作" class="headerlink" title="适当使用编译器生成操作"></a>适当使用编译器生成操作</h4><p>在特殊成员函数的隐式声明及其标准行为中提到了编译器会隐式生成和定义六种特殊的成员函数的行为。
因为编译器生成的copy constructor和copy assigment operator均是具有memberwise行为的。所以当我们撰写的类使用浅拷贝可以满足的时候(值语义)，没必要自己费劲再写相关的操作了，因为编译器生成的和你手写的一样好，而且不容易出错。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  A(int a=0,double b=0.0):x(a),y(b)&#123;&#125;</div><div class="line">  A(const A&amp;)=default;</div><div class="line">  A&amp; operator=(const A&amp;)=default;</div><div class="line">  int x;</div><div class="line">  double y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然当你没有显式定义一个copy constructor和copy assignment operator的时候编译器就会隐式定义，但是最好还是自己手动使用=delete指定。
编译器生成的和下面这样手写的一样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  A(int a=0,double b=0.0):x(a),y(b)&#123;&#125;</div><div class="line">  A(const A&amp; r)&#123;</div><div class="line">    x=r.x;</div><div class="line">    y=r.y;</div><div class="line">  &#125;</div><div class="line">  A&amp; operator=(const A&amp; r)&#123;</div><div class="line">    x=r.x;</div><div class="line">    y=r.y;</div><div class="line">    return *this;</div><div class="line">  &#125;</div><div class="line">  int x;</div><div class="line">  double y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>显然自己手写容易出错，这样的行为可以放心地交给编译器来做。</p>
<h4 id="STL容器中压缩容量和真正地删除元素"><a href="#STL容器中压缩容量和真正地删除元素" class="headerlink" title="STL容器中压缩容量和真正地删除元素"></a>STL容器中压缩容量和真正地删除元素</h4><p>摘取自《C++编程规范：101条规则/准则与最佳实践》第82条。</p>
<h5 id="压缩容器容量：swap魔术"><a href="#压缩容器容量：swap魔术" class="headerlink" title="压缩容器容量：swap魔术"></a>压缩容器容量：swap魔术</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; x&#123;1,2,3,4,5,6,7&#125;;</div><div class="line">// ...</div><div class="line">vector&lt;int&gt;(x).swap(x); // 压缩到合适容量</div><div class="line">vector&lt;int&gt;().swap(x); // 删除所有元素</div></pre></td></tr></table></figure>
<h5 id="真正地删除元素：std-remove并不执行删除操作"><a href="#真正地删除元素：std-remove并不执行删除操作" class="headerlink" title="真正地删除元素：std::remove并不执行删除操作"></a>真正地删除元素：std::remove并不执行删除操作</h5><p>STL中的std::remove算法并不真正地从容器中删除元素。因为std::remove属于algorithm，只操作迭代器范围，不掉用容器的成员函数，所以是不可能从容器中真正删除元素的。
来看一下SGISTL中的实现(SGISTL的实现太老，没有用到std::move)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template &lt;class _InputIter, class _Tp&gt;</div><div class="line">inline _InputIter find(_InputIter __first, _InputIter __last, const _Tp&amp; __val)</div><div class="line">&#123;</div><div class="line">  while (__first != __last &amp;&amp; !(*__first == __val))</div><div class="line">    ++__first;</div><div class="line">  return __first;</div><div class="line">&#125;</div><div class="line">template &lt;class _InputIter, class _OutputIter, class _Tp&gt;</div><div class="line">_OutputIter remove_copy(_InputIter __first, _InputIter __last, _OutputIter __result, const _Tp&amp; __value) &#123;</div><div class="line">  for ( ; __first != __last; ++__first)</div><div class="line">    if (!(*__first == __value)) &#123;</div><div class="line">      *__result = *__first;</div><div class="line">      ++__result;</div><div class="line">    &#125;</div><div class="line">  return __result;</div><div class="line">&#125;</div><div class="line">template &lt;class _ForwardIter, class _Tp&gt;</div><div class="line">_ForwardIter remove(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __value) &#123;</div><div class="line">  __first = find(__first, __last, __value);</div><div class="line">  _ForwardIter __i = __first;</div><div class="line">  return __first == __last ? __first : remove_copy(++__i, __last, __first, __value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到它们只是移动元素的位置，并非真正地把元素删除，只是将不该删除的元素移动到容器的首部，然后返回新的结束位置迭代器。
等于是把删除的部分移动到了元素的尾部，所以要真正地删除容器中所有匹配的元素，需要用erase-remove惯用法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.erase(std::remove(c.begin(),c.end(),value),c.end()); // 删除std::remove之后容器尾部的元素</div></pre></td></tr></table></figure></p>
<h4 id="谨防隐藏基类中的重载函数"><a href="#谨防隐藏基类中的重载函数" class="headerlink" title="谨防隐藏基类中的重载函数"></a>谨防隐藏基类中的重载函数</h4><p>如果基类中具有一个虚函数func但是其又重载了几个非虚函数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  virtual void func()&#123;</div><div class="line">    cout&lt;&lt;&quot;A::func()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  void func(int)&#123;</div><div class="line">    cout&lt;&lt;&quot;A::func(int)&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  void func(double)&#123;</div><div class="line">    cout&lt;&lt;&quot;A::func(double)&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">struct B:public A&#123;</div><div class="line">  virtual void func()&#123;</div><div class="line">    cout&lt;&lt;&quot;B::func()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果我们想要在B对象中使用非虚版本的func函数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B x;</div><div class="line">// error: too many arguments to function call, expected 0, have 1</div><div class="line">x.func(123);</div></pre></td></tr></table></figure></p>
<p>这是由于派生类在覆盖基类虚函数的时候会隐藏其他的重载函数，需要在B中显式引入：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct B:public A&#123;</div><div class="line">  virtual void func()&#123;</div><div class="line">    cout&lt;&lt;&quot;B::func()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  // 将A::func的重载函数引入作用域</div><div class="line">  using A::func;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="宏的替代"><a href="#宏的替代" class="headerlink" title="宏的替代"></a>宏的替代</h4><p>宏在预处理阶段被替换，此时C++的语法和语义规则还没有生效，宏能做的只是简单的文本替换，是极其生硬的工具。
C++中几乎从不需要宏。可以用const和enum定义易于理解的常量。用inline来避免函数调用的开销，用template指定函数系列和类型系列，用namespace避免名字冲突。
除非在条件编译时使用，其他任何时候都没有在C++中使用宏的正当理由。</p>
<h4 id="类内内存分配函数"><a href="#类内内存分配函数" class="headerlink" title="类内内存分配函数"></a>类内内存分配函数</h4><p>C++中类内的内存分配函数都是static成员函数:</p>
<blockquote>
<p>Any allocation function for a class T is a static member (even if not explicitly declared static).</p>
</blockquote>
<p>这意味着operator new/operator delete以及operator new[]/operator delete[]都被隐式声明为static成员函数。</p>
<h4 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h4><ol>
<li>析构函数、operator new、operator delete不能抛出异常</li>
<li>swap操作不要抛出异常</li>
<li>首先做任何可能抛出异常的事情(但不会改变对象重要的状态)，然后以不会抛出异常的操作结束。</li>
<li>当一个被抛出的异常从throw表达式奔向catch子句时，所经之路任何一个部分执行的函数比从执行堆栈上移除其激活记录之前，都必须清理他所控制的任何资源。</li>
<li>不要在代码中插入可能会提前返回的代码、调用可能会抛出异常的函数、或者插入其他一些东西从而使得函数末尾的资源释放得不到执行。</li>
</ol>
<h4 id="指向类成员函数指针的cv版本"><a href="#指向类成员函数指针的cv版本" class="headerlink" title="指向类成员函数指针的cv版本"></a>指向类成员函数指针的cv版本</h4><p>如果我们具有一个类A，其中具有重载的成员函数func，而他们的区别只是该成员函数是否为const，那么在定义一个指向成员函数的指针时如何分别？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  void func()const&#123;</div><div class="line">    std::cout&lt;&lt;&quot;void func()const&quot;&lt;&lt;std::endl;</div><div class="line">  &#125;</div><div class="line">  void func()&#123;</div><div class="line">    std::cout&lt;&lt;&quot;void func()&quot;&lt;&lt;std::endl;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果我们只是创建一个A::func的指针，指向的只是non-const版本。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(A::*funcP)()=&amp;A::func;</div></pre></td></tr></table></figure></p>
<p>想要指定const的版本，就需要在声明时指定const:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(A::*funcConstP)()const=&amp;A::func;</div></pre></td></tr></table></figure></p>
<p>对于const的A对象要使用const的版本，对于non-const的A对象要使用non-const的版本，不能混用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const A x;</div><div class="line">(x.*funcP)(); // ERROR!</div><div class="line">(x.*funcConstP)(); // OK</div><div class="line">A y;</div><div class="line">(y.*funcConstP)(); // ERROR!</div><div class="line">(y.*funcP)(); // OK</div></pre></td></tr></table></figure></p>
<h4 id="STL中的compare操作实现"><a href="#STL中的compare操作实现" class="headerlink" title="STL中的compare操作实现"></a>STL中的compare操作实现</h4><p>不同于C语言中的宏，使用C++中的模板(template)和谓词(Predicates)可以很轻易的写出泛型的比较操作。
在宏定义中还要注意参数的副作用，因为宏只是简单的替换，比如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define MAX(a,b) a&gt;=b?a:b;</div><div class="line">MAX(--a,++b);</div><div class="line">// 被替换为</div><div class="line">--a&gt;=++b?--a:++b;</div></pre></td></tr></table></figure></p>
<p>但是这个宏的实际操作这并不是我们所期待的行为。
幸运的是，在C++中我们可以使用模板来避免这种丑陋的宏定义，而且也可以传递一个自定义的谓词来实现我们的判断行为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct Compare&#123;</div><div class="line">  template&lt;typename T&gt;</div><div class="line">  bool operator()(const T&amp; a,const T&amp; b)&#123;</div><div class="line">    return a&lt;b?false:true;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">template&lt;class T, class Compare&gt;</div><div class="line">const T&amp; max(const T&amp; a, const T&amp; b, Compare comp)</div><div class="line">&#123;</div><div class="line">    return (comp(a, b)) ? b : a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="计算性构造函数"><a href="#计算性构造函数" class="headerlink" title="计算性构造函数"></a>计算性构造函数</h4><p>在某些情况下，可以通过创建构造函数的方式来提高成员函数的执行效率。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct String&#123;</div><div class="line">  String(const char* init);</div><div class="line">  const String operator+(const String&amp; l,const String&amp; r)&#123;</div><div class="line">    return String(l.s_,r.s_);</div><div class="line">  &#125;</div><div class="line">private:</div><div class="line">  String(const char* a,const char* b)&#123;</div><div class="line">    s_=new char[strlen(a)+strlen(b)+1];</div><div class="line">    strcat(strcpy(s_,a),b);</div><div class="line">  &#125;</div><div class="line">  char *s_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="自身类型的using成员"><a href="#自身类型的using成员" class="headerlink" title="自身类型的using成员"></a>自身类型的using成员</h4><p>怎么定义一个类的成员中能够获取到当前类类型的成员呢？
可以用下面这种写法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">struct base&#123;</div><div class="line">  using selfType=T;</div><div class="line">&#125;;</div><div class="line">template&lt;typename T&gt;</div><div class="line">struct foo:public base&lt;foo&lt;T&gt;&gt;&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然有种强行搞事的意思…</p>
<h4 id="std-vector的随机访问"><a href="#std-vector的随机访问" class="headerlink" title="std::vector的随机访问"></a>std::vector的随机访问</h4><p>std::vector可以随机访问，因为其重载了[]操作符，以及有at成员函数，则通常有下面两种方式：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void f(std::vector&lt;T&gt;&amp; x)&#123;</div><div class="line">  x[0];</div><div class="line">  x.at(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上两种随机访问方式有什么区别？</p>
<blockquote>
<p>顺序容器的at(size_type)要求有范围检查。
[ISO/IEC 14882:2014]The member function at() provides bounds-checked access to container elements. at() throws out_of_range if n &gt;= a.size().
而operator[]标准中则没有任何要求。</p>
</blockquote>
<p>可以来看一下一些STL实现(SGISTL)的源码对std::vector的operator[size_type]和at(size_type)的实现：
首先是at(size_type)的实现
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// at(size_type)的实现</div><div class="line">#ifdef __STL_THROW_RANGE_ERRORS</div><div class="line">void _M_range_check(size_type __n) const &#123;</div><div class="line">  if (__n &gt;= this-&gt;size())</div><div class="line">    __stl_throw_range_error(&quot;vector&quot;);</div><div class="line">&#125;</div><div class="line">reference at(size_type __n)</div><div class="line">  &#123; _M_range_check(__n); return (*this)[__n]; &#125;</div><div class="line">const_reference at(size_type __n) const</div><div class="line">  &#123; _M_range_check(__n); return (*this)[__n]; &#125;</div><div class="line">#endif /* __STL_THROW_RANGE_ERRORS */</div><div class="line">​`</div></pre></td></tr></table></figure></p>
<p>再看一下operator[] (size_type)的实现：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// operator[](size_type)的实现</div><div class="line">reference operator[](size_type __n) &#123; return *(begin() + __n); &#125;</div><div class="line">const_reference operator[](size_type __n) const &#123; return *(begin() + __n); &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，operator[]的随机访问并没有范围检查。
即上面的问题：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x[0];</div><div class="line">x.at(0);</div></pre></td></tr></table></figure></p>
<p>这两个的区别在于，若x不为空，则行为相同，若x为空，x.at(0)则抛出一个std::out_of_range异常(C++标准规定)，而x[0]是未定义行为。</p>
<h4 id="注意typedef和-define的区别"><a href="#注意typedef和-define的区别" class="headerlink" title="注意typedef和#define的区别"></a>注意typedef和#define的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef int* INTPTR;</div><div class="line">#define INTPTR2 int*</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  INTPTR i1,i2;</div><div class="line">  INTPTR2 i3,i4;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是直接从IR代码来看吧：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">%6 = alloca i32*, align 8</div><div class="line">%7 = alloca i32*, align 8</div><div class="line">%8 = alloca i32*, align 8</div><div class="line">%9 = alloca i32, align 4</div></pre></td></tr></table></figure></p>
<p>注意<code>%9</code>不是<code>i32*</code>,它是一个i32的对象。
因为<code>#define</code>只是编译期的简单替换，所以在编译期展开的时候会变成这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define INTPTR2 int*</div><div class="line">INTPTR2 i3,i4;</div><div class="line">// 编译期展开</div><div class="line">int* i3,i4;</div></pre></td></tr></table></figure></p>
<p>即只有i3为<code>int*</code>，而i4则为int</p>
<h4 id="为什么const-object不是编译时常量？"><a href="#为什么const-object不是编译时常量？" class="headerlink" title="为什么const object不是编译时常量？"></a>为什么const object不是编译时常量？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const int x=10;</div><div class="line">int y[x]=&#123;0&#125;;</div></pre></td></tr></table></figure>
<p>这里是可以的，在编译器优化下x会直接被替换为10
其中间代码如下:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%6 = alloca i32, align 4</div><div class="line">%7 = alloca [10 x i32], align 16</div><div class="line">store i32 10, i32* %6, align 4</div><div class="line">%8 = bitcast [10 x i32]* %7 to i8*</div><div class="line">call void @llvm.memset.p0i8.i64(i8* %8, i8 0, i64 40, i32 16, i1 false)</div></pre></td></tr></table></figure></p>
<p>可以看到<code>%7</code>的分配时并没有使用%6，所以也并不依赖x这个对象，这个对象是编译期已知的。
但是，当我们这么写时，又如何编译期可知：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int x;</div><div class="line">cin&gt;&gt;x;</div><div class="line">const int y=x;</div><div class="line">// error: variable-sized object may not be initialized</div><div class="line">int z[y]=&#123;0&#125;;</div></pre></td></tr></table></figure></p>
<p>这里是由于编译器扩展，所以C++也支持VLA。但是可以看到const是没办法为编译期常量的。</p>
<h4 id="继承层次中的类查询"><a href="#继承层次中的类查询" class="headerlink" title="继承层次中的类查询"></a>继承层次中的类查询</h4><p>在类的继承层次中，可能具有同一基类的几个不同的派生类，他们之间可能又互相继承派生出了几个继承层次，在这样的情况下如何判断某一个派生类的层次中是否继承自某一个类呢？</p>
<p>可以使用dynamic_cast来实现我们的要求，关于C++类型转换的部分可以看我之前的一篇文章：详细分析下C++中的类型转换。下面先来看一下dynamic_cast在C++标准中的描述(ISO/IEC 14882:2014)：</p>
<blockquote>
<p>The result of the expression dynamic_cast<t>(v) is the result of converting the expression v to type T. T shall be a pointer or reference to a complete class type, or “pointer to cv void.” The dynamic_cast operator shall not cast away constness (5.2.11).</t></p>
</blockquote>
<p>If C is the class type to which T points or refers, the run-time check logically executes as follows:</p>
<ul>
<li>If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class subobject of a C object, and if only one object of type C is derived from the subobject pointed (referred) to by v the result points (refers) to that C object.</li>
<li>Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the type of the most derived object has a base class, of type C, that is unambiguous and public, the result points (refers) to the C subobject of the most derived object.</li>
<li>Otherwise, the run-time check fails.</li>
</ul>
<blockquote>
<p>The value of a failed cast to pointer type is the null pointer value of the required result type. A failed cast to reference type throws an exception (15.1) of a type that would match a handler (15.3) of type std::bad_cast (18.7.2).</p>
</blockquote>
<p>所以我们可以对继承层次中的类指针执行dynamic_cast转换，检查是否转换成功，从而判断继承层次中是否具有某个类。
一个代码的例子如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">struct Shape&#123;</div><div class="line">  virtual void draw()=0;</div><div class="line">  virtual ~Shape()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">struct Roll&#123;</div><div class="line">  virtual void roll()&#123;cout&lt;&lt;&quot;Roll:roll()&quot;&lt;&lt;endl;&#125;</div><div class="line">  virtual ~Roll()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">struct Circle:public Shape,public Roll&#123;</div><div class="line">  void draw()&#123;</div><div class="line">    cout&lt;&lt;&quot;Circle::draw&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  void roll()&#123;</div><div class="line">    cout&lt;&lt;&quot;Circle::roll()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  ~Circle()=default;</div><div class="line">&#125;;</div><div class="line">struct Square:public Shape&#123;</div><div class="line">  void draw()&#123;</div><div class="line">    cout&lt;&lt;&quot;Square::draw()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  ~Square()=default;</div><div class="line">&#125;;</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  Shape *a=new Square;</div><div class="line">  Roll *b=dynamic_cast&lt;Roll*&gt;(a);</div><div class="line">  if(b!=NULL)&#123;</div><div class="line">    cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;</div><div class="line">  &#125;else&#123;</div><div class="line">    cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  delete a;</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line">// output: no</div></pre></td></tr></table></figure></p>
<p>面的继承层次比较简单，但是当假设我们不知道Cricle和Square的具体继承层次时，那么如何判断Square中是否存在某一基类(如Roll)？
解决的办法就是上面提到的dynamic_cast！通过dynamic_cast转换到转换到要检测的类类型的指针，如果转换成功，dynamic_cast会返回从源类型转换到目标类型的指针，如果失败会返回一个空指针(之所以不使用引用是因为要处理可能会抛出异常的潜在威胁)，这种转换并非是向上或者向下转型，而是横向转型。所以我们需要对dynamic_cast返回的对象(指针)作一个判断就可以得出检测目标的继承层次中是否存在要检测的类型。</p>
<p>但是，我觉得这种行为的适用场景十分狭窄，在良好的类设计下几乎不必要，如果你对自己所实现的类层次感到失控，那一定是糟糕的设计。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://imzlp.me/posts/1756/" target="_blank" rel="external">C/C++中的编程技巧及其概念</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/12/l-c-skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/12/l-c-skill/" itemprop="url">
                  l-c-skill
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-12T17:51:08+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Segmentation-fault段错误调试总结"><a href="#Segmentation-fault段错误调试总结" class="headerlink" title="Segmentation fault段错误调试总结"></a>Segmentation fault段错误调试总结</h3><p>Segmetation fault也叫做段错误，引发的原因有好多，这里我们只说一下段错误发生时的调试方法。</p>
<h4 id="方法1：加打印printf。"><a href="#方法1：加打印printf。" class="headerlink" title="方法1：加打印printf。"></a>方法1：加打印printf。</h4><p>这是最基本的往往也很有效的方法，在哪里Core掉就会在哪里停止打印–一目了然。同时这种方法也存在一个致命缺陷：如果恰巧Core掉的地方没加打印而程序代码又非常庞大又可能是多线程的，那查找问题等同于大海捞针。</p>
<h4 id="方法2：gdb调试。"><a href="#方法2：gdb调试。" class="headerlink" title="方法2：gdb调试。"></a>方法2：gdb调试。</h4><p>加gdb调试往往能在Core dump时抓到，甚至能抓到哪一个文件哪个类哪个函数哪一行，甚是精确。要确保GDB能抓到可用信息要做一些准备：</p>
<ul>
<li>加-g 参数，这样才会有调试信息。 我想是个程序员就应该知道吧。</li>
<li>在Makefile 中加上 -fstack-protector 和-fstack-protector-all 信息，确保函数调用栈不丢失，当然只能是一定程度的不丢失，要完成保留住是不太可能的，但起码可以得到栈顶函数。</li>
</ul>
<p>有了上面两点对大多数的Segmentation fault都能抓住，但是函数调用栈彻底乱掉或者在动态库so中Core而这个库编译时没有加-g参数，这些情况就gdb就无能为力了。</p>
<h4 id="方法3：手动获取函数调用栈。"><a href="#方法3：手动获取函数调用栈。" class="headerlink" title="方法3：手动获取函数调用栈。"></a>方法3：手动获取函数调用栈。</h4><p>这种方法其实是借住两个系统函数backtrace和backtrace_symbol来获取函数调用栈的，把这两个函数放在信号处理函数中：当收到 SIGSEG时在信号处理函数中调用这两个函数打印函数调用栈，在没用GDB调试的时候这种方法可以代替gdb的一部分功能，这听起来是不是非常酷啊，来看一看实现吧：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#include &lt;signal.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;execinfo.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">static void SignalHandle(int sig)</div><div class="line">&#123;</div><div class="line">    void *array[20];</div><div class="line">    size_t size;</div><div class="line">    char **strings;</div><div class="line">    int i;</div><div class="line">    size = backtrace(array, 10);</div><div class="line">    strings = backtrace_symbols(array, size);</div><div class="line">    printf(&quot;SIGNAL ocurre %d, stack tarce:\n&quot;, sig);</div><div class="line">    printf(&quot;obtained %d stack frames.\n&quot;, size);</div><div class="line"></div><div class="line">    for (i = 0; i &lt; size; i++)</div><div class="line">        printf(&quot;%s\n&quot;, strings);</div><div class="line"></div><div class="line">    free(strings);</div><div class="line">    printf(&quot;stack trace over!\n&quot;);</div><div class="line">    exit(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    signal(SIGSEGV, SignalHandle);</div><div class="line">    //...程序主体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这种方法在没有GDB时候会大显身手，经过实验就是有gdb的时候这种方法有时比gdb抓到调用栈要多一层；当然这种方法和用gdb调试一样要加<code>-g</code>和栈保护参数<code>-fstack-protector</code> 和 <code>-fstack-protector-all</code>。其缺点就是抓到的调用栈无效，这是什么意思呢？有时发生core dump,能定位到甚至哪一行，但是那一行根本没有明显的错误；或者追到没有调试信息的动态库里如glibc。当然这些情况大多数调试方法都无能为力，只能依靠程序员的经验了。</p>
<h4 id="方法4：经验之谈。"><a href="#方法4：经验之谈。" class="headerlink" title="方法4：经验之谈。"></a>方法4：经验之谈。</h4><p>如果我们的程序是多线程的，发生core dump用以上方法均无效，除了仔细排查代码外，还有这么一方法让我们缩小范围。</p>
<p><a href="https://coolshell.cn/articles/10115.html" target="_blank" rel="external">c语言全局变量那些事</a>
<a href="https://coolshell.cn/articles/9543.html" target="_blank" rel="external">“C++的数组不支持多态”？</a></p>
<p><a href="https://coolshell.cn/articles/7886.html" target="_blank" rel="external">代码执行的效率</a></p>
<p><a href="https://coolshell.cn/articles/5761.html" target="_blank" rel="external">深入理解C语言</a></p>
<p><a href="https://coolshell.cn/articles/5202.html" target="_blank" rel="external">对象的消息模型</a></p>
<p><a href="https://coolshell.cn/articles/4626.html" target="_blank" rel="external">读书笔记：对线程模型的批评</a></p>
<p><a href="https://coolshell.cn/articles/945.html" target="_blank" rel="external">C语言的谜题</a></p>
<p><a href="https://coolshell.cn/articles/3572.html" target="_blank" rel="external">C语言函数实现的另类方法</a></p>
<p><a href="https://coolshell.cn/articles/873.html" target="_blank" rel="external">谁说C语言很简单？</a></p>
<p><a href="https://coolshell.cn/articles/551.html" target="_blank" rel="external">C语言下的错误处理的问题</a></p>
<p><a href="https://coolshell.cn/articles/11377.html" target="_blank" rel="external">C语言结构体里的成员数组和指针</a></p>
<p><a href="http://blog.csdn.net/haoel/article/details/6212499" target="_blank" rel="external">C技巧：结构体参数转成不定参数</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/12/arithmetic-kmp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/12/arithmetic-kmp/" itemprop="url">
                  arithmetic-kmp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-12T17:48:52+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fr=aladdin" target="_blank" rel="external">https://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fr=aladdin</a></p>
<p><a href="http://blog.csdn.net/yutianzuijin/article/details/11954939/" target="_blank" rel="external">http://blog.csdn.net/yutianzuijin/article/details/11954939/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/10/10/course-makefile-project-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/course-makefile-project-practice/" itemprop="url">
                  (转)从头开始写项目makefile
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T17:58:27+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/makefile/" itemprop="url" rel="index">
                    <span itemprop="name">makefile</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1. 基本规则"></a>1. 基本规则</h3><p>一般一个稍大的linux项目会有很多个源文件组成，最终的可执行程序也是由这许多个源文件编译链接而成的。编译是把一个.c或.cpp文件编译成中间代码.o文件，链接是就使用这些中间代码文件生成可执行文件。比如在当前项目目录下有如下源文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ls  </div><div class="line">common.h  debug.c  debug.h  ipc.c  ipc.h  main.c  tags  timer.c  timer.h  tools.c  tools.h   </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>以上源代码可以这样编译：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># gcc -o target_bin main.c debug.c ipc.c timer.c tools.c</div></pre></td></tr></table></figure></p>
<p>如果之后修改了其中某一个文件（如tools.c），再执行一下上一行代码即可，但如果有成千上万个源文件这样编译肯定是不够合理的。此时我们可以按下面步骤来编译：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># gcc -c debug.c  </div><div class="line"># gcc -c ipc.c  </div><div class="line"># gcc -c main.c  </div><div class="line"># gcc -c timer.c  </div><div class="line"># gcc -c tools.c  </div><div class="line"># gcc -o target_bin main.o debug.o ipc.o timer.o tools.o</div></pre></td></tr></table></figure></p>
<p>如果其中tools.c修改了，只需要编译该文件，再执行最后生成可执行文件的操作，也就是做如下两步操作即可：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -c tools.c  </div><div class="line"># gcc -o target_bin main.o debug.o ipc.o timer.o tools.o</div></pre></td></tr></table></figure></p>
<p>这样做看上去应该很合理了。但是如果修改了多个文件，就很可能忘了编译某一文件，那么运行时就很有可能出错。如果是common.h文件修改了，那么包含该头文件的所有.c文件都需要重新编译，这样一来的话就更复杂更容易出错了。看来这种方法也不够好，手动处理很容易出错。那有没有一种自动化的处理方式呢？有的，那就是写一个Makefile来处理编译过程。
下面给一个简单的Makefile，在源代码目录下建一个名为Makefile的文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">main.o: main.c common.h                                                                                                                                                                     </div><div class="line">&gt;---gcc -c main.c  </div><div class="line"></div><div class="line">debug.o: debug.c debug.h common.h  </div><div class="line">&gt;---gcc -c debug.c  </div><div class="line"></div><div class="line">ipc.o: ipc.c ipc.h common.h  </div><div class="line">&gt;---gcc -c ipc.c  </div><div class="line"></div><div class="line">timer.o: timer.c timer.h common.h  </div><div class="line">&gt;---gcc -c timer.c  </div><div class="line"></div><div class="line">tools.o: tools.c tools.h common.h  </div><div class="line">&gt;---gcc -c tools.c</div></pre></td></tr></table></figure></p>
<p>然后在命令行上执行命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># make   </div><div class="line">gcc -c main.c  </div><div class="line">gcc -c debug.c  </div><div class="line">gcc -c ipc.c  </div><div class="line">gcc -c timer.c  </div><div class="line">gcc -c tools.c  </div><div class="line">gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line">#  </div><div class="line"># ls  </div><div class="line">common.h  common.h~  debug.c  debug.h  debug.o  ipc.c  ipc.h  ipc.o  main.c  main.o  Makefile  Makefile~  tags  target_bin  timer.c  timer.h  timer.o  tools.c  tools.h  tools.o  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>可见在该目录下生成了.o文件以及target_bin可执行文件。现在我们只需要执行一个make命令就可以完成所有编译工作，无需像之前一样手动执行所有动作，make命令会读取当前目录下的Makefile文件然后完成编译步骤。从编译过程输出到屏幕的内容看得到执行make命令之后所做的工作，其实就是我们之前手动执行的那些命令。现在来说一下什么是Makefile？
所谓Makefile我的理解其实就是由一组组编译规则组成的文件，每条规则格式大致为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target ... : prerequisites ...   </div><div class="line">&gt;---command  </div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>其中target是目标文件，可以为可执行文件、<code>*.o</code>文件或标签。Prerequisites是产生target所需要的源文件或<code>*.o</code>文件，可以是另一条规则的目标。commond是要产生该目标需要执行的操作系统命令，该命令必须以tab（文中以&gt;—标示tab字符）开头，不可用空格代替。
说白了就是要产生target，需要依赖后面的prerequisites文件，然后执行commond来产生来得到target。这和我们之前手动执行每条编译命令是一样的，其实就是定义好一个依赖关系，我们把产生每个文件的依赖文件写好，最终自动执行编译命令。
比如在我们给出的Makefile例子中target_bin main.o等就是target，main.o debug.o ipc.o timer.o tools.o是target_bin的prerequisites，gcc -o target_bin main.o debug.o ipc.o timer.o tools.o就是commond，把所有的目标文件编译为最终的可执行文件target，而main.c common.h是main.o的prerequisites，其gcc -c main.c命令生成target所需要的main.o文件。
在该例子中，Makefile工作过程如下：</p>
<ol>
<li>首先查找第一条规则目标，第一条规则的目标称为缺省目标，只要缺省目标更新了就算完成任务了，其它工作都是为这个目的而做的。 该Makefile中第一条规则的目标target_bin，由于我们是第一次编译，target_bin文件还没生成，显然需要更新，但此时依赖文件main.o debug.o ipc.o timer.o tools.o都没有生成，所以需要先更新这些文件，然后才能更新target_bin。</li>
<li>所以make会进一步查找以这些依赖文件main.o debug.o ipc.o timer.o tools.o为目标的规则。首先找main.o，该目标也没有生成，该目标依赖文件为main.c common.h，文件存在，所以执行规则命令gcc -c main.c，生成main.o。其他target_bin所需要的依赖文件也同样操作。</li>
<li>最后执行gcc -o target_bin main.o debug.o ipc.o timer.o tools.o，更新target_bin。</li>
</ol>
<p>在没有更改源代码的情况下，再次运行make：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make  </div><div class="line">make: `target_bin&apos; is up to date.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>得到提示目标target_bin已经是最新的了。
如果修改文件main.c之后，再运行make：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># vim main.c  </div><div class="line"># make  </div><div class="line">gcc -c main.c  </div><div class="line">gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>此时make会自动选择受影响的目标重新编译：
首先更新缺省目标，先检查target_bin是否需要更新，这需要检查其依赖文件main.o debug.o ipc.o timer.o tools.o是否需要更新。
其次发现main.o需要更新，因为main.o目标的依赖文件main.c最后修改时间比main.o晚，所以需要执行生成目标main.o的命令：gcc -c main.c更新main.o。
最后发现目标target_bin的依赖文件main.o有更新过，所以执行相应命令gcc -o target_bin main.o debug.o ipc.o timer.o tools.o更新target_bin。
总结下，执行一条规则步骤如下：</p>
<ol>
<li>先检查它的依赖文件，如果依赖文件需要更新，则执行以该文件为目标的的规则。如果没有该规则但找到文件，那么该依赖文件不需要更新。如果没有该规则也没有该文件，则报错退出。</li>
<li>再检查该文件的目标，如果目标不存在或者目标存在但依赖文件修改时间比他要晚或某依赖文件已更新，那么执行该规则的命令。
由此可见，Makefile可以自动发现更新过的文件，自动重新生成目标，使用Makefile比自己手动编译比起来，不仅效率高，还减少了出错的可能性。</li>
</ol>
<p>Makefile中有很多目标，我们可以编译其中一个指定目标，只需要在make命令后面带上目标名称即可。如果不指定编译目标的话make会编译缺省的目标，也就是第一个目标，在本文给出的Makefile第一个目标为target_bin。如果只修改了tools.c文件的话，我们可能只想看看我们的更改的源代码是否有语法错误而又不想重新编译这个工程的话可以执行如下命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make tools.o   </div><div class="line">gcc -c tools.c  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>编译成功，这里又引出一个问题，如果继续执行同样的命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make tools.o  </div><div class="line">make: `tools.o&apos; is up to date.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>我们先手动删掉tools.o文件再执行就可以了，怎么又是手动呢？我们要自动，要自动！！好吧，我们加一个目标来删除这些编译过程中产生的临时文件，该目标为clean。
我们在上面Makefile最后加上如下内容：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<p>当我们直接make命令时不会执行到该目标，因为没有被默认目标target_bin目标或以target_bin依赖文件为目标的目标包含在内。我们要执行该目标需要在make时指定目标即可。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make clean  </div><div class="line">rm *.o target_bin  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>可见clean目标被执行到了，再执行make时make就会重新生成所有目标对应的文件，因为执行make clean时，那些文件被清除了。
clean目标应该存在与你的Makefile当中，它既可以方便你的二次编译，又可以保持的源文件的干净。该目标一般放在最后，不可放在最开头，否则会被当做缺省目标被执行，这很可能不是你的意愿。
最后总结一下，Makefile只是告诉了make命令如何来编译和链接程序，告诉make命令生成目标文件需要的文件，具体的编译链接工作是你的目标对应的命令在做。
给一个今天完整的makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">main.o: main.c common.h                                                                                                                                                                     </div><div class="line">&gt;---gcc -c main.c  </div><div class="line"></div><div class="line">debug.o: debug.c debug.h common.h  </div><div class="line">&gt;---gcc -c debug.c  </div><div class="line"></div><div class="line">ipc.o: ipc.c ipc.h common.h  </div><div class="line">&gt;---gcc -c ipc.c  </div><div class="line"></div><div class="line">timer.o: timer.c timer.h common.h  </div><div class="line">&gt;---gcc -c timer.c  </div><div class="line"></div><div class="line">tools.o: tools.c tools.h common.h  </div><div class="line">&gt;---gcc -c tools.c  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<h3 id="2-隐含规则自动推导"><a href="#2-隐含规则自动推导" class="headerlink" title="2. 隐含规则自动推导"></a>2. 隐含规则自动推导</h3><p>上一节的Makefile勉强可用，但还写的比较繁琐，不够简洁。对每一个.c源文件，都需要写一个生成其对应的.o目标文件的规则，如果有几百个或上千个源文件，都手动来写，还不是很麻烦，这也不够自动化啊。
这样，我们把生成.o目标文件的规则全部删除掉，就是这样一个Makefile文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<p>这下简洁了不少，这样也能用吗？试试看吧先，make一下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># make  </div><div class="line">cc    -c -o main.o main.c  </div><div class="line">cc    -c -o debug.o debug.c  </div><div class="line">cc    -c -o ipc.o ipc.c  </div><div class="line">cc    -c -o timer.o timer.c  </div><div class="line">cc    -c -o tools.o tools.c  </div><div class="line">gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>原来酱紫都可以啊！！target_bin后面那一群依赖文件怎么生成呢？不是没有生成*.o目标文件的规则了吗？再看屏幕编译输出内容：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cc    -c -o main.o main.c  </div><div class="line">cc    -c -o debug.o debug.c  </div><div class="line">cc    -c -o ipc.o ipc.c  </div><div class="line">cc    -c -o timer.o timer.c  </div><div class="line">cc    -c -o tools.o tools.c</div></pre></td></tr></table></figure></p>
<p>怎么长的和之前不太一样呢，尤其是前面那个cc是何物？
其实make可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个*.o文件后都写上类似的命令，因为，我们的 make 会自动推导依赖文件，并根据隐含规则自己推导命令。所以上面.o文件是由于make自动推导出的依赖文件以及命令来生成的。
下面来看看make是如何推导的。
命令make –p可以打印出很多默认变量和隐含规则。Makefile变量可以理解为C语言的宏，直接展开即可（后面会讲到）。取出我们关心的部分：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># default  </div><div class="line">OUTPUT_OPTION = -o $@  </div><div class="line"># default  </div><div class="line">CC = cc  </div><div class="line"># default  </div><div class="line">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) –c  </div><div class="line"># Implicit Rules  </div><div class="line">%.o: %.c  </div><div class="line">#  commands to execute (built-in):  </div><div class="line">&gt;---$(COMPILE.c) $(OUTPUT_OPTION) $&lt;</div></pre></td></tr></table></figure></p>
<p>其中cc是一个符号链接，指向gcc，这就可以解释为什么我们看到的编译输出为cc，其实还是使用gcc在编译。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ll /usr/bin/cc    </div><div class="line">lrwxrwxrwx. 1 root root 3 Dec  3  2013 /usr/bin/cc -&gt; gcc  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>变量<code>$(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)</code>都为空。所以<code>%.o: %.c</code>规则命令展开为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc    -c -o $@ $&lt;</div></pre></td></tr></table></figure></p>
<p>再看屏幕输出编译内容，摘取一条：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc    -c -o main.o main.c</div></pre></td></tr></table></figure></p>
<p>不是看出点什么？<code>$@</code>和main.o对应，<code>$&lt;</code>和main.c对应。其实<code>$@</code>和<code>$&lt;</code>是两个变量。<code>$@</code>为规则中的目标，<code>$&lt;</code>为规则中的第一个依赖文件。<code>%.o:%.c</code>是一种称为模式规则的特殊规则。因为main.o符合该模模式，再推导出依赖文件main.c，最终推导出整个规则为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">main.o : main.c：  </div><div class="line">&gt;--- cc    -c -o main.o main.c</div></pre></td></tr></table></figure></p>
<p>其余几个目标也同样推导。make自动推导的功能为我们减少了不少的Makefile代码，尤其是对源文件比较多的大型工程，我们的Makefile可以不用写得那么繁琐了。
最后，今天的Makefile相对于上一节进化成这个样子了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<h3 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3. 变量的使用"></a>3. 变量的使用</h3><p>仔细研究我们的之前Makefile发现，我们还有改进的地方，就是此处：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o</div></pre></td></tr></table></figure></p>
<p>如果增加一个源文件xx.c的话，需要在两处或多处增加xx.o文件。我们可以使用变量来解决这个问题。之前说过，Makefile的变量就像C语言的宏一样，使用时在其位置上直接展开。变量在声明时赋予初值，在引用变量时需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。
默认目标target_bin也在多处出现了，该文件也可以使用变量代替。
修改我们的Makefile如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SRC_OBJ = main.o debug.o ipc.o timer.o tools.o  </div><div class="line">SRC_BIN = target_bin  </div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---gcc -o $(SRC_BIN) $(SRC_OBJ)  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm $(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>这样每次有新增的文件是只需要在SRC_OBJ变量里面增加一个文件即可。要修改最终目标的名字是可以只修改变量SRC_BIN。
其实在之前还说过特殊变量：</p>
<ul>
<li><code>$@</code>，表示规则中的目标。</li>
<li><code>$&lt;</code>，表示规则中的第一个依赖文件。</li>
<li><code>$?</code>，表示规则中所有比目标新的条件，组成一个列表，以空格分隔。
<code>$^</code>:，表示规则中的所有条件，组成一个列表，以空格分隔。
上一节我们看到make -p有很多自定义的变量，比如CC。其中很多变量我们可以直接使用或修改其变量值或增加值。我们的Makefile中可以使用CC（默认值为cc）、RM（默认值为rm -f）。</li>
</ul>
<p>由此可见我们的Makefile还可以进一步修改：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SRC_OBJ = main.o debug.o ipc.o timer.o tools.o  </div><div class="line">SRC_BIN = target_bin  </div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^                                                                                                                                           </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>这样的Makefile编译也是可用的。
但是这样的Makefile还是需要我们手动添加文件，还是不够自动化，最好增删文件都要修改Makefile。伟大的人类真是太懒了！！于是乎，他们发明了一个函数<code>wilcard</code>（函数后面会讲到），它可以用来获取指定目录下的所有的.c文件列表。这样的话我们可以自动获取当前目录下所有.c源文件，然后通过其他方法再得到.o文件列表，这样的话就不需要在每次增删文件时去修改Makefile了。所谓其他方法这里给出两种：</p>
<ol>
<li>使用patsubst函数。在<code>$(patsubst %.c,%.o,$(dir) )</code>中，patsubst把$(dir)中的变量符合后缀是.c的全部替换成.o。</li>
<li>变量值的替换。 我们可以替换变量中的共有的部分，其格式是<code>“$(var:a=b)”</code>或<code>“${var:a=b}”</code>，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。</li>
</ol>
<p>修改后的Makefile如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))                                                                                                                                          </div><div class="line"></div><div class="line">SRC = $(wildcard *.c)  </div><div class="line">SRC_OBJ = $(SRC:.c=.o)  </div><div class="line">SRC_BIN = target_bin  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>其中# 后面的内容为注释。
这样终于满足了那些懒人的想法了。可见在使用变量时，的确可以是编译变得更自动化。</p>
<p>其实变量的定义有三种运算符<code>=、:=、?=、+=</code>。</p>
<ol>
<li><code>=</code>运算符可以读取到后面定义的变量。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VAR = $(VAR2)  </div><div class="line">VAR2 = hello_make  </div><div class="line"></div><div class="line">all:  </div><div class="line">&gt;---@echo =====$(VAR)=====</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#  </div><div class="line">=====hello_make=====  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>但是这种定义可能会导致并非我们意愿的事发生，并不是很符合C语言的编程习惯。</p>
<ol>
<li><code>:=</code>运算符在遇到变量定义时立即展开。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VAR := $(VAR2)                                                                                         </div><div class="line">VAR2 = hello_make  </div><div class="line"></div><div class="line">all:  </div><div class="line">&gt;---@echo =====$(VAR)=====</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#  </div><div class="line">==========  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<ol>
<li><code>?=</code>运算符在复制之前先做判断变量是否已经存在。例如<code>var1 ?= $(var2)</code>的意思是：如果var1没有定义过，那么<code>?=</code>相当于<code>=</code>，如果var1先前已经定义了，则什么也不做，不会给var重新赋值。</li>
<li><code>+=</code>运算符是给变了追加值。如果变量还没有定义过就直接用+=赋值，那么<code>+=</code>相当于<code>=</code></li>
</ol>
<p>如何使用这几个运算符要看实际情况，有时一个大的工程可能有许多Makefile组成，变量可能在多个Makefile中都在使用，这时可能使用<code>+=</code>比较好。使用<code>:=</code>有时可能比要好。
有时在编译程序时，我们需要编译器给出警告，或加入调试信息，或告知编译器优化可执行文件。编译时C编译器的选项CFLAGS使用的较多，默认没有提供值，我们可以给该变量赋值。有时我们还需要使用链接器选项LFLAGS告诉链接器链接时需要的库文件。可能我们还需要给出包含头文件的路径，因为头文件很可能和源文件不再同一目录。所以，我们今天的Makefile加上部分注释又更新了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># A commonMakefile for c programs, version 1.0  </div><div class="line"># Copyright (C)2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall-Werror -O2  </div><div class="line">CPPFLAGS += -I.-I./inc                                                                                                                                                                    </div><div class="line">LDFLAGS +=-lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ =$(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES =$(wildcard *.c)  </div><div class="line">SRC_OBJ =$(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN =target_bin  </div><div class="line"></div><div class="line">$(SRC_BIN) :$(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@$^ $(LDFLAGS)  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>编译：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># make  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o debug.odebug.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o ipc.oipc.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o main.omain.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o timer.otimer.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o tools.otools.c  </div><div class="line">cc -o target_bindebug.o ipc.o main.o timer.o tools.o -lpthread  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>可见我们的预编译选项，编译选项都用到了，之前我们说过make的使用隐含规则自动推导：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) –c</div></pre></td></tr></table></figure></p>
<p>其中变量CFLAGS 和 CPPFLAGS均是我们给出的，变量$(TARGET_ARCH)未给，所以在编译输出可以看到-c前面有2个空，最早未给变量是有四个空。
目前给出的Makefile基本上可以适用于那些源代码全部在同一目录下的简单项目，并且基本上在增删文件时不需要再去手动修改Makefile代码。在新的一个项目只需要把该Makefile拷贝到源代码目录下，再修改一下你需要编译的可执行文件名称以及你需要的编译连接选项即可。
后面章节将会讲到如何写多目录源代码工程下的Makefile。
最后，今天的最终Makefile是这样的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># A commonMakefile for c programs, version 1.0  </div><div class="line"># Copyright (C)2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall-Werror -O2  </div><div class="line">CPPFLAGS += -I.-I./inc                                                                                                                                                                    </div><div class="line">LDFLAGS +=-lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ =$(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES =$(wildcard *.c)  </div><div class="line">SRC_OBJ =$(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN =target_bin  </div><div class="line"></div><div class="line">$(SRC_BIN) :$(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@$^ $(LDFLAGS)  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<h3 id="3-伪目标"><a href="#3-伪目标" class="headerlink" title="3. 伪目标"></a>3. 伪目标</h3><p>一般情况下，Makefile都会有一个clean目标，用于清除编译过程中产生的二进制文件。我们在第一节的Makefile就用到了这个 clean目标，该目标没有任何依赖文件，并且该目标对应的命令执行后不会生产clean文件。
像这种特点目标，它的规则所定义的命令不是去创建文件，而仅仅通过make指定目标来执行一些特定系统命令或其依赖为目标的规则（如all），称为伪目标。
一个Makefile一般都不会只有一个伪目标，如果按Makefile的“潜规则”以及其约定俗成的名字来说的话，在较大的项目的Makefile中比较常用的为目标有这些：</p>
<ul>
<li>all：执行主要的编译工作，通常用作缺省目标，放在最前面。</li>
<li>Install：执行编译后的安装工作，把可执行文件、配置文件、文档等分别拷到不同的安装目录。</li>
<li>clean：删除编译生成的二进制文件。</li>
<li>distclean：删除除源文件之外的所有中间生成文件，如配置文件，文档等。</li>
<li>tags：为vim等编辑器生成tags文件。</li>
<li>help：打印当前Makefile的帮助信息，比如有哪些目标可以有make指定去执行。
等。</li>
</ul>
<p>make处理Makefile时，首先读取所有规则，建立关系依赖图。然后从缺省目标（第一个目标）或指定的目标开始执行。像clean，tags这样的目标一般不会作为缺省目标，也不会跟缺省目标有任何依赖关系，所以 make 无法生成它的依赖关系和决定它是否要执行。所以要执行这样的目标时，必须要显示的指定make该目标。就像前面我们清楚便已产生的中间二进制文件一样，需要显示执行命令：make clean。
伪目标也可以作为默认目标（如all），并且可以为其指定依赖文件。
我们先将version 1.0的Makefile完善下，我们可以加入帮助信息，tags等功能。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># A common Makefile for c programs, version 1.1  </div><div class="line"></div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc  </div><div class="line">LDFLAGS += -lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard *.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN = target_bin  </div><div class="line"></div><div class="line">all : $(SRC_BIN)  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)  </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefile for cprograms==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163 \dotcom&quot;  </div><div class="line">&gt;---@echo &quot;The following targets are support:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all             - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj             - just compile, without link&quot;  </div><div class="line">&gt;---@echo &quot; clean           - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean       - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags            - create ctags for vim editor&quot;  </div><div class="line">&gt;---@echo &quot; help            - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make [target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version 1.1=======================&quot;  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe tags *~</div></pre></td></tr></table></figure></p>
<p>make会把执行的命令打印在屏幕上，如果我们不想把命令打印在屏幕上，只显示命令结果时，直接在命令前面加上符号“@”就可以实现。如上面help目标一样，只显示命令结果。一般我们会在make时都会输出“Compiling xxx.c…”,不输出编译时的命令。我们在后面写Makefile时可以模仿。
如果当前目录下存在一个和伪目标同名的文件时（如clean），此时如果执行命令make clean后出现如下结果：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># touch clean  </div><div class="line"># make clean  </div><div class="line">make: `clean&apos; is up to date.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>这是因为clean文件没有依赖文件，make认为目标clean是最新的不会去执行规则对应的命令。为了解决这个问题，我们可以明确地将该目标声明为伪目标。将一个目标声明为伪目标需要将它作为特殊目标.PHONY”的依赖。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.PHONY : clean</div></pre></td></tr></table></figure></p>
<p>这条规则写在clean:规则的后面也行，也能起到声明clean是伪目标的作用
这样修改一下之前Makefile，将所有伪目标都作为.PHONY的依赖：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.PHONY : all obj tag help clean disclean</div></pre></td></tr></table></figure></p>
<p>这样在当前目录下存在文件clean时执行:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make clean  </div><div class="line">rm -f debug.o ipc.o main.o timer.o tools.o target_bin target_bin.exe  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>发现问题解决。
最后，给出今天最终的Makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"># A common Makefile for c programs, version 1.1                                                                                                                                            </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc  </div><div class="line">LDFLAGS += -lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard *.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN = target_bin  </div><div class="line"></div><div class="line">all : $(SRC_BIN)  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)  </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line">tag:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefile for cprograms==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163 \dotcom&quot;  </div><div class="line">&gt;---@echo &quot;The following targets are support:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all             - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj             - just compile, without link&quot;  </div><div class="line">&gt;---@echo &quot; clean           - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean       - clean target and other information&quot;  </div><div class="line">&gt;---@echo &quot; tags            - create ctags for vim editor&quot;  </div><div class="line">&gt;---@echo &quot; help            - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make [target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version 1.1=======================&quot;  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe tags *~  </div><div class="line"></div><div class="line">.PHONY : all obj tag help clean disclean</div></pre></td></tr></table></figure></p>
<h3 id="5-嵌套执行"><a href="#5-嵌套执行" class="headerlink" title="5. 嵌套执行"></a>5. 嵌套执行</h3><p>在大一些的项目里面，所有源代码不会只放在同一个目录，一般各个功能模块的源代码都是分开的，各自放在各自目录下，并且头文件和.c源文件也会有各自的目录，这样便于项目代码的维护。这样我们可以在每个功能模块目录下都写一个Makefile，各自Makefile处理各自功能的编译链接工作，这样我们就不必把所有功能的编译链接都放在同一个Makefile里面，这可使得我们的Makefile变得更加简洁，并且编译的时候可选择编译哪一个模块，这对分块编译有很大的好处。
现在我所处于工程目录树如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">.  </div><div class="line"></div><div class="line">├── include  </div><div class="line">│   ├── common.h  </div><div class="line">│   ├── ipc  </div><div class="line">│   │   └── ipc.h  </div><div class="line">│   └── tools  </div><div class="line">│       ├── base64.h  </div><div class="line">│       ├── md5.h  </div><div class="line">│       └── tools.h  </div><div class="line">├── Makefile  </div><div class="line">├── src  </div><div class="line">│   ├── ipc  </div><div class="line">│   │   ├── inc  </div><div class="line">│   │   ├── Makefile  </div><div class="line">│   │   └── src  </div><div class="line">│   │       └── ipc.c  </div><div class="line">│   ├── main  </div><div class="line">│   │   ├── inc  </div><div class="line">│   │   ├── Makefile  </div><div class="line">│   │   └── src  </div><div class="line">│   │       ├── main.c  </div><div class="line">│   │       └── main.c~  </div><div class="line">│   └── tools  </div><div class="line">│       ├── inc  </div><div class="line">│       ├── Makefile  </div><div class="line">│       └── src  </div><div class="line">│           ├── base64.c  </div><div class="line">│           ├── md5.c  </div><div class="line">│           └── tools.c  </div><div class="line">└── tags  </div><div class="line"></div><div class="line">13 directories, 16 files</div></pre></td></tr></table></figure></p>
<p>这样组织项目源码要比之前合理一些，那这样怎么来写Makefile呢？我们可以在每个目录下写一个Makefile，通过最顶层的Makefile一层一层的向下嵌套执行各层Makefile。那么我们最顶层的Makefile简单点的话可以这样写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># top Makefile for xxx  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---$(MAKE) -C src  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---$(MAKE) -C src clean  </div><div class="line"></div><div class="line">.PHONY : all clean tags</div></pre></td></tr></table></figure></p>
<p>命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;---$(MAKE) -C src</div></pre></td></tr></table></figure></p>
<p>就是进入src目录继续执行该目录下的Makefile。然后src目录下的Makefile在使用同样的方法进入下一级目录tools、main、ipc，再执行该目录下的Makefile。其实这样有些麻烦，我们可以直接从顶层目录进入最后的目录执行make。再加入一些伪目标完善下，我们的顶层Makefile就出来了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"># Top Makefile for C program  </div><div class="line"></div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---$(MAKE) -C src/ipc  </div><div class="line">&gt;---$(MAKE) -C src/tools  </div><div class="line">&gt;---$(MAKE) -C src/main  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefilefor c programs==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163\dot com&quot;  </div><div class="line">&gt;---@echo &quot;The following targets aresupport:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all              - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj              - just compile, withoutlink&quot;  </div><div class="line">&gt;---@echo &quot; clean            - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean        - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags             - create ctags for vimeditor&quot;  </div><div class="line">&gt;---@echo &quot; help             - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make[target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version2.0 =======================&quot;  </div><div class="line"></div><div class="line">obj:  </div><div class="line">&gt;---$(MAKE) -C src/ipc obj  </div><div class="line">&gt;---$(MAKE) -C src/tools obj  </div><div class="line">&gt;---$(MAKE) -C src/main obj  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---$(MAKE) -C src/ipc clean  </div><div class="line">&gt;---$(MAKE) -C src/tools clean  </div><div class="line">&gt;---$(MAKE) -C src/main clean  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(MAKE) -C src/ipc distclean  </div><div class="line">&gt;---$(MAKE) -C src/tools distclean  </div><div class="line">&gt;---$(MAKE) -C src/main distclean  </div><div class="line"></div><div class="line">.PHONY : all clean distclean tags help</div></pre></td></tr></table></figure></p>
<p>当我们这样组织源代码时，最下面层次的Makefile怎么写呢？肯定不可以将我们上一节的Makefile（version 1.1）直接拷贝到功能模块目录下，需要稍作修改。不能所有的模块都最终生成各自的可执行文件吧，我们目前是一个工程，所以最后只会生成一个可执行程序。我们这样做，让主模块目录生成可执行文件，其他模块目录生成静态库文件，主模块链接时要用其他模块编译产生的库文件来生成最终的程序。将上一节Makefile稍作修改得出编译库文件Makefile和编译可执行文件Makefile分别如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># A Makefile to generate archive file  </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc -I../../include  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard src/*.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_LIB = libtools.a  </div><div class="line"></div><div class="line">all : $(SRC_LIB)  </div><div class="line"></div><div class="line">$(SRC_LIB) : $(SRC_OBJ)  </div><div class="line">&gt;---$(AR) rcs $@ $^  </div><div class="line">&gt;---cp $@ ../../libs  </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB)  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB) tags *~  </div><div class="line"></div><div class="line">.PHONY : all obj clean disclean</div></pre></td></tr></table></figure></p>
<p>====================</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># A Makefile to generate executive file                                                                                                                                                     </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc -I../../include  </div><div class="line">LDFLAGS += -lpthread -L../../libs -ltools -lipc  </div><div class="line"></div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard src/*.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)    </div><div class="line">SRC_BIN = target_bin            </div><div class="line"></div><div class="line">all : $(SRC_BIN)  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)         </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)   </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe tags*~  </div><div class="line"></div><div class="line">.PHONY : all obj clean disclean</div></pre></td></tr></table></figure>
<p>最后在顶层执行：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># make clean  </div><div class="line"></div><div class="line">make -C src/ipc clean  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">rm -f src/ipc.o libipc.a  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">make -C src/tools clean  </div><div class="line">make[1]: Entering directory `/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">rm -f src/base64.o src/md5.o src/tools.o libtools.a  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">make -C src/main clean  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line">rm -f src/main.o target_bin target_bin.exe  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line"># make  </div><div class="line">make -C src/ipc  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/ipc.osrc/ipc.c  </div><div class="line">ar rcs libipc.a src/ipc.o  </div><div class="line">cp libipc.a ../../libs  </div><div class="line">make[1]: Leaving directory `/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">make -C src/tools  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/base64.osrc/base64.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc -I../../include  -c -o src/md5.o src/md5.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/tools.osrc/tools.c  </div><div class="line">ar rcs libtools.a src/base64.o src/md5.o src/tools.o  </div><div class="line">cp libtools.a ../../libs  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">make -C src/main  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/main.osrc/main.c  </div><div class="line">cc -o target_bin src/main.o -lpthread -L../../libs -ltools-lipc  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>最后生成了可执行程序文件。这样的话一个工程的各个模块就变得独立出来了，不但源码分开了，而且各自有各自的Makefile，并且各个功能模块是可独立编译的。
我们发现顶层Makefile还有可以改进的地方，就是在进入下一层目录是要重复写多次，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;---$(MAKE) -C src/ipc  </div><div class="line">&gt;---$(MAKE) -C src/tools  </div><div class="line">&gt;---$(MAKE) -C src/main</div></pre></td></tr></table></figure></p>
<p>每增加一个目录都要在多个伪目标里面加入一行，这样不够自动化啊，于是我们想到shell的循环语 句，我们可以在每条规则的命令处使用for循环。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DIR = src  </div><div class="line">SUBDIRS = $(shell ls $(DIR))  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---@for subdir in $(SUBDIRS); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir; \                                                                                                                                             </div><div class="line">&gt;---done</div></pre></td></tr></table></figure></p>
<p>这样懒人有可以高兴很久了。不过还有问题：
上面for循环会依次进入系统命令ls列出的目录，但我们对每个目录的make顺序可能有要求，在该项目当中，main目录下的Makefile必须最后执行，因为最终的链接需要其他目录编译生成的库文件，否则会执行失败。并且在当前的Makefile中，当子目录执行make出现错误时，make不会退出。在最终执行失败的情况下，我们很难根据错误的提示定位出具体是是那个目录下的Makefile出现错误。这给问题定位造成了很大的困难。为了避免这样的问题，在命令执行错误后make退出。
所以将刚才的Makefile修改为如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DIR = src  </div><div class="line">SUBDIRS = $(shell ls $(DIR))  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---@for subdir in $(SUBDIRS); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir || exit 1; \                                                                                                                                             </div><div class="line">&gt;---done</div></pre></td></tr></table></figure></p>
<p>这样在执行出错时立马退出，但这样还是没有解决问题，编译错误还是会出现。那怎么解决呢？
我们可以通过增加规则来限制make执行顺序，这样就要用到伪目标，对每一个模块我们都为他写一条规则，每个模块名称是目标，最后需要执行的模块目标又是其他模块的目标，这样就限制了make顺序。在执行到最后需要执行的目标时，发现存在依赖，于是先更新依赖的目标，这样就不会出错了。并且这样的话，我们还可以对指定模块进行编译，比如我只修改了tools模块，我只想看看我修改的这个模块代码是否可以编译通过，我可以在编译时这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># make tools  </div><div class="line">make -C src/tools  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-2.1/src/tools&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/base64.o src/base64.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/md5.osrc/md5.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/tools.osrc/tools.c  </div><div class="line">ar rcs libtools.a src/base64.o src/md5.o src/tools.o  </div><div class="line">cp libtools.a ../../libs  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-2.1/src/tools&apos;  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>还有另外一种方法也可以解决此问题，就是手动列出需要进入执行的模块名称（这里就是目录了），把最后需要执行的模块放在最后，这样for循环执行时最后需要编译链接的模块就放在最后了，不会像我们之前那样make是按照使用系统命令ls列出模块目录的顺序来执行。ls列出目录是按照每个目录的名称来排序的，我们总不能要求写代码的时候最后执行的模块的名称必须是以z开头的吧，总之不现实。
 我们的顶层Makefile又进化了，也是这一节最终Makefile：
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"># Top Makefile for C program  </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">DIR = src  </div><div class="line">MODULES = $(shell ls $(DIR))  </div><div class="line"># MODULES = ipc main tools  </div><div class="line"></div><div class="line">all : $(MODULES)  </div><div class="line"></div><div class="line">$(MODULES):  </div><div class="line">&gt;---$(MAKE) -C $(DIR)/$@  </div><div class="line"></div><div class="line">main:tools ipc  </div><div class="line"></div><div class="line">obj:  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefilefor c programs==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163\dot com&quot;  </div><div class="line">&gt;---@echo &quot;The following targets aresupport:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all              - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj              - just compile, withoutlink&quot;  </div><div class="line">&gt;---@echo &quot; clean            - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean        - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags             - create ctags for vimeditor&quot;  </div><div class="line">&gt;---@echo &quot; help             - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make[target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version2.0 =======================&quot;  </div><div class="line"></div><div class="line">.PHONY : all clean distclean tags help</div></pre></td></tr></table></figure></p>
<h3 id="6-参数传递、条件判断、include"><a href="#6-参数传递、条件判断、include" class="headerlink" title="6.参数传递、条件判断、include"></a>6.参数传递、条件判断、include</h3><p> 在多个Makefile嵌套调用时，有时我们需要传递一些参数给下一层Makefile。比如我们在顶层Makefile里面定义的打开调试信息变量DEBUG_SYMBOLS，我们希望在进入子目录执行子Makefile时该变量仍然有效，这是需要将该变量传递给子Makefile，那怎么传递呢？这里有两种方法：</p>
<ol>
<li><p>在上层Makefile中使用”export”关键字对需要传递的变量进行声明。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DEBUG_SYMBOLS = TRUE  </div><div class="line">export DEBUG_SYMBOLS</div></pre></td></tr></table></figure>
<p>当不希望将一个变量传递给子 make 时，可以使用指示符 “unexport”来声明这个变量。
export一般用法是在定义变量的同时对它进行声明。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export DEBUG_SYMBOLS = TRUE</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>在命令行上指定变量。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(MAKE) -C xxx DEBUG_SYMBOLS = TRUE</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样在进入子目录xxx执行make时该变量也有效。</p>
<p>像编程语言一样，Makefile也有自己的条件语句。条件语句可以根据一个变量值来控制make的执行逻辑。比较常用的条件语句是ifeq –else-endif、ifneq-else-endif、ifdef-else-endif。
ifeq关键字用来判断参数是否相等。
比如判断是否生成调试信息可以这么用：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifeq ($(DEBUG_SYMBOLS), TRUE)  </div><div class="line">&gt;---CFLAGS += -g -Wall -Werror -O0  </div><div class="line">else  </div><div class="line">&gt;---CFLAGS += -Wall -Werror -O2  </div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>Ifneq和ifeq作用相反，此关键字是用来判断参数是否不相等。
ifdef关键字用来判断一个变量是否已经定义。
后两个关键字用法和ifeq类似。</p>
<p>现在我们继续改进我们上一节的Makefile，上一节的Makefile完成Makefile的嵌套调用，每一个模块都有自己的Makefile。其实每个模块的Makefile都大同小异，只需要改改最后编译成生成的目标名称或者编译链接选项，规则都差不多，那么我们是否可以考虑将规则部分提取出来，每个模块只需修改各自变量即可。这样是可行的，我们将规则单独提取出来，写一个Makefile.rule，将他放在顶层Makefile同目录下，其他模块内部的Makefile只需要include该Makefile就可以了。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include $(SRC_BASE)/Makefile.rule</div></pre></td></tr></table></figure></p>
<p>include类似于C语言的头文件包含，你把它理解为为本替换就什么都明白了。
这样以后规则有修改的话我们直接修改该Makefile就可以了，就不用进入每一个模块去修改，这样也便于维护。
这样我们今天顶层Makefile稍作修改：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># Top Makefile for C program                                                                                                                                                               </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">export DEBUG_SYMBOLS = TRUE  </div><div class="line"></div><div class="line">DIR = src  </div><div class="line">MODULES = $(shell ls $(DIR))  </div><div class="line"># MODULES = ipc main tools  </div><div class="line"></div><div class="line">all : $(MODULES)  </div><div class="line"></div><div class="line">$(MODULES):  </div><div class="line">&gt;---$(MAKE) -C $(DIR)/$@  </div><div class="line"></div><div class="line">main:tools ipc  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefilefor c programs==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163\dot com&quot;  </div><div class="line">&gt;---@echo &quot;The following targets aresupport:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all              - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; clean            - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean        - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags             - create ctags for vimeditor&quot;  </div><div class="line">&gt;---@echo &quot; help             - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make[target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version2.2 =======================&quot;  </div><div class="line"></div><div class="line">.PHONY : all clean distclean tags help</div></pre></td></tr></table></figure></p>
<p>目前我们顶层目录下的目录树为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">.  </div><div class="line">├── include  </div><div class="line">│   ├── common.h  </div><div class="line">│   ├── ipc  </div><div class="line">│   │   └── ipc.h  </div><div class="line">│   └── tools  </div><div class="line">│       ├── base64.h  </div><div class="line">│       ├── md5.h  </div><div class="line">│       └── tools.h  </div><div class="line">├── libs  </div><div class="line">├── Makefile  </div><div class="line">├── Makefile.rule  </div><div class="line">└── src  </div><div class="line">    ├── ipc  </div><div class="line">    │  ├──inc  </div><div class="line">    │  ├──Makefile  </div><div class="line">    │  └──src  </div><div class="line">    │       └── ipc.c  </div><div class="line">    ├── main  </div><div class="line">    │  ├──inc  </div><div class="line">    │  ├──Makefile  </div><div class="line">    │  └──src  </div><div class="line">    │       ├── main.c  </div><div class="line">    │       └── main.c~  </div><div class="line">    └── tools  </div><div class="line">        ├── inc  </div><div class="line">        ├── Makefile  </div><div class="line">        └── src  </div><div class="line">            ├── base64.c  </div><div class="line">            ├── md5.c  </div><div class="line">            └── tools.c  </div><div class="line"></div><div class="line">14 directories, 16 files</div></pre></td></tr></table></figure></p>
<p>每个子模块下的Makefile删除规则后修改为如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SRC_BASE = ../..  </div><div class="line"></div><div class="line">CFLAGS +=  </div><div class="line">CPPFLAGS += -I. -I./inc -I$(SRC_BASE)/include  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard src/*.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_LIB = libtools.a  </div><div class="line"></div><div class="line">include $(SRC_BASE)/Makefile.rule</div></pre></td></tr></table></figure></p>
<p>而处于顶层目录下的Makefile.rule专门处理各模块编译链接时需要的规则。内容如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com                                                                                                                                             </div><div class="line"></div><div class="line">ifeq ($(DEBUG_SYMBOLS), TRUE)  </div><div class="line">&gt;---CFLAGS += -g -Wall -Werror -O0  </div><div class="line">else  </div><div class="line">&gt;---CFLAGS += -Wall -Werror -O2  </div><div class="line">endif  </div><div class="line"></div><div class="line">all : $(SRC_BIN) $(SRC_LIB)  </div><div class="line"></div><div class="line">ifneq ($(SRC_BIN),)  </div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifneq ($(SRC_LIB),)  </div><div class="line">$(SRC_LIB) : $(SRC_OBJ)  </div><div class="line">&gt;---$(AR) rcs $@ $^  </div><div class="line">&gt;---cp $@ $(SRC_BASE)/libs  </div><div class="line">endif  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB) $(SRC_BIN)$(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB) $(SRC_BIN)$(SRC_BIN).exe $(SRC_BASE)/libs/* $(SRC_BASE)/tags *~  </div><div class="line"></div><div class="line">.PHONY : all clean disclean  </div><div class="line">~</div></pre></td></tr></table></figure></p>
<p>我们将Makefile.rule放在顶层有可能会一不小心在命令行上面执行了该Makefile，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make -f Makefile.rule  </div><div class="line">make: Nothing tobe done for `all&apos;.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>由于我们没有定义变量<code>$(SRC_BIN)</code>和<code>$(SRC_LIB)</code>，伪目标all没有任何依赖，所以编译是无法成功的。这里我们我们应该禁止直接执行该Makefile。
在make里面有这样一个变量：MAKELEVEL，它在多级调用的 make 执行过程中。变量代表了调用的深度。在 make 一级级的执行过程中变量MAKELEVEL的值不断的发生变化，通过它的值我们可以了解当前make 递归调用的深度。顶层的MAKELEVEL的值为“0” 、下一级时为“1” 、再下一级为“2”…….，所以我们希望一个子目录的Makefile必须被上层 make 调用才可以执行，而不允许直接执行，我们可以判断变量MAKELEVEL来控制。所以我们这一节最终的Makefile.rule为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># Copyright (C)2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">ifeq ($(DEBUG_SYMBOLS),TRUE)  </div><div class="line">&gt;---CFLAGS +=-g -Wall -Werror -O0  </div><div class="line">else  </div><div class="line">&gt;---CFLAGS +=-Wall -Werror -O2  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifeq($(MAKELEVEL), 0)                                                                                                                                                                     </div><div class="line">all : msg  </div><div class="line">else  </div><div class="line">all : $(SRC_BIN)$(SRC_LIB)  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifneq ($(SRC_BIN),)  </div><div class="line">$(SRC_BIN) :$(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@$^ $(LDFLAGS)  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifneq($(SRC_LIB),)  </div><div class="line">$(SRC_LIB) :$(SRC_OBJ)  </div><div class="line">&gt;---$(AR) rcs$@ $^  </div><div class="line">&gt;---cp $@$(SRC_BASE)/libs  </div><div class="line">endif  </div><div class="line"></div><div class="line">msg:  </div><div class="line">&gt;---@echo&quot;You cannot directily execute this Makefile! This Makefile should calledby toplevel Makefile.&quot;  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_LIB) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_LIB) $(SRC_BIN) $(SRC_BIN).exe $(SRC_BASE)/libs/*$(SRC_BASE)/tags *~  </div><div class="line"></div><div class="line">.PHONY : all cleandisclean</div></pre></td></tr></table></figure></p>
<p>此时再直接执行该Makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make -f Makefile.rule  </div><div class="line">You cannot directily execute this Makefile! This Makefile should called by toplevel Makefile.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<h3 id="7-统一目标输出目录"><a href="#7-统一目标输出目录" class="headerlink" title="7. 统一目标输出目录"></a>7. 统一目标输出目录</h3><p>上一节我们把规则单独提取出来，方便了Makefile的维护，每个模块只需要给出关于自己的一些变量，然后再使用统一的规则Makefile。这一节我们继续改进我们的Makefile，到目前为止我们的Makefile编译链接输出的目标都在源文件同目录下或模块Makefile同一目录下，当一个项目大了之后，这样会显得很乱，寻找编译输出的文件也比较困难。既然Makefile本身就是按照我们的的规则来编译链接程序，那么我们就可以指定其编译链接目标的目录，这样，我们可以清楚输出文件的地方，并且在清除已编译的目标时直接删除指定目录即可，不需要一层一层的进入源代码目录进行删除，这样又提高了效率。</p>
<p>既然要统一目标输出目录，那么该目录就需要存在，所以我们可以增加一条规则来创建这些目录，包括创建可执行文件的目录、链接库文件的目录以及.o文件的目录。并且目录还可以通过条件判断根据是否产生调试信息来区分开相应的目标文件。一般一个工程的顶层目录下都会有一个build目录来存放编译的目标文件结果，目前我的工程目录下通过Makefile创建的目录build的目录树如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">build/            //build根目录  </div><div class="line">├── unix        //unix平台项目下不带调试信息输出目录  </div><div class="line">│   ├── bin    //存放可执行文件目录  </div><div class="line">│   ├── lib    //存放可文件目录  </div><div class="line">│   └── obj    //存放.o文件目录，该目录下将每个模块生成的.o文件各自的目录下面  </div><div class="line">│       ├── ipc  </div><div class="line">│       ├── main  </div><div class="line">│       └── tools  </div><div class="line">└── unix_dbg   ////unix平台项目下带调试信息输出目录  </div><div class="line">    ├── bin  </div><div class="line">    ├── lib  </div><div class="line">    └── obj  </div><div class="line">        ├── ipc  </div><div class="line">        ├── main  </div><div class="line">        └── tools  </div><div class="line"></div><div class="line">14 directories, 0 files</div><div class="line">```    </div><div class="line">以上目录中bin和lib目录在顶层Makefile中创建，obj及其下面模块子目录在各模块的Makefile里面创建。</div><div class="line">顶层Makefile创建目录如下：</div></pre></td></tr></table></figure></p>
<p>ifeq ($(DEBUG_SYMBOLS), TRUE)  </p>
<blockquote>
<p>—BUILDDIR = ./build/$(PLATFORM)_dbg<br>else<br>—BUILDDIR = ./build/$(PLATFORM)<br>endif  </p>
</blockquote>
<p>all : $(BUILDDIR) $(MODULES)  </p>
<p>$(BUILDDIR):  </p>
<blockquote>
<p>—@echo “    Create directory $@ …”<br>—mkdir -p $(BUILDDIR)/bin $(BUILDDIR)/lib<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">我们在all目标里面增加了其依赖目标BUILDDIR，该目标对应的规则为创建bin目录和lib目录。这样每次编译之前都会创建目录。</div><div class="line"></div><div class="line">各模块内部Makefile创建生成.O文件的目录，如上目录树所示。类似于顶层Makefile，各模块内部Makefile需要根据平台、编译调试信息、以及模块名称来生成需要的目录名称，然后再增加创建该目录的规则。因为每个模块都会做这些处理，所以我们将这部分写在规则Makefile(Makefile.rule)里面，如下：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>……  </p>
<h1 id="define-a-root-build-directory-base-on-the-platform"><a href="#define-a-root-build-directory-base-on-the-platform" class="headerlink" title="define a root build directory base on the platform"></a>define a root build directory base on the platform</h1><h1 id="if-without-a-SRC-BASE-defined-just-use-local-src-directory"><a href="#if-without-a-SRC-BASE-defined-just-use-local-src-directory" class="headerlink" title="if without a SRC_BASE defined, just use local src directory"></a>if without a SRC_BASE defined, just use local src directory</h1><p>ifeq ($(SRC_BASE),)  </p>
<blockquote>
<p>—BUILDDIR = $(MOD_SRC_DIR)<br>—OBJDIR = $(MOD_SRC_DIR)<br>—LIBDIR = $(MOD_SRC_DIR)<br>—BINDIR = $(MOD_SRC_DIR)<br>else<br>—ifeq ($(DEBUG_SYMBOLS), TRUE)<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)_dbg<br>—else<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)<br>—endif<br>—OBJDIR = $(BUILDDIR)/obj/$(MODULE)<br>—LIBDIR = $(BUILDDIR)/lib<br>—BINDIR = $(BUILDDIR)/bin<br>endif<br>……<br>ifeq ($(MAKELEVEL), 0)<br>all : msg<br>else<br>all : lib bin<br>endif  </p>
</blockquote>
<p>lib : $(OBJDIR) $(SRC_LIB)  </p>
<p>bin : $(OBJDIR) $(SRC_BIN)                                                                                                                         </p>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—@echo “   MKDIR $(notdir $@)…”<br>—@mkdir -p $@<br>……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">此时我们编译一下后查看build目录：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>build/<br>└── unix_dbg<br>    ├── bin<br>    ├── lib<br>    └── obj<br>        ├── ipc<br>        ├── main<br>        └── tools  </p>
<p>7 directories, 0 files<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">由于我们是开启了调试信息，所以创建了unix_dbg目录，并且该目录下创建了bin、lib、obj目录及其模块目录，但我们没有发现有文件存放在里面。</div><div class="line"></div><div class="line">到目前为止，这一节仅仅讲述如何创建统一的目标文件存放目录，但是要想将编译生成的目标文件自动生成到这些目录还没有完成。其实我们只需要给目标加上路径即可，但还是有一些详细的地方需要处理，具体的我们会在下一节中讲到，这一节暂不给出最后的Makefile。</div><div class="line"></div><div class="line">### 8. 模式规则</div><div class="line">上一节讲到目录创建成功，目标文件没有生产到对应目录下，这里我们先给目标文件加上对应目录，这样的话产生对应的目标文件会直接生成到对应目录。我们先给库文件目标和可执行文件目标加上路径，如下：</div></pre></td></tr></table></figure></p>
<p>lib : $(OBJDIR) $(LIBDIR)/$(SRC_LIB)  </p>
<p>bin : $(OBJDIR) $(BINDIR)/$(SRC_BIN)  </p>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—@echo “   MKDIR $(notdir $@)…”<br>—@mkdir -p $@  </p>
</blockquote>
<p>ifneq ($(SRC_BIN),)<br>$(BINDIR)/$(SRC_BIN) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(CC) -o $@ $^ $(LDFLAGS)<br>endif  </p>
</blockquote>
<p>ifneq ($(SRC_LIB),)<br>$(LIBDIR)/$(SRC_LIB) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(AR) rcs $@ $^<br>—cp $@ $(SRC_BASE)/libs<br>endif<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">此时再执行make，完成后查看build目录树：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>build/<br>└── unix_dbg<br>    ├── bin<br>    │   └── target_bin<br>    ├── lib<br>    │   ├── libipc.a<br>    │   └── libtools.a<br>    └── obj<br>        ├── ipc<br>        ├── main<br>        └── tools<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以看到，生成的目标是在对应目录下。我们乘胜追击，把.o文件也将其修改了。我们之前的每个模块Makefile大致是这样写的：</div></pre></td></tr></table></figure></p>
<p>SRC_BASE = ../..                                                                               </p>
<p>CFLAGS +=<br>CPPFLAGS += -I. -I./inc -I$(SRC_BASE)/include                                                  </p>
<h1 id="SRC-OBJ-patsubst-c-o-wildcard-c"><a href="#SRC-OBJ-patsubst-c-o-wildcard-c" class="headerlink" title="SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))"></a>SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))</h1><p>SRC_FILES = $(wildcard src/*.c)<br>SRC_OBJ = $(SRC_FILES:.c=.o)<br>SRC_LIB = xx.a                                           </p>
<p>include $(SRC_BASE)/Makefile.rule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中SRC_OBJ在此处给出，然后再在Makefile.rule中使用，此处的.o文件会在.c文件相同目录下生成，所以我们现在需要将.o文件加上路径，由于取得路径是在Makefile.rule里面，所以我们可以统一在Makefile.rule里面给变量SRC_OBJ赋值，大致如下：</div></pre></td></tr></table></figure></p>
<p>SRC_OBJ = $(patsubst %.c, $(OBJDIR)/%.o, $(notdir $(SRC_FILES)))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这里用到函数patsubst、notdir，关于函数会在后面讲到。这样.o文件作为目标生成之后就会生成到相应目录里面了。</div><div class="line">此时再编译：</div></pre></td></tr></table></figure></p>
<h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-2.9/src/ipc&#39;  
make[1]: *** No rule to make target</code>../../build/unix_dbg/obj/ipc/ipc.o’, needed by <code>../../build/unix_dbg/lib/libipc.a&#39;.  Stop.  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-2.9/src/ipc’<br>make: <em>*</em> [ipc] Error 2  </p>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">发现出错了，并且是在生成目标文件ipc.o时没有成功，查看build目录树也没有生成.o文件。为什么会生成失败呢？</div><div class="line">我们没有给出生成.o目标的规则，之前可以生成是因为make有通过隐含规则来自动推导的能力（这个之前有讲到，链接过去）。在我们没有修改之前，生成.o通过隐含规则来完成：</div></pre></td></tr></table></figure>
<p>%.o: %.c  </p>
<h1 id="commands-to-execute-built-in"><a href="#commands-to-execute-built-in" class="headerlink" title="commands to execute (built-in):"></a>commands to execute (built-in):</h1><blockquote>
<p>—$(COMPILE.c) $(OUTPUT_OPTION) $&lt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">该模式规则中目标文件是$(OBJDIR)/%.o，那么现在有了符合生成我们需要的.o文件的规则了，编译一下：</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="make-1"><a href="#make-1" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-2.9/src/ipc&#39;  
make[1]: *** No rule to make target</code>../../build/unix_dbg/obj/ipc/ipc.o’, needed by <code>../../build/unix_dbg/lib/libipc.a&#39;.  Stop.  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-2.9/src/ipc’<br>make: <em>*</em> [ipc] Error 2<br>#
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">发现还是不对，不是已经增加了模式规则了吗，为何还是没有生成.o文件。</div><div class="line">我们这里先说说静态模式规则：</div><div class="line"></div><div class="line">一个规则中可以有多个目标，规则所定义的命令对所有的目标有效。一个具有多目标的规则相当于多个规则。 规则的命令对不同的目标的执行效果不同， 因为在规则的命令中可能使用了自动化变量 `“$@”` 。 多目标规则意味着所有的目标具有相同的依赖文件。多目标通常用在以下两种情况：虽然在多目标的规则中， 可以根据不同的目标使用不同的命令 （在命令行中使用自动化变量 `“$@”` ）。但是， 多目标的规则并不能做到根据目标文件自动改变依赖文件 （像上边例子中使用自动化变量“$@”改变规则的命令一样） 。需要实现这个目的是，要用到make的静态模式。</div><div class="line"></div><div class="line">静态模式规则是这样一个规则：规则存在多个目标， 并且不同的目标可以根据目标文件的名字来自动构造出依赖文件。静态模式规则比多目标规则更通用， 它不需要多个目标具有相同的依赖。但是静态模式规则中的依赖文件必须是相类似的而不是完全相同的。静态模式规则语法如下：</div></pre></td></tr></table></figure></p>
<p><targets ...="">: <target-pattern>: <prereq-patterns ...="">    </prereq-patterns></target-pattern></targets></p>
<p><commands><br>….<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">比如下面是一个静态模式规则：</div></pre></td></tr></table></figure></commands></p>
<p>objects = foo.o bar.o  </p>
<p>all: $(objects)  </p>
<p>$(objects): %.o: %.c<br>$(CC) -c $(CFLAGS) $&lt; -o $@
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">该规则描述了所有的.o文件的依赖文件为对应的.c文件，对于目标“foo.o” ，取其茎“foo”替代对应的依赖模式“%.c”中的模式字符“%”之后可得到目标的依赖文件“foo.c”。这就是目标“foo.o”的依赖关系“foo.o: foo.c”，规则的命令行描述了如何完成由“foo.c”编译生成目标“foo.o” 。命令行中“$&lt;”和“$@”是自动化变量，“$&lt;” 表示规则中的第一个依赖文件， “$@” 表示规则中的目标文件。上边的这个规则描述了以下两个具体的规则：</div></pre></td></tr></table></figure></p>
<p>foo.o : foo.c  </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) foo.c -o foo.o<br>bar.o : bar.c<br>—$(CC) -c $(CFLAGS) bar.c -o bar.o<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">注：该示例与其相关描述摘抄于互联网，描述很不错，估计比我讲的详细）</div><div class="line"></div><div class="line">那静态模式规则和普通的模式规则（非静态模式规则）有什么去区别呢？两者都是用目标模式和依赖模式来构建目标的规则中的文件依赖关系，两者不同的地方是 make 在执行时使用它们的时机。</div><div class="line">静态模式规则只能用在规则中明确指出的那些文件的重建过程中。不能用在除此之外的任何文件的重建过程中，并且它对指定的每一个目标来说是唯一的。如果一个目标存在于两个规则，并且这两个规则都定义了命令， make 执行时就会提示错误。</div><div class="line">非静态模式规则可被用在任何和它相匹配的目标上，当一个目标文件同时符合多个目标模式时，make将会把第一个目标匹配的模式规则作为重建它的规则。</div><div class="line"></div><div class="line">那有没有想过如果我们指定了模式规则后，那还有隐含规则呢，那怎么选择执行哪一个模式规则呢？Makefile中明确指定的模式规则会覆盖隐含模式规则。就是说如果在Makefile中出现了一个对目标文件合适可用的模式规则，那么make就不会再为这个目标文件寻找其它隐含规则，而直接使用在Makefile中出现的这个规则。在使用时，明确规则永远优先于隐含规则。</div><div class="line"></div><div class="line">我们继续说之前的那个问题，我们定义了模式规则后还是没有生成.o文件，我们现在将其改为静态规则再试试就看，如下：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : %.c                                                            </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行后：</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="make-2"><a href="#make-2" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-2.9/src/ipc&#39;  
make[1]: *** No rule to make target</code>ipc.c’, needed by <code>../../build/unix_dbg/obj/ipc/ipc.o&#39;.  Stop.  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-2.9/src/ipc’<br>make: <em>*</em> [ipc] Error 2<br>#
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">发现提示没有文件ipc.c，这说明没有生成.o的原因是没有.c文件，我很好奇的是为何使用非静态模式为何不提示呢？（还没搞懂，再研究研究，知道的可以给个提示哈~~）</div><div class="line"></div><div class="line">缺少依赖文件，为何没有*.c文件，仔细想想我们的.o文件没有和.c文件在同一目录。在我们工程中，将源代码和二进制文件（.o 文件和可执行文件）安排在不同的目录来进行区分管理。这种情况下，我们可以使用 make 提供的目录搜索依赖文件功能。该功能在下一节讲述，这一节说的够多了，有点累了。可惜最终还是没有给出一个可用的Makefile，在下一节将会给出。</div><div class="line"></div><div class="line">### 9. 目标搜索</div><div class="line">在一个较大的工程中，一般会将源代码和二进制文件（.o 文件和可执行文件）安排在不同的目录来进行区分管理。这种情况下，我们可以使用 make 提供的目录搜索依赖文件功能（在指定的若干个目录下自动搜索依赖文件）。在Makefile中，使用依赖文件的目录搜索功能。当工程的目录结构发生变化后，就可以做到不更改 Makefile的规则，只更改依赖文件的搜索目录。</div><div class="line"></div><div class="line">在我们上一节出现的问题当中，我们将.c文件统一放在src目录下，没有和Makefile目录在同一目录下，因此没有办法寻找到.o文件的依赖文件。make程序有一个特殊的变量VPATH，该变量可以指定依赖文件的搜索路径，当规则的依赖文件在当前目录不存在时，make 会在此变量所指定的目录下去寻找这些依赖文件。通常我们都是用此变量来指定规则的依赖文件的搜索路径。</div><div class="line">定义变量 “VPATH”时，使用空格或者冒号（:）将多个需要搜索的目录分开。make搜索目录的顺序是按照变量“VPATH”定义中的目录顺序进行的，当前目录永远是第一搜索目录。例如如下定义</div></pre></td></tr></table></figure></p>
<p>VPATH += ./src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">指定了依赖搜索目录为当前目录下的src目录，我们可以在Makefile.rules里面添加给VPATH变量赋值，而在包含该Makefile.rules之前给出当前模块.c文件所在目录。</div><div class="line"></div><div class="line">其实我们也可以直接指定依赖文件的路径，这样也是可以的，如下：</div></pre></td></tr></table></figure></p>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : $(MOD_SRC_DIR)/%.c                             </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是这样在我们更改了工程目录结构之后，对应的依赖文件没有在同一目录下，又变得麻烦了，所以还不如直接给VPATH变量赋值，我们只需要指定源码所在的目录即可。</div><div class="line"></div><div class="line">其实我们还有另外一种搜索文件路径方法：使用vpath关键字（注意不是VPATH变量）， 它和VPATH类似，但是它可以为不同类型的文件（由文件名区分）指定不同的搜索目录。使用方法有三种：</div><div class="line">1. vpath PATTERN DIRECTORIES</div><div class="line">为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES” 。多个目录使用空格或者冒号（：）分开。</div><div class="line">2. vpath PATTERN</div><div class="line">清除之前为符合模式“PATTERN”的文件设置的搜索路径。</div><div class="line">3. vpath</div><div class="line">清除所有已被设置的文件搜索路径。</div><div class="line"></div><div class="line">vapth 使用方法中的“PATTERN”需要包含模式字符“%”；例如上面的定义：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>VPATH += ./src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以写为：</div></pre></td></tr></table></figure></p>
<p>vpath %.c ./src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在给一个我们的Makefile.rules：</div></pre></td></tr></table></figure></p>
<h1 id="Copyright-C-2014-shallnew-at-163-dot-com"><a href="#Copyright-C-2014-shallnew-at-163-dot-com" class="headerlink" title="Copyright (C) 2014 shallnew \at 163 \dot com"></a>Copyright (C) 2014 shallnew \at 163 \dot com</h1><h1 id="if-without-a-platform-defined-give-value-“unknow”-to-PLATFORM"><a href="#if-without-a-platform-defined-give-value-“unknow”-to-PLATFORM" class="headerlink" title="if without a platform defined, give value “unknow” to PLATFORM"></a>if without a platform defined, give value “unknow” to PLATFORM</h1><p>ifndef PLATFORM  </p>
<blockquote>
<p>—PLATFORM = unknow<br>endif  </p>
</blockquote>
<h1 id="define-a-root-build-directory-base-on-the-platform-1"><a href="#define-a-root-build-directory-base-on-the-platform-1" class="headerlink" title="define a root build directory base on the platform"></a>define a root build directory base on the platform</h1><h1 id="if-without-a-SRC-BASE-defined-just-use-local-src-directory-1"><a href="#if-without-a-SRC-BASE-defined-just-use-local-src-directory-1" class="headerlink" title="if without a SRC_BASE defined, just use local src directory"></a>if without a SRC_BASE defined, just use local src directory</h1><p>ifeq ($(SRC_BASE),)  </p>
<blockquote>
<p>—BUILDDIR = $(MOD_SRC_DIR)<br>—OBJDIR = $(MOD_SRC_DIR)<br>—LIBDIR = $(MOD_SRC_DIR)<br>—BINDIR = $(MOD_SRC_DIR)<br>else<br>—ifeq ($(DEBUG_SYMBOLS), TRUE)<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)_dbg<br>—else<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)<br>—endif<br>—OBJDIR = $(BUILDDIR)/obj/$(MODULE)<br>—LIBDIR = $(BUILDDIR)/lib<br>—BINDIR = $(BUILDDIR)/bin<br>endif  </p>
</blockquote>
<h1 id="update-compilation-flags-base-on-“DEBUG-SYMBOLS”"><a href="#update-compilation-flags-base-on-“DEBUG-SYMBOLS”" class="headerlink" title="update compilation flags base on “DEBUG_SYMBOLS”"></a>update compilation flags base on “DEBUG_SYMBOLS”</h1><p>ifeq ($(DEBUG_SYMBOLS), TRUE)  </p>
<blockquote>
<p>—CFLAGS += -g -Wall -Werror -O0<br>else<br>—CFLAGS += -Wall -Werror -O2<br>endif  </p>
</blockquote>
<p>VPATH += $(MOD_SRC_DIR)  </p>
<p>SRC_OBJ = $(patsubst %.c, $(OBJDIR)/%.o, $(notdir $(SRC_FILES)))  </p>
<p>ifeq ($(MAKELEVEL), 0)<br>all : msg<br>else<br>all : lib bin<br>endif  </p>
<p>lib : $(OBJDIR) $(LIBDIR)/$(SRC_LIB)  </p>
<p>bin : $(OBJDIR) $(BINDIR)/$(SRC_BIN)  </p>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—mkdir -p $@  </p>
</blockquote>
<p>ifneq ($(SRC_BIN),)<br>$(BINDIR)/$(SRC_BIN) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(CC) -o $@ $^ $(LDFLAGS)<br>endif  </p>
</blockquote>
<p>ifneq ($(SRC_LIB),)<br>$(LIBDIR)/$(SRC_LIB) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(AR) rcs $@ $^<br>—cp $@ $(SRC_BASE)/libs<br>endif  </p>
</blockquote>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : %.c  </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@  </p>
</blockquote>
<p>msg:  </p>
<blockquote>
<p>—@echo “You cannot directily execute this Makefile! This Makefile should called by toplevel Makefile.”  </p>
</blockquote>
<h1 id="clean-target"><a href="#clean-target" class="headerlink" title="clean target"></a>clean target</h1><p>clean:<br>ifneq ($(SRC_LIB),)  </p>
<blockquote>
<p>—&gt;—$(RM) $(SRC_OBJ) $(LIBDIR)/$(SRC_LIB)<br>endif<br>ifneq ($(SRC_BIN),)<br>—&gt;—$(RM) $(SRC_OBJ) $(BINDIR)/$(SRC_BIN)<br>endif  </p>
</blockquote>
<p>.PHONY : all clean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 10. make内嵌函数及make命令显示</div><div class="line">这一节我们讲一下make的函数，在之前的章节已经讲到了几个函数：wildcard、patsubst、notdir、shell等。一般函数的调用格式如下：</div><div class="line">`$(funcname arguments)`</div><div class="line">或</div><div class="line">`$(funcname arguments)`</div><div class="line">其中funcname是需要调用函数的函数名称，应该是make内嵌函数；arguments是函数参数，参数和函数名之间使用空格分割，如果存在多个参数时，参数之间使用逗号“,”分开。函数调用以“$”开头，使用成对的圆括号或花括号把函数名和参数括起，一般使用圆括号。</div><div class="line">下面来看一下常用的一些函数：</div><div class="line"></div><div class="line">1.    获取匹配模式文件名函数—wildcard 。</div><div class="line">用法：`$(wildcard PATTERN)`</div><div class="line">该函数会列出当前目录下所有符合模式“PATTERN”格式的文件名。返回空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名。</div><div class="line">例如：</div></pre></td></tr></table></figure></p>
<p>SRC_FILES = $(wildcard src/*.c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">返回src目录下所有.c文件列表。</div><div class="line">2.    字符串替换函数—subst。</div><div class="line">用法：`$(subst FROM,TO,TEXT)`</div><div class="line">该函数把字串“TEXT”中的“FROM”字符替换为“TO”，返回替换后的新字符串。</div><div class="line">3.    模式替换函数—patsubst。</div><div class="line">用法：`$(patsubst PATTERN,REPLACEMENT,TEXT)`</div><div class="line">该函数搜索“TEXT”中以空格分开的单词，将符合模式“TATTERN”替换为“REPLACEMENT” 。参数“PATTERN”中可以使用模式通配符“%”，来代表一个单词中的若干字符。如果参数“REPLACEMENT”中也包含一个“%” ，那么“REPLACEMENT”中的“%”将是“TATTERN”中的那个“%”所代表的字符串。</div><div class="line">例如：</div></pre></td></tr></table></figure></p>
<p>SRC_OBJ = $(patsubst %.c, %.o, $(SRC_FILES))
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">将SRC_FILES中所有.c文件替换为.o返回给变量SRC_OBJ。</div><div class="line">此函数功能类似之前讲过的变量替换，http://blog.csdn.net/shallnet/article/details/37529935</div><div class="line">变量替换格式是“$(var:a=b)”或“$&#123;var:a=b&#125;”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。</div><div class="line">例如我们存在一个代表所有.c 文件的变量。定义为“src_files = a.c b.c c.c” 。</div><div class="line">为了得到这些.c文件所对应的.o源文件。如下两种使用可以得到同一种结果：</div></pre></td></tr></table></figure></p>
<p>$(objects:.c=.o)<br>$(patsubst %.c,%.o,$( src_files))
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">4.    过滤函数—filter。</div><div class="line">用法：$(filter PATTERN…,TEXT)</div><div class="line">该函数过滤掉字串“TEXT”中所有不符合模式“PATTERN”的单词，保留所有符合此模式的单词。可以使用多个模式。模式中一般需要包含模式字符“%” 。存在多个模式时，模式表达式之间使用空格分割。返回空格分割的“TEXT”字串中所有符合模式“PATTERN”的字串。</div><div class="line">5.    反过滤函数—filter-out。</div><div class="line">用法：`$(filter-out PATTERN...,TEXT)`</div><div class="line">和“filter”函数实现的功能相反。过滤掉字串“TEXT”中所有符合模式“PATTERN” 的单词， 保留所有不符合此模式的单词。 可以有多个模式。存在多个模式时，模式表达式之间使用空格分割。</div><div class="line">6.    取目录函数—dir。</div><div class="line">用法：`$(dir NAMES…)`</div><div class="line">从文件名序列“NAMES…”中取出各个文件名的目录部分。文件名的目录部分就是包含在文件名中的最后一个斜线`（ “/” ）` （包括斜线）之前的部分。返回空格分割的文件名序列“NAMES…”中每一个文件的目录部分。如果文件名中没有斜线，认为此文件为当前目录`（ “./” ）`下的文件。</div><div class="line">7.    取文件名函数——notdir。</div><div class="line">用法：`$(notdir NAMES…)`</div><div class="line">从文件名序列“NAMES…”中取出非目录部分。目录部分是指最后一个斜线`（ “/” ）` （包括斜线）之前的部分。删除所有文件名中的目录部分，只保留非目录部分。文件名序列“NAMES…”中每一个文件的非目录部分。</div><div class="line">8.    取后缀函数—suffix。</div><div class="line">用法：`$(suffix NAMES…) `</div><div class="line">函数从文件名序列“NAMES…”中取出各个文件名的后缀。后缀是文件名中最后一个以点“.”开始的（包含点号）部分，如果文件名中不包含一个点号，则为空。 返回以空格分割的文件名序列“NAMES…”中每一个文件的后缀序列。</div><div class="line">9.    取前缀函数—basename。</div><div class="line">用法：`$(basename NAMES…)`</div><div class="line">从文件名序列“NAMES…”中取出各个文件名的前缀部分（点号之后的部分） 。前缀部分指的是文件名中最后一个点号之前的部分。 返回空格分割的文件名序列“NAMES…”中各个文件的前缀序列。如果文件没有前缀，则返回空字串。</div><div class="line"></div><div class="line">这里仅仅讲到一些常用的函数，还有一些函数没有讲到，用到的时候可以去翻翻makefile手册。</div><div class="line"></div><div class="line">通常情况下make在编译时会打印出当前正在执行的命令，当编译链接选项很长时，会输出很多东西在屏幕上，如果我 不想再屏幕上看到很多东西，我们可以在命令前面加上@，这样命令就不会输出到屏幕了。我们这样尝试修改下：</div></pre></td></tr></table></figure></p>
<h1 id="make-3"><a href="#make-3" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/ipc&#39;  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/ipc’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/tools&#39;  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/tools’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/main&#39;  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/main’  </p>
<h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">发现只有进入目录和退出目录的显示，这样很难知道目前编译过程。其实我们可以在规则命令处加入一行类似打印：</div><div class="line">`@echo &quot;do something......&quot;`</div><div class="line">这样可以输出目前正在做的事，又不会输出正在执行命令。现在将规则修改下如下：</div></pre></td></tr></table></figure>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—@echo “   MKDIR $(notdir $@)…”<br>—@mkdir -p $@  </p>
</blockquote>
<p>ifneq ($(SRC_BIN),)<br>$(BINDIR)/$(SRC_BIN) : $(SRC_OBJ)  </p>
<blockquote>
<p>—@echo “   LINK $(notdir $@)…”<br>—@$(CC) -o $@ $^ $(LDFLAGS)<br>endif  </p>
</blockquote>
<p>ifneq ($(SRC_LIB),)<br>$(LIBDIR)/$(SRC_LIB) : $(SRC_OBJ)  </p>
<blockquote>
<p>—@echo “    ARCHIVE $(notdir $@)…”<br>—@$(AR) rcs $@ $^<br>—@echo “    COPY $@ to $(SRC_BASE)/libs”<br>—@cp $@ $(SRC_BASE)/libs<br>endif  </p>
</blockquote>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : %.c  </p>
<blockquote>
<p>—@echo “    COMPILE $(notdir $&lt;)…”<br>—@$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">编译输出如下：</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="make-4"><a href="#make-4" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/ipc&#39;  
    COMPILE ipc.c...  
    ARCHIVE libipc.a...  
    COPY ../../build/unix_dbg/lib/libipc.a to ../../libs  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/ipc’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/tools&#39;  
    COMPILE base64.c...  
    COMPILE md5.c...  
    COMPILE tools.c...  
    ARCHIVE libtools.a...  
    COPY ../../build/unix_dbg/lib/libtools.a to ../../libs  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/tools’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/main&#39;  
    COMPILE main.c...  
   LINK target_bin...  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/main’  </p>
<h1 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">其中目录切换的输出仍然很多，我们可以将其关闭，这需要使用到make的参数，在make -C是指定--no-print-</div><div class="line">directory参数。我们将顶层目录下Makefile规则修改如下：</div></pre></td></tr></table></figure>
<p>$(BUILDDIR):  </p>
<blockquote>
<p>—@echo “    Create directory $@ …”<br>—mkdir -p $(BUILDDIR)/bin $(BUILDDIR)/lib  </p>
</blockquote>
<p>$(MODULES):  </p>
<blockquote>
<p>—@$(MAKE) -C $(DIR)/$@ MODULE=$@ –no-print-directory  </p>
</blockquote>
<p>main:tools ipc  </p>
<p>clean :  </p>
<blockquote>
<p>—@for subdir in $(MODULES); \<br>—do $(MAKE) -C $(DIR)/$$subdir MODULE=$$subdir $@ –no-print-directory; \<br>—done<br>编译输出：  </p>
<h1 id="make-5"><a href="#make-5" class="headerlink" title="make"></a>make</h1><pre><code>COMPILE ipc.c...  
ARCHIVE libipc.a...  
COPY ../../build/unix_dbg/lib/libipc.a to ../../libs  
COMPILE base64.c...  
COMPILE md5.c...  
COMPILE tools.c...  
ARCHIVE libtools.a...  
COPY ../../build/unix_dbg/lib/libtools.a to ../../libs  
COMPILE main.c...  
</code></pre><p>   LINK target_bin…  </p>
<h1 id="make-clean"><a href="#make-clean" class="headerlink" title="make clean"></a>make clean</h1><p>rm -f  ../../build/unix_dbg/obj/ipc/ipc.o ../../build/unix_dbg/lib/libipc.a<br>rm -f  ../../build/unix_dbg/obj/main/main.o ../../build/unix_dbg/bin/target_bin<br>rm -f  ../../build/unix_dbg/obj/tools/base64.o  ../../build/unix_dbg/obj/tools/md5.o<br>../../build/unix_dbg/obj/tools/tools.o ../../build/unix_dbg/lib/libtools.a  </p>
</blockquote>
<p>#
```
这样看上去输出清爽多了。其实我们也可以使用make -s 来全面禁止命令的显示。</p>
<blockquote>
<p>【版权声明：转载请保留出处：<a href="http://blog.csdn.net/shallnet/article/details/37358655】" target="_blank" rel="external">http://blog.csdn.net/shallnet/article/details/37358655】</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/09/30/course-makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/30/course-makefile/" itemprop="url">
                  Makefile经典教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T15:18:09+08:00">
                2017-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/makefile/" itemprop="url" rel="index">
                    <span itemprop="name">makefile</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。</p>
<p>在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>
<p>关于程序的编译和链接</p>
<p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。   </p>
<ul>
<li><strong>编译时</strong>，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</li>
<li><strong>链接时</strong>，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</li>
</ul>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.</p>
<h3 id="1-Makefile-介绍"><a href="#1-Makefile-介绍" class="headerlink" title="1 Makefile 介绍"></a>1 Makefile 介绍</h3><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li>
<li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li>
</ol>
<p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h4 id="1-1-Makefile的规则"><a href="#1-1-Makefile的规则" class="headerlink" title="1.1 Makefile的规则"></a>1.1 Makefile的规则</h4><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target... : prerequisites ...</div><div class="line">  command</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  -------------------------------------------------------------------------------</div></pre></td></tr></table></figure></p>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
<ul>
<li>prerequisites就是，要生成那个target所需要的文件或是目标。</li>
<li>command也就是make需要执行的命令。（任意的Shell命令）</li>
</ul>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<p>说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p>
<h4 id="1-2-一个示例"><a href="#1-2-一个示例" class="headerlink" title="1.2 一个示例"></a>1.2 一个示例</h4><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">edit : main.o kbd.o command.o display.o \</div><div class="line">          insert.o search.o files.o utils.o</div><div class="line">          cc -o edit main.o kbd.o command.o display.o \</div><div class="line">                      insert.o search.o files.o utils.o</div><div class="line">main.o : main.c defs.h</div><div class="line">           cc -c main.c</div><div class="line">kbd.o : kbd.c defs.h command.h</div><div class="line">       cc -c kbd.c</div><div class="line">command.o : command.c defs.h command.h</div><div class="line">       cc -c command.c</div><div class="line">display.o : display.c defs.h buffer.h</div><div class="line">       cc -c display.c</div><div class="line">insert.o : insert.c defs.h buffer.h</div><div class="line">       cc -c insert.c</div><div class="line">search.o : search.c defs.h buffer.h</div><div class="line">       cc -c search.c</div><div class="line">files.o : files.c defs.h buffer.h command.h</div><div class="line">       cc -c files.c</div><div class="line">utils.o : utils.c defs.h</div><div class="line">       cc -c utils.c</div><div class="line">clean :</div><div class="line">      rm edit main.o kbd.o command.o display.o \</div><div class="line">            insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>反斜杠<code>（\）</code>是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下<code>make clean</code>就可以了。</p>
<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件<code>（*.o）</code>，依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h4 id="1-3-make是如何工作的"><a href="#1-3-make是如何工作的" class="headerlink" title="1.3 make是如何工作的"></a>1.3 make是如何工作的</h4><p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。</li>
<li>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——<code>make clean</code>，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<h4 id="1-4-makefile中使用变量"><a href="#1-4-makefile中使用变量" class="headerlink" title="1.4 makefile中使用变量"></a>1.4 makefile中使用变量</h4><p>在上面的例子中，先让我们看看edit的规则：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">edit : main.o kbd.o command.o display.o \</div><div class="line">                 insert.o search.o files.o utils.o</div><div class="line">                 cc -o edit main.o kbd.o command.o display.o \</div><div class="line">                      insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。
比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.osearch.o files.o utils.o</div><div class="line">edit : $(objects)</div><div class="line">       cc -o edit $(objects)</div><div class="line">main.o : main.c defs.h</div><div class="line">       cc -c main.c</div><div class="line">kbd.o : kbd.c defs.h command.h</div><div class="line">       cc -c kbd.c</div><div class="line">command.o : command.c defs.h command.h</div><div class="line">       cc -c command.c</div><div class="line">display.o : display.c defs.h buffer.h</div><div class="line">       cc -c display.c</div><div class="line">insert.o : insert.c defs.h buffer.h</div><div class="line">       cc -c insert.c</div><div class="line">search.o : search.c defs.h buffer.h</div><div class="line">       cc -c search.c</div><div class="line">files.o : files.c defs.h buffer.h command.h</div><div class="line">       cc -c files.c</div><div class="line">utils.o : utils.c defs.h</div><div class="line">       cc -c utils.c</div><div class="line">clean :</div><div class="line">       rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。
关于变量更多的话题，我会在后续给你一一道来。</p>
<h4 id="1-5-让make自动推导"><a href="#1-5-让make自动推导" class="headerlink" title="1.5 让make自动推导"></a>1.5 让make自动推导</h4><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.o search.o files.o utils.o</div><div class="line"></div><div class="line">edit : $(objects)</div><div class="line">       cc -o edit $(objects)</div><div class="line"></div><div class="line">main.o : defs.h</div><div class="line">kbd.o : defs.h command.h</div><div class="line">command.o : defs.h command.h</div><div class="line">display.o : defs.h buffer.h</div><div class="line">insert.o : defs.h buffer.h</div><div class="line">search.o : defs.h buffer.h</div><div class="line">files.o : defs.h buffer.h command.h</div><div class="line">utils.o : defs.h</div><div class="line"></div><div class="line">.PHONY : clean</div><div class="line">clean :</div><div class="line">       rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。
关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。</p>
<h4 id="1-6-另类风格的makefile"><a href="#1-6-另类风格的makefile" class="headerlink" title="1.6 另类风格的makefile"></a>1.6 另类风格的makefile</h4><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.o search.o files.o utils.o</div><div class="line"></div><div class="line">edit : $(objects)</div><div class="line">       cc -o edit $(objects)</div><div class="line"></div><div class="line">$(objects) : defs.h</div><div class="line">kbd.o command.o files.o : command.h</div><div class="line">display.o insert.o search.o files.o : buffer.h</div><div class="line"></div><div class="line">.PHONY : clean</div><div class="line">clean :</div><div class="line">       rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<h4 id="1-7-清空目标文件的规则"><a href="#1-7-清空目标文件的规则" class="headerlink" title="1.7 清空目标文件的规则"></a>1.7 清空目标文件的规则</h4><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">    rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>更为稳健的做法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.PHONY : clean</div><div class="line">clean :</div><div class="line">       -rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。<strong>当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样</strong>。不成文的规矩是——“clean从来都是放在文件的最后”。
上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>
<h3 id="2-Makefile-总述"><a href="#2-Makefile-总述" class="headerlink" title="2 Makefile 总述"></a>2 Makefile 总述</h3><h4 id="2-1-Makefile里有什么？"><a href="#2-1-Makefile里有什么？" class="headerlink" title="2.1 Makefile里有什么？"></a>2.1 Makefile里有什么？</h4><p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ol>
<li>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：<code>\#</code>。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</p>
<h4 id="2-2Makefile的文件名"><a href="#2-2Makefile的文件名" class="headerlink" title="2.2Makefile的文件名"></a>2.2Makefile的文件名</h4><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如：m<code>ake -f Make.Linux</code>或<code>make --file Make.AIX</code>。</p>
<h4 id="2-3-引用其它的Makefile"><a href="#2-3-引用其它的Makefile" class="headerlink" title="2.3 引用其它的Makefile"></a>2.3 引用其它的Makefile</h4><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include&lt;filename&gt;filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</div></pre></td></tr></table></figure></p>
<p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include foo.make *.mk $(bar)</div></pre></td></tr></table></figure></p>
<p>等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include foo.make a.mk b.mk c.mk e.mk f.mk</div></pre></td></tr></table></figure></p>
<p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<ol>
<li>如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。</li>
<li>如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</li>
</ol>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：
-include<filename>
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</filename></p>
<h4 id="2-4-环境变量-MAKEFILES"><a href="#2-4-环境变量-MAKEFILES" class="headerlink" title="2.4 环境变量 MAKEFILES"></a>2.4 环境变量 MAKEFILES</h4><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。
但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h4 id="2-5-make的工作方式"><a href="#2-5-make的工作方式" class="headerlink" title="2.5 make的工作方式"></a>2.5 make的工作方式</h4><p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>
<ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。
当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h3 id="3-Makefile书写规则"><a href="#3-Makefile书写规则" class="headerlink" title="3 Makefile书写规则"></a>3 Makefile书写规则</h3><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。
在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。
好了，还是让我们来看一看如何书写规则。</p>
<h4 id="3-1-规则举例"><a href="#3-1-规则举例" class="headerlink" title="3.1 规则举例"></a>3.1 规则举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo.o: foo.c defs.h       # foo模块</div><div class="line">          cc -c -g foo.c</div></pre></td></tr></table></figure>
<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：</p>
<ol>
<li>文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。</li>
<li>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</li>
</ol>
<h4 id="3-2-规则的语法"><a href="#3-2-规则的语法" class="headerlink" title="3.2 规则的语法"></a>3.2 规则的语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">targets : prerequisites</div><div class="line">       command</div><div class="line">       ...</div></pre></td></tr></table></figure>
<p>或是这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">targets : prerequisites ; command</div><div class="line">          command</div><div class="line">          ...</div></pre></td></tr></table></figure></p>
<p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。
command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）</p>
<p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。
如果命令太长，你可以使用反斜框<code>\</code>作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。
一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>
<h4 id="3-3-在规则中使用通配符"><a href="#3-3-在规则中使用通配符" class="headerlink" title="3.3 在规则中使用通配符"></a>3.3 在规则中使用通配符</h4><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：<code>*</code>，<code>?</code>和<code>[...]</code>。这是和Unix的B-Shell是相同的。</p>
<ol>
<li><code>~</code> :波浪号（<code>~</code>）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。
<code>*</code>:通配符代替了你一系列的文件，如<code>*.c</code>表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：<code>*</code>，那么可以用转义字符<code>\</code>，如<code>\*</code>来表示真实的<code>*</code>字符，而不是任意长度的字符串。
好吧，还是先来看几个例子吧：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">    rm -f *.o</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print: *.c</div><div class="line">    lpr -p $?</div><div class="line">    touch print</div></pre></td></tr></table></figure></p>
<p>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objects = *.o</div></pre></td></tr></table></figure></p>
<p>上面这个例子，表示了，通符同样可以用在变量中。并不是说<code>[*.o]</code>会展开，不！objects的值就是<code>*.o</code>。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objects := $(wildcard *.o)</div></pre></td></tr></table></figure></p>
<p>这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。</p>
<h4 id="3-4-文件搜寻"><a href="#3-4-文件搜寻" class="headerlink" title="3.4 文件搜寻"></a>3.4 文件搜寻</h4><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。
Makefile文件中的特殊变量<code>VPATH</code>就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VPATH = src:../headers</div></pre></td></tr></table></figure></p>
<p>上面的的定义指定两个目录，<code>src</code>和<code>../headers</code>，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）
另一个设置文件搜索路径的方法是使用make的<code>vpath</code>关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<ol>
<li><code>vpath &lt; pattern&gt; &lt; directories&gt;</code>  为符合模式&lt; pattern&gt;的文件指定搜索目录<directories>。</directories></li>
<li><code>vpath &lt; pattern&gt;</code>      清除符合模式&lt; pattern&gt;的文件的搜索目录。</li>
<li><code>vpath</code>    清除所有已被设置好了的文件搜索目录。
vapth使用方法中的&lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt; pattern&gt;指定了要搜索的文件集，而&lt; directories&gt;则指定了的文件集的搜索的目录。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vpath %.h ../headers</div></pre></td></tr></table></figure>
</li>
</ol>
<p>该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）
我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt; pattern&gt;，或是被重复了的&lt; pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vpath %.c foo</div><div class="line">vpath %   blish</div><div class="line">vpath %.c bar</div></pre></td></tr></table></figure></p>
<p>其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vpath %.c foo:bar</div><div class="line">vpath %   blish</div></pre></td></tr></table></figure></p>
<p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h4 id="3-5-伪目标"><a href="#3-5-伪目标" class="headerlink" title="3.5 伪目标"></a>3.5 伪目标</h4><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">       rm *.o temp</div></pre></td></tr></table></figure></p>
<p>正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）
因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。
当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记<code>.PHONY</code>来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.PHONY : clean</div></pre></td></tr></table></figure></p>
<p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.PHONY: clean</div><div class="line">clean:</div><div class="line">       rm *.o temp</div></pre></td></tr></table></figure></p>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">all : prog1 prog2 prog3</div><div class="line">.PHONY : all</div><div class="line"></div><div class="line">prog1 : prog1.o utils.o</div><div class="line">       cc -o prog1 prog1.o utils.o</div><div class="line"></div><div class="line">prog2 : prog2.o</div><div class="line">       cc -o prog2 prog2.o</div><div class="line"></div><div class="line">prog3 : prog3.o sort.o utils.o</div><div class="line">       cc -o prog3 prog3.o sort.o utils.o</div></pre></td></tr></table></figure></p>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。
随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.PHONY: cleanall cleanobj cleandiff</div><div class="line"></div><div class="line">cleanall : cleanobj cleandiff</div><div class="line">       rm program</div><div class="line"></div><div class="line">cleanobj :</div><div class="line">       rm *.o</div><div class="line"></div><div class="line">cleandiff :</div><div class="line">       rm *.diff</div></pre></td></tr></table></figure></p>
<p>“makeclean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的</p>
<h4 id="3-6-多目标"><a href="#3-6-多目标" class="headerlink" title="3.6 多目标"></a>3.6 多目标</h4><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bigoutput littleoutput : text.g</div><div class="line">       generate text.g -$(subst output,,$@) &gt; $@</div></pre></td></tr></table></figure></p>
<p>上述规则等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bigoutput : text.g</div><div class="line">       generate text.g -big &gt; bigoutput</div><div class="line">littleoutput : text.g</div><div class="line">       generate text.g -little &gt; littleoutput</div></pre></td></tr></table></figure></p>
<p>其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。</p>
<h4 id="3-7-静态模式"><a href="#3-7-静态模式" class="headerlink" title="3.7 静态模式"></a>3.7 静态模式</h4><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</div><div class="line">　　　&lt;commands&gt;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<ul>
<li>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</li>
<li>target-parrtern是指明了targets的模式，也就是的目标集模式。</li>
<li>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</li>
</ul>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。
所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠<code>\</code>进行转义，来标明真实的“%”字符。
看一个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">objects = foo.o bar.o</div><div class="line"></div><div class="line">all: $(objects)</div><div class="line"></div><div class="line">$(objects): %.o: %.c</div><div class="line">       $(CC) -c $(CFLAGS) $&lt; -o $@</div></pre></td></tr></table></figure></target-parrtern></target-parrtern></prereq-parrterns></target-parrtern></p>
<p>上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo.o : foo.c</div><div class="line">       $(CC) -c $(CFLAGS) foo.c -o foo.o</div><div class="line">bar.o : bar.c</div><div class="line">       $(CC) -c $(CFLAGS) bar.c -o bar.o</div></pre></td></tr></table></figure></p>
<p>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">files = foo.elc bar.o lose.o</div><div class="line"></div><div class="line">$(filter %.o,$(files)): %.o: %.c</div><div class="line">       $(CC) -c $(CFLAGS) $&lt; -o $@</div><div class="line">$(filter %.elc,$(files)): %.elc: %.el</div><div class="line">       emacs -f batch-byte-compile $&lt;</div></pre></td></tr></table></figure></p>
<p>$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>
<h4 id="3-8-自动生成依赖性"><a href="#3-8-自动生成依赖性" class="headerlink" title="3.8 自动生成依赖性"></a>3.8 自动生成依赖性</h4><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include “defs.h””，那么我们的依赖关系应该是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o : main.c defs.h</div></pre></td></tr></table></figure></p>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc -M main.c</div></pre></td></tr></table></figure></p>
<p>其输出是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o : main.c defs.h</div></pre></td></tr></table></figure></p>
<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用<code>-MM</code>参数，不然，<code>-M</code>参数会把一些标准库的头文件也包含进来。
<code>gcc-M main.c</code>的输出是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \</div><div class="line">    /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \</div><div class="line">    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \</div><div class="line">    /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \</div><div class="line">    /usr/include/bits/sched.h /usr/include/libio.h \</div><div class="line">    /usr/include/_G_config.h /usr/include/wchar.h \</div><div class="line">    /usr/include/bits/wchar.h /usr/include/gconv.h \</div><div class="line">    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \</div><div class="line">    /usr/include/bits/stdio_lim.h</div></pre></td></tr></table></figure></p>
<p><code>gcc-MM main.c</code>的输出则是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o: main.c defs.h</div></pre></td></tr></table></figure></p>
<p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。
于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。
这里，我们给出了一个模式规则来产生[.d]文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">%.d: %.c</div><div class="line">       @set -e; rm -f $@; \</div><div class="line">        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.</div><div class="line">; \</div><div class="line">        sed &apos;s,$∗\.o[ :]*,\1.o $@ : ,g&apos; &lt; $@.</div><div class="line">&gt; $@; \</div><div class="line">        rm -f $@.</div></pre></td></tr></table></figure></p>
<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，<code>rm-f $@</code>的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x201d;&#65292;&#x4e5f;&#x5c31;&#x662f;&#91;&#x2e;&#99;&#x5d;&#x6587;&#20214;&#x751f;&#x6210;&#x4f9d;&#x8d56;&#x6587;&#x4ef6;&#xff0c;&#8220;&#x24;&#64;&#x201d;&#x8868;&#x793a;&#x6a21;&#x5f0f;&#8220;&#37;&#x2e;&#x64;&#x201d;&#x6587;&#x4ef6;&#65292;&#22914;&#26524;&#x6709;&#19968;&#x4e2a;&#x43;&#25991;&#x4ef6;&#26159;&#x6e;&#97;&#109;&#x65;&#46;&#99;&#65292;&#37027;&#20040;&#8220;&#37;&#x201d;&#x5c31;&#x662f;&#8220;&#x6e;&#x61;&#x6d;&#x65;&#x201d;&#xff0c;&#x201c;&#10;&#8221;&#x610f;&#20026;&#x4e00;&#20010;&#38543;&#26426;&#32534;&#21495;&#xff0c;&#31532;&#x4e8c;&#x884c;&#x751f;&#25104;&#x7684;&#25991;&#x4ef6;&#26377;&#21487;&#x80fd;&#26159;&#x201c;&#x6e;&#97;&#x6d;&#101;&#46;&#x64;&#x2e;&#x31;&#x32;&#51;&#x34;&#53;&#8221;&#65292;&#x7b2c;&#x4e09;&#34892;&#x4f7f;&#x7528;&#x73;&#101;&#x64;&#x547d;&#x4ee4;&#x505a;&#x4e86;&#19968;&#20010;&#26367;&#x6362;&#xff0c;&#x5173;&#x4e8e;&#115;&#101;&#100;&#21629;&#20196;&#x7684;&#x7528;&#x6cd5;&#35831;&#x53c2;&#30475;&#x76f8;&#x5173;&#x7684;&#20351;&#29992;&#25991;&#26723;&#x3002;&#x7b2c;&#22235;&#34892;&#23601;&#26159;&#21024;&#x9664;&#x4e34;&#x65f6;&#x6587;&#x4ef6;&#12290;&#10;&#24635;&#32780;&#x8a00;&#20043;&#xff0c;&#36825;&#20010;&#27169;&#x5f0f;&#35201;&#x505a;&#30340;&#x4e8b;&#x5c31;&#26159;&#x5728;&#x7f16;&#35793;&#x5668;&#29983;&#25104;&#30340;&#20381;&#36182;&#x5173;&#x7cfb;&#20013;&#x52a0;&#20837;&#91;&#46;&#100;&#x5d;&#25991;&#x4ef6;&#x7684;&#20381;&#x8d56;&#65292;&#x5373;&#25226;&#20381;&#x8d56;&#20851;&#x7cfb;&#xff1a;&#xa;&#60;&#33;&#45;&#x2d;&#xfffc;&#x34;&#x30;&#45;&#45;">&#x201d;&#65292;&#x4e5f;&#x5c31;&#x662f;&#91;&#x2e;&#99;&#x5d;&#x6587;&#20214;&#x751f;&#x6210;&#x4f9d;&#x8d56;&#x6587;&#x4ef6;&#xff0c;&#8220;&#x24;&#64;&#x201d;&#x8868;&#x793a;&#x6a21;&#x5f0f;&#8220;&#37;&#x2e;&#x64;&#x201d;&#x6587;&#x4ef6;&#65292;&#22914;&#26524;&#x6709;&#19968;&#x4e2a;&#x43;&#25991;&#x4ef6;&#26159;&#x6e;&#97;&#109;&#x65;&#46;&#99;&#65292;&#37027;&#20040;&#8220;&#37;&#x201d;&#x5c31;&#x662f;&#8220;&#x6e;&#x61;&#x6d;&#x65;&#x201d;&#xff0c;&#x201c;&#10;&#8221;&#x610f;&#20026;&#x4e00;&#20010;&#38543;&#26426;&#32534;&#21495;&#xff0c;&#31532;&#x4e8c;&#x884c;&#x751f;&#25104;&#x7684;&#25991;&#x4ef6;&#26377;&#21487;&#x80fd;&#26159;&#x201c;&#x6e;&#97;&#x6d;&#101;&#46;&#x64;&#x2e;&#x31;&#x32;&#51;&#x34;&#53;&#8221;&#65292;&#x7b2c;&#x4e09;&#34892;&#x4f7f;&#x7528;&#x73;&#101;&#x64;&#x547d;&#x4ee4;&#x505a;&#x4e86;&#19968;&#20010;&#26367;&#x6362;&#xff0c;&#x5173;&#x4e8e;&#115;&#101;&#100;&#21629;&#20196;&#x7684;&#x7528;&#x6cd5;&#35831;&#x53c2;&#30475;&#x76f8;&#x5173;&#x7684;&#20351;&#29992;&#25991;&#26723;&#x3002;&#x7b2c;&#22235;&#34892;&#23601;&#26159;&#21024;&#x9664;&#x4e34;&#x65f6;&#x6587;&#x4ef6;&#12290;&#10;&#24635;&#32780;&#x8a00;&#20043;&#xff0c;&#36825;&#20010;&#27169;&#x5f0f;&#35201;&#x505a;&#30340;&#x4e8b;&#x5c31;&#26159;&#x5728;&#x7f16;&#35793;&#x5668;&#29983;&#25104;&#30340;&#20381;&#36182;&#x5173;&#x7cfb;&#20013;&#x52a0;&#20837;&#91;&#46;&#100;&#x5d;&#25991;&#x4ef6;&#x7684;&#20381;&#x8d56;&#65292;&#x5373;&#25226;&#20381;&#x8d56;&#20851;&#x7cfb;&#xff1a;&#xa;&#60;&#33;&#45;&#x2d;&#xfffc;&#x34;&#x30;&#45;&#45;</a></p>
<p>转成：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o main.d : main.c defs.h</div></pre></td></tr></table></figure></p>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sources = foo.c bar.c</div><div class="line"></div><div class="line">include $(sources:.c=.d)</div></pre></td></tr></table></figure></p>
<p>上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标</p>
<h3 id="4-Makefile-书写命令"><a href="#4-Makefile-书写命令" class="headerlink" title="4 Makefile 书写命令"></a>4 Makefile 书写命令</h3><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。
我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。</p>
<h4 id="4-1-显示命令"><a href="#4-1-显示命令" class="headerlink" title="4.1 显示命令"></a>4.1 显示命令</h4><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@echo 正在编译XXX模块......</div></pre></td></tr></table></figure></p>
<p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo 正在编译XXX模块......</div><div class="line">正在编译XXX模块......</div></pre></td></tr></table></figure></p>
<p>如果make执行时，带入make参数<code>-n</code>或<code>--just-print</code>，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。
而make参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示。</p>
<h4 id="4-2-命令执行"><a href="#4-2-命令执行" class="headerlink" title="4.2 命令执行"></a>4.2 命令执行</h4><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：
 示例一：
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exec:</div><div class="line">       cd /home/hchen</div><div class="line">       pwd</div></pre></td></tr></table></figure></p>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exec:</div><div class="line">       cd /home/hchen; pwd</div></pre></td></tr></table></figure></p>
<p>当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>
<h4 id="4-3-命令出错"><a href="#4-3-命令出错" class="headerlink" title="4.3 命令出错"></a>4.3 命令出错</h4><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。
有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。
为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">         -rm -f *.o</div></pre></td></tr></table></figure></p>
<p>还有一个全局的办法是，给make加上<code>-i</code>或是<code>--ignore-errors</code>参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。
还有一个要提一下的make的参数的是<code>-k</code>或是<code>--keep-going</code>，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h4 id="4-4-嵌套执行make"><a href="#4-4-嵌套执行make" class="headerlink" title="4.4 嵌套执行make"></a>4.4 嵌套执行make</h4><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subsystem:</div><div class="line">         cd subdir &amp;&amp; $(MAKE)</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subsystem:</div><div class="line">       $(MAKE) -C subdir</div></pre></td></tr></table></figure></p>
<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。
我们把这个Makefile叫做 <strong>总控Makefile</strong>，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。
如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export&lt;variable ...&gt;</div></pre></td></tr></table></figure></p>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unexport&lt;variable ...&gt;</div></pre></td></tr></table></figure></p>
<p>如：
示例一：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export variable = value</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable = value</div><div class="line">export variable</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export variable := value</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable := value</div><div class="line">export variable</div></pre></td></tr></table></figure></p>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export variable += value</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable += value</div><div class="line">export variable</div></pre></td></tr></table></figure></p>
<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。
需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。
但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subsystem:</div><div class="line">       cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=</div></pre></td></tr></table></figure></p>
<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。
还有一个在“嵌套执行”中比较有用的参数，“-w”或是“–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make: Entering directory `/home/hchen/gnu/make&apos;.</div></pre></td></tr></table></figure></p>
<p>而在完成下层make后离开目录时，我们会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make: Leaving directory `/home/hchen/gnu/make&apos;</div></pre></td></tr></table></figure></p>
<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“–slient”）或是“–no-print-directory”，那么，“-w”总是失效的。</p>
<h4 id="4-5-定义命令包"><a href="#4-5-定义命令包" class="headerlink" title="4.5 定义命令包"></a>4.5 定义命令包</h4><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define run-yacc</div><div class="line">yacc $(firstword $^)</div><div class="line">mv y.tab.c $@</div><div class="line">endef</div></pre></td></tr></table></figure></p>
<p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo.c : foo.y</div><div class="line">       $(run-yacc)</div></pre></td></tr></table></figure></p>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h3 id="5-使用变量"><a href="#5-使用变量" class="headerlink" title="5.使用变量"></a>5.使用变量</h3><p>在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。</p>
<h4 id="5-1变量的基础"><a href="#5-1变量的基础" class="headerlink" title="5.1变量的基础"></a>5.1变量的基础</h4><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用<code>$$</code>来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。</p>
<p>先看一个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">objects = program.o foo.o utils.o</div><div class="line">program : $(objects)</div><div class="line">cc -o program $(objects)</div><div class="line"></div><div class="line">$(objects) : defs.h</div></pre></td></tr></table></figure></p>
<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo = c</div><div class="line">prog.o : prog.$(foo)</div><div class="line">$(foo)$(foo) -$(foo) prog.$(foo)</div></pre></td></tr></table></figure></p>
<p>展开后得到：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">prog.o : prog.c</div><div class="line">cc -c prog.c</div></pre></td></tr></table></figure></p>
<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h4 id="5-2变量中的变量"><a href="#5-2变量中的变量" class="headerlink" title="5.2变量中的变量"></a>5.2变量中的变量</h4><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好
的值，其也可以使用后面定义的值。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo = $(bar)</div><div class="line">bar = $(ugh)</div><div class="line">ugh = Huh?</div><div class="line"></div><div class="line"></div><div class="line">all:</div><div class="line">echo $(foo)</div></pre></td></tr></table></figure></p>
<p>我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。
这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFLAGS = $(include_dirs) -O</div><div class="line">include_dirs = -Ifoo -Ibar</div></pre></td></tr></table></figure></p>
<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方
，那就是递归定义，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFLAGS = $(CFLAGS) -O</div></pre></td></tr></table></figure></p>
<p>或：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A = $(B)</div><div class="line">B = $(A)</div></pre></td></tr></table></figure></p>
<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x := foo</div><div class="line">y := $(x) bar</div><div class="line">x := later</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y := foo bar</div><div class="line">x := later</div></pre></td></tr></table></figure></p>
<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y := $(x) bar</div><div class="line">x := foo</div></pre></td></tr></table></figure></p>
<p>那么，y的值是“bar”，而不是“foo bar”。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ifeq (0,$&#123;MAKELEVEL&#125;)</div><div class="line">cur-dir := $(shell pwd)</div><div class="line">whoami := $(shell whoami)</div><div class="line">host-type := $(shell arch)</div><div class="line">MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nullstring :=</div><div class="line">space := $(nullstring) # end of the line</div></pre></td></tr></table></figure></p>
<p>nullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir := /foo/bar # directory to put the frobs in</div></pre></td></tr></table></figure></p>
<p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是“?=”，先看示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FOO ?= bar</div></pre></td></tr></table></figure></p>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifeq ($(origin FOO), undefined)</div><div class="line">FOO = bar</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<h4 id="5-3变量高级用法"><a href="#5-3变量高级用法" class="headerlink" title="5.3变量高级用法"></a>5.3变量高级用法</h4><p>这里介绍两种变量的高级使用方法</p>
<p>第一种是变量值的替换。</p>
<p>我们可以替换变量中的共有的部分，其格式是<code>$(var:a=b)</code>或是<code>${var:a=b}</code>，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p>
<p>还是看一个示例吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo := a.o b.o c.o</div><div class="line">bar := $(foo:.o=.c)</div></pre></td></tr></table></figure>
<p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。</p>
<p>另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo := a.o b.o c.o</div><div class="line">bar := $(foo:%.o=%.c)</div></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = y</div><div class="line">y = z</div><div class="line">a := $($(x))</div></pre></td></tr></table></figure>
<p>在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）</p>
<p>我们还可以使用更多的层次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = y</div><div class="line">y = z</div><div class="line">z = u</div><div class="line">a := $($($(x)))</div></pre></td></tr></table></figure>
<p>这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。</p>
<p>让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = $(y)</div><div class="line">y = z</div><div class="line">z = Hello</div><div class="line">a := $($(x))</div></pre></td></tr></table></figure>
<p>这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。</p>
<p>再复杂一点，我们再加上函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = variable1</div><div class="line">variable2 := Hello</div><div class="line">y = $(subst 1,2,$(x))</div><div class="line">z = y</div><div class="line">a := $($($(z)))</div></pre></td></tr></table></figure>
<p>这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">first_second = Hello</div><div class="line">a = first</div><div class="line">b = second</div><div class="line">all = $($a_$b)</div></pre></td></tr></table></figure></p>
<p>这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。</p>
<p>再来看看结合第一种技术的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a_objects := a.o b.o c.o</div><div class="line">1_objects := 1.o 2.o 3.o</div><div class="line"></div><div class="line">sources := $($(a1)_objects:.o=.c)</div></pre></td></tr></table></figure>
<p>这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。</p>
<p>再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ifdef do_sort</div><div class="line">func := sort</div><div class="line">else</div><div class="line">func := strip</div><div class="line">endif</div><div class="line"></div><div class="line">bar := a d b g q c</div><div class="line"></div><div class="line">foo := $($(func) $(bar))</div></pre></td></tr></table></figure>
<p>这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d bg q c)，调用的就是strip函数。</p>
<p>当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dir = foo</div><div class="line">$(dir)_sources := $(wildcard $(dir)/*.c)</div><div class="line">define $(dir)_print</div><div class="line">lpr $($(dir)_sources)</div><div class="line">endef</div></pre></td></tr></table></figure></p>
<p>这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</p>
<h4 id="5-4追加变量值"><a href="#5-4追加变量值" class="headerlink" title="5.4追加变量值"></a>5.4追加变量值</h4><p>我们可以使用“+=”操作符给变量追加值，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects = main.o foo.o bar.o utils.o</div><div class="line">objects += another.o</div></pre></td></tr></table></figure></p>
<p>于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p>
<p>使用“+=”操作符，可以模拟为下面的这种例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects = main.o foo.o bar.o utils.o</div><div class="line">objects := $(objects) another.o</div></pre></td></tr></table></figure>
<p>所不同的是，用“+=”更为简洁。</p>
<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable := value</div><div class="line">variable += more</div></pre></td></tr></table></figure></p>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable := value</div><div class="line">variable := $(variable) more</div></pre></td></tr></table></figure>
<p>但如果是这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable = value</div><div class="line">variable += more</div></pre></td></tr></table></figure>
<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h4 id="5-5override-指示符"><a href="#5-5override-指示符" class="headerlink" title="5.5override 指示符"></a>5.5override 指示符</h4><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">override &lt;variable&gt; = &lt;value&gt;</div><div class="line">override &lt;variable&gt; := &lt;value&gt;</div></pre></td></tr></table></figure></p>
<p>当然，你还可以追加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">override &lt;variable&gt; += &lt;more text&gt;</div></pre></td></tr></table></figure>
<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override define foo</div><div class="line">bar</div><div class="line">endef</div></pre></td></tr></table></figure>
<h4 id="5-6多行变量"><a href="#5-6多行变量" class="headerlink" title="5.6多行变量"></a>5.6多行变量</h4><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>
<p>define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define two-lines</div><div class="line">echo foo</div><div class="line">echo $(bar)</div><div class="line">endef</div></pre></td></tr></table></figure>
<h4 id="5-7环境变量"><a href="#5-7环境变量" class="headerlink" title="5.7环境变量"></a>5.7环境变量</h4><p>make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。     当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h4 id="5-8目标变量"><a href="#5-8目标变量" class="headerlink" title="5.8目标变量"></a>5.8目标变量</h4><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;</div><div class="line"></div><div class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure></p>
<p><variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</variable-assignment></p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">prog : CFLAGS = -g</div><div class="line">prog : prog.o foo.o bar.o</div><div class="line">$(CC) $(CFLAGS) prog.o foo.o bar.o</div><div class="line"></div><div class="line"></div><div class="line">prog.o : prog.c</div><div class="line">$(CC) $(CFLAGS) prog.c</div><div class="line"></div><div class="line"></div><div class="line">foo.o : foo.c</div><div class="line">$(CC) $(CFLAGS) foo.c</div><div class="line"></div><div class="line"></div><div class="line">bar.o : bar.c</div><div class="line">$(CC) $(CFLAGS) bar.c</div></pre></td></tr></table></figure></p>
<p>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”</p>
<h4 id="5-9模式变量"><a href="#5-9模式变量" class="headerlink" title="5.9模式变量"></a>5.9模式变量</h4><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.o : CFLAGS = -O</div></pre></td></tr></table></figure>
<p>同样，模式变量的语法和“目标变量”一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;pattern ...&gt; : &lt;variable-assignment&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;pattern ...&gt; : override &lt;variable-assignment&gt;</div></pre></td></tr></table></figure>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h3 id="6-使用条件判断"><a href="#6-使用条件判断" class="headerlink" title="6. 使用条件判断"></a>6. 使用条件判断</h3><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h4 id="6-1-示例"><a href="#6-1-示例" class="headerlink" title="6.1 示例"></a>6.1 示例</h4><p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">libs_for_gcc = -lgnu</div><div class="line">normal_libs =</div><div class="line"></div><div class="line"></div><div class="line">foo: $(objects)</div><div class="line">ifeq ($(CC),gcc)</div><div class="line">$(CC) -o foo $(objects) $(libs_for_gcc)</div><div class="line">else</div><div class="line">$(CC) -o foo $(objects) $(normal_libs)</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>
<p>当我们的变量$(CC)值是“gcc”时，目标foo的规则是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo: $(objects)</div><div class="line">$(CC) -o foo $(objects) $(libs_for_gcc)</div></pre></td></tr></table></figure>
<p>而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo: $(objects)</div><div class="line">$(CC) -o foo $(objects) $(normal_libs)</div></pre></td></tr></table></figure></p>
<p>当然，我们还可以把上面的那个例子写得更简洁一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">libs_for_gcc = -lgnu</div><div class="line">normal_libs =</div><div class="line"></div><div class="line"></div><div class="line">ifeq ($(CC),gcc)</div><div class="line">libs=$(libs_for_gcc)</div><div class="line">else</div><div class="line">libs=$(normal_libs)</div><div class="line">endif</div><div class="line"></div><div class="line"></div><div class="line">foo: $(objects)</div><div class="line">$(CC) -o foo $(objects) $(libs)</div></pre></td></tr></table></figure>
<h4 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h4><p>条件表达式的语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;conditional-directive&gt;</div><div class="line">&lt;text-if-true&gt;</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;conditional-directive&gt;</div><div class="line">&lt;text-if-true&gt;</div><div class="line">else</div><div class="line">&lt;text-if-false&gt;</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。</conditional-directive></p>
<p>第一个是我们前面所见过的“ifeq”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifeq (&lt;arg1&gt;, &lt;arg2&gt; )</div><div class="line">ifeq &apos;&lt;arg1&gt;&apos; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;</div><div class="line">ifeq &quot;&lt;arg1&gt;&quot; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifeq &apos;&lt;arg1&gt;&apos; &quot;&lt;arg2&gt;&quot;</div></pre></td></tr></table></figure>
<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifeq ($(strip $(foo)),)</div><div class="line">&lt;text-if-empty&gt;</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。</text-if-empty></p>
<p>第二个条件关键字是“ifneq”。语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifneq (&lt;arg1&gt;, &lt;arg2&gt; )</div><div class="line">ifneq &apos;&lt;arg1&gt;&apos; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;</div><div class="line">ifneq &quot;&lt;arg1&gt;&quot; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifneq &apos;&lt;arg1&gt;&apos; &quot;&lt;arg2&gt;&quot;</div></pre></td></tr></table></figure>
<p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p>
<p>第三个条件关键字是“ifdef”。语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifdef &lt;variable-name&gt;</div></pre></td></tr></table></figure>
<p>如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</variable-name></variable-name></p>
<p>示例一：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bar =</div><div class="line">foo = $(bar)</div><div class="line">ifdef foo</div><div class="line">frobozz = yes</div><div class="line">else</div><div class="line">frobozz = no</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo =</div><div class="line">ifdef foo</div><div class="line">frobozz = yes</div><div class="line">else</div><div class="line">frobozz = no</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。</p>
<p>第四个条件关键字是“ifndef”。其语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifndef &lt;variable-name&gt;</div></pre></td></tr></table></figure>
<p>这个我就不多说了，和“ifdef”是相反的意思。</p>
<p>在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也
一样，只要不是以[Tab]键开始就行了。</conditional-directive></p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h3 id="7-使用函数"><a href="#7-使用函数" class="headerlink" title="7. 使用函数"></a>7. 使用函数</h3><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h4 id="7-1函数的调用语法"><a href="#7-1函数的调用语法" class="headerlink" title="7.1函数的调用语法"></a>7.1函数的调用语法</h4><p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&lt;function&gt; &lt;arguments&gt; )</div></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</div></pre></td></tr></table></figure>
<p>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</arguments></function></p>
<p>还是来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">comma:= ,</div><div class="line">empty:=</div><div class="line">space:= $(empty) $(empty)</div><div class="line">foo:= a b c</div><div class="line">bar:= $(subst $(space),$(comma),$(foo))</div></pre></td></tr></table></figure>
<p>在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“
a,b,c”。</p>
<h4 id="7-2-字符串处理函数"><a href="#7-2-字符串处理函数" class="headerlink" title="7.2 字符串处理函数"></a>7.2 字符串处理函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：字符串替换函数——subst。
功能：把字串<text>中的<from>字符串替换成<to>。
返回：函数返回被替换过后的字符串。</to></from></text></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(subst ee,EE,feet on the street)，</div></pre></td></tr></table></figure>
<p>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt
”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：模式字符串替换函数——patsubst。
功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。</pattern></replacement></replacement></pattern></replacement></pattern></text></p>
<p>示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(patsubst %.c,%.o,x.c.c bar.c)</div></pre></td></tr></table></figure></p>
<p>把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</p>
<p>备注：</p>
<p>这和我们前面“变量章节”说过的相关知识有点相似。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">“$(var:&lt;pattern&gt;=&lt;replacement&gt; )”</div></pre></td></tr></table></figure>
<p>相当于
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">“$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))”，</div></pre></td></tr></table></figure></p>
<p>而“$(var: <suffix>=<replacement> )”
则相当于
“$(patsubst %<suffix>,%<replacement>,$(var))”。</replacement></suffix></replacement></suffix></p>
<p>例如有：objects = foo.o bar.o baz.o，
那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(strip &lt;string&gt; )</div></pre></td></tr></table></figure>
<p>名称：去空格函数——strip。
功能：去掉<string>字串中开头和结尾的空字符。
返回：返回被去掉空格的字符串值。
示例：</string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(strip a b c )</div></pre></td></tr></table></figure>
<p>把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(findstring &lt;find&gt;,&lt;in&gt; )</div></pre></td></tr></table></figure>
<p>名称：查找字符串函数——findstring。
功能：在字串<in>中查找<find>字串。
返回：如果找到，那么返回<find>，否则返回空字符串。
示例：</find></find></in></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(findstring a,a b c)</div><div class="line">$(findstring a,b c)</div></pre></td></tr></table></figure>
<p>第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(filter &lt;pattern...&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：过滤函数——filter。
功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可
以有多个模式。
返回：返回符合模式<pattern>的字串。
示例：</pattern></pattern></text></pattern></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sources := foo.c bar.c baz.s ugh.h</div><div class="line">foo: $(sources)</div><div class="line">cc $(filter %.c %.s,$(sources)) -o foo</div></pre></td></tr></table></figure>
<p>$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(filter-out &lt;pattern...&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：反过滤函数——filter-out。
功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可
以有多个模式。
返回：返回不符合模式<pattern>的字串。
示例：</pattern></pattern></text></pattern></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects=main1.o foo.o main2.o bar.o</div><div class="line">mains=main1.o main2.o</div></pre></td></tr></table></figure>
<p>$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(sort &lt;list&gt; )</div></pre></td></tr></table></figure>
<p>名称：排序函数——sort。
功能：给字符串<list>中的单词排序（升序）。
返回：返回排序后的字符串。
示例：$(sort foo bar lose)返回“bar foo lose” 。
备注：sort函数会去掉<list>中相同的单词。</list></list></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(word &lt;n&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：取单词函数——word。
功能：取字符串<text>中第<n>个单词。（从一开始）
返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空
字符串。
示例：$(word 2, foo bar baz)返回值是“bar”。</text></n></n></text></n></text></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：取单词串函数——wordlist。
功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。
返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那
么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单
词串。
示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</text></s></text></e></text></s></e></s></text></e></s></e></s></text></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(words &lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：单词个数统计函数——words。
功能：统计<text>中字符串中的单词个数。
返回：返回<text>中的单词数。
示例：$(words, foo bar baz)返回值是“3”。
备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text>
),<text> )。</text></text></text></text></text></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(firstword &lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：首单词函数——firstword。
功能：取字符串<text>中的第一个单词。
返回：返回字符串<text>的第一个单词。
示例：$(firstword foo bar)返回值是“foo”。
备注：这个函数可以用word函数来实现：$(word 1,<text> )。</text></text></text></p>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，
举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索
路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，
如：</p>
<p>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))</p>
<p>如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :
, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数</p>
<h4 id="7-3文件名操作函数"><a href="#7-3文件名操作函数" class="headerlink" title="7.3文件名操作函数"></a>7.3文件名操作函数</h4><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是
一系列的文件名来对待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(dir &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取目录函数——dir。
功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之
前的部分。如果没有反斜杠，那么返回“./”。
返回：返回文件名序列<names>的目录部分。
示例： $(dir src/foo.c hacks)返回值是“src/ ./”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(notdir &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取文件函数——notdir。
功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”
）之后的部分。
返回：返回文件名序列<names>的非目录部分。
示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(suffix &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取后缀函数——suffix。
功能：从文件名序列<names>中取出各个文件名的后缀。
返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。
示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(basename &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取前缀函数——basename。
功能：从文件名序列<names>中取出各个文件名的前缀部分。
返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。
示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar h
acks”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：加后缀函数——addsuffix。
功能：把后缀<suffix>加到<names>中的每个单词后面。
返回：返回加过后缀的文件名序列。
示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(addprefix &lt;prefix&gt;,&lt;names...&gt; )</div></pre></td></tr></table></figure></names></suffix></p>
<p>名称：加前缀函数——addprefix。
功能：把前缀<prefix>加到<names>中的每个单词后面。
返回：返回加过前缀的文件名序列。
示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。</names></prefix></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(join &lt;list1&gt;,&lt;list2&gt; )</div></pre></td></tr></table></figure>
<p>名称：连接函数——join。
功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比&lt;
list2&gt;的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比</list2></list1></list1></list1></list2></p>
<p><list1>多，那么，<list2>多出来的单词将被复制到<list2>中。
返回：返回连接过后的字符串。
示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</list2></list2></list1></p>
<h4 id="7-4-foreach-函数"><a href="#7-4-foreach-函数" class="headerlink" title="7.4 foreach 函数"></a>7.4 foreach 函数</h4><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的
foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin
/csh）中的foreach语句而构建的。它的语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure></p>
<p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</text></text></text></text></var></list></p>
<p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>
这个参数来依次枚举<list>中的单词。举个例子：</list></var></text></list></var></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">names := a b c d</div><div class="line"></div><div class="line"></div><div class="line">files := $(foreach n,$(names),$(n).o)</div></pre></td></tr></table></figure>
<p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(f
iles)的值是“a.o b.o c.o d.o”。</p>
<p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</var></var></p>
<h4 id="7-5-if-函数"><a href="#7-5-if-函数" class="headerlink" title="7.5 if 函数"></a>7.5 if 函数</h4><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(if &lt;condition&gt;,&lt;then-part&gt; )</div></pre></td></tr></table></figure>
<p>或是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; )</div></pre></td></tr></table></figure></p>
<p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。</else-part></then-part></condition></p>
<p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part="">会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</else-part></else-part></condition></then-></condition></p>
<p>所以，<then-part>和<else-part>只会有一个被计算。</else-part></then-part></p>
<h4 id="7-6-call函数"><a href="#7-6-call函数" class="headerlink" title="7.6 call函数"></a>7.6 call函数</h4><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</div></pre></td></tr></table></figure>
<p>当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reverse = $(1) $(2)</div><div class="line"></div><div class="line">foo = $(call reverse,a,b)</div></pre></td></tr></table></figure></expression></parm3></parm2></parm1></expression></p>
<p>那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">reverse = $(2) $(1)</div><div class="line">foo = $(call reverse,a,b)</div></pre></td></tr></table></figure></p>
<p>此时的foo的值就是“b a”。</p>
<h4 id="7-7origin函数"><a href="#7-7origin函数" class="headerlink" title="7.7origin函数"></a>7.7origin函数</h4><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(origin &lt;variable&gt; )</div></pre></td></tr></table></figure></p>
<p>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函
数的返回值:</variable></variable></p>
<p>“undefined”</p>
<p>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</variable></p>
<p>“default”</p>
<p>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</variable></p>
<p>“environment”</p>
<p>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</variable></p>
<p>“file”</p>
<p>如果<variable>这个变量被定义在Makefile中。</variable></p>
<p>“command line”</p>
<p>如果<variable>这个变量是被命令行定义的。</variable></p>
<p>“override”</p>
<p>如果<variable>是被override指示符重新定义的。</variable></p>
<p>“automatic”</p>
<p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</variable></p>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一
个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是
，在我们的Makefile中，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ifdef bletch</div><div class="line"></div><div class="line"></div><div class="line">ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;</div><div class="line"></div><div class="line"></div><div class="line">bletch = barf, gag, etc.</div><div class="line"></div><div class="line">endif</div><div class="line"></div><div class="line">endif</div></pre></td></tr></table></figure>
<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗
暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h4 id="7-8-shell函数"><a href="#7-8-shell函数" class="headerlink" title="7.8 shell函数"></a>7.8 shell函数</h4><p>shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号 是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数
返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">contents := $(shell cat foo)</div><div class="line">files := $(shell echo *.c)</div></pre></td></tr></table></figure>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h4 id="7-9-控制make的函数"><a href="#7-9-控制make的函数" class="headerlink" title="7.9 控制make的函数"></a>7.9 控制make的函数</h4><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(error &lt;text ...&gt; )</div></pre></td></tr></table></figure>
<p>产生一个致命的错误，<text ...="">是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也
是可以的。例如：</text></p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifdef ERROR_001</div><div class="line">$(error error is $(ERROR_001))</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERR = $(error found an error!)</div><div class="line">.PHONY: err</div><div class="line">err: ; $(ERR)</div></pre></td></tr></table></figure></p>
<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(warning &lt;text ...&gt; )</div></pre></td></tr></table></figure></p>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h3 id="8-make-的运行"><a href="#8-make-的运行" class="headerlink" title="8. make 的运行"></a>8. make 的运行</h3><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h4 id="8-1-make的退出码"><a href="#8-1-make的退出码" class="headerlink" title="8.1 make的退出码"></a>8.1 make的退出码</h4><p>make命令执行后有三个退出码：</p>
<ul>
<li>0 —— 表示成功执行。</li>
<li>1 —— 如果make运行时出现任何错误，其返回1。</li>
<li>2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li>
</ul>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h4 id="8-2-指定Makefile"><a href="#8-2-指定Makefile" class="headerlink" title="8.2 指定Makefile"></a>8.2 指定Makefile</h4><p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就
开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“– makefile”参数也行）。例如，我们有个mak
efile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make –f hchen.mk</div></pre></td></tr></table></figure></p>
<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h3 id="8-3-指定目标"><a href="#8-3-指定目标" class="headerlink" title="8.3 指定目标"></a>8.3 指定目标</h3><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sources = foo.c bar.c</div><div class="line">ifneq ( $(MAKECMDGOALS),clean)</div><div class="line">include $(sources:.c=.d)</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.PHONY: all</div><div class="line">all: prog1 prog2 prog3 prog4</div></pre></td></tr></table></figure>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标
（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。</p>
<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件
发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<ul>
<li>“all”              这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li>“clean”       这个伪目标功能是删除所有被make创建的文件。</li>
<li>“install”       这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li>“print”         这个伪目标的功能是例出改变过的源文件。</li>
<li>“tar”             这个伪目标功能是把源程序打包备份。也就是一个tar文件。</li>
<li>“dist”           这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</li>
<li>“TAGS”        这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li>“check”和“test”    这两个伪目标一般用来测试makefile的流程。</li>
</ul>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h4 id="8-4-检查规则"><a href="#8-4-检查规则" class="headerlink" title="8.4 检查规则"></a>8.4 检查规则</h4><p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<ul>
<li>“-n”</li>
<li>“–just-print”</li>
<li>“–dry-run”</li>
<li><p>“–recon”
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
</li>
<li><p>“-t”</p>
</li>
<li><p>“–touch”
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
</li>
<li><p>“-q”</p>
</li>
<li>“–question”
这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</li>
</ul>
<ul>
<li>“-W <file>”</file></li>
<li>“–what-if=<file>”</file></li>
<li>“–assume-new=<file>”</file></li>
<li>“–new-file=<file>”
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件
所发生的规则命令。</file></li>
</ul>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h4 id="8-5-make的参数"><a href="#8-5-make的参数" class="headerlink" title="8.5 make的参数"></a>8.5 make的参数</h4><p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<ul>
<li>“-b”</li>
<li>“-m”
这两个参数的作用是忽略和其它版本make的兼容性。</li>
</ul>
<ul>
<li>“-B”</li>
<li>“–always-make”
认为所有的目标都需要更新（重编译）。</li>
</ul>
<ul>
<li>“-C <dir>”</dir></li>
<li>“–directory=<dir>”
指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”
等价于“make –C ~hchen/test/prog”。</dir></li>
</ul>
<ul>
<li>“—debug[=<options>]”
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：
a —— 也就是all，输出所有的调试信息。（会非常的多）
b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。
v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。
i —— 也就是implicit，输出所以的隐含规则。
j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。
m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</options></options></li>
</ul>
<ul>
<li>“-d”
相当于“–debug=a”。</li>
</ul>
<ul>
<li>“-e”</li>
<li>“–environment-overrides”
指明环境变量的值覆盖makefile中定义的变量的值。</li>
</ul>
<ul>
<li>“-f=<file>”</file></li>
<li>“–file=<file>”</file></li>
<li>“–makefile=<file>”
指定需要执行的makefile。</file></li>
</ul>
<ul>
<li>“-h”</li>
<li>“–help”
显示帮助信息。</li>
</ul>
<ul>
<li>“-i”</li>
<li>“–ignore-errors”
在执行时忽略所有的错误。</li>
</ul>
<ul>
<li>“-I <dir>”</dir></li>
<li>“–include-dir=<dir>”
指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</dir></li>
</ul>
<ul>
<li>“-j [<jobsnum>]”</jobsnum></li>
<li>“–jobs[=<jobsnum>]”
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-D
OS中是无用的）</jobsnum></li>
</ul>
<ul>
<li>“-k”</li>
<li>“–keep-going”
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</li>
</ul>
<ul>
<li>“-l <load>”</load></li>
<li>“–load-average[=&lt;load]”</li>
<li>“—max-load[=<load>]”
指定make运行命令的负载。</load></li>
</ul>
<ul>
<li>“-n”</li>
<li>“–just-print”</li>
<li>“–dry-run”</li>
<li>“–recon”
仅输出执行过程中的命令序列，但并不执行。</li>
</ul>
<ul>
<li>“-o <file>”</file></li>
<li>“–old-file=<file>”</file></li>
<li>“–assume-old=<file>”
不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</file></file></li>
</ul>
<ul>
<li>“-p”</li>
<li><p>“–print-data-base”
输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -q
p”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用
这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
</li>
<li><p>“-q”</p>
</li>
<li>“–question”
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</li>
</ul>
<ul>
<li>“-r”</li>
<li>“–no-builtin-rules”
禁止make使用任何隐含规则。</li>
</ul>
<ul>
<li>“-R”</li>
<li>“–no-builtin-variabes”
禁止make使用任何作用于变量上的隐含规则。</li>
</ul>
<ul>
<li>“-s”</li>
<li>“–silent”</li>
<li>“–quiet”
在命令运行时不输出命令的输出。</li>
</ul>
<ul>
<li>“-S”</li>
<li>“–no-keep-going”</li>
<li>“–stop”
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</li>
</ul>
<ul>
<li>“-t”</li>
<li>“–touch”
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</li>
</ul>
<ul>
<li>“-v”</li>
<li>“–version”
输出make程序的版本、版权等关于make的信息。</li>
</ul>
<ul>
<li>“-w”</li>
<li>“–print-directory”
输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</li>
</ul>
<ul>
<li>“–no-print-directory”
禁止“-w”选项。</li>
</ul>
<ul>
<li>“-W <file>”</file></li>
<li>“–what-if=<file>”</file></li>
<li>“–new-file=<file>”</file></li>
<li>“–assume-file=<file>”
假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时
间为当前时间。</file></file></file></li>
</ul>
<ul>
<li>“–warn-undefined-variables”
只要make发现有未定义的变量，那么就输出警告信息。</li>
</ul>
<h3 id="9-隐含规则"><a href="#9-隐含规则" class="headerlink" title="9. 隐含规则"></a>9. 隐含规则</h3><p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就
不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>
<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保
证我们Makefile的兼容性。
我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当
然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h4 id="9-1-使用隐含规则"><a href="#9-1-使用隐含规则" class="headerlink" title="9.1 使用隐含规则"></a>9.1 使用隐含规则</h4><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo : foo.o bar.o</div><div class="line">cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</div></pre></td></tr></table></figure></p>
<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成
命令。</p>
<p>make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo.o : foo.c</div><div class="line">cc –c foo.c $(CFLAGS)</div><div class="line">bar.o : bar.c</div><div class="line">cc –c bar.c $(CFLAGS)</div></pre></td></tr></table></figure></p>
<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.o : foo.p</div></pre></td></tr></table></figure></p>
<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成f
oo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
<h4 id="9-2隐含规则一览"><a href="#9-2隐含规则一览" class="headerlink" title="9.2隐含规则一览"></a>9.2隐含规则一览</h4><p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统
定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：<code>.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .
h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el</code>。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<ol>
<li>编译C程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“<code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code>”</n></n></li>
</ol>
<ol>
<li>编译C++程序的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“<code>$(CXX) –c $(CPPFLAGS) $(CFLAGS)</code>”。（建议使用“.cc”作为C++源文件的后缀，而
不是“.C”）</n></n></n></li>
</ol>
<ol>
<li>编译Pascal程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“<code>$(PC) –c $(PFLAGS)</code>”。</n></n></li>
</ol>
<ol>
<li><p>编译Fortran/Ratfor程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:</n></n></n></n></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">“.f” “$(FC) –c $(FFLAGS)”</div><div class="line">“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”</div><div class="line">“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”</div></pre></td></tr></table></figure>
</li>
<li><p>预处理Fortran/Ratfor程序的隐含规则。
“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</n></n></n></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”</div><div class="line">“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”</div></pre></td></tr></table></figure>
</li>
<li><p>编译Modula-2程序的隐含规则。
“<n>.sym” 的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：<code>“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;”</code>的目标的依赖目标会自动推导为“<n>.mod”，
并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。</n></n></n></p>
</li>
</ol>
<ol>
<li>汇编和汇编预处理的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”
，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。</n></n></n></n></li>
</ol>
<ol>
<li>链接Object文件的隐含规则。
“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对
于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x : y.o z.o</div></pre></td></tr></table></figure>
</n></n></n></li>
</ol>
<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cc -c x.c -o x.o</div><div class="line">cc -c y.c -o y.o</div><div class="line">cc -c z.c -o z.o</div><div class="line">cc x.o y.o z.o -o x</div><div class="line">rm -f x.o</div><div class="line">rm -f y.o</div><div class="line">rm -f z.o</div></pre></td></tr></table></figure></p>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<ol>
<li>Yacc C程序时的隐含规则。</li>
</ol>
<p>“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</n></p>
<ol>
<li>Lex C程序时的隐含规则。
“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）</n></li>
</ol>
<ol>
<li>Lex Ratfor程序时的隐含规则。
“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX
) $(LFALGS)”。</n></li>
</ol>
<ol>
<li>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。
“<n>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。</n></n></n></li>
</ol>
<h4 id="9-3隐含规则使用的变量"><a href="#9-3隐含规则使用的变量" class="headerlink" title="9.3隐含规则使用的变量"></a>9.3隐含规则使用的变量</h4><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量
对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把
变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数
相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<ol>
<li>关于命令的变量。</li>
</ol>
<ul>
<li>AR 函数库打包程序。默认命令是“ar”。</li>
<li>AS 汇编语言编译程序。默认命令是“as”。</li>
<li>CC C语言编译程序。默认命令是“cc”。</li>
<li>CXX C++语言编译程序。默认命令是“g++”。</li>
<li>CO 从 RCS文件中扩展文件程序。默认命令是“co”。</li>
<li>CPP C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。</li>
<li>FC Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。</li>
<li>GET 从SCCS文件中扩展文件的程序。默认命令是“get”。</li>
<li>LEX Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。</li>
<li>PC Pascal语言编译程序。默认命令是“pc”。</li>
<li>YACC Yacc文法分析器（针对于C程序）。默认命令是“yacc”。</li>
<li>YACCR Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。</li>
<li>MAKEINFO 转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。</li>
<li>TEX 从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。</li>
<li>TEXI2DVI 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。</li>
<li>WEAVE 转换Web到TeX的程序。默认命令是“weave”。</li>
<li>CWEAVE 转换C Web 到 TeX的程序。默认命令是“cweave”。</li>
<li>TANGLE 转换Web到Pascal语言的程序。默认命令是“tangle”。</li>
<li>CTANGLE 转换C Web 到 C。默认命令是“ctangle”。</li>
<li>RM 删除文件命令。默认命令是“rm –f”。</li>
</ul>
<ol>
<li>关于命令参数的变量
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是
空。</li>
</ol>
<ul>
<li>ARFLAGS 函数库打包程序AR命令的参数。默认值是“rv”。</li>
<li>ASFLAGS 汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。</li>
<li>CFLAGS C语言编译器参数。</li>
<li>CXXFLAGS C++语言编译器参数。</li>
<li>COFLAGS RCS命令参数。</li>
<li>CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。</li>
<li>FFLAGS Fortran语言编译器参数。</li>
<li>GFLAGS</li>
<li>SCCS “get”程序参数。</li>
<li>LDFLAGS 链接器参数。（如：“ld”）</li>
<li>LFLAGS Lex文法分析器参数。</li>
<li>PFLAGS Pascal语言编译器参数。</li>
<li>RFLAGS Ratfor 程序的Fortran 编译器参数。</li>
<li>YFLAGS Yacc文法分析器参数。</li>
</ul>
<h4 id="9-4-隐含规则链"><a href="#9-4-隐含规则链" class="headerlink" title="9.4 隐含规则链"></a>9.4 隐含规则链</h4><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则
叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调
用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规
则就不会生成中间文件。</p>
<h4 id="9-5定义模式规则"><a href="#9-5定义模式规则" class="headerlink" title="9.5定义模式规则"></a>9.5定义模式规则</h4><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p>
<p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p>
<h5 id="9-5-1-模式规则介绍"><a href="#9-5-1-模式规则介绍" class="headerlink" title="9.5.1 模式规则介绍"></a>9.5.1 模式规则介绍</h5><p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为 5）。</p>
<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.o : %.c ; &lt;command ......&gt;</div></pre></td></tr></table></figure></p>
<p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是”a.o b.o”，那么”%c”就是”a.c b.c”。</p>
<p>一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h5 id="9-5-2-模式规则示例"><a href="#9-5-2-模式规则示例" class="headerlink" title="9.5.2 模式规则示例"></a>9.5.2 模式规则示例</h5><p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.o : %.c</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</div></pre></td></tr></table></figure></p>
<p>其中，<code>&quot;$@&quot;</code>表示所有的目标的挨个值，<code>&quot;$&lt;&quot;</code>表示了所有依赖目标的挨个值。这些奇怪的变
量我们叫”自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.tab.c %.tab.h: %.y</div><div class="line">bison -d $&lt;</div></pre></td></tr></table></figure></p>
<p>这条规则告诉make把所有的[.y]文件都以”bison -d <n>.y”执行，然后生成”<n>.tab.c”和”<n>.tab.h”文件。（其中，”<n>“ 表示一个任意字符串）。如果我们的执行程序”foo”依
赖于文件”parse.tab.o”和”scan.o”，并且文件”scan.o”依赖于文件”parse.tab.h”，如果”parse.y”文件被更新了，那么根据上述的规则，”bison -d parse.y”就会被执行一次，于
是，”parse.tab.o”和”scan.o”的依赖文件就齐了。（假设，”parse.tab.o” 由”parse.tab.c”生成，和”scan.o”由”scan.c”生成，而”foo”由”parse.tab.o”和”scan.o”链接生成，
而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</n></n></n></n></p>
<h5 id="9-5-3-自动化变量"><a href="#9-5-3-自动化变量" class="headerlink" title="9.5.3 自动化变量"></a>9.5.3 自动化变量</h5><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<ul>
<li><code>$@</code>:表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</li>
<li><code>$%</code>:仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，<code>&quot;$%&quot;</code>就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是<code>[.a]</code>，Windows下是<code>[.lib]</code>），那么，其值为空。</li>
<li><code>$&lt;</code>:依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li>
<li><code>$?</code>: 所有比目标新的依赖目标的集合。以空格分隔。</li>
<li><code>$^</code>: 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</li>
<li><code>$+</code>:这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li>
<li><code>$*</code>:这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，<code>&quot;$*&quot;</code>的值就是<code>&quot;dir /a.foo</code>“。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么<code>&quot;$*</code>“也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么<code>&quot;$*&quot;</code>就是除了后缀的那一部分。例如：如果目标是”foo.c”，因为”.c”是make所能识别的后缀名，所以，<code>&quot;$*&quot;</code>的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用<code>&quot;$*&quot;</code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么<code>&quot;$*&quot;</code>就是空值。当你希望只对更新过的依赖文件进行操作时，<code>&quot;$?&quot;</code>在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：<code>lib : foo.o bar.o lose.o win.o
ar r lib $?</code></li>
</ul>
<p>在上述所列出来的自动量变量中。四个变量（<code>$@、$&lt;、$%、$*）</code>在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNU make中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上”D”或是”F”的含义：</p>
<ul>
<li><code>$(@D)</code>:表示”$@”的目录部分（不以斜杠作为结尾），如果”$@”值是”dir/foo.o”，那么<code>&quot;$(@D)&quot;</code>就是”dir”，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。</li>
<li><code>$(@F)</code>:表示”$@”的文件部分，如果”$@”值是”dir/foo.o”，那么<code>&quot;$(@F)&quot;</code>就是”foo.o”，<code>&quot;$(@F)&quot;</code>相当于函数”$(notdir $@)”。</li>
<li><code>&quot;$(*D)&quot;</code></li>
<li><code>&quot;$(*F)&quot;</code>:和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>&quot;$(*D)&quot;</code>返回”dir”，而<code>&quot;$(*F)&quot;</code>返回”foo”</li>
<li><code>&quot;$(%D)&quot;</code></li>
<li><code>&quot;$(%F)&quot;</code>:分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。</li>
<li><code>&quot;$(&lt;D)&quot;</code></li>
<li><code>&quot;$(&lt;F)&quot;</code>:分别表示依赖文件的目录部分和文件部分。</li>
<li><code>&quot;$(^D)&quot;</code></li>
<li><code>&quot;$(^F)&quot;</code>:分别表示所有依赖文件的目录部分和文件部分。（无相同的）</li>
<li><code>&quot;$(+D)&quot;</code></li>
<li><code>&quot;$(+F)&quot;</code>:分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</li>
<li><code>&quot;$(?D)&quot;</code></li>
<li><code>&quot;$(?F)&quot;</code>:分别表示被更新的依赖文件的目录部分和文件部分。</li>
</ul>
<p>最后想提醒一下的是，对于<code>&quot;$&lt;&quot;</code>，为了避免产生不必要的麻烦，我们最好给<code>$</code>后面的那个特定字符都加上圆括号，比如，<code>&quot;$(&lt; )&quot;</code>就要比<code>&quot;$&lt;&quot;</code>要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。</p>
<h5 id="9-5-4-模式的匹配"><a href="#9-5-4-模式的匹配" class="headerlink" title="9.5.4 模式的匹配"></a>9.5.4 模式的匹配</h5><p>一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat” 匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）</p>
<h5 id="9-5-5-重载内建隐含规则"><a href="#9-5-5-重载内建隐含规则" class="headerlink" title="9.5.5 重载内建隐含规则"></a>9.5.5 重载内建隐含规则</h5><p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.o : %.c</div><div class="line">$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)</div></pre></td></tr></table></figure></p>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.o : %.s</div></pre></td></tr></table></figure></p>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h4 id="9-6-老式风格的”后缀规则”"><a href="#9-6-老式风格的”后缀规则”" class="headerlink" title="9.6 老式风格的”后缀规则”"></a>9.6 老式风格的”后缀规则”</h4><p>后缀规则是一个比较老式的定义隐含规则的方法。<strong>后缀规则</strong> 会被 <strong>模式规则</strong> 逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o : %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”% : %.c”。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c” 是源文件的后缀，”.o”是目标文件的后缀。如下示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.c.o:</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</div></pre></td></tr></table></figure></p>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.c.o: foo.h</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</div></pre></td></tr></table></figure>
<p>这个例子，就是说，文件”.c.o”依赖于文件”foo.h”，而不是我们想要的这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.o: %.c foo.h</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</div></pre></td></tr></table></figure></p>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标<code>&quot;.SUFFIXES&quot;</code>来定义或是删除，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.SUFFIXES: .hack .win</div></pre></td></tr></table></figure></p>
<p>把后缀.hack和.win加入后缀列表中的末尾。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.SUFFIXES: # 删除默认的后缀</div><div class="line">.SUFFIXES: .c .o .h # 定义自己的后缀</div></pre></td></tr></table></figure></p>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p>make的参数”-r”或”-no-builtin-rules”也会使用得默认的后缀列表为空。而变量”SUFFIXE”被用来定义默认的后缀列表，你可以用”.SUFFIXES”来改变后缀列表，但请不要改变变量”SUFFIXE”的值。</p>
<h4 id="9-7-隐含规则搜索算法"><a href="#9-7-隐含规则搜索算法" class="headerlink" title="9.7 隐含规则搜索算法"></a>9.7 隐含规则搜索算法</h4><p>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是”archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把”member”当作T来搜索。</p>
<ol>
<li>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）</li>
<li>创建所有匹配于T或是N的模式规则列表。</li>
<li>如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。</li>
<li>移除列表中没有命令的规则。</li>
<li>对于第一个在列表中的模式规则：<ul>
<li>推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。</li>
<li>计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li>
<li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）</li>
<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>
<li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<ul>
<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li>
<li>计算依赖文件。（同第5步）</li>
<li>测试所有的依赖文件是否存在或是理当存在。</li>
<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li>
<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li>
<li>如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h3 id="10-使用make更新函数库文件"><a href="#10-使用make更新函数库文件" class="headerlink" title="10. 使用make更新函数库文件"></a>10. 使用make更新函数库文件</h3><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p>
<h4 id="10-1-函数库文件的成员"><a href="#10-1-函数库文件的成员" class="headerlink" title="10.1 函数库文件的成员"></a>10.1 函数库文件的成员</h4><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">archive(member)</div></pre></td></tr></table></figure></p>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foolib(hack.o) : hack.o</div><div class="line">ar cr foolib hack.o</div></pre></td></tr></table></figure></p>
<p>如果要指定多个member，那就以空格分开，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foolib(hack.o kludge.o)</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foolib(hack.o) foolib(kludge.o)</div></pre></td></tr></table></figure></p>
<p>你还可以使用Shell的文件通配符来定义，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foolib(*.o)</div></pre></td></tr></table></figure></p>
<h4 id="10-2-函数库成员的隐含规则"><a href="#10-2-函数库成员的隐含规则" class="headerlink" title="10.2 函数库成员的隐含规则"></a>10.2 函数库成员的隐含规则</h4><p>当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o” 的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cc -c bar.c -o bar.o</div><div class="line">ar r foo.a bar.o</div><div class="line">rm -f bar.o</div></pre></td></tr></table></figure>
<p>还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。</p>
<h4 id="10-3-函数库文件的后缀规则"><a href="#10-3-函数库文件的后缀规则" class="headerlink" title="10.3 函数库文件的后缀规则"></a>10.3 函数库文件的后缀规则</h4><p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.c.a:</div><div class="line">$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</div><div class="line">$(AR) r $@ $*.o</div><div class="line">$(RM) $*.o</div></pre></td></tr></table></figure></p>
<p>其等效于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(%.o) : %.c</div><div class="line">$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</div><div class="line">$(AR) r $@ $*.o</div><div class="line">$(RM) $*.o</div></pre></td></tr></table></figure></p>
<h4 id="10-4-注意事项"><a href="#10-4-注意事项" class="headerlink" title="10.4 注意事项"></a>10.4 注意事项</h4><p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。
但就目前而言，你还是应该不要尽量不要使用”-j”参数。</p>
<p>该篇文章为转载，是对原作者系列文章的总汇加上标注。
支持原创，请移步陈浩大神博客：
<a href="http://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="external">http://blog.csdn.net/haoel/article/details/2886</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/09/30/tips-makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/30/tips-makefile/" itemprop="url">
                  makefile语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T12:22:14+08:00">
                2017-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/makefile/" itemprop="url" rel="index">
                    <span itemprop="name">makefile</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一个自定义模式规则示例"><a href="#一个自定义模式规则示例" class="headerlink" title="一个自定义模式规则示例"></a>一个自定义模式规则示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">CC=gcc</div><div class="line">SRCPATH=src</div><div class="line">OUTPATH=objs</div><div class="line"></div><div class="line">SRCS_TEST_SORT=$(SRCPATH)/Common.c \</div><div class="line">	$(SRCPATH)/XSort.c\</div><div class="line">	$(SRCPATH)/Test_Sort.c</div><div class="line">#OBJS_TEST_SORT=$(SRCS_TEST_SORT:.c=.o)</div><div class="line">OBJS_TEST_SORT=$(patsubst src/%.c,$(OUTPATH)/%.o,$(SRCS_TEST_SORT))</div><div class="line">EXERC_TEST_SORT=TestSort</div><div class="line"></div><div class="line">SRCS_TEST_LIST=$(SRCPATH)/Common.c \</div><div class="line">	$(SRCPATH)/alist.c\</div><div class="line">	$(SRCPATH)/llist.c\</div><div class="line">	$(SRCPATH)/sllist.c\</div><div class="line">	$(SRCPATH)/linkedlist.c\</div><div class="line">	$(SRCPATH)/Test_List.c\</div><div class="line">	$(SRCPATH)/polynomial.c</div><div class="line"></div><div class="line">#OBJS_TEST_LIST=$(SRCS_TEST_LIST:.c=.o)</div><div class="line">OBJS_TEST_LIST=$(patsubst src/%.c,$(OUTPATH)/%.o,$(SRCS_TEST_LIST))</div><div class="line">EXERC_TEST_LIST=TestList</div><div class="line"></div><div class="line">start:$(OBJS_TEST_SORT) $(OBJS_TEST_LIST)</div><div class="line">	$(CC) -o $(EXERC_TEST_SORT) $(OBJS_TEST_SORT)</div><div class="line">	$(CC) -o $(EXERC_TEST_LIST) $(OBJS_TEST_LIST)</div><div class="line">	@echo ---------------SUCCESS----------------</div><div class="line">$(OUTPATH)/%.o:src/%.c</div><div class="line">	$(CC) -g -fstack-protector -fstack-protector-all -o $@ -c $&lt;</div><div class="line">clean:</div><div class="line">	rm -rf $(OBJS_TEST_SORT) $(EXERC_TEST_SORT)</div><div class="line">	rm -rf $(OBJS_TEST_LIST) $(EXEC_TEST_LIST)</div></pre></td></tr></table></figure>
<ol>
<li>使用VPATH设置搜索路径<code>VPATH = path1:path2:...</code>,make 会自动找到指定文件的目录并添加到文件上</li>
<li>可以指定文件输入/输出路径,<code>OBJS_TEST_SORT=$(SRCS_TEST_SORT:.c=.o)</code>使用源文件集合推到编译输出文件名,当源文件增加路径后,如<code>src/Common.c</code>后,输出路径也变为<code>src/Common.o</code>,不是需要的<code>bin/Common.o</code>,使用函数<code>patsubst</code>替换输出文件集合中文件路径.</li>
<li>使用模式匹配<code>%.o:%.c</code>替换后缀规则<code>.c.o:</code></li>
<li>patsubst ( patten substitude,匹配替换的缩写)函数。它需要3个参数——第一个是一个需要匹配的式样，第二个表示用什么来替换它，第三个是一个需要处理由空格分隔的序列。我们将两个函数合起来用：<code>objects := $(patsubst %.c,%.o,$(wildcard *.c))</code>会被处理为: <code>objects := a.o b.o</code>同理： <code>executables := $(patsubst %.c,%,$(wildcard *.c))</code>会被处理为： <code>executables := a b</code>.<code>%o：</code>所有以“.o”结尾的目标，也就是如Common.o alist.o等,依赖模式<code>“%.c”</code>：取模式<code>“%.o”</code>的<code>%</code>Common alist，并为其加上<code>.c</code>后缀，即<code>Common.c</code>，<code>alist.c</code></li>
<li><code>$&lt;：</code>表示所有依赖目标集，也就是<code>Common.c alist.c</code>,<code>$@：</code>表示目标集，也就是<code>Common.o alist.o</code>.命令前加<code>@</code>，表示在终端中不打印，如<code>@mkdir -p ./bin</code></li>
</ol>
<h3 id="makefile之隐含规则和模式规则"><a href="#makefile之隐含规则和模式规则" class="headerlink" title="makefile之隐含规则和模式规则"></a>makefile之隐含规则和模式规则</h3><p>Makefile有很多灵活的写法，可以写得更简洁，同时减少出错的可能。本节我们来看看这样一个例子还有哪些改进的余地。
 一个目标依赖的所有条件不一定非得写在一条规则中，也可以拆开写，例如：
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">main.o: main.h stack.h maze.h  </div><div class="line"></div><div class="line">main.o: main.c  </div><div class="line">         gcc-c main.c</div></pre></td></tr></table></figure></p>
<p> 就相当于：
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">main.o: main.c main.h stack.h maze.h  </div><div class="line">         gcc-c main.c</div></pre></td></tr></table></figure></p>
<p>如果一个目标拆开写多条规则，其中只有一条规则允许有命令列表，其它规则应该没有命令列表，否则make会报警告并且采用最后一条规则的命令列表。</p>
<p>这样我们的例子可以改写成：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">main: main.o stack.o maze.o  </div><div class="line">         gccmain.o stack.o maze.o -o main  </div><div class="line"></div><div class="line">main.o: main.h stack.h maze.h  </div><div class="line">stack.o: stack.h main.h  </div><div class="line">maze.o: maze.h main.h  </div><div class="line"></div><div class="line">main.o: main.c  </div><div class="line">         gcc-c main.c  </div><div class="line"></div><div class="line">stack.o: stack.c  </div><div class="line">         gcc-c stack.c  </div><div class="line"></div><div class="line">maze.o: maze.c  </div><div class="line">         gcc-c maze.c  </div><div class="line"></div><div class="line">clean:  </div><div class="line">         -rmmain *.o  </div><div class="line"></div><div class="line">.PHONY: clean</div></pre></td></tr></table></figure></p>
<p>这不是比原来更繁琐了吗？现在可以把提出来的三条规则删去，写成：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main: main.o stack.o maze.o  </div><div class="line">         gccmain.o stack.o maze.o -o main  </div><div class="line"></div><div class="line">main.o: main.h stack.h maze.h  </div><div class="line">stack.o: stack.h main.h  </div><div class="line">maze.o: maze.h main.h  </div><div class="line"></div><div class="line">clean:  </div><div class="line">         -rmmain *.o  </div><div class="line"></div><div class="line">.PHONY: clean</div></pre></td></tr></table></figure></p>
<p>这就比原来简单多了。可是现在main.o、stack.o和maze.o这三个目标连编译命令都没有了，怎么编译的呢？试试看：
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ make  </div><div class="line">cc   -c -o main.o main.c  </div><div class="line">cc   -c -o stack.o stack.c  </div><div class="line">cc   -c -o maze.o maze.c  </div><div class="line">gcc main.o stack.o maze.o -o main</div></pre></td></tr></table></figure></p>
<p>现在解释一下前三条编译命令是怎么来。如果一个目标在Makefile中的所有规则都没有命令列表，make会尝试在内建的隐含规则（Implicit Rule）数据库中查找适用的规则。make的隐含规则数据库可以用make -p命令打印，打印出来的格式也是Makefile的格式，包括很多变量和规则，其中和我们这个例子有关的隐含规则有：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># default  </div><div class="line">OUTPUT_OPTION = -o $@  </div><div class="line"></div><div class="line"># default  </div><div class="line">CC = cc  </div><div class="line"></div><div class="line"># default  </div><div class="line">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS)$(TARGET_ARCH) -c  </div><div class="line"></div><div class="line">%.o: %.c  </div><div class="line"># commands to execute (built-in):  </div><div class="line">       $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</div></pre></td></tr></table></figure></p>
<p><code>#</code>号在Makefile中表示单行注释，就像C语言的//注释一样。CC是一个Makefile变量，用<code>CC = cc</code>定义和赋值，用<code>$(CC)</code>取它的值，其值应该是cc。Makefile变量像C的宏定义一样，代表一串字符，在取值的地方展开。cc是一个符号链接，通常指向gcc，在有些UNIX系统上可能指向另外一种C编译器。</p>
<p>CFLAGS这个变量没有定义，<code>$(CFLAGS)</code>展开是空，CPPFLAGS和TARGET_ARCH也是如此。这样<code>$(COMPILE.c)</code>展开应该是cc 空 空 空 -c，去掉“空”得到cc -c，注意中间留下4个空格，所以<code>%.o:%.c</code>规则的命令<code>$(COMPILE.c) $(OUTPUT_OPTION) $&lt;</code>展开之后是<code>cc -c -o $@$&lt;</code>，和上面的编译命令已经很接近了。</p>
<p><code>$@</code>和<code>$&lt;</code>是两个特殊的变量，<code>$@</code>的取值为规则中的目标，<code>$&lt;</code>的取值为规则中的第一个条件。<code>%.o: %.c</code>是一种特殊的规则，称为模式规则（Pattern Rule）。现在回顾一下整个过程，在我们的Makefile中以main.o为目标的规则都没有命令列表，所以make会查找隐含规则，发现隐含规则中有这样一条模式规则适用，main.o符合<code>%.o</code>的模式，现在%就代表main（称为main.o这个名字的Stem），再替换到%.c中就是main.c。所以这条模式规则相当于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">main.o: main.c  </div><div class="line">         cc    -c -o main.o main.c</div></pre></td></tr></table></figure></p>
<p>随后，在处理stack.o目标时又用到这条模式规则，这时又相当于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stack.o: stack.c  </div><div class="line">         cc    -c -o stack.o stack.c</div></pre></td></tr></table></figure></p>
<p>maze.o也同样处理。这三条规则可以由make的隐含规则推导出来，所以不必写在Makefile中。</p>
<p>先前我们写Makefile都是以目标为中心，一个目标依赖于若干条件，现在换个角度，以条件为中心，Makefile还可以这么写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main: main.o stack.o maze.o  </div><div class="line">         gccmain.o stack.o maze.o -o main  </div><div class="line"></div><div class="line">main.o stack.o maze.o: main.h  </div><div class="line">main.o maze.o: maze.h  </div><div class="line">main.o stack.o: stack.h  </div><div class="line"></div><div class="line">clean:  </div><div class="line">         -rmmain *.o  </div><div class="line"></div><div class="line">.PHONY: clean</div></pre></td></tr></table></figure></p>
<p>我们知道，写规则的目的是让make建立依赖关系图，不管怎么写，只要把所有的依赖关系都描述清楚了就行。对于多目标的规则，make会拆成几条单目标的规则来处理，例如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">target1 target2: prerequisite1prerequisite2  </div><div class="line">         command$&lt; -o $@</div></pre></td></tr></table></figure></p>
<p>这样一条规则相当于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">target1: prerequisite1 prerequisite2  </div><div class="line">         commandprerequisite1 -o target1  </div><div class="line"></div><div class="line">target2: prerequisite1 prerequisite2  </div><div class="line">         commandprerequisite1 -o target2</div></pre></td></tr></table></figure></p>
<p>注意两条规则的命令列表是一样的，但$@的取值不同。</p>
<h3 id="Linux-Makefile与shell脚本区别"><a href="#Linux-Makefile与shell脚本区别" class="headerlink" title="Linux Makefile与shell脚本区别"></a>Linux Makefile与shell脚本区别</h3><p>在Makefile可以调用shell脚本，但是Makefile和shell脚本是不同的。本文试着归纳一下Makefile和shell脚本的不同。</p>
<h4 id="1-shell中所有引用以-打头的变量其后要加-而在Makefile中的变量是以-打头的后加-。"><a href="#1-shell中所有引用以-打头的变量其后要加-而在Makefile中的变量是以-打头的后加-。" class="headerlink" title="1. shell中所有引用以$打头的变量其后要加{},而在Makefile中的变量是以$打头的后加()。"></a>1. shell中所有引用以<code>$</code>打头的变量其后要加{},而在Makefile中的变量是以<code>$</code>打头的后加()。</h4><p>实例如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Makefile:</div><div class="line">PATH=&quot;/data/&quot;</div><div class="line">SUBPATH=$(PATH)</div><div class="line">Shell:</div><div class="line">PATH=&quot;/data/&quot;</div><div class="line">SUBPATH=$&#123;PATH&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-Makefile中所有以-打头的单词都会被解释成Makefile中的变量。"><a href="#2-Makefile中所有以-打头的单词都会被解释成Makefile中的变量。" class="headerlink" title="2. Makefile中所有以$打头的单词都会被解释成Makefile中的变量。"></a>2. Makefile中所有以<code>$</code>打头的单词都会被解释成Makefile中的变量。</h4><p>如果你需要调用shell中的变量（或者正则表达式中锚定句位<code>$</code>），都需要加两个<code>$</code>符号（<code>$$</code>）。
Makfile实例如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PATH=&quot;/data/&quot;</div><div class="line">all:</div><div class="line">    echo $&#123;PATH&#125;</div><div class="line">    echo $$PATH</div></pre></td></tr></table></figure></p>
<p>例子中的第一个<code>${PATH}</code>引用的是Makefile中的变量，而不是shell中的PATH环境变量，后者引用的是Shell中的PATH环境变量。</p>
<p>####3. 通配符区别
shell 中通配符<code>*</code>表示所有的字符
Makefile 中通配符<code>%</code>表示所有的字符</p>
<p>####4. 在Makefile中只能在target中调用Shell脚本，其他地方是不能输出的。比如如下代码就是没有任何输出：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">VAR=&quot;Hello&quot;</div><div class="line">echo &quot;$VAR&quot;  </div><div class="line">all:</div><div class="line">   .....</div></pre></td></tr></table></figure></p>
<p>以上代码任何时候都不会输出，而且还会报错，如下：<code>Makefile:*** command commence before first target.Stop</code>,因为没有在target内。如果上述代码改为如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">VAR=&quot;Hello&quot;</div><div class="line">all:</div><div class="line">    echo &quot;$VAR&quot;   </div><div class="line">    .....</div></pre></td></tr></table></figure></p>
<p>以上代码，在make all的时候将会执行echo命令，同时必须注意<code>echo &quot;$VAR&quot;</code>之前必须有一个table，这样Makefile才会认为其为一条command，如果没有table会报错如下：<code>Makefile:*** missing separator.Stop.</code></p>
<p>####5. 在Makefile中执行shell命令，一行创建一个进程来执行。
这也是为什么很多Makefile中有很多行的末尾都是<code>“;  \”</code>，以此来保证代码是一行而不是多行，这样Makefile可以在一个进程中执行，例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SUBDIR=src example</div><div class="line">all:</div><div class="line">    @for subdir in $(SUBDIR); \</div><div class="line">    do\</div><div class="line">        echo &quot;building &quot;; \</div><div class="line">    done</div></pre></td></tr></table></figure></p>
<p>上述可以看出for循环中每行都是以”; \”结尾的。</p>
<p>####6. 获取当前目录
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PATH=`pwd` 注意是``,不是&apos;&apos;</div></pre></td></tr></table></figure></p>
<p>####7. shell总=两边不允许有空格，Makfile中=两边允许有空格。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">77</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
