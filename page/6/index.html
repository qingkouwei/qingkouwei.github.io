<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/page/6/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/page/6/">





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/02/26/tips-universal-cmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/26/tips-universal-cmd/" itemprop="url">
                  常用命令备忘
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T10:55:28+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tips/" itemprop="url" rel="index">
                    <span itemprop="name">tips</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><ul>
<li><code>git stash save &quot;test-cmd-stash&quot;</code>:给stash增加message</li>
<li><code>git stash pop</code>:将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</li>
<li><code>git stash apply</code>:将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝</li>
<li><code>git stash list</code>:查看现有stash</li>
<li><code>git stash drop stash@{0}</code>:移除stash</li>
<li><code>git stash clear</code>:删除所有缓存的stash</li>
<li><code>git stash show</code>:查看指定stash的diff,后面可以跟着stash名字,还可以添加-p或–patch,查看特定stash的全部diff</li>
<li><code>git stash branch</code>:创建一个新的分支,检出储藏工作时的所处的提交,重新应用工作</li>
<li><code>git stash -u/--include-untracked</code>储藏untracked文件,<code>git stash -a/--all</code>:stash当前目录下所有修改</li>
</ul>
<h5 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/02/15/env-centos-nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/15/env-centos-nginx/" itemprop="url">
                  Nginx安装配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-15T17:24:07+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/env/" itemprop="url" rel="index">
                    <span itemprop="name">env</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CentOS安装Nginx"><a href="#CentOS安装Nginx" class="headerlink" title="CentOS安装Nginx"></a>CentOS安装Nginx</h2><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。</p>
<p>在高连接并发的情况下，Nginx是Apache服务器不错的替代品。</p>
<p>系统平台: 阿里云CentOS7.6 64位</p>
<h3 id="1-安装编译工具及库文件"><a href="#1-安装编译工具及库文件" class="headerlink" title="1.安装编译工具及库文件"></a>1.安装编译工具及库文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="2-首先要安装PCRE"><a href="#2-首先要安装PCRE" class="headerlink" title="2.首先要安装PCRE"></a>2.首先要安装PCRE</h3><p>PCRE 作用是让 Nginx 支持 Rewrite 功能</p>
<h4 id="2-1-下载PCRE安装包"><a href="#2-1-下载PCRE安装包" class="headerlink" title="2.1 下载PCRE安装包:"></a>2.1 下载PCRE安装包:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line">wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="2-2-解压安装包"><a href="#2-2-解压安装包" class="headerlink" title="2.2 解压安装包"></a>2.2 解压安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf pcre-8.35.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="2-3-进入安装包目录"><a href="#2-3-进入安装包目录" class="headerlink" title="2.3 进入安装包目录"></a>2.3 进入安装包目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd pcre-8.35</span><br></pre></td></tr></table></figure>

<h4 id="2-4-编译安装"><a href="#2-4-编译安装" class="headerlink" title="2.4 编译安装"></a>2.4 编译安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h5 id="2-5-查看pcre版本"><a href="#2-5-查看pcre版本" class="headerlink" title="2.5 查看pcre版本"></a>2.5 查看pcre版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcre-config --version</span><br></pre></td></tr></table></figure>

<h3 id="3-安装Nginx"><a href="#3-安装Nginx" class="headerlink" title="3.安装Nginx"></a>3.安装Nginx</h3><h4 id="3-1-下载-Nginx，下载地址：http-nginx-org-download-nginx-1-6-2-tar-gz"><a href="#3-1-下载-Nginx，下载地址：http-nginx-org-download-nginx-1-6-2-tar-gz" class="headerlink" title="3.1 下载 Nginx，下载地址：http://nginx.org/download/nginx-1.6.2.tar.gz"></a>3.1 下载 Nginx，下载地址：<a href="http://nginx.org/download/nginx-1.6.2.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.6.2.tar.gz</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line">wget http://nginx.org/download/nginx-1.6.2.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="3-2-解压安装包"><a href="#3-2-解压安装包" class="headerlink" title="3.2 解压安装包"></a>3.2 解压安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nginx-1.6.2.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="3-3-进入安装包目录"><a href="#3-3-进入安装包目录" class="headerlink" title="3.3 进入安装包目录"></a>3.3 进入安装包目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.6.2</span><br></pre></td></tr></table></figure>

<h4 id="3-4-编译安装"><a href="#3-4-编译安装" class="headerlink" title="3.4 编译安装"></a>3.4 编译安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="3-5-查看nginx版本"><a href="#3-5-查看nginx版本" class="headerlink" title="3.5 查看nginx版本"></a>3.5 查看nginx版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -v</span><br></pre></td></tr></table></figure>

<h3 id="4-Nginx-配置"><a href="#4-Nginx-配置" class="headerlink" title="4. Nginx 配置"></a>4. Nginx 配置</h3><p>创建 Nginx 运行使用的用户 www：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/groupadd www </span><br><span class="line">/usr/sbin/useradd -g www www</span><br></pre></td></tr></table></figure>

<p>配置nginx.conf ，将<code>/usr/local/webserver/nginx/conf/nginx.conf</code>替换为以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/webserver/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">user www www;</span><br><span class="line">worker_processes 2; #设置值和CPU核心数一致</span><br><span class="line">error_log /usr/local/webserver/nginx/logs/nginx_error.log crit; #日志位置和日志级别</span><br><span class="line">pid /usr/local/webserver/nginx/nginx.pid;</span><br><span class="line">#Specifies the value for maximum file descriptors that can be opened by this process.</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">  use epoll;</span><br><span class="line">  worker_connections 65535;</span><br><span class="line">&#125;</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">  include mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  log_format main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">               &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">               &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line">  </span><br><span class="line">#charset gb2312;</span><br><span class="line">     </span><br><span class="line">  server_names_hash_bucket_size 128;</span><br><span class="line">  client_header_buffer_size 32k;</span><br><span class="line">  large_client_header_buffers 4 32k;</span><br><span class="line">  client_max_body_size 8m;</span><br><span class="line">     </span><br><span class="line">  sendfile on;</span><br><span class="line">  tcp_nopush on;</span><br><span class="line">  keepalive_timeout 60;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  fastcgi_connect_timeout 300;</span><br><span class="line">  fastcgi_send_timeout 300;</span><br><span class="line">  fastcgi_read_timeout 300;</span><br><span class="line">  fastcgi_buffer_size 64k;</span><br><span class="line">  fastcgi_buffers 4 64k;</span><br><span class="line">  fastcgi_busy_buffers_size 128k;</span><br><span class="line">  fastcgi_temp_file_write_size 128k;</span><br><span class="line">  gzip on; </span><br><span class="line">  gzip_min_length 1k;</span><br><span class="line">  gzip_buffers 4 16k;</span><br><span class="line">  gzip_http_version 1.0;</span><br><span class="line">  gzip_comp_level 2;</span><br><span class="line">  gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">  gzip_vary on;</span><br><span class="line"> </span><br><span class="line">  #limit_zone crawler $binary_remote_addr 10m;</span><br><span class="line"> #下面是server虚拟主机的配置</span><br><span class="line"> server</span><br><span class="line">  &#123;</span><br><span class="line">    listen 80;#监听端口</span><br><span class="line">    server_name localhost;#域名</span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line">    root /usr/local/webserver/nginx/html;#站点目录</span><br><span class="line">      location ~ .*\.(php|php5)?$</span><br><span class="line">    &#123;</span><br><span class="line">      #fastcgi_pass unix:/tmp/php-cgi.sock;</span><br><span class="line">      fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">      fastcgi_index index.php;</span><br><span class="line">      include fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$</span><br><span class="line">    &#123;</span><br><span class="line">      expires 30d;</span><br><span class="line">  # access_log off;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ .*\.(js|css)?$</span><br><span class="line">    &#123;</span><br><span class="line">      expires 15d;</span><br><span class="line">   # access_log off;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log off;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查配置文件nginx.conf的正确性命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure>

<h3 id="4-Nginx命令"><a href="#4-Nginx命令" class="headerlink" title="4. Nginx命令"></a>4. Nginx命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx                      # 启动</span><br><span class="line">/usr/local/webserver/nginx/sbin/nginx -s reload            # 重新载入配置文件</span><br><span class="line">/usr/local/webserver/nginx/sbin/nginx -s reopen            # 重启 Nginx</span><br><span class="line">/usr/local/webserver/nginx/sbin/nginx -s stop              # 停止 Nginx</span><br></pre></td></tr></table></figure>

<h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p><code>nginx: [error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;</code>
解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -c /usr/local/nigin/conf/nginx.conf</span><br><span class="line">/usr/local/webserver/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/02/11/ffmpeg-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/11/ffmpeg-command/" itemprop="url">
                  FFMPEG常用命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T11:01:13+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFMPEG/" itemprop="url" rel="index">
                    <span itemprop="name">FFMPEG</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="将多个视频片段合成一个视频"><a href="#将多个视频片段合成一个视频" class="headerlink" title="将多个视频片段合成一个视频"></a>将多个视频片段合成一个视频</h6><p>新建文本文件,输入要合成的视频列表(如果文件名有奇怪的字符,需要转意)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file &apos;output_train_video_0.mp4&apos;</span><br><span class="line">file &apos;output_train_video_1.mp4&apos;</span><br><span class="line">file &apos;output_train_video_2.mp4&apos;</span><br><span class="line">file &apos;output_train_video_3.mp4&apos;</span><br><span class="line">file &apos;output_train_video_4.mp4&apos;</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -i filelist.txt -c copy output_set.mp4</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/01/30/gl-egl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/30/gl-egl/" itemprop="url">
                  OpenGL之EGL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T18:48:27+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index">
                    <span itemprop="name">OpenGL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>OpenGL ES的javax.microedition.khronos.openges包定义了平台无关的GL绘制指令,EGL(javax.microedition.khronos.egl)则定义了控制dispays,contexts以及surfaces的统一的平台接口.</p>
<p><img src="http://images.wodekouwei.com/gl/egl2.gif" alt="image">
EGL 是 OpenGL ES 渲染 API 和本地窗口系统(native platform window system)之间的一个中间接口层，它主要由系统制造商实现。EGL提供如下机制：</p>
<ul>
<li>与设备的原生窗口系统通信</li>
<li>查询绘图表面的可用类型和配置</li>
<li>创建绘图表面</li>
<li>在OpenGL ES 和其他图形渲染API之间同步渲染</li>
<li>管理纹理贴图等渲染资源</li>
</ul>
<p>为了让OpenGL ES能够绘制在当前设备上，我们需要EGL作为OpenGL ES与设备的桥梁。</p>
<p><img src="http://images.wodekouwei.com/gl/egl.png" alt="image"></p>
<ul>
<li>Display(EGLDisplay)是对实际显示设备的抽象</li>
<li>Surface(EGLSurface)是对用来存储图像的内存区域FrameBuffer的抽象,包括Color Buffer, Stencil Buffer, Depth Buffer.</li>
<li>Context(EGLContext)存储OpenGLES绘图的一些状态信息</li>
</ul>
<p>使用EGL绘制的一般步骤:</p>
<ol>
<li>获取EGLDisplay对象</li>
<li>初始化与EGLDisplay之间的连接</li>
<li>获取EGLConfig实例</li>
<li>创建EGLContext实例</li>
<li>创建EGLSurface实例</li>
<li>连接EGLContext和EGLSurface</li>
<li>使用GL指令绘制图形</li>
<li>断开并释放与EGLSurface关联的EGLContext对象</li>
<li>删除EGLSurface对象</li>
<li>删除EGLContext对象</li>
<li>终止与EGLDisplay之间的连接</li>
</ol>
<p>源码:
本地代码:</p>
<ul>
<li><code>frameworks/native/opengl/libs/EGL</code>:Android EGL框架，负责加载OpenGL函数库和EGL本地实现。</li>
<li><code>frameworks/native/opengl/libagl</code>:Android提供的OpenGL软件库</li>
</ul>
<p>JNI代码:</p>
<ul>
<li><code>frameworks/base/core/jni/com_google_android_gles_jni_EGLImpl.cpp</code>:EGL本地代码的JNI调用接口</li>
<li><code>frameworks/base/core/jni/com_google_android_gles_jni_GLImpl.cpp</code></li>
<li><code>frameworks/base/core/jni/android_opengl_GLESXXX.cpp</code>:OpenGL功能函数的JNI调用接口</li>
</ul>
<p>JAVA代码:</p>
<ul>
<li><code>frameworks/base/opengl/java/javax/microedition/khronos/egl</code></li>
<li><code>frameworks/base/opengl/java/javax/microedition/khronos/opengles</code></li>
<li><code>frameworks/base/opengl/java/com/google/android/gles_jni/</code></li>
<li><code>frameworks/base/opengl/java/android/opengl</code> :EGL和OpenGL的Java层接口，提供给应用开发者，通过JNI方式调用底层函数。</li>
</ul>
<h5 id="OpenGL-ES-EGL-Wrapper-库"><a href="#OpenGL-ES-EGL-Wrapper-库" class="headerlink" title="OpenGL ES/EGL Wrapper 库"></a>OpenGL ES/EGL Wrapper 库</h5><p>前面我们已经介绍过 OpenGL ES/EGL Wrapper 库是一个将 OpenGL ES API 和 OpenGL ES API 具体实现绑定在一起的库，它对应的源码路径是：/frameworks/native/opengl/libs/，其中:</p>
<p>libGLESv1_CM.so：OpenGL ES 1.x API 的 Wrapper 库
libGLESv2.so：OpenGL ES 2.0 的 Wrapper 库
libGLESv3.so：OpenGL ES 3.0 的 Wrapper 库
其中因为 OpenGL ES 3.0 API 是兼容 OpenGL ES 2.0 API 的，所以 libGLESv2.so 库本质上和 libGLESv3.so 库是一样的。</p>
<h5 id="OpenGL-ES-EGL-实现库"><a href="#OpenGL-ES-EGL-实现库" class="headerlink" title="OpenGL ES/EGL 实现库"></a>OpenGL ES/EGL 实现库</h5><p>如果Android系统平台支持 OpenGL ES 硬件加速渲染，那么 OpenGL ES/EGL 实现库由系统厂商以.so的共享链接库的形式提供，例如，Nexus 9 平板中的厂商提供的 OpenGL ES/EGL 实现库为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flounder:/vendor/lib64/egl # ls</span><br><span class="line">libEGL_tegra.so libGLESv1_CM_tegra.so libGLESv2_tegra.so</span><br></pre></td></tr></table></figure>

<p>如果Android系统平台不支持 OpenGL ES 硬件加速渲染，那么它就会默认启用软件模拟渲染，这时 OpenGL ES/EGL 实现库就是由 AOSP 提供，链接库的存在的路径为： /system/lib64/egl/libGLES_android.so。而 libGLES_android.so 库在 Android 7.1 系统对应的实现源码路径为：/frameworks/native/opengl/libagl/ 。</p>
<h5 id="Android-7-1-中加载-OpenGL-ES-库的过程"><a href="#Android-7-1-中加载-OpenGL-ES-库的过程" class="headerlink" title="Android 7.1 中加载 OpenGL ES 库的过程"></a>Android 7.1 中加载 OpenGL ES 库的过程</h5><p>Android 中图形渲染所采用的方式（硬件 or 软件）是在系统启动之后动态确定的，而确定渲染方式的这个源码文件就是 /frameworks/native/opengl/libs/EGL/Loader.cpp 。</p>
<p>####### Android 7.1 OpenGL ES 库和 EGL 库加载说明
How Android finds OpenGL libraries, and the death of egl.cfg 这篇文章中提到了非常关键的一点，就是从 Android Kitkat 4.4 之后，Android 中加载 OpenGL ES/EGL 库的方法发生了变化了（但是整个加载过程都是由 /frameworks/native/opengl/libs/EGL/Loader.cpp 程序所决定的，也就是说 Loader.cpp 文件发生了变化）。</p>
<p>在 Android 4.4 之前，加载 OpenGL ES 库是由 /system/lib/egl/egl.cfg 文件所决定的，通过读取这个配置文件来确定是加载 OpenGL ES 软件模拟实现的库，还是OpenGL ES 硬件加速实现的库。</p>
<p>但是，在Android 4.4 之后，Android 不再通过读取 egl.cfg 配置文件的方式来加载 OpenGL ES 库，新的加载 OpenGL ES 库的规则，如下所示：</p>
<p>从 /system/lib/egl 或者 /vendor/lib/egl/ 目录下加载 libGLES.so 库文件或者 libEGL_vendor.so，libGLESv1_CM_vendor.so，libGLESv2_vendor.so 库文件。
为了向下兼容旧的库的命名方式，同样也会加载 /system/lib/egl 或者 /vendor/lib/egl/ 目录下的 libGLES_<em>.so 或者 libEGL_</em>.so，libGLESv1CM<em>.so，libGLESv2_</em>.so 库文件。
3.2　硬件加速渲染 or 软件模拟渲染？
前面我们提到 OpenGL ES 库的实现方式有两种，一种是硬件加速实现，一种是软件模拟实现，那么系统是怎么确定加载那一种 OpenGL ES 库的呢？</p>
<p>Android 7.1 源码中负责加载 OpenGL ES/EGL 库部分的代码位于：/frameworks/native/opengl/libs/EGL/Loader.cpp 文件中，这个文件中代码的主要入口函数是 Loader::open() 函数，而决定加载硬件加速渲染库还是软件模拟渲染库主要涉及到下面两个函数：</p>
<p>setEmulatorGlesValue()
checkGlesEmulationStatus()
下面就来简要的分析一下 Android 系统是如何选择加载硬件加速渲染库还是软件模拟渲染库：</p>
<ol>
<li><p>首先，Loader::open() 入口函数会调用 setEmulatorGlesValue() 从 property 属性系统中获取一些属性值来判断当前 Android 系统是否在 Emulator 环境中运行，并根据读取出来的信息来重新设置新的属性键值对，setEmulatorGlesValue() 函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void setEmulatorGlesValue(void) &#123;</span><br><span class="line">     char prop[PROPERTY_VALUE_MAX];</span><br><span class="line">     property_get(&quot;ro.kernel.qemu&quot;, prop, &quot;0&quot;); //读取 ro.kernel.qemu 属性值，判断Android系统是否运行在 qemu 中</span><br><span class="line">     if (atoi(prop) != 1) return;</span><br><span class="line">    </span><br><span class="line">     property_get(&quot;ro.kernel.qemu.gles&quot;, prop, &quot;0&quot;); //读取 ro.kernel.qemu.gles 属性值，判断 qemu 中 OpenGL ES 库的实现方式</span><br><span class="line">     if (atoi(prop) == 1) &#123;</span><br><span class="line">         ALOGD(&quot;Emulator has host GPU support, qemu.gles is set to 1.&quot;);</span><br><span class="line">         property_set(&quot;qemu.gles&quot;, &quot;1&quot;);</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     // for now, checking the following</span><br><span class="line">     // directory is good enough for emulator system images</span><br><span class="line">     const char* vendor_lib_path =</span><br><span class="line"> #if defined(__LP64__)</span><br><span class="line">         &quot;/vendor/lib64/egl&quot;;</span><br><span class="line"> #else</span><br><span class="line">         &quot;/vendor/lib/egl&quot;;</span><br><span class="line"> #endif</span><br><span class="line">    </span><br><span class="line">     const bool has_vendor_lib = (access(vendor_lib_path, R_OK) == 0);</span><br><span class="line">     //如果存在 vendor_lib_path 这个路径，那么就说明厂商提供了 OpenGL ES库自己的软件模拟渲染库，而不是 Android 系统自己编译得到的软件模拟渲染库</span><br><span class="line">     if (has_vendor_lib) &#123;</span><br><span class="line">         ALOGD(&quot;Emulator has vendor provided software renderer, qemu.gles is set to 2.&quot;);</span><br><span class="line">         property_set(&quot;qemu.gles&quot;, &quot;2&quot;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         ALOGD(&quot;Emulator without GPU support detected. &quot;</span><br><span class="line">               &quot;Fallback to legacy software renderer, qemu.gles is set to 0.&quot;);</span><br><span class="line">         property_set(&quot;qemu.gles&quot;, &quot;0&quot;); //最后，默认采取的是方案就是调用传统的Android系统自己编译得到软件模拟渲染库</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 load_system_driver() 函数中，内部类 MatchFile 类中会调用 checkGlesEmulationStatus() 函数来检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能，然后根据 checkGlesEmulationStatus() 函数的返回状态值来确定要加载共享链接库的文件绝对路径。load_system_driver() 和 checkGlesEmulationStatus() 函数代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void* load_system_driver(const char* kind) &#123;</span><br><span class="line">     ATRACE_CALL();</span><br><span class="line">     class MatchFile &#123;</span><br><span class="line">     public:</span><br><span class="line">         //这个函数作用是返回需要加载打开的 OpenGL ES 和 EGL API 实现库文件的绝对路径</span><br><span class="line">         static String8 find(const char* kind) &#123;</span><br><span class="line">             String8 result;</span><br><span class="line">             int emulationStatus = checkGlesEmulationStatus(); //检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能</span><br><span class="line">             switch (emulationStatus) &#123;</span><br><span class="line">             case 0: //Android 运行在模拟器中，使用系统软件模拟实现的 OpenGL ES API 库 libGLES_android.so</span><br><span class="line"> #if defined(__LP64__)</span><br><span class="line">                 result.setTo(&quot;/system/lib64/egl/libGLES_android.so&quot;);</span><br><span class="line"> #else</span><br><span class="line">                 result.setTo(&quot;/system/lib/egl/libGLES_android.so&quot;);</span><br><span class="line"> #endif</span><br><span class="line">                 return result;</span><br><span class="line">             case 1: // Android 运行在模拟器中，通过主机系统中实现 OpenGL ES 加速渲染，通过 libGLES_emulation.so 库将  OpenGL ES API 指令重定向到 host 中执行</span><br><span class="line">                 // Use host-side OpenGL through the &quot;emulation&quot; library</span><br><span class="line"> #if defined(__LP64__)</span><br><span class="line">                 result.appendFormat(&quot;/system/lib64/egl/lib%s_emulation.so&quot;, kind);</span><br><span class="line"> #else</span><br><span class="line">                 result.appendFormat(&quot;/system/lib/egl/lib%s_emulation.so&quot;, kind);</span><br><span class="line"> #endif</span><br><span class="line">                 return result;</span><br><span class="line">             default:</span><br><span class="line">                 // Not in emulator, or use other guest-side implementation</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">             // 如果不是上面两种情况，就根据库的命名规则去找到厂商实现库文件的绝对路径</span><br><span class="line">             String8 pattern;</span><br><span class="line">             pattern.appendFormat(&quot;lib%s&quot;, kind);</span><br><span class="line">             const char* const searchPaths[] = &#123;</span><br><span class="line"> #if defined(__LP64__)</span><br><span class="line">                 &quot;/vendor/lib64/egl&quot;,</span><br><span class="line">                 &quot;/system/lib64/egl&quot;</span><br><span class="line"> #else</span><br><span class="line">                 &quot;/vendor/lib/egl&quot;,</span><br><span class="line">                 &quot;/system/lib/egl&quot;</span><br><span class="line"> #endif</span><br><span class="line">             &#125;;</span><br><span class="line">                </span><br><span class="line">             ......</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line"> checkGlesEmulationStatus(void)</span><br><span class="line"> &#123;</span><br><span class="line">     /* We&apos;re going to check for the following kernel parameters:</span><br><span class="line">      *</span><br><span class="line">      *    qemu=1                      -&gt; tells us that we run inside the emulator</span><br><span class="line">      *    android.qemu.gles=&lt;number&gt;  -&gt; tells us the GLES GPU emulation status</span><br><span class="line">      *</span><br><span class="line">      * Note that we will return &lt;number&gt; if we find it. This let us support</span><br><span class="line">      * more additionnal emulation modes in the future.</span><br><span class="line">      */</span><br><span class="line">     char  prop[PROPERTY_VALUE_MAX];</span><br><span class="line">     int   result = -1;</span><br><span class="line">    </span><br><span class="line">     /* Check if hardware acceleration disabled explicitly */</span><br><span class="line">     property_get(&quot;debug.egl.hw&quot;, prop, &quot;1&quot;); //读取 debu.egl.hw 属性值，判断3D硬件加速功能是否被关闭了</span><br><span class="line">     if (!atoi(prop)) &#123;</span><br><span class="line">         ALOGD(&quot;3D hardware acceleration is disabled&quot;);</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     /* First, check for qemu=1 */</span><br><span class="line">     property_get(&quot;ro.kernel.qemu&quot;, prop, &quot;0&quot;); //读取ro.kernel.qemu，判断是否运行在 qemu 中</span><br><span class="line">     if (atoi(prop) != 1)</span><br><span class="line">         return -1;</span><br><span class="line">    </span><br><span class="line">     /* We are in the emulator, get GPU status value */</span><br><span class="line">     property_get(&quot;qemu.gles&quot;, prop, &quot;0&quot;); // 如果 Android 系统运行在 qemu 中，就返回 qemu.gles 的值，根据这个值就可以确定加载的是那种 OpenGL ES 库了</span><br><span class="line">     return atoi(prop);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>总结一下上面代码的功能就是，首先判断 Android 是否在 qemu 虚拟机中运行，如果不是，那么就直接去加载厂商存放库的路径中去加载 OpenGL ES 实现库（不管是硬件加速实现的，还是软件模拟实现的）；如果是在 qemu 中运行，那么就要根据返回的 emulationStatus 值 来确定是加软件模拟实现的 OpenGL ES API 库 libGLES_android.so，还是加载 libGLES_emulation.so库将 OpenGL ES 指令重定向到 Host 系统中去执行。</li>
</ol>
<h6 id="OpenGL-ES-EGL-库加载和解析过程"><a href="#OpenGL-ES-EGL-库加载和解析过程" class="headerlink" title="OpenGL ES/EGL 库加载和解析过程"></a>OpenGL ES/EGL 库加载和解析过程</h6><p>正如Android 系统图形栈: OpenGL ES 和 EGL 介绍这篇文章中分析的那样，在进行 OpenGL 编程时，最先开始需要获取 Display，这将调用 eglgGetDisplay() 函数被调用。在 eglGetDisplay() 里则会调用 egl_init_drivers() 初始化驱动：装载各个库进行解析，将 OpenGL ES/EGL API 函数接口和具体的实现绑定在一起，并将结果保存在 egl_connection_t 类型的全局变量 gEGLImpl 的结构体的成员变量中。</p>
<p>下面以 SurfaceFlinger 进程为例进行分析，整个 OpenGL ES/EGL 库的加载和解析流程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op1=&gt;operation: SurfaceFlinger::init()</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">op2=&gt;operation: eglGetDisplay(EGL_DEFAULT_DISPLAY)</span><br><span class="line">op3=&gt;operation: egl_init_drivers()</span><br><span class="line">op4=&gt;operation: egl_init_drivers_locked();</span><br><span class="line">op5=&gt;operation: loader.open()</span><br><span class="line">op6=&gt;operation: load_driver()</span><br><span class="line">op7=&gt;operation: load_system_driver()</span><br><span class="line">op8=&gt;operation: Loader::init_api()</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;op7-&gt;op8-&gt;e</span><br></pre></td></tr></table></figure>

<p>gEGLImpl 全局变量
struct egl_connection_t 类型的 gEGLImpl 全局变量是一个非常重要变量，它里面的成员指向了打开的 OpenGL ES/EGL Wrapper 库和 OpenGL ES/EGL 实现库： /frameworks/native/opengl/libs/EGL/egl.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">egl_connection_t gEGLImpl;</span><br><span class="line">gl_hooks_t gHooks[2];</span><br><span class="line">gl_hooks_t gHooksNoContext;</span><br></pre></td></tr></table></figure>

<p>其中 egl_connection_t 的定义： /frameworks/native/opengl/libs/EGL/egldefs.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct egl_connection_t &#123;</span><br><span class="line">    enum &#123;</span><br><span class="line">        GLESv1_INDEX = 0,</span><br><span class="line">        GLESv2_INDEX = 1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    inline egl_connection_t() : dso(0) &#123; &#125;</span><br><span class="line">    void *              dso; //指向打开的共享链接库的句柄</span><br><span class="line">    gl_hooks_t *        hooks[2]; //指向打开的 OpenGL ES API 对象</span><br><span class="line">    EGLint              major; // 主版本好</span><br><span class="line">    EGLint              minor;</span><br><span class="line">    egl_t               egl; //dui x</span><br><span class="line"></span><br><span class="line">    void*               libEgl;</span><br><span class="line">    void*               libGles1;</span><br><span class="line">    void*               libGles2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面就对其中的主要成员进行一个说明：</p>
<ul>
<li>hooks：这是一个 gl_hook_t* 类型的指针数组，它最终将 OpenGL ES API 和实现库钩在一起。</li>
<li>egl：这是一个 egl_t 类型的成员变量，它最终将 EGL API 和 EGL 实现库了钩在一起。
那么 gl_hook_t 和 egl_t 是什么呢？</li>
</ul>
<p>gl_hook_t 和 egl_t 的定义如下所示： /frameworks/native/opengl/libs/hooks.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define GL_ENTRY(_r, _api, ...) _r (*_api)(__VA_ARGS__);</span><br><span class="line">#define EGL_ENTRY(_r, _api, ...) _r (*_api)(__VA_ARGS__);</span><br><span class="line"></span><br><span class="line">struct egl_t &#123;</span><br><span class="line">    #include &quot;EGL/egl_entries.in&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct gl_hooks_t &#123;</span><br><span class="line">    struct gl_t &#123;</span><br><span class="line">        #include &quot;entries.in&quot;</span><br><span class="line">    &#125; gl;</span><br><span class="line">    struct gl_ext_t &#123;</span><br><span class="line">        // __eglMustCastToProperFunctionPointerType 是一个 typedef 的函数指针类型，它的返回值是void，参数也是void</span><br><span class="line">        __eglMustCastToProperFunctionPointerType extensions[MAX_NUMBER_OF_GL_EXTENSIONS];</span><br><span class="line">    &#125; ext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的定义中我们发现，egl_t 和 gl_hooks_t 这两个结构体中主要就是一个 include 语句，那么它们包含的是什么呢？</p>
<p><code>#include “EGL/egl_entries.in 包含的文件路径如下所示： /frameworks/native/opengl/libs/EGL/egl_entries.in</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EGL_ENTRY(EGLDisplay, eglGetDisplay, NativeDisplayType)</span><br><span class="line">EGL_ENTRY(EGLBoolean, eglInitialize, EGLDisplay, EGLint*, EGLint*)</span><br><span class="line">EGL_ENTRY(EGLBoolean, eglTerminate, EGLDisplay)</span><br><span class="line">EGL_ENTRY(EGLBoolean, eglGetConfigs, EGLDisplay, EGLConfig*, EGLint, EGLint*)</span><br><span class="line">EGL_ENTRY(EGLBoolean, eglChooseConfig, EGLDisplay, const EGLint *, EGLConfig *, EGLint, EGLint *)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这个文件中，我们可以看到所有的内容都是 EGL_ENTRY 宏定义的，根据 EGL_ENTRY 宏定义： /frameworks/native/opengl/libs/EGL/hooks.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//下面的两个宏定义分别是 OpenGL 和 EGL API 函数的函数指针变量</span><br><span class="line">//这些函数变量最后会和具体的 OpenGL 和 EGL API 的实现绑定在一起</span><br><span class="line">#define GL_ENTRY(_r,_api,...) _r (*_api)(__VA_ARGS__);</span><br><span class="line">#define EGL_ENTRY(_r,_api,...) _r(*_api)(__VA_ARGS__);</span><br></pre></td></tr></table></figure>

<p>我们可以将下面的这个宏定义展开成如下的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EGL_ENTRY(EGLDisplay, eglGetDisplay, NativeDisplayType)</span><br><span class="line">//展开后的形式如下所示，它实际上就是 EGL API 函数声明</span><br><span class="line">EGLDisplay eglGetDisplay(NativeDisplayType)</span><br></pre></td></tr></table></figure>

<p><code>#include “entries.in” 包含的文件路径为： /frameworks/native/opengl/libs/entries.in</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GL_ENTRY(void, glReadPixels, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>和上面的 EGL_ENTRY 一样，GL_ENTRY 都是通过宏定义的形式来将 OpenGL ES 的 API 函数接口进行声明，例如，上面的宏定义声明可以展开成下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GL_ENTRY(void, glReadPixels, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)</span><br><span class="line">// 展开后的形式如下所示，它实际上就是 OpenGL ES API 函数声明</span><br><span class="line">void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)</span><br></pre></td></tr></table></figure>

<p>最后，通过 entries.in 和 egl_entries.in 这两个文件，我们就可以得到 OpenGL ES 和 EGL 中的所有 API 函数接口的说明。</p>
<p>SurfaceFlinger 初始化成员变量 mEGLDisplay
在 SurfaceFlinger 类中有一个 EGLDisplay 类型的成员变量 mEGLDisplay，它是 EGL 中用来构建 OpenGL ES 渲染环境所需的参数。</p>
<p>SurfaceFlinger 中调用 eglGetDisplay() 初始化 mEGLDisplay 的代码如下： /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ALOGI(  &quot;SurfaceFlinger&apos;s main thread ready to run. &quot;</span><br><span class="line">            &quot;Initializing graphics H/W...&quot;);</span><br><span class="line"></span><br><span class="line">    status_t err;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    // initialize EGL for the default display</span><br><span class="line">    // 调用 eglGetDisplay 函数获取默认的显示设备</span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); </span><br><span class="line">    eglInitialize(mEGLDisplay, NULL, NULL);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>紧接着在 eglGetDisplay() 中调用 egl_init_drivers() /frameworks/native/opengl/libs/EGL/eglApi.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EGLDisplay eglGetDisplay(EGLNativeDisplayType display)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 调用egl_init_drivers() 加载 OpenGL ES 库和 EGL 库</span><br><span class="line">    if (egl_init_drivers() == EGL_FALSE) &#123;</span><br><span class="line">        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);</span><br><span class="line">    return dpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，egl_init_drivers() 函数中使用了 pthread_mutex_lock 上锁保护，继续调用 egl_init_drivers_locked() 函数 /frameworks/native/opengl/libs/EGL/egl.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EGLBoolean egl_init_drivers() &#123;</span><br><span class="line">    EGLBoolean res;</span><br><span class="line">    pthread_mutex_lock(&amp;sInitDriverMutex);</span><br><span class="line">    // 使用了 pthread_mutex_lock 上锁保护，继续调用 egl_init_drivers_locked</span><br><span class="line">    res = egl_init_drivers_locked();</span><br><span class="line">    pthread_mutex_unlock(&amp;sInitDriverMutex);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是对 egl_init_drivers_locked() 函数进行一个分析：</p>
<p>egl_init_drivers_locked() 函数代码如下所示： /frameworks/native/opengl/libs/EGL/egl.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//在该文件起始位置定义的全局变量</span><br><span class="line">egl_connection_t gEGLImpl; // 描述EGL实现内容的结构体对象</span><br><span class="line">gl_hooks_t gHooks[2]; // gl_hooks_t 是包含 OpenGL ES API 函数声明对应的函数指针结构体</span><br><span class="line">gl_hooks_t gHooksNoContext;</span><br><span class="line">pthread_key_t gGLWrapperKey = -1;</span><br><span class="line"></span><br><span class="line">static EGLBoolean egl_init_drivers_locked() &#123;</span><br><span class="line">    if (sEarlyInitState) &#123;</span><br><span class="line">        // initialized by static ctor. should be set here.</span><br><span class="line">        return EGL_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到 Loader 对象单例</span><br><span class="line">    // get our driver loader</span><br><span class="line">    Loader&amp; loader(Loader::getInstance());</span><br><span class="line"></span><br><span class="line">    //  gEGLImple 是一个全局变量，数据类型为 egl_connection_t 结构体类型</span><br><span class="line">    // dynamically load our EGL implementation</span><br><span class="line">    egl_connection_t* cnx = &amp;gEGLImpl;</span><br><span class="line"></span><br><span class="line">    // cnx-&gt;dso 本质上是一个 (void *)类型的指针，它指向的对象是 EGL 共享库打开之后的句柄</span><br><span class="line">    if (cnx-&gt;dso == 0) &#123; </span><br><span class="line">        // &gt;= 将cnx中的 hooks 数组中指向OpenGL ES API 函数指针结构体指的数组成员，用 gHooks 中的成员的地址去初始化</span><br><span class="line">        //也就是说 gEGLImpl 中 hook 数组指向 gHooks 数组，最终指向同一个 OpenGL ES API 函数指针的实现</span><br><span class="line">        cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX] =</span><br><span class="line">            &amp;gHooks[egl_connection_t::GLESv1_INDEX];</span><br><span class="line">        cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX] =</span><br><span class="line">            &amp;gHooks[egl_connection_t::GLESv2_INDEX];</span><br><span class="line"></span><br><span class="line">        // &gt;= 最后通过loader对象的open函数开始加载 OpenGL ES 和 EGL wrapper 库</span><br><span class="line">        cnx-&gt;dso = loader.open(cnx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnx-&gt;dso ? EGL_TRUE : EGL_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中，有一个非常关键的 egl_connection_t 指针指向一个全局变量 gEGLImpl，当第一次初始化加载 OpenGL ES 实现库和 EGL 实现库时，还需要将 gEGLImpl 中的 hooks 数组中的两个指针指向一个全局的 gl_hooks_t 数组 gHooks（这就是两个指针钩子，最终初始化完成后将分别勾住 OpenGL ES 1.0 和 OpenGL ES 2.0 的实现库），接着调用 Loader 类的实例的 open() 函数完成从 OpenGL ES 实现库中完成符号解析工作。</p>
<p>通过 Loader 类加载和解析 OpenGL ES 库和 EGL 库
Loader::open() 函数的代码如下所示： /frameworks/native/opengl/libs/EGL/Loader.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// &gt;= Loader 类对象构造完成后，就在 /EGL/egl.cpp 文件中的 egl_init_drivers_locked() 中被调用</span><br><span class="line">void* Loader::open(egl_connection_t* cnx)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    void* dso;</span><br><span class="line">    driver_t* hnd = 0;</span><br><span class="line"></span><br><span class="line">    setEmulatorGlesValue();</span><br><span class="line"></span><br><span class="line">    dso = load_driver(&quot;GLES&quot;, cnx, EGL | GLESv1_CM | GLESv2);</span><br><span class="line">    if (dso) &#123;</span><br><span class="line">        hnd = new driver_t(dso);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Always load EGL first</span><br><span class="line">        dso = load_driver(&quot;EGL&quot;, cnx, EGL);</span><br><span class="line">        if (dso) &#123;</span><br><span class="line">            hnd = new driver_t(dso);</span><br><span class="line">            hnd-&gt;set( load_driver(&quot;GLESv1_CM&quot;, cnx, GLESv1_CM), GLESv1_CM );</span><br><span class="line">            hnd-&gt;set( load_driver(&quot;GLESv2&quot;,    cnx, GLESv2),    GLESv2 );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!hnd, &quot;couldn&apos;t find an OpenGL ES implementation&quot;);</span><br><span class="line"></span><br><span class="line">    cnx-&gt;libEgl   = load_wrapper(EGL_WRAPPER_DIR &quot;/libEGL.so&quot;);</span><br><span class="line">    cnx-&gt;libGles2 = load_wrapper(EGL_WRAPPER_DIR &quot;/libGLESv2.so&quot;);</span><br><span class="line">    cnx-&gt;libGles1 = load_wrapper(EGL_WRAPPER_DIR &quot;/libGLESv1_CM.so&quot;);</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!cnx-&gt;libEgl,</span><br><span class="line">            &quot;couldn&apos;t load system EGL wrapper libraries&quot;);</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!cnx-&gt;libGles2 || !cnx-&gt;libGles1,</span><br><span class="line">            &quot;couldn&apos;t load system OpenGL ES wrapper libraries&quot;);</span><br><span class="line"></span><br><span class="line">    return (void*)hnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open() 函数主要负责 OpenGL ES 库加载前的准备工作，具体的加载细节，则是通过调用 load_driver() 去完成的。</p>
<p>Loader::load_driver() 函数代码如下所示： /frameworks/native/opengl/libs/EGL/Loader.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void *Loader::load_driver(const char* kind,</span><br><span class="line">                          egl_connection_t* cnx, uint32_t mask)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    void* dso = nullptr;</span><br><span class="line">    if (mGetDriverNamespace) &#123;</span><br><span class="line">        android_namespace_t* ns = mGetDriverNamespace();</span><br><span class="line">        if (ns) &#123;</span><br><span class="line">            dso = load_updated_driver(kind, ns); //加载 OpenGL ES 实现库，放回打开的共享链接库的句柄</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!dso) &#123;</span><br><span class="line">        dso = load_system_driver(kind);</span><br><span class="line">        if (!dso)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解析 EGL 库，并将wrapper 库 libEGL.so 中的函数 API 指针和具体的实现绑定在一起</span><br><span class="line">    if (mask &amp; EGL) &#123;</span><br><span class="line">        getProcAddress = (getProcAddressType)dlsym(dso, &quot;eglGetProcAddress&quot;);</span><br><span class="line"></span><br><span class="line">        ALOGE_IF(!getProcAddress,</span><br><span class="line">                 &quot;can&apos;t find eglGetProcAddress() in EGL driver library&quot;);</span><br><span class="line"></span><br><span class="line">        egl_t* egl = &amp;cnx-&gt;egl; //将 egl 指针指向描述当前系统支持 OpenGL ES和 EGL 全局变量的 gEGLImpl</span><br><span class="line">        __eglMustCastToProperFunctionPointerType* curr =</span><br><span class="line">            (__eglMustCastToProperFunctionPointerType*)egl;</span><br><span class="line">        char const * const * api = egl_names; //egl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 EGL API 函数指针</span><br><span class="line">        while (*api) &#123;</span><br><span class="line">            char const * name = *api;</span><br><span class="line">            __eglMustCastToProperFunctionPointerType f =</span><br><span class="line">                (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);</span><br><span class="line">            if (f == NULL) &#123;</span><br><span class="line">                // couldn&apos;t find the entry-point, use eglGetProcAddress()</span><br><span class="line">                f = getProcAddress(name);</span><br><span class="line">                if (f == NULL) &#123;</span><br><span class="line">                    f = (__eglMustCastToProperFunctionPointerType)0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            *curr++ = f; //这一步就是最关键的将共享链接库中的 EGL API 的实现和上层调用的 API 函数指针绑定在一起</span><br><span class="line">            api++; //指向下一个需要绑定的 api 函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解析 OpenGL ES 库中的 OpenGL ES 1.x API 符号</span><br><span class="line">    if (mask &amp; GLESv1_CM) &#123;</span><br><span class="line">        // 调用 init_api 实现 OpenGL API 和对应实现函数的绑定</span><br><span class="line">        init_api(dso, gl_names, // gl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 OpenGL ES API 函数指针</span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl, //gl成员变量是一个结构体变量，结构体中的是 OpenGL ES API 函数指针</span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解析 OpenGL ES 库中的 OpenGL ES 2.0 API 符号</span><br><span class="line">    if (mask &amp; GLESv2) &#123;</span><br><span class="line">        init_api(dso, gl_names,</span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl,</span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dso;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Loader::load_driver() 它主要实现了两个功能：</p>
<p>通过 load_system_driver()  函数查找 OpenGL ES/EGL 实现库，并在指定的存放路径中找到共享链接库文件并打开它。
调用 init_api()解析打开的 OpenGL ES/EGL 共享链接库，将 OpenGL ES/EGL API 函数指针和共享链接库中实现的对应的函数符号绑定在一起，这样调用 OpenGL ES/EGL API 就会调用到具体实现的OpenGL ES/EGL 共享链接库中对应函数。
具体 load_system_driver() 函数和 init_api() 函数的实现就不一一展开了，大家可以到 /frameworks/native/opengl/libs/EGL/Loader.cpp 文件中查看，应该写得非常直接清楚了。</p>
<p>整个加载和解析的目的就是将 OpenGL ES/EGL API 和具体实现函数绑定在一起，这样当程序调用 OpenGL ES/EGL API 时，就会调用到实际的实现函数了。然后，在硬件平台上的 Android 系统加载的是硬件厂商提供的 OpenGL ES/EGL 实现库，而在 qemu 模拟器中运行的 Android 系统中加载的则是软件模拟实现的 OpenGL ES/EGL 库或者是将 OpenGL ES 重定向到主机系统中进行硬件加速的库。</p>
<p><a href="https://woshijpf.github.io/android/2017/09/05/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88OpenGLES%E5%92%8CEGL%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" target="_blank" rel="noopener">Android 系统图形栈（二）：OpenGL ES 库和 EGL 库加载过程</a>
<a href="http://www.2net.co.uk/tutorial/android-egl-cgf-is-dead" target="_blank" rel="noopener">How Android finds OpenGL libraries, and the death of egl.cfg</a></p>
<h4 id="eglSwapBuffers接口实现说明"><a href="#eglSwapBuffers接口实现说明" class="headerlink" title="eglSwapBuffers接口实现说明"></a>eglSwapBuffers接口实现说明</h4><p>一般性嵌入式平台
<img src="http://images.wodekouwei.com/gl/egl_swapbuffer.png" alt="iamge"></p>
<p>利用双缓冲进行Swap的时候，Display和Surface进行实际意义上的地址交换，来实现eglSwapBuffers的标准， 如上图的右侧所示。上图的左侧表示，单缓冲Framebuffer的形式，Surface永远都在后端， 显示的永远是Display，在GPU出现后已不使用。</p>
<p>Android平台:
为了实现eglSwapBuffers， eglSurface其实代表了一个从NativeWindow 申请到的一个Buffer（Dequeue操作）。当调用eglSwapBuffers时，对于一般应用窗口而言，NativeWindow将该Surface的Buffer 提交回去给SurfaceFlinger（Queue操作)，然后又重新从NativeWindow中重新Dequeue出来一个新的Buffer给eglSurface。而eglDisplay并不代表实际的意义。我们只是从接口上感觉是，surface和display进行了交换。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/01/30/daily/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/30/daily/" itemprop="url">
                  日常的
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T18:36:22+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Parameters were incorrect. We wanted {“required”:[“desiredCapabilities”],
pip uninstall selenium
pip install selenium==3.0.1</p>
<p>fbo与pbuffer区别</p>
<p>像zoom这样把多个流放到一个upd里究竟有什么好处?
节省端口
这个理由似乎不是很充分，付出的代价有点大，而且单机其实支持不了多少路，端口足够用了</p>
<p>付出什么代价了
单机支持一两千路足够视频会议用了\</p>
<p>猜测而已: 1. 避免NAT穿越时候多个Port的维护  2. 在UDP层面复用的话，保证UDP的流量足够，同时也避免了维护多个Socket，减小资源开销
当集群来应对大量客户的时候，这样做的话，机器之间会有很多的互相拉流的操作，</p>
<p>ICE打洞过程会快了，但是也得要支持动态更新啊，因为肯定会存在半路上有人进，有人出，SDP不是要变化吗？</p>
<p>没记错的话，RTP、RTCP曾经打算复用一个Port，避免一次使用两个 ：）</p>
<p>和TS的统计复用很类似
所以我猜测Zoom并不是全部随意把流放到一个Port里面去，上层逻辑是做了控制的
TS的统计复用是为了适应CBR</p>
<p>我抓包看到ZOOM是哪个SFU入，就从那个SFU出流，但流被复接连</p>
<p>是不是好做集群，好做负载均衡，好做就近接入，还是好和SD-WAN结合，我想ZOOM体验那么好，一定是多方面优化的结果，究竟在哪些地方不一样达成的这种效果</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/01/30/at-android-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/30/at-android-performance/" itemprop="url">
                  Android性能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T12:20:22+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/autotest/" itemprop="url" rel="index">
                    <span itemprop="name">autotest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="性能标准"><a href="#性能标准" class="headerlink" title="性能标准"></a>性能标准</h2><p>安卓绿色联盟应用性能标准主要基于主观体验、资源消耗和应用质量三个方面进行制定。</p>
<ol>
<li>主观体验:主观体验主要是对应用启动时间和界面帧率制定标准，要求应用在视觉上足够流畅。其中应用启动时间又分为冷启动时间和热启动时间.安卓绿色联盟性能标准要求，应用冷启动时间需小于1000ms，热启动时间需小于500ms；普通应用帧率应大于55fps，游戏视频帧率应大于25fps。</li>
<li>资源消耗:资源消耗主要是要求应用不能占用过高的内存和CPU。安卓绿色联盟性能标准要求应用前台内存占用应小于500M，后台内存占用应小于400M；在CPU占用方面要求应用在后台灭屏5分钟后，CPU占用不超过2%。</li>
<li>应用质量:应用质量主要是对应用过度绘制和内存泄露的情况作出要求，规定应用不能存在过度绘制和内存泄露。安卓绿色联盟性能标准要求应用界面任意像素点不存在4x的绘制的情况， 3x绘制的区域不能超过界面面积的1/3，在Strict Mode中不允许有红框闪烁。</li>
</ol>
<h3 id="性能调试方法"><a href="#性能调试方法" class="headerlink" title="性能调试方法"></a>性能调试方法</h3><p>在了解性能调试方法之前，我们可以先通过下图了解安卓应用性能与系统之间的关系。一个应用从应用绘制到最终显示在LCD上经历了一个漫长的路径，在任何一个阶段出现延时都会导致界面上的卡顿。
<img src="http://images.wodekouwei.com/at-android-performance-201935151844.jpg" alt="at-android-performance-201935151844"></p>
<h4 id="1、Strict-Mode"><a href="#1、Strict-Mode" class="headerlink" title="1、Strict Mode"></a>1、Strict Mode</h4><p>Strict Mode意思为严格模式，是Android提供的一种运行时检测机制，一般用来检测在主线程发生的耗时动作，比如IO读写、数据库操作、复杂算法等。在手机设置开发者选项把Strict Mode打开，就可以在界面上把它打开了。</p>
<p>严格模式主要有2个策略，一个是线程策略，即ThreadPolicy，主要检测主线程中的一些耗时操作；另一个是虚拟机策略，即VmPolicy，主要检测一些对象的泄漏。</p>
<p>两大策略检测的内容和开启方法可以依据下图中的说明进行使用。
<strong>ThreadPolicy</strong>:</p>
<ul>
<li>自定义的耗时调用使用detectCustomSlowCalls()开启</li>
<li>磁盘读取操作使用detectDiskReads()开启</li>
<li>磁盘写入操作使用detectDiskWrites()开启</li>
<li>网络操作使用detectNetwork()开启</li>
</ul>
<p><strong>VmPolicy</strong>:</p>
<ul>
<li>Activity泄露使用detectActivityLeaks()开启</li>
<li>未关闭的Closable对象泄露使用detectLeakedClosableObjects()开启</li>
<li>泄露的Sqlite对象,使用detectLeakedSqlLiteObjects()开启</li>
<li>检测实例数量,使用setClassInstanceLimit()开启
严格模式有三种惩罚模式：应用崩溃、弹窗警告和打印日志。在性能测试中，我们可以通过APPLogcat抓取Strict Mode的日志，同时利用代码启用Strict Mode，配合我们所需要的策略和惩罚，就可以及时定位应用的违规细节，并及时进行性能优化。</li>
</ul>
<p>当我们碰到违规的行为时，该如何进行治理呢？建议将文件操作放到工作线程去完成，如果在主线程上提及操作，建议使用Apply和Commit去完成。如果存在对象未关闭的情况，可以通过对应的StackTrace进行关闭。</p>
<h4 id="2、OverDraw-DeBugger"><a href="#2、OverDraw-DeBugger" class="headerlink" title="2、OverDraw DeBugger"></a>2、OverDraw DeBugger</h4><p>Overdraw是指屏幕上的某个像素在同一帧的时间内被绘制了多次，这个工具使用色块来代表不同数量的过度绘制，我们可以使用这个工具来定位由过度绘制引起的用户界面卡顿问题。</p>
<p>在开发者选项中选择开启 Debug GPU Overdraw选项，即可在安卓设备上将过度绘制问题可视化。
<img src="http://images.wodekouwei.com/at-android-performance-201935152838.jpg" alt="at-android-performance-201935152838">
左图为正常模式下显示的视图，右图为开启GPU Overdraw后显示的视图</p>
<h4 id="3、Profile-GPU-Rendering"><a href="#3、Profile-GPU-Rendering" class="headerlink" title="3、Profile GPU Rendering"></a>3、Profile GPU Rendering</h4><p>ProfileGPU Rendering 工具以滚动直方图的形式直观地显示渲染界面窗口帧所花费的相对时间（以每帧 16 毫秒的速度作为对比基准）。这个工具同样也是在安卓设备的开发者选项中开启。每个管线的高度表示时间，管线中各个彩色区段代表不同含义。</p>
<p>下表介绍了使用运行Android 6.0及更高版本的设备时分析器中不同竖条区段的含义。
<img src="http://images.wodekouwei.com/at-android-performance-201935152931.jpg" alt="at-android-performance-201935152931"></p>
<h4 id="4、Android-Profiler"><a href="#4、Android-Profiler" class="headerlink" title="4、Android Profiler"></a>4、Android Profiler</h4><p>Android Profiler是一个Android Studio集成的应用性能分析器，可以实时查看CPU、Memory和Network的动态情况。以下重点介绍CPU Profiler：</p>
<p>CPU Profiler 可帮助您实时检查应用的 CPU 使用率和线程 Activity，并记录函数跟踪，方便大家优化和调试应用代码。</p>
<p>当打开 CPU Profiler 时，它将显示应用的 CPU 使用率和线程 Activity。
CPU Profiler可以选择不同的标签，并对应用线程进行跟踪。如：</p>
<ul>
<li>Flame Chart标签会提供一个倒置的调用图表，汇总相同的调用堆栈，收集调用顺序完全一致的函数，并在火焰图中用一个较长的横条表示它们。</li>
<li>Top Down标签能够提供每个函数调用上所花费的CPU时间。Self表示函数调用在执行自己的代码上所花的时间；Children表示函数调用子方法所花费的时间；Total表示Self和Children时间的总和。</li>
</ul>
<h4 id="5、Systrace"><a href="#5、Systrace" class="headerlink" title="5、Systrace"></a>5、Systrace</h4><p>Systrace是我们分析性能最常用的工具之一，它可以分析整机系统性能及动态场景的性能问题。</p>
<p>Systrace 允许您在系统级别收集和检查设备上运行的所有进程的计时信息。它将来自Android内核的数据（例如CPU调度程序，磁盘活动和应用程序线程）组合起来，以生成HTML报告。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935153057.jpg" alt="at-android-performance-201935153057">
上图左部是Systrace的界面，我们可以通过右边的代码抓取Systrace，观察进程的执行时间。在输入抓取命令时，时间参数一般选择5到10秒，因为时间过短可能会抓不到想要的数据，时间过长则可能抓取失败。</p>
<p>一般我们通过Chrome浏览器查看生成的trace文件，也可以通过DDMS图形界面去抓取Systrace。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935153130.jpg" alt="at-android-performance-201935153130">
拿到一个Systrace时主要考察哪些因素？首先看一下CPU的频率，找到对应的进程或者线程，查看相关信息；同时还要观察GPU的频率、Surface Flinger还有绘图的Buffer状态等。</p>
<p>当应用发生卡顿时，我们可以通过Systrace进行分析。在生成的trace文件中，找到主线程UI，每一帧都会标记一个带有F的圆形。当原型为绿色时，代表页面流畅，而黄色和红色则存在超时，我们可以点击去查看具体存在什么问题。</p>
<h3 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h3><p>应用启动时间是应用性能最重要的指标之一,分冷启动和热启动两种情况:</p>
<ul>
<li>冷启动:当APP启动时,后台没有该app的进程,这时系统会重新创建一个新的进程分配给该app,这个启动方式就叫做冷启动(后台不存在该APP进程)</li>
<li>热启动:当APP已经被打开,但是被按下返回键,Home键等按钮时回到桌面或者是其他程序的时候,再重新打开该APP时,这种方式叫做热启动(后台已经存在该APP进程)</li>
</ul>
<p>测试方法:
将手机root之后,使用adb工具连接手机.使用adb shell am start -S -W 命令获取应用冷启动时间,adb shell am Start -W命令获取应用冷启动时间.
<code>adb shell am start -W -n packagename/packageName.MainActivity</code>
<code>aapt dump badging &lt;apk路径&gt;</code>:搜package 的 launchable-activity</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-20193512931.png" alt="at-android-performance-20193512931">
执行成功后将返回三个测量到的时间：</p>
<ol>
<li>ThisTime:一般和TotalTime时间一样，除非在应用启动时开了一个透明的Activity预先处理一些事再显示出主Activity，这样将比TotalTime小。</li>
<li>TotalTime:应用的启动时间，包括创建进程+Application初始化+Activity初始化到界面显示。</li>
<li>WaitTime:一般比TotalTime大点，包括系统影响的耗时。</li>
</ol>
<p>关于ThisTime/TotalTime/WaitTime的区别,下面是其解释：“adb shell am start -W ”的实现在『frameworks\base\cmds\am\src\com\android\commands\am\Am.java』文件中。其实就是跨Binder调用ActivityManagerService.startActivityAndWait() 接口（后面将ActivityManagerService简称为AMS），这个接口返回的结果包含上面打印的ThisTime、TotalTime时间.</p>
<ul>
<li>startTime记录的刚准备调用startActivityAndWait()的时间点</li>
<li>endTime记录的是startActivityAndWait()函数调用返回的时间点</li>
<li>WaitTime = startActivityAndWait()调用耗时。</li>
</ul>
<p>ThisTime、TotalTime 的计算在 frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java 文件的 reportLaunchTimeLocked() 函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void reportLaunchTimeLocked(final long curTime) &#123;</span><br><span class="line">    final ActivityStack stack = task.stack;</span><br><span class="line">    final long thisTime = curTime - displayStartTime;</span><br><span class="line">    final long totalTime = stack.mLaunchStartTime != 0</span><br><span class="line">            ? (curTime - stack.mLaunchStartTime) : thisTime;</span><br><span class="line">    if (ActivityManagerService.SHOW_ACTIVITY_START_TIME) &#123;</span><br><span class="line">        Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;launching&quot;, 0);</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_ACTIVITY_LAUNCH_TIME,</span><br><span class="line">                userId, System.identityHashCode(this), shortComponentName,</span><br><span class="line">                thisTime, totalTime);</span><br><span class="line">        StringBuilder sb = service.mStringBuilder;</span><br><span class="line">        sb.setLength(0);</span><br><span class="line">        sb.append(&quot;Displayed &quot;);</span><br><span class="line">        sb.append(shortComponentName);</span><br><span class="line">        sb.append(&quot;: &quot;);</span><br><span class="line">        TimeUtils.formatDuration(thisTime, sb);</span><br><span class="line">        if (thisTime != totalTime) &#123;</span><br><span class="line">            sb.append(&quot; (total &quot;);</span><br><span class="line">            TimeUtils.formatDuration(totalTime, sb);</span><br><span class="line">            sb.append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(ActivityManagerService.TAG, sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    mStackSupervisor.reportActivityLaunchedLocked(false, this, thisTime, totalTime);</span><br><span class="line">    if (totalTime &gt; 0) &#123;</span><br><span class="line">        //service.mUsageStatsService.noteLaunchTime(realActivity, (int)totalTime);</span><br><span class="line">    &#125;</span><br><span class="line">    displayStartTime = 0;</span><br><span class="line">    stack.mLaunchStartTime = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>curTime表示该函数调用的时间点.</li>
<li>displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.</li>
<li>mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点.</li>
</ul>
<p>正常情况下点击桌面图标只启动一个有界面的 Activity，此时 displayStartTime 与mLaunchStartTime 便指向同一时间点，此时 ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的 Activity 做逻辑处理，接着又启动一个有界面的Activity，在这种启动一连串 Activity 的情况下（知乎的启动就是属于这种情况），displayStartTime 便指向最后一个 Activity 的开始启动时间点，mLaunchStartTime 指向第一个无界面Activity的开始启动时间点，此时 ThisTime！=TotalTime。这两种情况如下图：
<img src="http://images.wodekouwei.com/at-android-performance-20193514439.png" alt="at-android-performance-20193514439"></p>
<p>在上面的图中，我用①②③分别标注了三个时间段，在这三个时间段内分别干了什么事呢？</p>
<ul>
<li>在第①个时间段内，AMS 创建 ActivityRecord 记录块和选择合理的 Task、将当前Resume 的 Activity 进行 pause</li>
<li>在第②个时间段内，启动进程、调用无界面 Activity 的 onCreate() 等、 pause/finish 无界面的 Activity</li>
<li>在第③个时间段内，调用有界面 Activity 的 onCreate、onResume</li>
</ul>
<p>看到这里应该清楚 ThisTime、TotalTime、WaitTime 三个时间的关系了吧。WaitTime 就是总的耗时，包括前一个应用 Activity pause 的时间和新应用启动的时间；ThisTime 表示一连串启动 Activity 的最后一个 Activity 的启动耗时；TotalTime 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，但不包括前一个应用 Activity pause 的耗时。也就是说，开发者一般只要关心 TotalTime 即可，这个时间才是自己应用真正启动的耗时。</p>
<p>Event log中 TAG=am_activity_launch_time 中的两个值分表表示 ThisTime、TotalTime，跟通过 “adb shell am start -W ” 得到的值是一致的。</p>
<p>最后再说下系统根据什么来判断应用启动结束。我们知道应用启动包括进程启动、走 Activity生命周期 onCreate/onResume 等。在第一次 onResume 时添加窗口到WMS中，然后measure/layout/draw，窗口绘制完成后通知 WMS，WMS 在合适的时机控制界面开始显示(夹杂了界面切换动画逻辑)。记住是窗口界面显示出来后，WMS 才调用reportLaunchTimeLocked() 通知 AMS Activity 启动完成。</p>
<p>最后总结一下，如果只关心某个应用自身启动耗时，参考TotalTime；如果关心系统启动应用耗时，参考WaitTime；如果关心应用有界面Activity启动耗时，参考ThisTime。</p>
<p><strong>指标</strong></p>
<p>一般情况下，应用启动时间在1秒以内，用户反馈系统响应很快；1-3秒内完成启动，用户认为反应速度尚可；3-5秒内完成启动，用户会认为系统反应很慢，但是还可以接受；若启动时间超过5秒，则大部分用户会认为系统反应糟糕，甚至卸载应用。</p>
<p>安卓绿色联盟应用体验标准规定，应用冷启动时间应该不超过1000毫秒，热启动时间应该不超过500毫秒，若不满足，则无法获得绿色应用认证。</p>
<p>从上面的测评结果可以看出，参与测评的8款应用冷启动和热启动的时间都是非常快，也都符合安卓绿色联盟对绿色应用启动时间标准。其中QQ音乐和芒果TV的冷启动时间最为优秀，分别只有283毫秒和596毫秒。</p>
<p>Android系统上，APP无进程状态，启动流程见下：
Application的构造器方法 ——&gt;attachBaseContext() ——&gt;onCreate() ——&gt;Activity的构造方法 ——&gt;onCreate() ——&gt;配置主题中背景等属性 ——&gt;onStart() ——&gt;onResume() ——&gt;测量布局绘制显示在界面上。</p>
<p>当点击APP的启动图标时，安卓系统会从Zygote进程中fork创建出一个新的进程分配给该应用，之后会依次创建和初始化Application类、创建MainActivity类、加载主题样式Theme中的windowBackground等属性设置给MainActivity以及配置Activity层级上的一些属性、再inflate布局、当onCreate/onStart/onResume方法都走完了后最后才进行contentView的measure/layout/draw显示在界面上，所以直到这里，应用的第一次启动才算完成，这时候我们看到的界面也就是所说的第一帧。</p>
<p>启动时间:</p>
<ol>
<li>冷启动时间:当用户点击目标app图标的 timepoint到显示界面第一帧的时间段（当用户点击你的app那一刻到系统调用Activity.onCreate()之间的时间段）,在这个时间段内，WindowManager会先加载app主题样式中的windowBackground做为app的预览元素，然后再真正去加载activity的layout布局。API19 之后，系统会出打印日志输出启动的时间:冷启动时间 = 应用启动（创建进程） —&gt; 完成视图的第一次绘制（Activity内容对用户可见）；</li>
<li>热启动时间:用户把目标app切换至后台后，点击app图标的timepoint到显示界面第一帧的时间段</li>
</ol>
<p>优化建议</p>
<ol>
<li>减少Application中过多的三方SDK初始化操作，在真正使用到功能时在进行初始化操作。</li>
<li>减少首界面布局文件的层级和嵌套，来减少界面的量测和绘制的时间。</li>
<li>减少首界面oncreate()方法中的复杂逻辑和工作量，从而降低启动时间。</li>
<li>不要以静态变量的方式在Application中保存数据</li>
</ol>
<h3 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h3><p>人为感受的性能不好属于下面两种:</p>
<ol>
<li>响应时间,界面跳转后响应时间</li>
<li>流畅度,界面操作时或动画展示的效果</li>
</ol>
<p>流畅度的衡量指标:</p>
<ol>
<li>帧率fps</li>
<li>丢帧SF(Skipped frame)</li>
<li>流畅度SM(SMoothness)</li>
</ol>
<p>帧率计算:</p>
<ol>
<li><code>adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt;</code></li>
<li><code>adb shell dumpsys SurfaceFlinger --latency &lt;window_activity&gt;</code></li>
</ol>
<p><a href="https://blog.csdn.net/itfootball/article/details/43084527" target="_blank" rel="noopener">https://blog.csdn.net/itfootball/article/details/43084527</a>
<a href="https://developer.android.com/training/testing/performance?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/training/testing/performance?hl=zh-cn</a>
<a href="https://testerhome.com/topics/4441" target="_blank" rel="noopener">https://testerhome.com/topics/4441</a>
<a href="https://testerhome.com/topics/4643" target="_blank" rel="noopener">https://testerhome.com/topics/4643</a></p>
<h4 id="页面响应时间TTLB-Time-To-Last-Byte"><a href="#页面响应时间TTLB-Time-To-Last-Byte" class="headerlink" title="页面响应时间TTLB(Time To Last Byte)"></a>页面响应时间TTLB(Time To Last Byte)</h4><p>页面响应时间是指从用户发出请求到客户端收到最后一个字节所耗费的时间.</p>
<h3 id="性能案例分析"><a href="#性能案例分析" class="headerlink" title="性能案例分析"></a>性能案例分析</h3><h4 id="案例1：界面滑动卡顿"><a href="#案例1：界面滑动卡顿" class="headerlink" title="案例1：界面滑动卡顿"></a>案例1：界面滑动卡顿</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154448.jpg" alt="at-android-performance-201935154448"></p>
<p>从图中可以看到，这是一个手动滑动事件，当deliverInput事件发生后，第一帧就发生了卡顿。从systrace看UI thread执行draw的时间相当耗时导致丢帧卡顿，而且大部分时间都在做decodeBitmap，共耗时99.045ms。这时，我们打开applog发现，有StrictMode相关的错误提示，从中可以定位到耗时函数。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-20193515453.jpg" alt="at-android-performance-20193515453"></p>
<p>从上图我们看出有一个网络访问违规，大概可以推测应用在从网络上下载了一个数据流，数据流里可能包含了一些图形，通过decodeBitmap把它解析出来展示在UI界面中。正产情况下，我们应该把网络访问放在工作线程里面去处理，将数据下载完了之后再放到主线程中去展示，避免这种问题的发生。</p>
<h4 id="案例2：Strict-Mode错误提示"><a href="#案例2：Strict-Mode错误提示" class="headerlink" title="案例2：Strict Mode错误提示"></a>案例2：Strict Mode错误提示</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154542.jpg" alt="at-android-performance-201935154542">
从上图Strict Mode的日志可以看出：StrictMode policy violation耗时2秒左右。通过最下行蓝色的log，可以知道应用是在某一个目录里面寻找一个文件，判断文件是否存在。</p>
<p>面对这种问题，我们应该把IO操作放到工作线程。正常情况下IO的发生非常快，但是在系统繁忙时，IO放在主线程会产生较大的问题，因为它要等别的程序读写完成之后，才会下发，产生超时。</p>
<h4 id="案例3：GPU调用不当导致的卡顿问题"><a href="#案例3：GPU调用不当导致的卡顿问题" class="headerlink" title="案例3：GPU调用不当导致的卡顿问题"></a>案例3：GPU调用不当导致的卡顿问题</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154612.jpg" alt="at-android-performance-201935154612">
这是一个GPU的例子，上图主要问题是GPU使用了太长时间处理应用传过来的buffer,例子中Surfaceflinger 使用GPU 做了图像叠加，说明图层比较多。使用GPU做叠加主要会产生功耗和唤醒耗时的问题。大家在做界面设计的时候，尽量不要使用GPU进行叠加。在上面的例子中，GPU叠加之后，导致了大概15ms左右的延时，因为GPU操作完成以后还需要交给Surfaceflinger把图像显示到屏幕上。</p>
<h4 id="案例4：CPU调用不当导致的界面滑动卡顿问题"><a href="#案例4：CPU调用不当导致的界面滑动卡顿问题" class="headerlink" title="案例4：CPU调用不当导致的界面滑动卡顿问题"></a>案例4：CPU调用不当导致的界面滑动卡顿问题</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154711.jpg" alt="at-android-performance-201935154711">
可以通过上图的红色条块了解messageloop RunTask信息，红色条块上的蓝色bar，表示线程在CPU上的状态。蓝色表示这个线程处于等待CPU调度的状态，可见等待超过8ms的时间，是正常调度周期好几倍。导致这种情况发生的原因有两个：CPU负载过大或CPU调度出现了问题。在上图中我们可以看出，CPU0和CPU1使用率100%，但是CPU2和CPU3是offline的状态，说明系统出现问题，导致CPU2和CPU3未能唤醒，帮助完成系统任务。</p>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><h4 id="1、避免内存泄露"><a href="#1、避免内存泄露" class="headerlink" title="1、避免内存泄露"></a>1、避免内存泄露</h4><p>在应用开发过程中，首先要避免内存泄露的问题，内存泄露是一种比较严重的性能问题，在安卓绿色联盟应用性能标准中也要求应用不允许发生内存泄露。
常见内存泄露:</p>
<ol>
<li>手动关闭try/catch/finally中使用网络文件等流文件的对象,关注对象:HTTP,File, ContentProvider,Bitmap,Uri,Socket</li>
<li>注意关闭onDestroy()或者onPause()中未及时关闭对象,防止如下内存泄露:线程泄露,Handler泄露,广播泄露,第三方SDK/开源框架泄露,各种callBack/Listener的泄露</li>
</ol>
<p>常见内存泄露坚持工具:</p>
<ul>
<li>Memory Monitor</li>
<li>Allocation Tracker</li>
<li>Heap Viewer</li>
<li>LeakCanary</li>
</ul>
<h4 id="2、避免不良设计或程序算法导致CPU占有率持续偏高"><a href="#2、避免不良设计或程序算法导致CPU占有率持续偏高" class="headerlink" title="2、避免不良设计或程序算法导致CPU占有率持续偏高"></a>2、避免不良设计或程序算法导致CPU占有率持续偏高</h4><ul>
<li>主要业务处理分散到不同线程，便于后续利用多核处理器的并行处理能力，避免一核累死，7核围观；</li>
<li>使用top命令观察应用线程的CPU占有率，找出高负载的进程进行分析，并针对优化。</li>
</ul>
<h4 id="3、避免OnXXX-回调函数中进行耗时操作，避免主线程卡顿"><a href="#3、避免OnXXX-回调函数中进行耗时操作，避免主线程卡顿" class="headerlink" title="3、避免OnXXX 回调函数中进行耗时操作，避免主线程卡顿"></a>3、避免OnXXX 回调函数中进行耗时操作，避免主线程卡顿</h4><p>Android系统中正常情况下所有onXXX类函数均运行在主线程中。
两帧中间有一个因为接收广播处理导致的158ms的卡顿。在这些函数中，我们应该避免网络通信操作、文件读写操作、数据库数据改动的操作、图形处理、文本分析等操作，将这些工作尽可能的移到工作线程中去，从而避免主线程卡顿。</p>
<h4 id="4、合理使用系统资源"><a href="#4、合理使用系统资源" class="headerlink" title="4、合理使用系统资源"></a>4、合理使用系统资源</h4><p>合理使用系统资源主要指的是软资源。下图是对广播资源调用的一些建议。</p>
<ul>
<li>避免同一广播在多个不同实例中重复注册</li>
<li>对象释放时,必须保证注销广播,避免广播注册泄露</li>
<li>尽量不要过度依赖广播机制进行通信,只注册必要的广播</li>
<li>尽量不要注册使用频繁放生的系统广播</li>
<li>不高频调用系统服务接口,避免引起系统互锁造成阻塞</li>
</ul>
<h2 id="性能治理"><a href="#性能治理" class="headerlink" title="性能治理"></a>性能治理</h2><h3 id="主线程卡顿"><a href="#主线程卡顿" class="headerlink" title="主线程卡顿"></a>主线程卡顿</h3><p>主线程卡顿是因为主线程的消息超过阈值，从而导致页面丢帧。手淘通过接管主线程消息的分发机制，获取消息的分发耗时和消息类型，从而定位触发主线程卡顿的具体业务并进行针对性治理。</p>
<p>另外手淘在使用系统的SharedPreferences时，发现页面跳转导致界面ANR的情况。通过阅读系统源码，发现它在做Receiver或者Service时会强制把所有SharedPreferences apply的内容写入文档，导致ANR。针对这个问题，手淘重写SharedPreferences提升性能，减少了这类ANR问题的发生。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935222118.jpg" alt="at-android-performance-201935222118"></p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>手淘团队投入了大量时间对内存泄露进行治理。一方面通过接管系统底层组件的生命周期，当组件的生命周期销毁时，对它进行一个WeakReference的引用，然后根据GC事件触发情况来判定该对象是否泄漏。另一方面，在Native层通过Hook操作系统底层malloc和free方法，计算每一个so处理内存的情况，根据malloc与free差值大小与白名单进行对比判断是否存在内存泄露。</p>
<p>内存使用不当</p>
<p>何为内存使用不当？举个例子，当开发一个大小为100×100 view，实际却使用了200<em>200甚至更大的bitmap。比如在系统drawable目录下放置一张图片，在高清的设备上展示时，它会根据系统自身的原理对它进行拉伸。这时原本只需要单位1的内存（100</em>100），可能变成单位16的内存（400*400），内存的浪费率达到90%以上。针对这种情况，手淘做了一个内存使用不当排查插件。</p>
<p>视频也同样存这种问题，在低分辨率设备上播放高质量的视频不仅不会给用户带来更好的体验，还可能让设备出现卡顿。还有就是图片持有的问题，当页面已经沉入栈底，最好不要保留之前页面的图片。这样可以保证有足够的内存给前台页面使用，否则随着页面层级的深入，很容易出现OOM。</p>
<h3 id="资源泄露"><a href="#资源泄露" class="headerlink" title="资源泄露"></a>资源泄露</h3><p>手淘主要通过接管系统底层的open和close两个Native方法函数对资源泄露进行治理。当open和close没有成对出现，并且该业务并不是伴随整个应用生命周期（伴随整个生命周期的文件有白名单），可以判断该操作可能存在资源泄漏。平台会将该异常行为告知对应的开发同学检查和治理。数据库的治理同样也采用了这套方案。</p>
<h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><p>线程问题比较复杂。在线程创建时可能会触发一些意想不到的问题，比如Out Of Memory error。Out Of Memory error可能是由线程创建失败导致的。因此，手淘对线程创建进行了接管。业务在创建时，对它的方法调用栈进行聚类，就可以知道每个业务创建的线程数量，以及线程创建是否合理。建议应用开发者在创建线程时一定规范命名，以便快速定位具体的业务方。</p>
<h3 id="流量监控"><a href="#流量监控" class="headerlink" title="流量监控"></a>流量监控</h3><p>手淘主要是通过接管Socket协议，分析协议头部获取请求和回流数据内容的大小信息进行流量监控治理。如发现异常，可以让开发同学定位解决。同时也可以监听后台流量行为，观察APP切到后台以后是否还有大量的网络请求。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935222346.jpg" alt="at-android-performance-201935222346"></p>
<h3 id="设备评级"><a href="#设备评级" class="headerlink" title="设备评级"></a>设备评级</h3><p>安卓设备百花齐放，手淘对不同的设备采取了计分的方法进行评级，根据设备分数采用不同的策略，展示相应的图片、视频和业务，给用户带来最佳的性能体验。这个设备评级方案可以给开发同学提供指导建议，更好的展现业务形态。</p>
<h3 id="布局性能"><a href="#布局性能" class="headerlink" title="布局性能"></a>布局性能</h3><p>在开发的过程中，常常要通过HierarchyViewer的方法检查布局结构是否合理。手淘写了一套算法，检查页面结构是否合理，页面层级是否过深、页面层级是否还有继续优化的空间。同时还实现了一套OverDraw的算法，给开发同学提示具体哪个层级可以优化，怎么样的降层级，怎么样解决OverDraw的问题。</p>
<h3 id="用户体验优化"><a href="#用户体验优化" class="headerlink" title="用户体验优化"></a>用户体验优化</h3><p>手淘很关注用户的体验，包括启动时间、每个页面的打开耗时等。通过监控启动时各个子任务的耗时，以及对这些信息快速的分析，判断每一次发版质量变化的具体原因。</p>
<h3 id="4-X设备体验优化"><a href="#4-X设备体验优化" class="headerlink" title="4.X设备体验优化"></a>4.X设备体验优化</h3><p>随着产品功能越来越丰富和产品体积逐渐的壮大，4.X设备出现了multidex越来越慢的情况。基于这个现象，手淘把谷歌的support multidex包进行了重构改造。经过重构以后的support multidex方案，4.X设备的Dex加载随着Dex越来越多，它性能提升越好。</p>
<h3 id="内存容灾"><a href="#内存容灾" class="headerlink" title="内存容灾"></a>内存容灾</h3><p>内存容灾手淘一直很关注。当用户使用当前页面时，如果内存不足，手淘期望后台页面可以快速释放内存资源，为前台页面服务。手淘开发了内存容灾插件，监听JVM的GC事件以及轮寻物理页表计算实际使用物理内存，通过这个计算给手淘的业务方发送对应的内存水位事件，如果是属于非常高危的内存事件，就可以让后台快速的释放缓存资源，从而为可视的页面提供更好的服务</p>
<h2 id="稳定性治理"><a href="#稳定性治理" class="headerlink" title="稳定性治理"></a>稳定性治理</h2><p>稳定性的治理主要是两部分，Java Crash和Native Crash
<img src="http://images.wodekouwei.com/at-android-performance-201935222554.jpg" alt="at-android-performance-201935222554"></p>
<h3 id="Java-Crash治理"><a href="#Java-Crash治理" class="headerlink" title="Java Crash治理"></a>Java Crash治理</h3><p>手淘通过接管UncaughtExceptionHandler，拿到具体的Java Crash的信息及它的堆栈来进行Java Crash治理。Java Crash治理还有一个经常遇到的OOM的情况，一方面可能是虚拟机的内存不足导致的，另一方面可能是线程创建失败导致的，可以使用前面讲到的线程创建插件解决。</p>
<h3 id="Native-Crash治理"><a href="#Native-Crash治理" class="headerlink" title="Native Crash治理"></a>Native Crash治理</h3><p>手淘通过捕获信号量的方式对Native Crash进行治理。当Native发生异常时，创建一个子进程，通过ptrace的方式去dump Native Crash上下文的线程信息。 基于前面讲到的性能治理方式，OOM的Native Crash可以通过malloc和free的接管，定位具体是哪个SO导致这个问题的发生并进行治理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/01/18/l-python-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/18/l-python-basic/" itemprop="url">
                  python之基础语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T16:29:11+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="python清空列表"><a href="#python清空列表" class="headerlink" title="python清空列表"></a>python清空列表</h6><ol>
<li>在非函数参数的list中使用<code>del list_new[]</code>或者<code>list_new = []</code>来清空列表</li>
<li>对于作为函数中的list,方法1行不通,因为函数执行后,list长度是不变的,但是可以在函数中释放一个参数list所占内存:<code>del list_new[:]</code>或者<code>list_new[:] = []</code>达到清空列表的目的,速度快,并且彻底</li>
</ol>
<h6 id="查看对象占用内存大小"><a href="#查看对象占用内存大小" class="headerlink" title="查看对象占用内存大小"></a>查看对象占用内存大小</h6><p>os.getsizeof(1.0)</p>
<h6 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">    import math</span><br><span class="line">    print(&quot;1000.003 is %s&quot; %(int(struct.pack(&apos;&gt;f&apos;, 1000.003).encode(&apos;hex&apos;), 16)))</span><br><span class="line">    print(&quot;1000.003 is %s&quot; %(struct.pack(&apos;&gt;I&apos;, 1000)))</span><br><span class="line">    #print(&quot;1000.003 is %d&quot; %(int(floor(1000.003))))</span><br></pre></td></tr></table></figure>

<p>IEEE 754标准是IEEE二进制浮点数算术标准(IEEE Standard for Floating-Point Arithmetic)的标准编号,它规定了浮点数在计算机当中的存储方式以及算术标准.
计算机中数据均是按二进制的方式存储的,浮点数的存储也是如此.但是由于浮点数的特殊性,无法采用整数的补码存储方式,浮点数需要有特定的存储方式.一个浮点数可以分成3部分存储:</p>
<ul>
<li>sign(符号)</li>
<li>exponent(指数)</li>
<li>fraction(尾数)</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/IEEE_754-1985" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/IEEE_754-1985</a></p>
<h6 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h6><p>本地模块名和系统库模块名冲突报:
ImportError: cannot import name AttrItem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import configparser </span><br><span class="line">print configparser.__file__</span><br></pre></td></tr></table></figure>

<p>自定义configparser与系统冲突,通过打印<strong>file</strong>查看</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/01/17/l-python-method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/17/l-python-method/" itemprop="url">
                  python之函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-17T12:15:33+08:00">
                2019-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul>
<li>位置参数: <code>def power(x):</code></li>
<li>默认参数: <code>def power(x, n=2):</code> 默认参数必须指向不变对象！</li>
<li>可变参数: <code>def calc(*numbers):</code></li>
<li>关键字参数: <code>def person(name, age, **kw):</code></li>
<li>命名关键字参数:<code>def person(name, age, *, city, job):</code></li>
</ul>
<p>参数组合:
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</p>
<p>递归及尾递归优化</p>
<p>切片</p>
<p>迭代 
默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。
通过collections模块的Iterable类型判断一个对象是否可迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure>

<p>列表生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list(range(1, 11))</span><br><span class="line">[x * x for x in range(1, 11)]</span><br><span class="line">[x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录</span><br><span class="line">[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]</span><br><span class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">[&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</span><br></pre></td></tr></table></figure>

<p>生成器：generator 不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制
方法一:只要把一个列表生成式的[]改成()，就创建了一个generator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure>

<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">49</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">81</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：
函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>
<p>迭代器</p>
<p>高阶函数
map/reduce
map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<p>filter: 用于过滤序列</p>
<p>sorted: 对list进行排序</p>
<p>返回函数</p>
<p>匿名函数</p>
<p>装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>

<p>偏函数
functools.partial</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/01/17/l-python-class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/17/l-python-class/" itemprop="url">
                  python之面向对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-17T10:48:57+08:00">
                2019-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h6><p>限制类的绑定属性</p>
<p><code>__str__</code>: print打印对象,返回用户看到的字符串
<code>__repr__</code>:返回程序开发者看到的字符串,如直接输入变量,是为调试服务的 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __str__(self):</span><br><span class="line">    return &apos;Student object (name: %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">print(Student(&apos;hell0&apos;))</span><br></pre></td></tr></table></figure>

<p>可以直接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__repr = __str__</span><br></pre></td></tr></table></figure>

<p><code>__iter__</code>: 一个类用于for…in循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    </span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a+self.b</span><br><span class="line">        if self.a &gt; 100000:</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a</span><br><span class="line"></span><br><span class="line">for n in Fib():</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>

<p><code>__getitem__</code>:Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Fib()[5]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;Fib&apos; object does not support indexing</span><br></pre></td></tr></table></figure>

<p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        a, b = 1, 1</span><br><span class="line">        for x in range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure>

<p>但是list有个神奇的切片方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(100))[5:10]</span><br></pre></td></tr></table></figure>

<p>对于Fib却报错,原因是<strong>getitem</strong>()传入的参数可能是一个int,也可能是一个切片对象slice,所以要做判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def __getitem__(self, n):</span><br><span class="line">        if isinstance(n, int): # n是索引</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            for x in range(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return a</span><br><span class="line">        if isinstance(n, slice): # n是切片</span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            if start is None:</span><br><span class="line">                start = 0</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            L = []</span><br><span class="line">            for x in range(stop):</span><br><span class="line">                if x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return L</span><br></pre></td></tr></table></figure>

<p>但是现在没有对step参数处理f[:10:2],也没有对负数做处理
此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。
与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。
总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<p><code>__getattr__</code>:动态返回一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;Michael&apos;</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr==&apos;score&apos;:</span><br><span class="line">            return 99</span><br></pre></td></tr></table></figure>

<p>当调用不存在的属性时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值：
注意，只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性，比如name，不会在<strong>getattr</strong>中查找</p>
<p><code>__call__</code>:一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。</p>
<p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。请看示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&apos;My name is %s.&apos; % self.name)</span><br></pre></td></tr></table></figure>

<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student(&apos;Michael&apos;)</span><br><span class="line">&gt;&gt;&gt; s() # self参数不要传入</span><br><span class="line">My name is Michael.</span><br></pre></td></tr></table></figure>

<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; callable(Student())</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable(max)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable([1, 2, 3])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(None)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(&apos;str&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</span><br><span class="line"></span><br><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)</span><br></pre></td></tr></table></figure>

<p>value属性则是自动赋给成员的int常量，默认从1开始计数。
如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br></pre></td></tr></table></figure>

<p>@unique装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; day1 = Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Mon)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Tue)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(Weekday(1))</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday(1))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Weekday(7)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: 7 is not a valid Weekday</span><br><span class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</span><br><span class="line">...     print(name, &apos;=&gt;&apos;, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/01/15/evn-mac-vscode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/15/evn-mac-vscode/" itemprop="url">
                  vscode使用技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-15T10:31:09+08:00">
                2019-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/env/" itemprop="url" rel="index">
                    <span itemprop="name">env</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="设置隐藏文件"><a href="#设置隐藏文件" class="headerlink" title="设置隐藏文件"></a>设置隐藏文件</h3><p>用于在资源管理器隐藏固定后缀的文件,配置方式:</p>
<ol>
<li>首选项-&gt;设置</li>
<li>搜索files.exclude,选择工作区设置</li>
<li>添加模式:<code>**/*.pyc</code></li>
</ol>
<h2 id="Creating-your-own-snippets"><a href="#Creating-your-own-snippets" class="headerlink" title="Creating your own snippets"></a>Creating your own snippets</h2><p>既然你点开了这个页面，那就说明要么你不知道 VSCode 上已有拓展「C/C++ Snippets」，要么你对这个拓展不甚满意。对于后者，本文将为你介绍如何在 VSCode 上设置 snippets，并为你提供一套可以直接用的 C 语言 snippets。</p>
<h3 id="1-snippet-简介"><a href="#1-snippet-简介" class="headerlink" title="1. snippet 简介"></a>1. snippet 简介</h3><p>snippet[ˈsnɪpɪt]，或者说「code snippet」，也即代码段，指的是能够帮助输入重复代码模式，比如循环或条件语句，的模板。通过 snippet ，我们仅仅输入一小段字符串，就可以在代码段引擎的帮助下，生成预定义的模板代码，接着我们还可以通过在预定义的光标位置之间跳转，来快速补全模板。</p>
<p>当然，看图更易懂。下图将 aja 补全为 JQuery 的 ajax() 方法，并通过光标的跳转，快速补全了待填键值对：
<img src="https://code.visualstudio.com/assets/docs/editor/userdefinedsnippets/ajax-snippet.gif" alt="image"></p>
<h3 id="2-snippet-配置流程"><a href="#2-snippet-配置流程" class="headerlink" title="2. snippet 配置流程"></a>2. snippet 配置流程</h3><p>进入 snippet 设置文件，这里提供了三种方法： 
通过快捷键「Ctrl + Shift + P」打开命令窗口（All Command Window），输入「snippet」，点选「首选项：配置用户代码段片段」；
点击界面最左侧竖栏（也即活动栏）最下方的齿轮按钮，在弹出来的菜单中点选「用户代码片段」；
按下「Alt」键切换菜单栏，通过文件 &gt; 首选项 &gt; 用户代码片段；
填写 snippets</p>
<h3 id="3-snippet-详细介绍"><a href="#3-snippet-详细介绍" class="headerlink" title="3. snippet 详细介绍"></a>3. snippet 详细介绍</h3><h4 id="3-1-引子"><a href="#3-1-引子" class="headerlink" title="3.1 引子"></a>3.1 引子</h4><p>设置文件头部的一个块注释给出了设置 snippet 的格式，了解过「json」就不会对此感到奇怪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Place your snippets for C here. Each snippet is defined under a snippet name and has a prefix, body and </span><br><span class="line"> // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><br><span class="line"> // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span><br><span class="line"> // same ids are connected.</span><br><span class="line"> // Example:</span><br><span class="line"> &quot;Print to console&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &quot;log&quot;,,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &quot;console.log(&apos;$1&apos;);&quot;,</span><br><span class="line">        &quot;$2&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;description&quot;: &quot;Log output to console&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例定义了一个名为「Print to console」的 snippet，其功能为：在输入 log 并确认后，可将原文本替换为console.log(‘’);</p>
<h4 id="3-2-语法结构"><a href="#3-2-语法结构" class="headerlink" title="3.2 语法结构"></a>3.2 语法结构</h4><p>然而引子中只是最简单的功能，而 VSCode 的代码段引擎所能做的远不止这些。本文将以官方教程1为本，对其进行详实地阐述。</p>
<p>snippet 由三部分组成：</p>
<ol>
<li>prefix：前缀，定义了 snippets 从 IntelliSense 中呼出的关键字;</li>
<li>body： 主体，即模板的主体内容，其中每个字符串表示一行;</li>
<li>description：说明，会在 IntelliSense 候选栏中出现。未定义的情况下直接显示对象名，上例中将会显示 Print to console。
Snippet 的三个部分目前只有主体部分支持丰富的特性。接下来整篇文章都是拿来介绍主体部分的。主体部分的介绍将分为两部分：较为直接的基础用法，及结合正则表达式的高级用法。</li>
</ol>
<h4 id="3-3-Body-基本用法"><a href="#3-3-Body-基本用法" class="headerlink" title="3.3 Body - 基本用法"></a>3.3 Body - 基本用法</h4><p>主体部分可以使用特殊语法结构，来控制光标和要插入的文本，其支持的基本结构如下：</p>
<ol>
<li><p>Tabstops：制表符 
用「Tabstops」可以让编辑器的指针在 snippet 内跳转。使用 $1，$2 等指定光标位置。这些数字指定了光标跳转的顺序。特别地，$0表示最终光标位置。相同序号的「Tabstops」被链接在一起，将会同步更新，比如下列用于生成头文件封装的 snippet 被替换到编辑器上时，光标就将同时出现在所有$1位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;#ifndef $1&quot;</span><br><span class="line">&quot;#define $1&quot;</span><br><span class="line">&quot;#end // $1&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Placeholders：占位符 
「Placeholder」是带有默认值的「Tabstops」，如${1：foo}。「placeholder」文本将被插入「Tabstops」位置，并在跳转时被全选，以方便修改。占位符还可以嵌套，例如${1:another ${2:placeholder}}。
比如，结构体的 snippet 主体可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct $&#123;1:name_t&#125; &#123;\n\t$2\n&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>作为「Placeholder」的name_t一方面可以提供默认的结构名称，另一方面可以作为输入的提示。</p>
<ol start="3">
<li><p>Choice：可选项
「Choice」是提供可选值的「Placeholder」。其语法为一系列用逗号隔开，并最终被两个竖线圈起来的枚举值，比如 ${1|one,two,three|}。当光标跳转到该位置的时候，用户将会被提供多个值（one 或 two 或 three）以供选择。</p>
</li>
<li><p>Variables：变量
使用$name或${name:default}可以插入变量的值。当变量未赋值时（如），将插入其缺省值或空字符串。 当varibale未知（即，其名称未定义）时，将插入变量的名称，并将其转换为「Placeholder」。可以使用的「Variable」如下：</p>
</li>
</ol>
<ul>
<li><p>TM_SELECTED_TEXT：当前选定的文本或空字符串； </p>
</li>
<li><p>注：选定后通过在命令窗口点选「插入代码片段」插入。</p>
</li>
<li><p>TM_CURRENT_LINE：当前行的内容；</p>
</li>
<li><p>TM_CURRENT_WORD：光标所处单词或空字符串 </p>
</li>
<li><p>注：所谓光标一般为文本输入处那条闪来闪去的竖线，该项可定制。单词使用 VSCode 选词（Word Wrap）器选择。你最好只用它选择英文单词，因为这个选择器明显没有针对宽字符优化过，它甚至无法识别宽字符的标点符号。</p>
</li>
<li><p>TM_LINE_INDEX：行号（从零开始）；</p>
</li>
<li><p>TM_LINE_NUMBER：行号（从一开始）；</p>
</li>
<li><p>TM_FILENAME：当前文档的文件名；</p>
</li>
<li><p>TM_FILENAME_BASE：当前文档的文件名（不含后缀名）；</p>
</li>
<li><p>TM_DIRECTORY：当前文档所在目录；</p>
</li>
<li><p>TM_FILEPATH：当前文档的完整文件路径；</p>
</li>
<li><p>CLIPBOARD：当前剪贴板中内容。
此外，还有一些用于插入当前时间的变量，这里单独列出：</p>
</li>
<li><p>CURRENT_YEAR: 当前年份；</p>
</li>
<li><p>CURRENT_YEAR_SHORT: 当前年份的后两位；</p>
</li>
<li><p>CURRENT_MONTH: 格式化为两位数字的当前月份，如 02；</p>
</li>
<li><p>CURRENT_MONTH_NAME: 当前月份的全称，如 July；</p>
</li>
<li><p>CURRENT_MONTH_NAME_SHORT: 当前月份的简称，如 Jul；</p>
</li>
<li><p>CURRENT_DATE: 当天月份第几天；</p>
</li>
<li><p>CURRENT_DAY_NAME: 当天周几，如 Monday；</p>
</li>
<li><p>CURRENT_DAY_NAME_SHORT: 当天周几的简称，如 Mon；</p>
</li>
<li><p>CURRENT_HOUR: 当前小时（24 小时制）；</p>
</li>
<li><p>CURRENT_MINUTE: 当前分钟；</p>
</li>
<li><p>CURRENT_SECOND: 当前秒数。
注：这些都是变量名，不是宏，在实际使用的时要加上 $ 符。</p>
</li>
</ul>
<h4 id="3-4-Body-高级语法"><a href="#3-4-Body-高级语法" class="headerlink" title="3.4 Body - 高级语法"></a>3.4 Body - 高级语法</h4><h5 id="3-4-1-变量转换"><a href="#3-4-1-变量转换" class="headerlink" title="3.4.1 变量转换"></a>3.4.1 变量转换</h5><p>变量转换可将变量的值格式化处理后插入预定的位置。</p>
<h6 id="3-4-1-1-语法结构"><a href="#3-4-1-1-语法结构" class="headerlink" title="3.4.1.1 语法结构"></a>3.4.1.1 语法结构</h6><p>我们可以通过 ${var_name/regular_expression/format_string/options} 插入格式化后的代码段。显然，「variable transformations」由 4 部分构成：</p>
<ol>
<li>var_name：变量名；</li>
<li>regular_expression：正则表达式；</li>
<li>format_string：格式串；</li>
<li>options：正则表达式匹配选项。
其中正则表达式的写法和匹配选项部分不在本篇博文的讲解范围之内，具体内容请分别参考 javascript 有关 RegExp(pattern [, flags]) 构造函数中的 pattern 及 flags 参数项的说明2。</li>
</ol>
<p>本文只对 format_string 部分进行详细介绍。</p>
<h6 id="3-4-1-2-format-string-部分"><a href="#3-4-1-2-format-string-部分" class="headerlink" title="3.4.1.2 format_string 部分"></a>3.4.1.2 format_string 部分</h6><p>根据其 EBNF 范式，我们可以知道 format_string 其实是 format 或 text 的线性组合：</p>
<ol>
<li>text：也即没有任何作用的普通文本，你甚至可以使用汉字；</li>
<li>format：格式串，分为 7 种： </li>
</ol>
<ul>
<li>$sn：表示插入匹配项；</li>
<li>${sn}：同 $sn；</li>
<li>${sn:/upcase} 或 ${sn:/downcase} 或 ${sn:/capitalize}：表示将匹配项变更为「所有字母均大写/所有字母均小写/首字母大写其余小写」后，插入；</li>
<li>${sn:+if}：表示当匹配成功时，并且捕捉括号捕捉特定序号的捕捉项成功时，在捕捉项位置插入「if」所述语句；</li>
<li>${sn:?if:else}：表示当匹配成功，并且捕捉括号捕捉特定序号的捕捉项成功时，在捕捉项位置插入「if」所述语句；否则当匹配成功，但当捕捉括号捕捉特定序号的捕捉项失败时，在捕捉项位置插入「else」所述语句；</li>
<li>${sn:-else}：表示当匹配成功，但当捕捉括号捕捉特定序号的捕捉项失败时，在捕捉项位置插入「else」所述语句；</li>
<li>${sn:else}：同 ${sn:-else}。
format 的后三条理解起来可能比较困难。这里我们以倒数第三条为例进行说明。假设我们有一个「make.c」文件，我们有这么一条 snippet: “body”: “${TM_FILENAME/make.c(pp|++)?/${1:?c++:clang}/}”。整个模式串匹配成功，但是捕捉括号捕捉后缀名中的 pp 或 ++ 失败，因此判断条件在捕捉括号的位置插入捕捉失败时应插入的字符串，也即「clang」。<blockquote>
<p>注：
其中 sn 表示捕捉项的序号
其中 if 表示捕捉项捕捉成功时替换的文本
其中 else 表示捕捉项捕失败时替换的文本</p>
</blockquote>
</li>
</ul>
<h6 id="3-4-1-3-案例分析"><a href="#3-4-1-3-案例分析" class="headerlink" title="3.4.1.3 案例分析"></a>3.4.1.3 案例分析</h6><p>下面笔者再介绍一个简单的例子，帮助大家理解「variable transformations」。</p>
<p>假设有一个名为「make.c」的文件中，并且我们已经定义如下 snippet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;#ifndef HEADER … #define … #endif&quot;:&#123;</span><br><span class="line">&quot;prefix&quot;: &quot;defheader&quot;,</span><br><span class="line">&quot;body&quot;: &quot;#ifndef $&#123;1:$&#123;TM_FILENAME/(.*)\\.C$/$&#123;1:/upcase&#125;_H/i&#125;&#125; \n#define $1 \n$&#123;2:header content&#125;\n#endif\t// $1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最复杂的模式为：${1:${TM_FILENAME/(.*)\.C$/${1:/upcase}_H/i}}，我们将之拆解为如下五部分： </p>
<ol>
<li>${1:…}：嵌套的 placeholder； </li>
<li>${TM_FILENAM/…/…/.}：「variable transformations」中的「var_name」，表示带后缀的文件名； </li>
<li>${…/(.*)\.C$/…/.}：「variable transformations」中的「regular_expression」，表示匹配任意以「.C」为后缀的字符串； </li>
<li>${…/…/${1:/upcase}_H/.}}：「variable transformations」中的「options」，表示将第一个捕捉项替换为大写的，并添加「_H」的后缀； </li>
<li>${…/…/…/i}：「variable transformations」中的「options」，表示无视大小写。</li>
</ol>
<h5 id="3-4-2-占位符转换"><a href="#3-4-2-占位符转换" class="headerlink" title="3.4.2 占位符转换"></a>3.4.2 占位符转换</h5><h6 id="3-4-2-1-语法结构"><a href="#3-4-2-1-语法结构" class="headerlink" title="3.4.2.1 语法结构"></a>3.4.2.1 语法结构</h6><p>我们可以通过 ${int/regular_expression/format_string/options} 插入格式化后的代码段。显然，与变量转换，「placeholder transformations」也由 4 部分构成：</p>
<ol>
<li>int：占位符相应光标序号；</li>
<li>regular_expression：正则表达式；</li>
<li>format_string：格式串；</li>
<li>options：正则表达式匹配选项。
上述全部内容我们都在前文介绍过了，因此此处不做赘述。我们唯一需要关注的是转换触发的时机：占位符转换将在进行占位符跳转（假设 1→2）的时候自动适用到当前占位符（1）。</li>
</ol>
<h6 id="3-4-2-2-案例分析"><a href="#3-4-2-2-案例分析" class="headerlink" title="3.4.2.2 案例分析"></a>3.4.2.2 案例分析</h6><p>假设我们已经这样的 Snippet：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;HelloWorld&quot;: &#123;</span><br><span class="line">  &quot;prefix&quot;: &quot;say_hello&quot;,</span><br><span class="line">  &quot;body&quot;: &quot;$&#123;1&#125; $&#123;2&#125; -&gt; $&#123;1/Hello/Hallo/&#125; $&#123;2/World/Welt/&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们在两个制表位同时键入 Hello 并跳转的时候，第一个制表位依然保持 Hello 不变，而第二个制表位（占位符）被替换为 Hallo。键入 Welt 亦然。</p>
<h4 id="3-5-语法定义"><a href="#3-5-语法定义" class="headerlink" title="3.5 语法定义"></a>3.5 语法定义</h4><p>官网给出了 snippet 的 EBNF 范式的正则文法，注意，作普通字符使用时，$ , } 和 \ 可使用 \（反斜杠）转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">any         ::= tabstop | placeholder | choice | variable | text</span><br><span class="line">tabstop     ::= &apos;$&apos; int</span><br><span class="line">                | &apos;$&#123;&apos; int &apos;&#125;&apos;</span><br><span class="line">                | &apos;$&#123;&apos; int  transform &apos;&#125;&apos;</span><br><span class="line">placeholder ::= &apos;$&#123;&apos; int &apos;:&apos; any &apos;&#125;&apos;</span><br><span class="line">choice      ::= &apos;$&#123;&apos; int &apos;|&apos; text (&apos;,&apos; text)* &apos;|&#125;&apos;</span><br><span class="line">variable    ::= &apos;$&apos; var | &apos;$&#123;&apos; var &apos;&#125;&apos;</span><br><span class="line">                | &apos;$&#123;&apos; var &apos;:&apos; any &apos;&#125;&apos;</span><br><span class="line">                | &apos;$&#123;&apos; var transform &apos;&#125;&apos;</span><br><span class="line">transform   ::= &apos;/&apos; regex &apos;/&apos; (format | text)+ &apos;/&apos; options</span><br><span class="line">format      ::= &apos;$&apos; int | &apos;$&#123;&apos; int &apos;&#125;&apos;</span><br><span class="line">                | &apos;$&#123;&apos; int &apos;:&apos; &apos;/upcase&apos; | &apos;/downcase&apos; | &apos;/capitalize&apos; &apos;&#125;&apos;</span><br><span class="line">                | &apos;$&#123;&apos; int &apos;:+&apos; if &apos;&#125;&apos;</span><br><span class="line">                | &apos;$&#123;&apos; int &apos;:?&apos; if &apos;:&apos; else &apos;&#125;&apos;</span><br><span class="line">                | &apos;$&#123;&apos; int &apos;:-&apos; else &apos;&#125;&apos; | &apos;$&#123;&apos; int &apos;:&apos; else &apos;&#125;&apos;</span><br><span class="line">regex       ::= JavaScript Regular Expression value (ctor-string)</span><br><span class="line">options     ::= JavaScript Regular Expression option (ctor-options)</span><br><span class="line">var         ::= [_a-zA-Z] [_a-zA-Z0-9]*</span><br><span class="line">int         ::= [0-9]+</span><br><span class="line">text        ::= .*</span><br></pre></td></tr></table></figure>

<h3 id="4-一些建议"><a href="#4-一些建议" class="headerlink" title="4. 一些建议"></a>4. 一些建议</h3><p>默认情况下 snippet 在 IntelliSense 中的显示优先级并不高，而且在 IntelliSense 中选择相应 snippet 需要按「enter」键，这对于手指短的人来说并不是什么很好的体验。</p>
<p>所幸，VSCode 意识到了这一点，并为我们提供了改进的方式。我们可以在 VSCode 的用户设置（「Ctrl+P」在输入框中写「user settings」后点选）中，检索代码段，然后根据提示修改代码段的相关设置。</p>
<p>我们可以设置在 IntelliSense 中优先显示代码段，并可以通过「TAB」补全。</p>
<p>修改后设置文件中会多出这两行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;editor.snippetSuggestions&quot;: &quot;top&quot;,</span><br><span class="line">&quot;editor.tabCompletion&quot;: true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考:<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank" rel="noopener">https://code.visualstudio.com/docs/editor/userdefinedsnippets</a>
<a href="https://blog.csdn.net/maokelong95/article/details/54379046?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/maokelong95/article/details/54379046?utm_source=blogxgwz0</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg" alt="轻口味">
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">190</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </div></footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
