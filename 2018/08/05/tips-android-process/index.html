<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,tips," />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="正常情况下，一个apk启动后只会运行在一个进程中，其进程名为AndroidManifest.xml文件中指定的应用包名，所有的基本组件都会在这个进程中运行。但是如果需要将某些组件（如Service、Activity等）运行在单独的进程中，就需要用到android:process属性了。我们可以为android的基础组件指定process属性来指定它们运行在指定进程中。 默认情况下，同一应用的所有组">
<meta name="keywords" content="Android,tips">
<meta property="og:type" content="article">
<meta property="og:title" content="Android应用内多进程">
<meta property="og:url" content="http://wodekouwei.com/2018/08/05/tips-android-process/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta property="og:description" content="正常情况下，一个apk启动后只会运行在一个进程中，其进程名为AndroidManifest.xml文件中指定的应用包名，所有的基本组件都会在这个进程中运行。但是如果需要将某些组件（如Service、Activity等）运行在单独的进程中，就需要用到android:process属性了。我们可以为android的基础组件指定process属性来指定它们运行在指定进程中。 默认情况下，同一应用的所有组">
<meta property="og:image" content="http://images.wodekouwei.com/tips-android-process-201938151316.png">
<meta property="og:image" content="http://images.wodekouwei.com/tips-android-process-201938104639.png">
<meta property="og:image" content="http://images.wodekouwei.com/tips-android-process-201938104833.png">
<meta property="og:updated_time" content="2019-03-08T08:28:33.453Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android应用内多进程">
<meta name="twitter:description" content="正常情况下，一个apk启动后只会运行在一个进程中，其进程名为AndroidManifest.xml文件中指定的应用包名，所有的基本组件都会在这个进程中运行。但是如果需要将某些组件（如Service、Activity等）运行在单独的进程中，就需要用到android:process属性了。我们可以为android的基础组件指定process属性来指定它们运行在指定进程中。 默认情况下，同一应用的所有组">
<meta name="twitter:image" content="http://images.wodekouwei.com/tips-android-process-201938151316.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/2018/08/05/tips-android-process/"/>





  <title> Android应用内多进程 | 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/08/05/tips-android-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android应用内多进程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-05T05:14:39+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2018/08/05/tips-android-process/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>正常情况下，一个apk启动后只会运行在一个进程中，其进程名为AndroidManifest.xml文件中指定的应用包名，所有的基本组件都会在这个进程中运行。但是如果需要将某些组件（如Service、Activity等）运行在单独的进程中，就需要用到android:process属性了。我们可以为android的基础组件指定process属性来指定它们运行在指定进程中。</p>
<p>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。</p>
<p>各类组件元素的清单文件条目—<code>&lt;activity&gt;、&lt;service&gt;、&lt;receiver&gt; 和 &lt;provider&gt;</code>—均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。</p>
<p>此外，<code>&lt;application&gt;</code> 元素还支持 android:process 属性，以设置适用于所有组件的默认值。</p>
<p>如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。</p>
<p>决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 的进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面，我们介绍决定终止进程所用的规则。</p>
<h4 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h4><p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。</p>
<p>重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：</p>
<h5 id="前台进程"><a href="#前台进程" class="headerlink" title="前台进程"></a>前台进程</h5><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p>
<ul>
<li>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</li>
<li>托管某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>托管正在“前台”运行的 Service（服务已调用 startForeground()）</li>
<li>托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>托管正执行其 onReceive() 方法的 BroadcastReceiver
通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</li>
</ul>
<h5 id="可见进程"><a href="#可见进程" class="headerlink" title="可见进程"></a>可见进程</h5><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</p>
<ul>
<li>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</li>
<li>托管绑定到可见（或前台）Activity 的 Service。
可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</li>
</ul>
<h5 id="服务进程"><a href="#服务进程" class="headerlink" title="服务进程"></a>服务进程</h5><p>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
<h5 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h5><p>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。</p>
<h5 id="空进程"><a href="#空进程" class="headerlink" title="空进程"></a>空进程</h5><p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<p>根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 Activity，则会将此进程评定为可见进程，而不是服务进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h4 id="线程安全方法"><a href="#线程安全方法" class="headerlink" title="线程安全方法"></a>线程安全方法</h4><p>在某些情况下，您实现的方法可能会从多个线程调用，因此编写这些方法时必须确保其满足线程安全的要求。</p>
<p>这一点主要适用于可以远程调用的方法，如绑定服务中的方法。如果对 IBinder 中所实现方法的调用源自运行 IBinder 的同一进程，则该方法在调用方的线程中执行。但是，如果调用源自其他进程，则该方法将在从线程池选择的某个线程中执行（而不是在进程的 UI 线程中执行），线程池由系统在与 IBinder 相同的进程中维护。 例如，即使服务的 onBind() 方法将从服务进程的 UI 线程调用，在 onBind() 返回的对象中实现的方法（例如，实现 RPC 方法的子类）仍会从线程池中的线程调用。 由于一个服务可以有多个客户端，因此可能会有多个池线程在同一时间使用同一 IBinder 方法。因此，IBinder 方法必须实现为线程安全方法。</p>
<p>同样，内容提供程序也可接收来自其他进程的数据请求。尽管 ContentResolver 和 ContentProvider 类隐藏了如何管理进程间通信的细节，但响应这些请求的 ContentProvider 方法（query()、insert()、delete()、update() 和 getType() 方法）将从内容提供程序所在进程的线程池中调用，而不是从进程的 UI 线程调用。 由于这些方法可能会同时从任意数量的线程调用，因此它们也必须实现为线程安全方法。</p>
<h4 id="多进程好处"><a href="#多进程好处" class="headerlink" title="多进程好处"></a>多进程好处</h4><p> 一般来说，Android应用多进程有三个好处。</p>
<ol>
<li>我们知道Android系统对每个应用进程的内存占用是有限制的，而且占用内存越大的进程，通常被系统杀死的可能性越大。让一个组件运行在单独的进程中，可以减少主进程所占用的内存，降低被系统杀死的概率.</li>
<li>如果子进程因为某种原因崩溃了，不会直接导致主程序的崩溃，可以降低我们程序的崩溃率。</li>
<li>即使主进程退出了，我们的子进程仍然可以继续工作，假设子进程是推送服务，在主进程退出的情况下，仍然能够保证用户可以收到推送消息。</li>
</ol>
<p>在Android中，虚拟机分配给各个进程的运行内存是有限制值的（这个值可以是32M，48M，64M等，根据机型而定），试想一下，如果在app中，增加了一个很常用的图片选择模块用于上传图片或者头像，加载大量Bitmap会使app的内存占用迅速增加，如果你还把查看过的图片缓存在了内存中，那么OOM的风险将会大大增加，如果此时还需要使用WebView加载一波网页，我就问你怕不怕！</p>
<h4 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h4><p> 我们已经开启了应用内多进程，那么，开启多进程是不是只是我们看到的这么简单呢？其实这里面会有一些陷阱，稍微不注意就会陷入其中。我们首先要明确的一点是进程间的内存空间时不可见的。从而，开启多进程后，我们需要面临这样几个问题：</p>
<ol>
<li>所有运行在不同的进程中的四大组件,只要它们之间需要通过内存来共享数据,都会共享失败</li>
<li>Application的多次重建。</li>
<li>线程同步机制完全失效(不同的进程的锁都不是同一个对象)</li>
<li>静态成员和单例模式完全失效(不同进程的内存区域都不一样了)</li>
<li>SharedPreferce的可靠性下降(SharedPreference底层是读写xml文件实现的,系统对它的读写有一定的缓存策略,在内存中会有一份SharedPreferce文件的缓存,所以多个进程并发写操作可能导致数据丢失)</li>
<li>断点调试问题。</li>
</ol>
<p>多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等。在多线程的情况下我们有锁机制控制资源的共享，但是在多进程中比较难，虽然有文件锁、排队等机制，但是在Android里很难实现。解决办法就是多进程的时候不并发访问同一个文件，比如子进程涉及到操作数据库，就可以考虑调用主进程进行数据库的操作。</p>
<p>调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。不过可以通过下面的方式实现：调试时去掉AndroidManifest.xml中android:process标签，这样保证调试状态下是在同一进程中，堆栈信息是连贯的。待调试完成后，再将标签复原。</p>
<h4 id="process属性的设置有两种形式"><a href="#process属性的设置有两种形式" class="headerlink" title="process属性的设置有两种形式"></a>process属性的设置有两种形式</h4><p>第一种形式如 android:process=”:remote”，以冒号开头，冒号后面的字符串原则上是可以随意指定的。如果我们的包名为“com.example.processtest”，则实际的进程名为“com.example.processtest:remote”。这种设置形式表示该进程为当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中。</p>
<p>第二种情况如 android:process=”com.example.processtest.remote”，以小写字母开头，表示运行在一个以这个名字命名的全局进程中，其他应用通过设置相同的ShareUID可以和它跑在同一个进程。</p>
<h4 id="线程与进程区别"><a href="#线程与进程区别" class="headerlink" title="线程与进程区别"></a>线程与进程区别</h4><p>进程是系统进行资源分配和调度的一个独立单位。
线程是进程的一个实体，是CPU调度和分配的基本单位，是比进程更小的能独立运行的基本单位，线程本身不拥有系统资源（除了必不可少的资源如程序计数器、寄存器、栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
主要差别在于是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的健壮，但是多进程在切换时，资源耗费大，效率要差。</p>
<h3 id="查看当前手机中进程方式"><a href="#查看当前手机中进程方式" class="headerlink" title="查看当前手机中进程方式"></a>查看当前手机中进程方式</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>各列参数意义：</p>
<ul>
<li>USER 进程当前用户；</li>
<li>PID Process ID，进程ID；</li>
<li>PPID Process Parent ID，进程的父进程ID；</li>
<li>VSIZE Virtual Size，进程的虚拟内存大小；</li>
<li>RSS Resident Set Size，实际驻留”在内存中”的内存大小；</li>
<li>WCHAN 休眠进程在内核中的地址；</li>
<li>PC Program Counter；</li>
<li>NAME 进程名；</li>
</ul>
<h4 id="oom-adj"><a href="#oom-adj" class="headerlink" title="oom_adj"></a>oom_adj</h4><p>Android 中对于内存的回收，主要依靠 Lowmemorykiller 来完成，是一种根据 OOM_ADJ 阈值级别触发相应力度的内存回收的机制。
关于OOM_ADJ的说明如下:
<img src="http://images.wodekouwei.com/tips-android-process-201938151316.png" alt="tips-android-process-201938151316"></p>
<p>其中红色部分代表比较容易被杀死的 Android 进程（OOM_ADJ&gt;=4）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。在 Lowmemorykiller 回收内存时会根据进程的级别优先杀死 OOM_ADJ 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。</p>
<p>Android 手机中进程被杀死可能有如下情况：
|进程杀死场景|调用接口|可能影响范围|
|—|—|—|
|触发系统进程管理机制|Lowmemorykiller|从进程importance值由大到小依次杀死,释放内存|
|被第三方应用杀死(无Root)|killBackgoundProcess|只能杀死OOM_ADJ为4以上的进程|
|被第三方应用杀死(有Root)|force-stop或者kill|理论上可以杀死所有进程,一般只杀非系统关键进程和非前台和可见进程|
|厂商杀进程功能|fource-stop或者kill|理论上可以杀所有进程,包括Native进程|
|用户主动”强行停止”进程|force-stop|只能停用第三方和非system/phone进程应用(停用system进程应用会造成Android重启)|</p>
<p>通过<code>cat /proc/进程id/oom_adj</code>可以看到当前进程的adj指，比如输入<code>cat /proc/32366/oom_adj</code>,adj值具体决定了系统在资源吃紧的情况下该杀掉哪些进程。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ps | grep &quot;beike&quot;</div><div class="line">u0_a332   12952 3183  2072548 185728 SyS_epoll_ 0000000000 S com.lianjia.beike</div><div class="line">u0_a332   12972 3183  1792404 45848 SyS_epoll_ 0000000000 S com.lianjia.beike:coreservice</div><div class="line">u0_a332   13141 3183  1824480 61480 SyS_epoll_ 0000000000 S com.lianjia.beike:pushservice</div><div class="line">u0_a332   13225 3183  1787776 49968 SyS_epoll_ 0000000000 S com.lianjia.beike:remote</div><div class="line">nobleltechn:/ $ cat /proc/12952/oom_adj</div><div class="line">0</div><div class="line">nobleltechn:/ $ cat /proc/12972/oom_adj</div><div class="line">1</div><div class="line">nobleltechn:/ $ cat /proc/13141/oom_adj</div><div class="line">8</div><div class="line">nobleltechn:/ $ cat /proc/13225/oom_adj</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>而adj值则在ProcessList中定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">final class ProcessList &#123;</div><div class="line">// OOM adjustments for processes in various states:</div><div class="line"></div><div class="line">// Adjustment used in certain places where we don&apos;t know it yet.</div><div class="line">// (Generally this is something that is going to be cached, but we</div><div class="line">// don&apos;t know the exact value in the cached range to assign yet.)</div><div class="line">static final int UNKNOWN_ADJ = 16;</div><div class="line"></div><div class="line">// This is a process only hosting activities that are not visible,</div><div class="line">// so it can be killed without any disruption.</div><div class="line">static final int CACHED_APP_MAX_ADJ = 15;</div><div class="line">static final int CACHED_APP_MIN_ADJ = 9;</div><div class="line"></div><div class="line">// The B list of SERVICE_ADJ -- these are the old and decrepit</div><div class="line">// services that aren&apos;t as shiny and interesting as the ones in the A list.</div><div class="line">static final int SERVICE_B_ADJ = 8;</div><div class="line"></div><div class="line">// This is the process of the previous application that the user was in.</div><div class="line">// This process is kept above other things, because it is very common to</div><div class="line">// switch back to the previous app.  This is important both for recent</div><div class="line">// task switch (toggling between the two top recent apps) as well as normal</div><div class="line">// UI flow such as clicking on a URI in the e-mail app to view in the browser,</div><div class="line">// and then pressing back to return to e-mail.</div><div class="line">static final int PREVIOUS_APP_ADJ = 7;</div><div class="line"></div><div class="line">// This is a process holding the home application -- we want to try</div><div class="line">// avoiding killing it, even if it would normally be in the background,</div><div class="line">// because the user interacts with it so much.</div><div class="line">static final int HOME_APP_ADJ = 6;</div><div class="line"></div><div class="line">// This is a process holding an application service -- killing it will not</div><div class="line">// have much of an impact as far as the user is concerned.</div><div class="line">static final int SERVICE_ADJ = 5;</div><div class="line"></div><div class="line">// This is a process with a heavy-weight application.  It is in the</div><div class="line">// background, but we want to try to avoid killing it.  Value set in</div><div class="line">// system/rootdir/init.rc on startup.</div><div class="line">static final int HEAVY_WEIGHT_APP_ADJ = 4;</div><div class="line"></div><div class="line">// This is a process currently hosting a backup operation.  Killing it</div><div class="line">// is not entirely fatal but is generally a bad idea.</div><div class="line">static final int BACKUP_APP_ADJ = 3;</div><div class="line"></div><div class="line">// This is a process only hosting components that are perceptible to the</div><div class="line">// user, and we really want to avoid killing them, but they are not</div><div class="line">// immediately visible. An example is background music playback.</div><div class="line">static final int PERCEPTIBLE_APP_ADJ = 2;</div><div class="line"></div><div class="line">// This is a process only hosting activities that are visible to the</div><div class="line">// user, so we&apos;d prefer they don&apos;t disappear.</div><div class="line">static final int VISIBLE_APP_ADJ = 1;</div><div class="line"></div><div class="line">// This is the process running the current foreground app.  We&apos;d really</div><div class="line">// rather not kill it!</div><div class="line">static final int FOREGROUND_APP_ADJ = 0;</div><div class="line"></div><div class="line">// This is a process that the system or a persistent process has bound to,</div><div class="line">// and indicated it is important.</div><div class="line">static final int PERSISTENT_SERVICE_ADJ = -11;</div><div class="line"></div><div class="line">// This is a system persistent process, such as telephony.  Definitely</div><div class="line">// don&apos;t want to kill it, but doing so is not completely fatal.</div><div class="line">static final int PERSISTENT_PROC_ADJ = -12;</div><div class="line"></div><div class="line">// The system process runs at the default adjustment.</div><div class="line">static final int SYSTEM_ADJ = -16;</div><div class="line"></div><div class="line">// Special code for native processes that are not being managed by the system (so</div><div class="line">// don&apos;t have an oom adj assigned by the system).</div><div class="line">static final int NATIVE_ADJ = -17;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>较于Importance等级而言adj值可以赋予我们更多的参考价值，从上述adj值的定义中我们可以看到，值越小优先级越高，比如native进程的adj值为－17，对于这个adj值的进程来说，系统根本不会动它一分一毫，实质上当进程的adj值去到2时系统就很少会因为其它原因而去杀死它，这些在研究进程保活中都非常重要。</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ul>
<li>IPC: InterProcess Communication</li>
<li>RPC: Remote Procedure Call</li>
</ul>
<h5 id="进程间通信的方式-对比"><a href="#进程间通信的方式-对比" class="headerlink" title="进程间通信的方式-对比"></a>进程间通信的方式-对比</h5><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Intent</td>
<td>简单易用</td>
<td>只能传输Bundle所支持的数据类型</td>
<td>四大组件的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发</td>
<td>简单的数据共享,无高并发场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大,支持一对多并发实时通信</td>
<td>适用稍微复杂,需要注意线程同步</td>
<td>复杂的进程间调用,Android中最常用</td>
</tr>
<tr>
<td>Messenger</td>
<td>比AIDL稍微简单易用些</td>
<td>比AIDL功能弱,只支持一对多串行实时通信</td>
<td>简单的进程间通信</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>功能强大的数据共享能力,可通过call方法扩张</td>
<td>受约束的AIDL,主要对外提供数据线的CRUD操作</td>
<td>进程间的大量数据共享</td>
</tr>
<tr>
<td>RemoteViews</td>
<td>在跨进程方法UI方面有奇效</td>
<td>比较小众的通信方式</td>
<td>某些特殊的场景</td>
</tr>
<tr>
<td>Socket</td>
<td>跨主机,通信范围广</td>
<td>只能传输原始的字节流</td>
<td>常用与网络通信中</td>
</tr>
</tbody>
</table>
<h4 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h4><ul>
<li>四大组件中的三大组件（Activity、Service、Receiver）都支持在Intent中传递Bundle数据</li>
<li>Bundle中的数据除了基本类型，其他的都需要可序列化</li>
<li>适用于从一个进程启动另一个进程，比如在一个进程中启动另一个进程中的Activity、Service、Receiver，与此同时传递数据的情况</li>
</ul>
<h5 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h5><ul>
<li>2个进程通过读写同一个文件来交换数据</li>
<li>当然要把数据写入文件，必然要求数据可以序列化和反序列化</li>
<li>文件共享对文件格式没有要求，只要读写双方约定好数据格式</li>
<li>文件共享的方式存在并发读写的问题，适合对数据同步要求不高的进程间通信，并且要妥善处理并发读写的问题</li>
</ul>
<h5 id="使用Messager"><a href="#使用Messager" class="headerlink" title="使用Messager"></a>使用Messager</h5><p>使用Messager来传递Message，Message中能使用的字段只有what、arg1、arg2、Bundle和replyTo,自定义的Parcelable对象无法通过object字段来传输
Message中的Bundle支持多种数据类型，replyTo字段用于传输Messager对象，以便进程间相互通信
Messager以串行的方式处理客户端发来的消息，不适合有大量并发的请求
Messager方法只能传递消息，不能跨进程调用方法</p>
<h5 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h5><p>AIDL接口可以通过编写AIDL文件然后由系统生成对应的Binder类，通过Binder我们就可以进行跨进程通信了
AIDL文件中只支持如下几种类型：</p>
<ul>
<li>基本类型，如int、long等</li>
<li>String和CharSequence</li>
<li>List：只支持ArrayList，里面的每个元素都必须被AIDL支持</li>
<li>Map：只支持HashMap，里面的key、value都必须被AIDL支持</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用</li>
</ul>
<p>AIDL文件中用到的自定义Parcelable对象和AIDL对象必须要显示的import进来
除了基本数据类型，其他类型的参数必须标明是入参还是出参，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数</p>
<h4 id="进程保活机制"><a href="#进程保活机制" class="headerlink" title="进程保活机制"></a>进程保活机制</h4><p>Android 进程拉活包括两个层面：</p>
<ol>
<li>提供进程优先级，降低进程被杀死的概率</li>
<li>在进程被杀死后，进行拉活</li>
</ol>
<h5 id="提升进程优先级的方案"><a href="#提升进程优先级的方案" class="headerlink" title="提升进程优先级的方案"></a>提升进程优先级的方案</h5><h6 id="利用-Activity-提升权限"><a href="#利用-Activity-提升权限" class="headerlink" title="利用 Activity 提升权限"></a>利用 Activity 提升权限</h6><ol>
<li>方案设计思想:监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。注意该 Activity 需设计成用户无感知。通过该方案，可以使进程的优先级在屏幕锁屏时间由4提升为最高优先级1。</li>
<li>方案适用范围</li>
</ol>
<ul>
<li>适用场景：本方案主要解决第三方应用及系统管理工具在检测到锁屏事件后一段时间（一般为5分钟以内）内会杀死后台进程，已达到省电的目的问题。</li>
<li>适用版本： 适用于所有的 Android 版本。</li>
</ul>
<ol>
<li>方案具体实现
首先定义 Activity，并设置 Activity 的大小为1像素：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">protected void onCreate(Bundle savedInstanceState)&#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    Window window = getWindow();</div><div class="line">    window.setGravity(Gravity.LEFT|Gravity.TOP);</div><div class="line">    WindowManager.LayoutParams params = window.getAttributes();</div><div class="line">    params.x = 0;</div><div class="line">    params.y = 0;</div><div class="line">    params.height = 1;</div><div class="line">    params.width = 1;</div><div class="line">    window.setAttributes(params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过如下属性,排除Activity在RecentTask中的显示:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">    android:excludeFromRecents = &quot;true&quot;</div><div class="line">    android:exported = &quot;false&quot;</div><div class="line">    android:finishOnTaskLaunch = &quot;false&quot;</div><div class="line">    android:launchMode = &quot;singleInstance&quot;</div><div class="line">    android:process = &quot;:live&quot;</div><div class="line">    android:theme=&quot;@style/LiveActivityStyle&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>控制Activity为透明:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;LiveActivityStyle&gt;</div><div class="line">&lt;item name=&quot;android:windowBackground&gt;@android:color/transparent&lt;/item&gt;</div><div class="line">&lt;item name=&quot;android:windowBackGround&gt;@null&lt;/item&gt;</div><div class="line">&lt;item name=&quot;android:windowContentOverlay&gt;@null&lt;/item&gt;</div><div class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;@null&lt;/item&gt;</div><div class="line">...</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>Activity启动与销毁时机的控制:监控Intent.ACTION_SCREEN_OFF与Intent.ACTION_USER_PRESENT广播接收者</p>
<h6 id="利用-Notification-提升权限"><a href="#利用-Notification-提升权限" class="headerlink" title="利用 Notification 提升权限"></a>利用 Notification 提升权限</h6><ol>
<li>方案设计思想: Android 中 Service 的优先级为4，通过 setForeground 接口可以将后台 Service 设置为前台 Service，使进程的优先级由4提升为2，从而使进程的优先级仅仅低于用户当前正在交互的进程，与可见进程优先级一致，使进程被杀死的概率大大降低。</li>
<li>方案实现挑战: 从 Android2.3 开始调用 setForeground 将后台 Service 设置为前台 Service 时，必须在系统的通知栏发送一条通知，也就是前台 Service 与一条可见的通知时绑定在一起的。对于不需要常驻通知栏的应用来说，该方案虽好，但却是用户感知的，无法直接使用。</li>
<li>方案挑战应对措施: 通过实现一个内部 Service，在 LiveService 和其内部 Service 中同时发送具有相同 ID 的 Notification，然后将内部 Service 结束掉。随着内部 Service 的结束，Notification 将会消失，但系统优先级依然保持为2。</li>
<li>方案适用范围: 适用于目前已知所有版本。</li>
<li>方案具体实现</li>
</ol>
<h5 id="进程死后拉活的方案"><a href="#进程死后拉活的方案" class="headerlink" title="进程死后拉活的方案"></a>进程死后拉活的方案</h5><h6 id="利用系统广播拉活"><a href="#利用系统广播拉活" class="headerlink" title="利用系统广播拉活"></a>利用系统广播拉活</h6><ol>
<li>方案设计思想：在发生特定系统事件时，系统会发出响应的广播，通过在 AndroidManifest 中“静态”注册对应的广播监听器，即可在发生响应事件时拉活。常用的用于拉活的广播事件包括：开机广播,网络变化,文件挂载,屏幕亮灭,锁屏解屏,应用安装卸载</li>
<li>方案适用范围：适用于全部 Android 平台。但存在如下几个缺点：广播接收器被管理软件、系统软件通过“自启管理”等功能禁用的场景无法接收到广播，从而无法自启;系统广播事件不可控，只能保证发生事件时拉活进程，但无法保证进程挂掉后立即拉活。因此，该方案主要作为备用手段。</li>
</ol>
<h6 id="利用第三方应用广播拉活"><a href="#利用第三方应用广播拉活" class="headerlink" title="利用第三方应用广播拉活"></a>利用第三方应用广播拉活</h6><ol>
<li>方案设计思想：该方案总的设计思想与接收系统广播类似，不同的是该方案为接收第三方 Top 应用广播。通过反编译第三方 Top 应用，如：手机QQ、微信、支付宝、UC浏览器等，以及友盟、信鸽、个推等 SDK，找出它们外发的广播，在应用中进行监听，这样当这些应用发出广播时，就会将我们的应用拉活。</li>
<li>方案适用范围：该方案的有效程度除与系统广播一样的因素外，主要受如下因素限制：反编译分析过的第三方应用的多少;第三方应用的广播属于应用私有，当前版本中有效的广播，在后续版本随时就可能被移除或被改为不外发。这些因素都影响了拉活的效果。</li>
</ol>
<h6 id="利用系统Service机制拉活"><a href="#利用系统Service机制拉活" class="headerlink" title="利用系统Service机制拉活"></a>利用系统Service机制拉活</h6><ol>
<li>方案设计思想：将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活：</li>
<li>方案适用范围：如下两种情况无法拉活. 1.Service 第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内 Service 被杀死达到5次，则系统不再拉;。2.进程被取得 Root 权限的管理工具或系统工具通过 forestop 停止掉，无法重启。</li>
</ol>
<h6 id="利用Native进程拉活"><a href="#利用Native进程拉活" class="headerlink" title="利用Native进程拉活"></a>利用Native进程拉活</h6><ol>
<li>方案设计思想：</li>
</ol>
<ul>
<li>主要思想：利用 Linux 中的 fork 机制创建 Native 进程，在 Native 进程中监控主进程的存活，当主进程挂掉后，在 Native 进程中立即对主进程进行拉活。</li>
<li>主要原理：在 Android 中所有进程和系统组件的生命周期受 ActivityManagerService 的统一管理。而且，通过 Linux 的 fork 机制创建的进程为纯 Linux 进程，其生命周期不受 Android 的管理。</li>
</ul>
<ol>
<li>方案实现挑战：
挑战一：在 Native 进程中如何感知主进程死亡。
要在 Native 进程中感知主进程是否存活有两种实现方式：</li>
</ol>
<ul>
<li>在 Native 进程中通过死循环或定时器，轮训判断主进程是否存活，档主进程不存活时进行拉活。该方案的很大缺点是不停的轮询执行判断逻辑，非常耗电。</li>
<li>在主进程中创建一个监控文件，并且在主进程中持有文件锁。在拉活进程启动后申请文件锁将会被堵塞，一旦可以成功获取到锁，说明主进程挂掉，即可进行拉活。由于 Android 中的应用都运行于虚拟机之上，Java 层的文件锁与 Linux 层的文件锁是不同的，要实现该功能需要封装 Linux 层的文件锁供上层调用。
封装 Linux 文件锁的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int linuxflock(JNIEnv *env, jobject obj, jstring lockFilePath)&#123;</div><div class="line">    LOGI(&quot;flock&quot;);</div><div class="line">    int fd = linuxgetlockfd(env, lockFilePath);</div><div class="line">    LOGD(&quot;Lock file fd : %d&quot;, fd);</div><div class="line">    if(fd &gt; 0)&#123;</div><div class="line">        if(linuxtestflock(fd) == 0)&#123;</div><div class="line">            LOGD(&quot;try to lock the file&quot;);</div><div class="line">            return flock(fd, LOCK_EX);//创建文件排它锁</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Native 层中堵塞申请文件锁的部分代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void *thread_watch(void* arg)&#123;</div><div class="line">    LOGI(&quot;jni thread_watch);</div><div class="line">    int fd = 0;</div><div class="line">    if((fd == open(mLockFilePath, O_RDWR)))&#123;</div><div class="line">        LOGE(&quot;jni thread_watch open file failed,errno: %d&quot;, errno);</div><div class="line">        pthread_exit(0);</div><div class="line">    &#125;</div><div class="line">    LOGD(&quot;jni thread_watch,open file success, try to lock the file&quot;);</div><div class="line">    set_watch_state_symbol(1);</div><div class="line">    if(flock(fd, LOCK_EX) == 0)//申请文件的排他锁</div><div class="line">    &#123;</div><div class="line">        LOGD(&quot;jni thread_watch successfuly get file lock&quot;);</div><div class="line">        try_pullup();</div><div class="line">    &#125;else&#123;</div><div class="line">        set_watch_state_symbol(0);</div><div class="line">        LOGD(&quot;jni thread_watch,lock file error!!!&quot;);</div><div class="line">    &#125;</div><div class="line">    close(fd);//关闭文件会将锁自动释放</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>挑战二：在 Native 进程中如何拉活主进程。
通过 Native 进程拉活主进程的部分代码如下，即通过 am 命令进行拉活。通过指定“–include-stopped-packages”参数来拉活主进程处于 forestop 状态的情况。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static void try_pullup()</div><div class="line">&#123;</div><div class="line">    LOGI(&quot;jni try_pullup&quot;);</div><div class="line">    if(!is_application_exist(mPackageName))</div><div class="line">    &#123;</div><div class="line">        LOGD(&quot;jni try_pullup process exit, because xlb has been removed!&quot;);</div><div class="line">        set_watch_state_symbol(0);</div><div class="line">        freeAppMsg();</div><div class="line">        exit(0);</div><div class="line">    &#125;</div><div class="line">    LOGD(&quot;jni try_pullup try to wake up live service...&quot;);</div><div class="line">    char pkg[256] = &quot;&quot;;</div><div class="line">    strcat(pkg, &quot; -n &quot;);</div><div class="line">    strcat(pkg, mPackageName);</div><div class="line">    strcat(pkg, &quot;/com.xlb.keeplive.KeepLiveService\&quot;&quot;);</div><div class="line">    int ret - execlp(&quot;am&quot;, &quot;am&quot;, &quot;startservice&quot;, &quot;--user&quot;, mSerial, &quot;-n&quot;, pkg, &quot;--include-stopped-packages&quot;, NULL);</div><div class="line">    LOGD(&quot;start service, ret = %d&quot;, ret);</div><div class="line">    freeAppMsg();</div><div class="line">    set_watch_state_symbol(0);</div><div class="line">    pthread_exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>挑战三：如何保证 Native 进程的唯一。
从可扩展性和进程唯一等多方面考虑，将 Native 进程设计层 C/S 结构模式，主进程与 Native 进程通过 Localsocket 进行通信。在Native进程中利用 Localsocket 保证 Native 进程的唯一性，不至于出现创建多个 Native 进程以及 Native 进程变成僵尸进程等问题。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int main(const int argc, const char *argv[])</div><div class="line">&#123;</div><div class="line">    LOGI(&quot;jni do_main&quot;);</div><div class="line">    if(argc &lt; 2)&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    struct sockaddr addr;</div><div class="line">    socklen_t alen;</div><div class="line">    int lsocket, s, count;</div><div class="line"></div><div class="line">    const char* socket_name = argv[1];</div><div class="line">    LOGD(&quot;jni socket name: %s&quot;, socket_name);</div><div class="line">    lsocket = socket_local_server(socket_name, ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM);</div><div class="line">    if(lsocket &lt;0)</div><div class="line">    &#123;</div><div class="line">        LOGE(&quot;jni Failed to get socket from environment: %s&quot;, strerror(errno));</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line">    fcntl(lsocket, F_SETFD&lt; FD_CLOEXEC);</div><div class="line">    LOGD(&quot;jni native pid = %d&quot;, getpid());</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案适用范围：该方案主要适用于 Android5.0 以下版本手机。该方案不受 forcestop 影响，被强制停止的应用依然可以被拉活，在 Android5.0 以下版本拉活效果非常好。对于 Android5.0 以上手机，系统虽然会将native进程内的所有进程都杀死，这里其实就是系统“依次”杀死进程时间与拉活逻辑执行时间赛跑的问题，如果可以跑的比系统逻辑快，依然可以有效拉起。记得网上有人做过实验，该结论是成立的，在某些 Android 5.0 以上机型有效。</li>
</ol>
<h6 id="利用-JobScheduler-机制拉活"><a href="#利用-JobScheduler-机制拉活" class="headerlink" title="利用 JobScheduler 机制拉活"></a>利用 JobScheduler 机制拉活</h6><ol>
<li>方案设计思想：Android5.0 以后系统对 Native 进程等加强了管理，Native 拉活方式失效。系统在 Android5.0 以上版本提供了 JobScheduler 接口，系统会定时调用该进程以使应用进行一些逻辑操作。</li>
</ol>
<p>在本项目中，我对 JobScheduler 进行了进一步封装，兼容 Android5.0 以下版本。封装后 JobScheduler 接口的使用如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class KeepLiveService extends JobService&#123;</div><div class="line">    private final static String TAG = &quot;keeplive&quot;;</div><div class="line">    private boolean isServiceExit = false;//通过变量控制是否需要退出service</div><div class="line">    private volatile static Service mKeepLiveService = null;</div><div class="line">    public static boolean isServiceLive()&#123;</div><div class="line">        return mKeepLiveSErvice != null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">* 启动JobScheduler拉活</div><div class="line">* 适用范围:用于Android5.0以后版本进程保活,对被&quot;强制停止&quot;有效</div><div class="line">*/</div><div class="line">public void startJobScheduler()&#123;</div><div class="line">    try&#123;</div><div class="line">        int jobId = 1;</div><div class="line">        JobInfo.Builer builder = new JobInfo.Builder(jobId, new CompentName(FZApplication.self, KeepLiveSErvice.class));</div><div class="line">        builder.setPeriodic(10);</div><div class="line">        builder.setPersisted(true);</div><div class="line">        JobScheduler.getInstance(FZApplication.self()).schedule(builder.build());</div><div class="line">    &#125;catch(Throwable t)&#123;</div><div class="line">        t.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案适用范围：该方案主要适用于 Android5.0 以上版本手机。方案在 Android5.0 以上版本中不受 forcestop 影响，被强制停止的应用依然可以被拉活，在 Android5.0 以上版本拉活效果非常好。仅在小米手机可能会出现有时无法拉活的问题。</li>
</ol>
<h6 id="利用账号同步机制拉活"><a href="#利用账号同步机制拉活" class="headerlink" title="利用账号同步机制拉活"></a>利用账号同步机制拉活</h6><ol>
<li>方案设计思想：Android 系统的账号同步机制会定期同步账号进行，该方案目的在于利用同步机制进行进程的拉活。添加账号和设置同步周期的代码如下：</li>
</ol>
<p>该方案需要在 AndroidManifest 中定义账号授权与同步服务。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 添加账户,并启用账号同步功能&lt;br/&gt;</div><div class="line">* 利用账户同步功能进行拉活,适用范围为目前所有版本&lt;br/&gt;</div><div class="line">* 这是设置的账号同步周期为30秒,可以通过常量SYNC_FREQUENCY修改</div></pre></td></tr></table></figure></p>
<p>private void addAccount(){
    AccountManager accountManager = (AccountManager)this.getSystemService(Context.ACCOUNT_SERVICE);
    Account account = null;
    Account[] accounts = accountManager.getAccountsByType(ACCOUNT_TYPE);
    if(accounts.length &gt; 0){
        account = accounts[0];
    }else{
        account = new Account(getString(R.string.account_name), ACCOUNT_TYPE);
    }
    if(accountManager.addAccountExplicitly(account,null,null)){
        //开启同步,并设置同步周期
        ContentResolver.setIsSyncable(Account, CONTENT_AUTHORITY, 1);
        ContentResolver.setSyncAutomatically(account,CONTENT_AUTHORITY, true);
        ContentResolver.addPeriodicSync(account, CONTENT_AUTHORITY, new Bundle…);
    }
}
该方案需要在AndroidManifest中定义账号授权与同步服务.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=&quot;com.xlb.keeplive.KeepLiveService$AuthenticationSErvice&quot;</div><div class="line">    android:exported=&quot;true&quot;</div><div class="line">    android:process=&quot;:live&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;android.accounts.AccountAuthenticator&quot;/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">    &lt;meta-data</div><div class="line">        android:name = &quot;android.accounts.AccountAuthenticator&quot;</div><div class="line">        android:resource=&quot;@xml/authenticator&quot;/&gt;</div><div class="line">/&gt;</div><div class="line">&lt;service</div><div class="line">    android:name=&quot;com.xlb.keeplive.KeepLiveService$AccountSyncService&quot;</div><div class="line">    android:exported=&quot;true&quot;</div><div class="line">    android:process=&quot;:live&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;android.accounts.SyncAdapter&quot;/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">    &lt;meta-data</div><div class="line">        android:name = &quot;android.accounts.SyncAdapter&quot;</div><div class="line">        android:resource=&quot;@xml/SyncAdapter&quot;/&gt;</div><div class="line">/&gt;</div><div class="line">&lt;&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案适用范围：该方案适用于所有的 Android 版本，包括被 forestop 掉的进程也可以进行拉活。最新 Android 版本（Android N）中系统好像对账户同步这里做了变动，该方法不再有效。</li>
</ol>
<h6 id="其他有效拉活方案"><a href="#其他有效拉活方案" class="headerlink" title="其他有效拉活方案"></a>其他有效拉活方案</h6><p>经研究发现还有其他一些系统拉活措施可以使用，但在使用时需要用户授权，用户感知比较强烈。
这些方案包括：</p>
<ol>
<li>利用系统通知管理权限进行拉活</li>
<li>利用辅助功能拉活，将应用加入厂商或管理软件白名单。</li>
</ol>
<p>这些方案需要结合具体产品特性来搞。</p>
<p>上面所有解释这些方案都是考虑的无 Root 的情况。其他还有一些技术之外的措施，比如说应用内 Push 通道的选择：</p>
<ol>
<li>国外版应用：接入 Google 的 GCM。</li>
<li>国内版应用：根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</li>
</ol>
<h4 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h4><h5 id="Parcelable和Serializable"><a href="#Parcelable和Serializable" class="headerlink" title="Parcelable和Serializable"></a>Parcelable和Serializable</h5><h6 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h6><p>Serializable接口实现序列化比较简单，只需要在需要实现序列化的类实现Serializable接口就行
serialVersionUID可以指定也可以不指定，不指定的话系统会默认给我们生成
serialVersionUID的作用是用于标识当前类的版本，便于在反序列化过程中判断类是否有更改，如果serialVersionUID不一致，反序列化就会失败
人为指定serialVersionUID后，如果不是破坏性的改动了类，比如版本升级后增加了一个字段，那反序列化以后仍然能成功；而如果没有指定，反序列化就会失败
serialVersionUID是否指定需要根据具体的需要来确定
静态成员变量和transient关键字标记的变量不参与序列化过程</p>
<h6 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h6><p>Parcelable接口实现序列化稍微复杂，需要实现writeToParcel方法、describeContents方法以及生成器Creator
内容描述功能的describeContents方法一般都返回0，当前对象中存在文件描述符时才返回1
Parcelable接口中的Parcel内部包装了可序列化的数据，可以在Binder中自由传输</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>Serializable使用简单但是开销很大，序列化和反序列化过程需要大量的IO操作，一般用于将对象序列化到存储设备中或者将对象序列化后通过网络传输。</p>
<p>Parcelable使用麻烦，但效率很高。</p>
<h5 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h5><p>binder是Android中的一种跨进程通信方式
可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder.
从Android Framework角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。
从Android应用层来说，Binder是客户端和服务端进行通信的媒介。当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
<p>更安全，比如socket的ip地址可以进行伪造，而Binder机制从协议本身就支持对通信双方做身份校验，因而大大提升了安全性，这个也是Android权限模型的基础。</p>
<p><img src="http://images.wodekouwei.com/tips-android-process-201938104639.png" alt="tips-android-process-201938104639"></p>
<p>如下图，伪装。即代理模式。对代理对象的操作会通过驱动最终转发到Binder本地对象上去完成，当然使用者无需关心这些细节。
<img src="http://images.wodekouwei.com/tips-android-process-201938104833.png" alt="tips-android-process-201938104833"></p>
<p>Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，它的引用却遍布于系统的各个进程中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给另一个进程，让大家都能访问同一Server，就像一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://images.wodekouwei.com/Pay/weixin_qingkouwei.png" alt="轻口味 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://images.wodekouwei.com/Pay/zhifubao_qingkouwei.jpg" alt="轻口味 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/tips/" rel="tag"># tips</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/31/tips-android-pluggable-8/" rel="next" title="tips-android-pluggable-8">
                <i class="fa fa-chevron-left"></i> tips-android-pluggable-8
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/06/at-android-source/" rel="prev" title="android自动化测试(二):源码分析">
                android自动化测试(二):源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">159</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程生命周期"><span class="nav-number">1.</span> <span class="nav-text">进程生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#前台进程"><span class="nav-number">1.1.</span> <span class="nav-text">前台进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可见进程"><span class="nav-number">1.2.</span> <span class="nav-text">可见进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#服务进程"><span class="nav-number">1.3.</span> <span class="nav-text">服务进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#后台进程"><span class="nav-number">1.4.</span> <span class="nav-text">后台进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#空进程"><span class="nav-number">1.5.</span> <span class="nav-text">空进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全方法"><span class="nav-number">2.</span> <span class="nav-text">线程安全方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多进程好处"><span class="nav-number">3.</span> <span class="nav-text">多进程好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#陷阱"><span class="nav-number">4.</span> <span class="nav-text">陷阱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#process属性的设置有两种形式"><span class="nav-number">5.</span> <span class="nav-text">process属性的设置有两种形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程与进程区别"><span class="nav-number">6.</span> <span class="nav-text">线程与进程区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看当前手机中进程方式"><span class="nav-number"></span> <span class="nav-text">查看当前手机中进程方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ps"><span class="nav-number">1.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#oom-adj"><span class="nav-number">2.</span> <span class="nav-text">oom_adj</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间通信"><span class="nav-number">3.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程间通信的方式-对比"><span class="nav-number">3.1.</span> <span class="nav-text">进程间通信的方式-对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Bundle"><span class="nav-number">4.</span> <span class="nav-text">使用Bundle</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用文件共享"><span class="nav-number">4.1.</span> <span class="nav-text">使用文件共享</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用Messager"><span class="nav-number">4.2.</span> <span class="nav-text">使用Messager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用AIDL"><span class="nav-number">4.3.</span> <span class="nav-text">使用AIDL</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程保活机制"><span class="nav-number">5.</span> <span class="nav-text">进程保活机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#提升进程优先级的方案"><span class="nav-number">5.1.</span> <span class="nav-text">提升进程优先级的方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#利用-Activity-提升权限"><span class="nav-number">5.1.1.</span> <span class="nav-text">利用 Activity 提升权限</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利用-Notification-提升权限"><span class="nav-number">5.1.2.</span> <span class="nav-text">利用 Notification 提升权限</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程死后拉活的方案"><span class="nav-number">5.2.</span> <span class="nav-text">进程死后拉活的方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#利用系统广播拉活"><span class="nav-number">5.2.1.</span> <span class="nav-text">利用系统广播拉活</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利用第三方应用广播拉活"><span class="nav-number">5.2.2.</span> <span class="nav-text">利用第三方应用广播拉活</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利用系统Service机制拉活"><span class="nav-number">5.2.3.</span> <span class="nav-text">利用系统Service机制拉活</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利用Native进程拉活"><span class="nav-number">5.2.4.</span> <span class="nav-text">利用Native进程拉活</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利用-JobScheduler-机制拉活"><span class="nav-number">5.2.5.</span> <span class="nav-text">利用 JobScheduler 机制拉活</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利用账号同步机制拉活"><span class="nav-number">5.2.6.</span> <span class="nav-text">利用账号同步机制拉活</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#其他有效拉活方案"><span class="nav-number">5.2.7.</span> <span class="nav-text">其他有效拉活方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他概念"><span class="nav-number">6.</span> <span class="nav-text">其他概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Parcelable和Serializable"><span class="nav-number">6.1.</span> <span class="nav-text">Parcelable和Serializable</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Serializable接口"><span class="nav-number">6.1.1.</span> <span class="nav-text">Serializable接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Parcelable接口"><span class="nav-number">6.1.2.</span> <span class="nav-text">Parcelable接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#总结"><span class="nav-number">6.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Binder"><span class="nav-number">6.2.</span> <span class="nav-text">Binder</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  


  

</body>
</html>
