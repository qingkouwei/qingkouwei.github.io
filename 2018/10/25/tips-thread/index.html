<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java,Linux,tips," />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="什么是线程线程5种状态  新建状态(New)： 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码 就绪状态(Runnable) 一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运">
<meta name="keywords" content="Java,Linux,tips">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程只是总结">
<meta property="og:url" content="http://wodekouwei.com/2018/10/25/tips-thread/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta property="og:description" content="什么是线程线程5种状态  新建状态(New)： 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码 就绪状态(Runnable) 一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运">
<meta property="og:image" content="http://images.wodekouwei.com/technology/thread-lifecycle.jpeg">
<meta property="og:updated_time" content="2018-11-07T11:46:33.802Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程只是总结">
<meta name="twitter:description" content="什么是线程线程5种状态  新建状态(New)： 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码 就绪状态(Runnable) 一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运">
<meta name="twitter:image" content="http://images.wodekouwei.com/technology/thread-lifecycle.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/2018/10/25/tips-thread/"/>





  <title> 多线程只是总结 | 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2018/10/25/tips-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                多线程只是总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T15:08:43+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index">
                    <span itemprop="name">language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2018/10/25/tips-thread/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><h4 id="线程5种状态"><a href="#线程5种状态" class="headerlink" title="线程5种状态"></a>线程5种状态</h4><p><img src="http://images.wodekouwei.com/technology/thread-lifecycle.jpeg" alt="image"></p>
<ol>
<li>新建状态(New)：
当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</li>
<li>就绪状态(Runnable)
一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。
处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。</li>
<li>运行状态(Running)
当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.</li>
<li>阻塞状态(Blocked)
线程运行过程中，可能由于各种原因进入阻塞状态:
1&gt;线程通过调用sleep方法进入睡眠状态；
2&gt;线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
3&gt;线程试图得到一个锁，而该锁正被其他线程持有；
4&gt;线程在等待某个触发条件；<br>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</li>
<li>死亡状态(Dead)
有两个原因会导致线程死亡：
1) run方法正常退出而自然死亡，
2) 一个未捕获的异常终止了run方法而使线程猝死。
为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.</li>
</ol>
<h4 id="线程同步的7种方式"><a href="#线程同步的7种方式" class="headerlink" title="线程同步的7种方式"></a>线程同步的7种方式</h4><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， 将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<h5 id="方式1-同步方法"><a href="#方式1-同步方法" class="headerlink" title="方式1:同步方法"></a>方式1:同步方法</h5><p>即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
代码如： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public synchronized void save()&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</p>
<h5 id="方式2-同步代码块"><a href="#方式2-同步代码块" class="headerlink" title="方式2:同步代码块"></a>方式2:同步代码块</h5><p>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
代码如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">synchronized(object)&#123; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 </p>
<h5 id="方式3-使用特殊域变量-volatile-实现线程同步"><a href="#方式3-使用特殊域变量-volatile-实现线程同步" class="headerlink" title="方式3:使用特殊域变量(volatile)实现线程同步"></a>方式3:使用特殊域变量(volatile)实现线程同步</h5><ol>
<li>volatile关键字为域变量的访问提供了一种免锁机制， </li>
<li>使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， </li>
<li>因此每次使用该域就要重新计算，而不是使用寄存器中的值 </li>
<li>volatile不会提供任何原子操作，它也不能用来修饰final类型的变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Bank &#123;</div><div class="line">    //需要同步的变量加上volatile</div><div class="line">    private volatile int account = 100;</div><div class="line"></div><div class="line">    public int getAccount() &#123;</div><div class="line">        return account;</div><div class="line">    &#125;</div><div class="line">    //这里不再需要synchronized </div><div class="line">    public void save(int money) &#123;</div><div class="line">        account += money;</div><div class="line">    &#125;</div><div class="line">｝</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。 </p>
<h5 id="方式4-使用重入锁实现线程同步"><a href="#方式4-使用重入锁实现线程同步" class="headerlink" title="方式4:使用重入锁实现线程同步"></a>方式4:使用重入锁实现线程同步</h5><p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 
ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力
ReenreantLock类的常用方法有：</p>
<ol>
<li>ReentrantLock() : 创建一个ReentrantLock实例 </li>
<li>lock() : 获得锁 </li>
<li>unlock() : 释放锁 </li>
</ol>
<p>注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Bank &#123;</div><div class="line">    </div><div class="line">    private int account = 100;</div><div class="line">    //需要声明这个锁</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">    public int getAccount() &#123;</div><div class="line">        return account;</div><div class="line">    &#125;</div><div class="line">    //这里不再需要synchronized </div><div class="line">    public void save(int money) &#123;</div><div class="line">        lock.lock();</div><div class="line">        try&#123;</div><div class="line">            account += money;</div><div class="line">        &#125;finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">｝</div></pre></td></tr></table></figure></p>
<p>注：关于Lock对象和synchronized关键字的选择： </p>
<ol>
<li>最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。 </li>
<li>如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 </li>
<li>如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 </li>
</ol>
<h5 id="方式5-使用局部变量实现线程同步"><a href="#方式5-使用局部变量实现线程同步" class="headerlink" title="方式5:使用局部变量实现线程同步"></a>方式5:使用局部变量实现线程同步</h5><p>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p> ThreadLocal 类的常用方法</p>
<ul>
<li>ThreadLocal() : 创建一个线程本地变量 </li>
<li>get() : 返回此线程局部变量的当前线程副本中的值 </li>
<li>initialValue() : 返回此线程局部变量的当前线程的”初始值” </li>
<li>set(T value) : 将此线程局部变量的当前线程副本中的值设置为value</li>
</ul>
<p>首先定义一个ThreadLocal对象，这里选择Boolean类型的，如下所示：</p>
<p>private ThreadLocal<boolean>mBooleanThreadLocal = new ThreadLocal<boolean>();</boolean></boolean></p>
<p>然后分别在主线程、子线程1和子线程2中设置和访问它的值，代码如下所示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mBooleanThreadLocal.set(true);</div><div class="line">Log.d(TAG, &quot;[Thread#main]mBooleanThreadLocal=&quot; + mBooleanThreadLocal.get());</div><div class="line"> </div><div class="line">new Thread(&quot;Thread#1&quot;) &#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		mBooleanThreadLocal.set(false);</div><div class="line">		Log.d(TAG, &quot;[Thread#1]mBooleanThreadLocal=&quot; + mBooleanThreadLocal.get());</div><div class="line">	&#125;;</div><div class="line">&#125;.start();</div><div class="line"> </div><div class="line">new Thread(&quot;Thread#2&quot;) &#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		Log.d(TAG, &quot;[Thread#2]mBooleanThreadLocal=&quot; + mBooleanThreadLocal.get());</div><div class="line">	&#125;;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure></p>
<p>上面的代码中，在主线程中设置mBooleanThreadLocal的值为true，在子线程1中设置mBooleanThreadLocal的值为false，在子线程2中不设置mBooleanThreadLocal的值，然后分别在3个线程中通过get方法去mBooleanThreadLocal的值，根据前面对ThreadLocal的描述，这个时候，主线程中应该是true，子线程1中应该是false，而子线程2中由于没有设置值，所以应该是null，安装并运行程序，日志如下所示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">D/TestActivity(8676):[Thread#main]mBooleanThreadLocal=true</div><div class="line"></div><div class="line">D/TestActivity(8676):[Thread#1]mBooleanThreadLocal=false</div><div class="line"></div><div class="line">D/TestActivity(8676):[Thread#2]mBooleanThreadLocal=null</div></pre></td></tr></table></figure></p>
<p>注：ThreadLocal与同步机制 </p>
<ol>
<li>ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 </li>
<li>前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式</li>
</ol>
<h5 id="方式6-使用阻塞队列实现线程同步"><a href="#方式6-使用阻塞队列实现线程同步" class="headerlink" title="方式6:使用阻塞队列实现线程同步"></a>方式6:使用阻塞队列实现线程同步</h5><p>前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 这里主要是使用LinkedBlockingQueue<e>来实现线程的同步.
LinkedBlockingQueue<e>是一个基于已连接节点的，范围任意的blocking queue。 队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~ 
LinkedBlockingQueue 类常用方法 </e></e></p>
<ul>
<li>LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue </li>
<li>put(E e) : 在队尾添加一个元素，如果队列满则阻塞 </li>
<li>size() : 返回队列中的元素个数 </li>
<li>take() : 移除并返回队头元素，如果队列空则阻塞 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">package com.xhj.thread;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.LinkedBlockingQueue;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用</div><div class="line"> * </div><div class="line"> * @author XIEHEJUN</div><div class="line"> * </div><div class="line"> */</div><div class="line">public class BlockingSynchronizedThread &#123;</div><div class="line">    /**</div><div class="line">     * 定义一个阻塞队列用来存储生产出来的商品</div><div class="line">     */</div><div class="line">    private LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;Integer&gt;();</div><div class="line">    /**</div><div class="line">     * 定义生产商品个数</div><div class="line">     */</div><div class="line">    private static final int size = 10;</div><div class="line">    /**</div><div class="line">     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程</div><div class="line">     */</div><div class="line">    private int flag = 0;</div><div class="line"></div><div class="line">    private class LinkBlockThread implements Runnable &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            int new_flag = flag++;</div><div class="line">            System.out.println(&quot;启动线程 &quot; + new_flag);</div><div class="line">            if (new_flag == 0) &#123;</div><div class="line">                for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">                    int b = new Random().nextInt(255);</div><div class="line">                    System.out.println(&quot;生产商品：&quot; + b + &quot;号&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        queue.put(b);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        // TODO Auto-generated catch block</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(100);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        // TODO Auto-generated catch block</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                for (int i = 0; i &lt; size / 2; i++) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        int n = queue.take();</div><div class="line">                        System.out.println(&quot;消费者买去了&quot; + n + &quot;号商品&quot;);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        // TODO Auto-generated catch block</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(100);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        // TODO: handle exception</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BlockingSynchronizedThread bst = new BlockingSynchronizedThread();</div><div class="line">        LinkBlockThread lbt = bst.new LinkBlockThread();</div><div class="line">        Thread thread1 = new Thread(lbt);</div><div class="line">        Thread thread2 = new Thread(lbt);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：BlockingQueue<e>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：</e></p>
<ul>
<li>add()方法会抛出异常</li>
<li>offer()方法返回false</li>
<li>put()方法会阻塞</li>
</ul>
<h5 id="方式7-使用原子变量实现线程同步"><a href="#方式7-使用原子变量实现线程同步" class="headerlink" title="方式7:使用原子变量实现线程同步"></a>方式7:使用原子变量实现线程同步</h5><p>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<p>那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作,即-这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。</p>
<p>其中AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，
但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。</p>
<p>AtomicInteger类常用方法：</p>
<ul>
<li>AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger</li>
<li>addAddGet(int dalta) : 以原子方式将给定值与当前值相加</li>
<li>get() : 获取当前值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Bank &#123;</div><div class="line">        private AtomicInteger account = new AtomicInteger(100);</div><div class="line"></div><div class="line">        public AtomicInteger getAccount() &#123;</div><div class="line">            return account;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void save(int money) &#123;</div><div class="line">            account.addAndGet(money);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>补充–原子操作主要有：
对于引用变量和大多数原始变量(long和double除外)的读写操作；
对于所有使用volatile修饰的变量(包括long和double)的读写操作。</p>
<h4 id="线程局部存储ThreadLocal"><a href="#线程局部存储ThreadLocal" class="headerlink" title="线程局部存储ThreadLocal"></a>线程局部存储ThreadLocal</h4><h4 id="分析Java线程中断机制stop和interrupted的用法"><a href="#分析Java线程中断机制stop和interrupted的用法" class="headerlink" title="分析Java线程中断机制stop和interrupted的用法"></a>分析Java线程中断机制stop和interrupted的用法</h4><p>当我们点击某个杀毒软件的取消按钮来停止查杀病毒时，当我们在控制台敲入quit命令以结束某个后台服务时……都需要通过一个线程去取消另一个线程正在执行的任务。Java没有提供一种安全直接的方法来停止某个线程，但是Java提供了中断机制。如果对Java中断没有一个全面的了解，可能会误以为被中断的线程将立马退出运行，但事实并非如此。中断机制是如何工作的？捕获或检测到中断后，是抛出InterruptedException还是重设中断状态以及在方法中吞掉中断状态会有什么后果？Thread.stop与中断相比又有哪些异同？什么情况下需要使用中断？中断的原理Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。这好比是家里的父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。Java中断模型也是这么简单，每个线程对象里都有一个boolean类型的标识（不一定就要是Thread类的字段，实际上也的确不是，这几个方法最终都是通过native方法来完成的），代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。例如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。java.lang.Thread类提供了几个方法来操作这个中断状态，这些方法包括：</p>
<ul>
<li>public static boolean interrupted测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</li>
<li>public boolean isInterrupted()测试线程是否已经中断。线程的中断状态不受该方法的影响。</li>
<li>public void interrupt()中断线程。其中，interrupt方法是唯一能将中断状态设置为true的方法。静态方法interrupted会将当前线程的中断状态清除，但这个方法的命名极不直观，很容易造成误解，需要特别注意。</li>
</ul>
<p>上面的例子中，线程t1通过调用interrupt方法将线程t2的中断状态置为true，t2可以在合适的时候调用interrupted或isInterrupted来检测状态并做相应的处理。此外，类库中的有些类的方法也可能会调用中断，如FutureTask中的cancel方法，如果传入的参数为true，它将会在正在运行异步任务的线程上调用interrupt方法，如果正在执行的异步任务中的代码没有对中断做出响应，那么cancel方法中的参数将不会起到什么效果；又如ThreadPoolExecutor中的shutdownNow方法会遍历线程池中的工作线程并调用线程的interrupt方法来中断线程，所以如果工作线程中正在执行的任务没有对中断做出响应，任务将一直执行直到正常结束。</p>
<p>既然Java中断机制只是设置被中断线程的中断状态，那么被中断线程该做些什么？显然，作为一种协作机制，不会强求被中断线程一定要在某个点进行处理。实际上，被中断线程只需在合适的时候处理即可，如果没有合适的时间点，甚至可以不处理，这时候在任务处理层面，就跟没有调用中断方法一样。“合适的时候”与线程正在处理的业务逻辑紧密相关，例如，每次迭代的时候，进入一个可能阻塞且无法中断的方法之前等，但多半不会出现在某个临界区更新另一个对象状态的时候，因为这可能会导致对象处于不一致状态。
处理时机决定着程序的效率与中断响应的灵敏性。频繁的检查中断状态可能会使程序执行效率下降，相反，检查的较少可能使中断请求得不到及时响应。如果发出中断请求之后，被中断的线程继续执行一段时间不会给系统带来灾难，那么就可以将中断处理放到方便检查中断，同时又能从一定程度上保证响应灵敏度的地方。当程序的性能指标比较关键时，可能需要建立一个测试模型来分析最佳的中断检测点，以平衡性能和响应灵敏性。</p>
<p>一般说来，当可能阻塞的方法声明中有抛出InterruptedException则暗示该方法是可中断的，如BlockingQueue#put、BlockingQueue#take、Object#wait、Thread#sleep等，如果程序捕获到这些可中断的阻塞方法抛出的InterruptedException或检测到中断后，这些中断信息该如何处理？一般有以下两个通用原则：</p>
<ol>
<li>如果遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常，如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。 若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态。如果是检测并清除了中断状态，亦是如此。 一般的代码中，尤其是作为一个基础类库时，绝不应当吞掉中断，即捕获到InterruptedException后在catch里什么也不做，清除中断状态后又不重设中断状态也不抛出InterruptedException等。因为吞掉中断状态会导致方法调用栈的上层得不到这些信息。当然，凡事总有例外的时候，当你完全清楚自己的方法会被谁调用，而调用者也不会因为中断被吞掉了而遇到麻烦，就可以这么做。总得来说，就是要让方法调用栈的上层获知中断的发生。假设你写了一个类库，类库里有个方法amethod，在amethod中检测并清除了中断状态，而没有抛出InterruptedException，作为amethod的用户来说，他并不知道里面的细节，如果用户在调用amethod后也要使用中断来做些事情，那么在调用amethod之后他将永远也检测不到中断了，因为中断信息已经被amethod清除掉了。如果作为用户，遇到这样有问题的类库，又不能修改代码，那该怎么处理？只好在自己的类里设置一个自己的中断状态，在调用interrupt方法的时候，同时设置该状态，这实在是无路可走时才使用的方法。</li>
<li>中断的响应 程序里发现中断后该怎么响应？这就得视实际情况而定了。有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务……作为一种协作机制，这要与中断方协商好，当调用interrupt会发生些什么都是事先知道的，如做一些事务回滚操作，一些清理工作，一些补偿操作等。若不确定调用某个线程的interrupt后该线程会做出什么样的响应，那就不应当中断该线程。</li>
</ol>
<p>Thread.interrupt VS Thread.stopThread.stop方法已经不推荐使用了。而在某些方面Thread.stop与中断机制有着相似之处。如当线程在等待内置锁或IO时，stop跟interrupt一样，不会中止这些操作；当catch住stop导致的异常时，程序也可以继续执行，虽然stop本意是要停止线程，这么做会让程序行为变得更加混乱。那么它们的区别在哪里？最重要的就是中断需要程序自己去检测然后做相应的处理，而Thread.stop会直接在代码执行过程中抛出ThreadDeath错误，这是一个java.lang.Error的子类。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package com.ticmy.interrupt;  </div><div class="line">import java.util.Arrays;  </div><div class="line">import java.util.Random;  </div><div class="line">import java.util.concurrent.TimeUnit;  </div><div class="line">public class TestStop &#123;  </div><div class="line">    private static final int[] array = new int[80000];  </div><div class="line">    private static final Thread t = new Thread() &#123;  </div><div class="line">        public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                System.out.println(sort(array));  </div><div class="line">            &#125; catch (Error err) &#123;  </div><div class="line">                err.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">            System.out.println(&quot;in thread t&quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;;  </div><div class="line"></div><div class="line">    static &#123;  </div><div class="line">        Random random = new Random();  </div><div class="line">        for(int i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">            array[i] = random.nextInt(i + 1);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private static int sort(int[] array) &#123;  </div><div class="line">        for (int i = 0; i &lt; array.length-1; i++)&#123;  </div><div class="line">            for(int j = 0 ;j &lt; array.length - i - 1; j++)&#123;  </div><div class="line">                if(array[j] &lt; array[j + 1])&#123;  </div><div class="line">                    int temp = array[j];  </div><div class="line">                    array[j] = array[j + 1];  </div><div class="line">                    array[j + 1] = temp;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return array[0];  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        t.start();  </div><div class="line">        TimeUnit.SECONDS.sleep(1);  </div><div class="line">        System.out.println(&quot;go to stop thread t&quot;);  </div><div class="line">        t.stop();  </div><div class="line">        System.out.println(&quot;finish main&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子很简单，线程t里面做了一个非常耗时的排序操作，排序方法中，只有简单的加、减、赋值、比较等操作，一个可能的执行结果如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">go to stop thread t  </div><div class="line">java.lang.ThreadDeath  </div><div class="line">    at java.lang.Thread.stop(Thread.java:758)  </div><div class="line">    at com.ticmy.interrupt.TestStop.main(TestStop.java:44)  </div><div class="line">finish main  </div><div class="line">in thread t</div></pre></td></tr></table></figure></p>
<p>这里sort方法是个非常耗时的操作，也就是说主线程休眠一秒钟后调用stop的时候，线程t还在执行sort方法。就是这样一个简单的方法，也会抛出错误！换一句话说，调用stop后，大部分Java字节码都有可能抛出错误，哪怕是简单的加法！
如果线程当前正持有锁，stop之后则会释放该锁。由于此错误可能出现在很多地方，那么这就让编程人员防不胜防，极易造成对象状态的不一致。例如，对象obj中存放着一个范围值：最小值low，最大值high，且low不得大于high，这种关系由锁lock保护，以避免并发时产生竞态条件而导致该关系失效。假设当前low值是5，high值是10，当线程t获取lock后，将low值更新为了15，此时被stop了，真是糟糕，如果没有捕获住stop导致的Error，low的值就为15，high还是10，这导致它们之间的小于关系得不到保证，也就是对象状态被破坏了！如果在给low赋值的时候catch住stop导致的Error则可能使后面high变量的赋值继续，但是谁也不知道Error会在哪条语句抛出，如果对象状态之间的关系更复杂呢？这种方式几乎是无法维护的，太复杂了！如果是中断操作，它决计不会在执行low赋值的时候抛出错误，这样程序对于对象状态一致性就是可控的。
正是因为可能导致对象状态不一致，stop才被禁用。</p>
<p>中断的使用通常，中断的使用场景有以下几个：</p>
<ul>
<li>点击某个桌面应用中的取消按钮时；</li>
<li>某个操作超过了一定的执行时间限制需要中止时；</li>
<li>多个线程做相同的事情，只要一个线程成功其它线程都可以取消时；</li>
<li>一组线程中的一个或多个出现错误导致整组都无法继续时；</li>
<li>当一个应用或服务需要停止时。</li>
</ul>
<p>下面来看一个具体的例子。这个例子里，本打算采用GUI形式，但考虑到GUI代码会使程序复杂化，就使用控制台来模拟下核心的逻辑。这里新建了一个磁盘文件扫描的任务，扫描某个目录下的所有文件并将文件路径打印到控制台，扫描的过程可能会很长。若需要中止该任务，只需在控制台键入quit并回车即可。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.ticmy.interrupt;  </div><div class="line">import java.io.BufferedReader;  </div><div class="line">import java.io.File;  </div><div class="line">import java.io.InputStreamReader;  </div><div class="line"></div><div class="line">public class FileScanner &#123;  </div><div class="line">    private static void listFile(File f) throws InterruptedException &#123;  </div><div class="line">        if(f == null) &#123;  </div><div class="line">            throw new IllegalArgumentException();  </div><div class="line">        &#125;  </div><div class="line">        if(f.isFile()) &#123;  </div><div class="line">            System.out.println(f);  </div><div class="line">            return;  </div><div class="line">        &#125;  </div><div class="line">        File[] allFiles = f.listFiles();  </div><div class="line">        if(Thread.interrupted()) &#123;  </div><div class="line">            throw new InterruptedException(&quot;文件扫描任务被中断&quot;);  </div><div class="line">        &#125;  </div><div class="line">        for(File file : allFiles) &#123;  </div><div class="line">            //还可以将中断检测放到这里  </div><div class="line">            listFile(file);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static String readFromConsole() &#123;  </div><div class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  </div><div class="line">        try &#123;  </div><div class="line">            return reader.readLine();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">            return &quot;&quot;;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        final Thread fileIteratorThread = new Thread() &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                try &#123;  </div><div class="line">                    listFile(new File(&quot;c:\\&quot;));  </div><div class="line">                &#125; catch (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;;  </div><div class="line">        new Thread() &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                while(true) &#123;  </div><div class="line">                    if(&quot;quit&quot;.equalsIgnoreCase(readFromConsole())) &#123;  </div><div class="line">                        if(fileIteratorThread.isAlive()) &#123;  </div><div class="line">                            fileIteratorThread.interrupt();  </div><div class="line">                            return;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125; else &#123;  </div><div class="line">                        System.out.println(&quot;输入quit退出文件扫描&quot;);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;.start();  </div><div class="line">        fileIteratorThread.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在扫描文件的过程中，对于中断的检测这里采用的策略是，如果碰到的是文件就不检测中断，是目录才检测中断，因为文件可能是非常多的，每次遇到文件都检测一次会降低程序执行效率。此外，在fileIteratorThread线程中，仅是捕获了InterruptedException，没有重设中断状态也没有继续抛出异常，因为我非常清楚它的使用环境，run方法的调用栈上层已经没有可能需要检测中断状态的方法了。
在这个程序中，输入quit完全可以执行System.exit(0)操作来退出程序，但正如前面提到的，这是个GUI程序核心逻辑的模拟，在GUI中，执行System.exit(0)会使得整个程序退出。</p>
<p>线程stop方法源码:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Forces the thread to stop executing.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt;</div><div class="line">     * method is called with &lt;code&gt;this&lt;/code&gt;</div><div class="line">     * as its argument. This may result in a</div><div class="line">     * &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).</div><div class="line">     * &lt;p&gt;</div><div class="line">     * If this thread is different from the current thread (that is, the current</div><div class="line">     * thread is trying to stop a thread other than itself), the</div><div class="line">     * security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method (with a</div><div class="line">     * &lt;code&gt;RuntimePermission(&quot;stopThread&quot;)&lt;/code&gt; argument) is called in</div><div class="line">     * addition.</div><div class="line">     * Again, this may result in throwing a</div><div class="line">     * &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The thread represented by this thread is forced to stop whatever</div><div class="line">     * it is doing abnormally and to throw a newly created</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * It is permitted to stop a thread that has not yet been started.</div><div class="line">     * If the thread is eventually started, it immediately terminates.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * An application should not normally try to catch</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; unless it must do some extraordinary</div><div class="line">     * cleanup operation (note that the throwing of</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; causes &lt;code&gt;finally&lt;/code&gt; clauses of</div><div class="line">     * &lt;code&gt;try&lt;/code&gt; statements to be executed before the thread</div><div class="line">     * officially dies).  If a &lt;code&gt;catch&lt;/code&gt; clause catches a</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt; object, it is important to rethrow the</div><div class="line">     * object so that the thread actually dies.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The top-level error handler that reacts to otherwise uncaught</div><div class="line">     * exceptions does not print out a message or otherwise notify the</div><div class="line">     * application if the uncaught exception is an instance of</div><div class="line">     * &lt;code&gt;ThreadDeath&lt;/code&gt;.</div><div class="line">     *</div><div class="line">     * @exception  SecurityException  if the current thread cannot</div><div class="line">     *               modify this thread.</div><div class="line">     * @see        #interrupt()</div><div class="line">     * @see        #checkAccess()</div><div class="line">     * @see        #run()</div><div class="line">     * @see        #start()</div><div class="line">     * @see        ThreadDeath</div><div class="line">     * @see        ThreadGroup#uncaughtException(Thread,Throwable)</div><div class="line">     * @see        SecurityManager#checkAccess(Thread)</div><div class="line">     * @see        SecurityManager#checkPermission</div><div class="line">     * @deprecated This method is inherently unsafe.  Stopping a thread with</div><div class="line">     *       Thread.stop causes it to unlock all of the monitors that it</div><div class="line">     *       has locked (as a natural consequence of the unchecked</div><div class="line">     *       &lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up the stack).  If</div><div class="line">     *       any of the objects previously protected by these monitors were in</div><div class="line">     *       an inconsistent state, the damaged objects become visible to</div><div class="line">     *       other threads, potentially resulting in arbitrary behavior.  Many</div><div class="line">     *       uses of &lt;code&gt;stop&lt;/code&gt; should be replaced by code that simply</div><div class="line">     *       modifies some variable to indicate that the target thread should</div><div class="line">     *       stop running.  The target thread should check this variable</div><div class="line">     *       regularly, and return from its run method in an orderly fashion</div><div class="line">     *       if the variable indicates that it is to stop running.  If the</div><div class="line">     *       target thread waits for long periods (on a condition variable,</div><div class="line">     *       for example), the &lt;code&gt;interrupt&lt;/code&gt; method should be used to</div><div class="line">     *       interrupt the wait.</div><div class="line">     *       For more information, see</div><div class="line">     *       &lt;a href=&quot;&#123;@docRoot&#125;/../technotes/guides/concurrency/threadPrimitiveDeprecation.html&quot;&gt;Why</div><div class="line">     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.</div><div class="line">     */</div><div class="line">    @Deprecated</div><div class="line">    public final void stop() &#123;</div><div class="line">        stop(new ThreadDeath());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面注释，第9行到第16行表明，stop()方法可以停止“其他线程”。执行thread.stop()方法这条语句的线程称为当前线程，而“其他线程”则是 调用thread.stop()方法的对象thread所代表的线程。
第21行至23行表明，可以停止一个尚未started(启动)的线程。它的效果是：当该线程启动后，就立马结束了。</p>
<p>第48行以后的注释，则深刻表明了为什么stop()方法被弃用！为什么它是不安全的。比如说，threadA线程拥有了监视器，这些监视器负责保护某些临界资源，比如说银行的转账的金额。当正在转账过程中，main线程调用 threadA.stop()方法。结果导致监视器被释放，其保护的资源（转账金额）很可能出现不一致性。比如，A账户减少了100，而B账户却没有增加100</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://images.wodekouwei.com/Pay/weixin_qingkouwei.png" alt="轻口味 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://images.wodekouwei.com/Pay/zhifubao_qingkouwei.jpg" alt="轻口味 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/tips/" rel="tag"># tips</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/23/interview-repository-android/" rel="next" title="面试题库Android">
                <i class="fa fa-chevron-left"></i> 面试题库Android
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/31/tips-innerclass/" rel="prev" title="Java内部类详解">
                Java内部类详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">145</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是线程"><span class="nav-number">1.</span> <span class="nav-text">什么是线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程5种状态"><span class="nav-number">1.1.</span> <span class="nav-text">线程5种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程同步的7种方式"><span class="nav-number">1.2.</span> <span class="nav-text">线程同步的7种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方式1-同步方法"><span class="nav-number">1.2.1.</span> <span class="nav-text">方式1:同步方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方式2-同步代码块"><span class="nav-number">1.2.2.</span> <span class="nav-text">方式2:同步代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方式3-使用特殊域变量-volatile-实现线程同步"><span class="nav-number">1.2.3.</span> <span class="nav-text">方式3:使用特殊域变量(volatile)实现线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方式4-使用重入锁实现线程同步"><span class="nav-number">1.2.4.</span> <span class="nav-text">方式4:使用重入锁实现线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方式5-使用局部变量实现线程同步"><span class="nav-number">1.2.5.</span> <span class="nav-text">方式5:使用局部变量实现线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方式6-使用阻塞队列实现线程同步"><span class="nav-number">1.2.6.</span> <span class="nav-text">方式6:使用阻塞队列实现线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方式7-使用原子变量实现线程同步"><span class="nav-number">1.2.7.</span> <span class="nav-text">方式7:使用原子变量实现线程同步</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程局部存储ThreadLocal"><span class="nav-number">1.3.</span> <span class="nav-text">线程局部存储ThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析Java线程中断机制stop和interrupted的用法"><span class="nav-number">1.4.</span> <span class="nav-text">分析Java线程中断机制stop和interrupted的用法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  


  

</body>
</html>
