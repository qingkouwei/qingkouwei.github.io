<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老司机种菜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wodekouwei.com/"/>
  <updated>2018-01-08T10:15:40.697Z</updated>
  <id>http://wodekouwei.com/</id>
  
  <author>
    <name>轻口味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(转)聊一聊机器学习的MLE和MAP:最大似然估计和最大后验估计</title>
    <link href="http://wodekouwei.com/2018/01/08/tips-ml-mle-map/"/>
    <id>http://wodekouwei.com/2018/01/08/tips-ml-mle-map/</id>
    <published>2018-01-08T09:36:01.000Z</published>
    <updated>2018-01-08T10:15:40.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TLDR-or-the-take-away"><a href="#TLDR-or-the-take-away" class="headerlink" title="TLDR (or the take away)"></a>TLDR (or the take away)</h3><ul>
<li>概率学派 - Frequentist - Maximum Likelihood Estimation(MLE,最大似然估计)</li>
<li>贝叶斯学派 - Baysesian - Maximum A Posteriori(MAP, 最大后验估计)</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>有时候和别人聊天，对方会说自己有很多机器学习经验，深入一聊发现，对方竟然对MLE和MAP一知半解，至少在我看来，这位同学的机器学习基础并不扎实。难道在这个深度学习盛行的年代，不少同学都只注重调参数？</p>
<p>现代机器学习的终极问题都会转化为解目标函数的优化问题，MLE和MAP是生成这个函数的很基本的思想，因此我们对二者的认知是非常重要的。这次就和大家认真聊一聊MLE和MAP这两种estimator。</p>
<h3 id="两大学派的争论"><a href="#两大学派的争论" class="headerlink" title="两大学派的争论"></a>两大学派的争论</h3><p>抽象一点来讲，频率学派和贝叶斯学派对世界的认知有本质不同：频率学派认为世界是确定的，有一个本体，这个本体的真值是不变的，我们的目标就是要找到这个真值或真值所在的范围；而贝叶斯学派认为世界是不确定的，人们对世界先有一个预判，而后通过观测数据对这个预判做调整，我们的目标是要找到最优的描述这个世界的概率分布。</p>
<p>在对事物建模时，用 θ  表示模型的参数，请注意，解决问题的本质就是求θ 。那么：
<strong>(1) 频率学派：</strong> 存在唯一真值 θ  。举一个简单直观的例子–抛硬币，我们用 P(head) 来表示硬币的bias。抛一枚硬币100次，有20次正面朝上，要估计抛硬币正面朝上的bias P(head)=θ。在频率学派来看，θ = 20 / 100 = 0.2，很直观。当数据量趋于无穷时，这种方法能给出精准的估计；然而缺乏数据时则可能产生严重的偏差。例如，对于一枚均匀硬币，即 θ = 0.5，抛掷5次，出现5次正面 (这种情况出现的概率是1/2^5=3.125%)，频率学派会直接估计这枚硬币 θ = 1，出现严重错误。</p>
<p><strong>(2) 贝叶斯学派：</strong> θ 是一个随机变量，符合一定的概率分布。在贝叶斯学派里有两大输入和一大输出，输入是先验 (prior)和似然 (likelihood)，输出是后验 (posterior)。先验，即 P(θ) ，指的是在没有观测到任何数据时对 θ 的预先判断，例如给我一个硬币，一种可行的先验是认为这个硬币有很大的概率是均匀的，有较小的概率是是不均匀的；似然，即 P(X|θ) ，是假设 θ 已知后我们观察到的数据应该是什么样子的；后验，即 P(θ|X) ，是最终的参数分布。贝叶斯估计的基础是贝叶斯公式，如下：</p>
<p>$P(\theta|X)=\frac{P(X|\theta) \times P(\theta)}{P(X)}$</p>
<p>同样是抛硬币的例子，对一枚均匀硬币抛5次得到5次正面，那么 P(head) ，即 P(θ|X) ，是一个distribution，最大值会介于0.5~1之间，而不是武断的 θ = 1。</p>
<p>这里有两点值得注意的地方：</p>
<p>随着数据量的增加，参数分布会越来越向数据靠拢，先验的影响力会越来越小
如果先验是uniform distribution，则贝叶斯方法等价于频率方法。因为直观上来讲，先验是uniform distribution本质上表示对事物没有任何预判</p>
<h3 id="MLE-最大似然估计"><a href="#MLE-最大似然估计" class="headerlink" title="MLE - 最大似然估计"></a>MLE - 最大似然估计</h3><p>Maximum Likelihood Estimation, MLE是频率学派常用的估计方法！</p>
<p>假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。其中i.i.d.表示Independent and identical distribution，独立同分布。那么MLE对 $\theta$ 的估计方法可以如下推导：</p>
<p>Maximum Likelihood Estimation, MLE是频率学派常用的估计方法！</p>
<p>假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。其中i.i.d.表示Independent and identical distribution，独立同分布。那么MLE对 $\theta$ 的估计方法可以如下推导：</p>
<p>最后这一行所优化的函数被称为Negative Log Likelihood (NLL)，这个概念和上面的推导是非常重要的！</p>
<p>我们经常在不经意间使用MLE，例如</p>
<ul>
<li>上文中关于频率学派求硬币概率的例子，其方法其实本质是由优化NLL得出。本文末尾附录中给出了具体的原因 :-)</li>
<li>给定一些数据，求对应的高斯分布时，我们经常会算这些数据点的均值和方差然后带入到高斯分布的公式，其理论依据是优化NLL</li>
<li>深度学习做分类任务时所用的cross entropy loss，其本质也是MLE</li>
</ul>
<h3 id="MAP-最大后验估计"><a href="#MAP-最大后验估计" class="headerlink" title="MAP - 最大后验估计"></a>MAP - 最大后验估计</h3><p>Maximum A Posteriori, MAP是贝叶斯学派常用的估计方法！</p>
<p>同样的，假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。那么MLE对 $\theta$ 的估计方法可以如下推导：
其中，第二行到第三行使用了贝叶斯定理，第三行到第四行P(X) 可以丢掉因为与 $\theta$ 无关。注意 $-\log P(X|\theta )$ 其实就是NLL，所以MLE和MAP在优化时的不同就是在于先验项 - $\log P(\theta) $。好的，那现在我们来研究一下这个先验项，假定先验是一个高斯分布，即</p>
<p>$P(\theta) = \text{constant} \times e^{-\frac{\theta^2}{2\sigma^2}}$</p>
<p>那么， $-\log P(\theta) = \text{constant} + \frac{\theta^2}{2\sigma^2} $。至此，一件神奇的事情发生了 – 在MAP中使用一个高斯分布的先验等价于在MLE中采用L2的regularizaton！</p>
<p>再稍微补充几点：</p>
<ul>
<li>我们不少同学大学里学习概率论时，最主要的还是频率学派的思想，其实贝叶斯学派思想也非常流行，而且实战性很强</li>
<li>CMU的很多老师都喜欢用贝叶斯思想解决问题；我本科时的导师朱军老师也在做<a href="https://arxiv.org/abs/1709.05870" target="_blank" rel="external">贝叶斯深度学习</a>的工作，有兴趣可以关注一下。</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>有的同学说：“了解这些没用，现在大家都不用了。”这种想法是不对的，因为这是大家常年在用的知识，是推导优化函数的核心，而优化函数又是机器学习 (包含深度学习) 的核心之一。这位同学有这样的看法，说明对机器学习的本质并没有足够的认识，而让我吃惊的是，竟然有不少其他同学为这种看法点赞。内心感到有点儿悲凉，也引发了我写这篇文章的动力，希望能帮到一些朋友 :-)</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>[1] <a href="http://link.zhihu.com/?target=http%3A//www.utdallas.edu/%7Enrr150130/cs7301/2016fa/lects/Lecture_14_Bayes.pdf" target="_blank" rel="external">Bayesian Method Lecture</a>, UT Dallas.</p>
</li>
<li><p>[2] <a href="http://link.zhihu.com/?target=http%3A//www.utdallas.edu/%7Enrr150130/cs7301/2016fa/lects/Lecture_14_Bayes.pdf" target="_blank" rel="external">MLE, MAP, Bayes classification Lecture</a>, CMU.</p>
</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>为什么说频率学派求硬币概率的算法本质是在优化NLL？</p>
<p>因为抛硬币可以表示为参数为 $\theta$  的Bernoulli分布，即</p>
<p>$P(x_i; \theta) =\left{ \begin{array}{ll} \theta &amp; x_i = 1 \ 1 - \theta &amp; x_i = 0 \ \end{array} \right. \ = \theta^{x_i} (1- \theta)^{1-x_i}$</p>
<p>其中 x_i = 1 表示第 i 次抛出正面。那么，</p>
<p>$\text{NLL} = -\sum_{i=1}^n \log P(x<em>i; \theta) = -\sum</em>{i=1}^n \log \theta^{x_i} (1- \theta)^{1-x_i}$</p>
<p>求导数并使其等于零，得到</p>
<p>$\text{NLL}’ = -\sum_{i=1}^n\Big(\frac{x_i}{\theta} + (1-x_i)\frac{-1}{1-\theta}\Big) = 0$</p>
<p>即 $\hat{\theta} = \frac{\sum_{i=1}^n x_i}{n}$ ，也就是出现正面的次数除以总共的抛掷次数。</p>
<blockquote>
<p>转自<a href="https://zhuanlan.zhihu.com/p/32480810" target="_blank" rel="external">聊一聊机器学习的MLE和MAP：最大似然估计和最大后验估计</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TLDR-or-the-take-away&quot;&gt;&lt;a href=&quot;#TLDR-or-the-take-away&quot; class=&quot;headerlink&quot; title=&quot;TLDR (or the take away)&quot;&gt;&lt;/a&gt;TLDR (or the take awa
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
      <category term="reprint" scheme="http://wodekouwei.com/tags/reprint/"/>
    
  </entry>
  
  <entry>
    <title>机器学习资源</title>
    <link href="http://wodekouwei.com/2017/12/29/tips-ml-res/"/>
    <id>http://wodekouwei.com/2017/12/29/tips-ml-res/</id>
    <published>2017-12-29T01:59:09.000Z</published>
    <updated>2018-01-08T09:50:27.006Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/andabi/deep-voice-conversion" target="_blank" rel="external">deep-voice-conversion</a>:Deep neural networks for voice conversion (voice style transfer) in Tensorflow</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/andabi/deep-voice-conversion&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;deep-voice-conversion&lt;/a&gt;:Deep neural networks f
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
      <category term="res" scheme="http://wodekouwei.com/tags/res/"/>
    
  </entry>
  
  <entry>
    <title>FLV格式解析</title>
    <link href="http://wodekouwei.com/2017/12/20/m-f-flv/"/>
    <id>http://wodekouwei.com/2017/12/20/m-f-flv/</id>
    <published>2017-12-20T06:49:06.000Z</published>
    <updated>2018-01-08T11:37:26.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流的视频网站无一例外地使用了FLV格式。另外由于当前浏览器与Flash Player紧密的结合，使得网页播放FLV视频轻而易举，也是FLV流行的原因之一。</p>
<p>FLV是流媒体封装格式，我们可以将其数据看为二进制字节流。总体上看，FLV包括文件头（File Header）和文件体（File Body）两部分，其中文件体由一系列的Tag及Tag Size对组成。
<img src="http://images.wodekouwei.com/M/F/flv-struct.jpg" alt="flv-struct"></p>
<h3 id="FLV格式解析"><a href="#FLV格式解析" class="headerlink" title="FLV格式解析"></a>FLV格式解析</h3><p>先来一张图，这是《科比退役演讲》下载）的一个FLV视频。我使用的是UltraEdit的二进制查看工具。
<img src="http://images.wodekouwei.com/M/F/flv1.png" alt="flv-head"></p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>头部分由一下几部分组成
Signature(3 Byte)+Version(1 Byte)+Flags(1 Bypte)+DataOffset(4 Byte)</p>
<ul>
<li>signature 占3个字节 固定FLV三个字符作为标示。一般发现前三个字符为FLV时就认为他是flv文件。图中0x46 0x4C 0x56,代表FLV</li>
<li>Version 占1个字节 标示FLV的版本号。这里我们看到是1</li>
<li>Flags 占1个字节 内容标示。第0位和第2位,分别表示 video 与 audio 存在的情况.(1表示存在,0表示不存在)。截图看到是0x05，也就是00000101，代表既有视频，也有音频。</li>
<li>DataOffset 4个字节 表示FLV的header长度。这里可以看到固定是9</li>
</ul>
<h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>FLV的body部分是一系列的back-pointers+tag构成的</p>
<ul>
<li>back-pointers固定4个字节,表示前一个tag的size</li>
<li><p>tag分三种类型:video,audio,scripts.</p>
<h5 id="tag组成"><a href="#tag组成" class="headerlink" title="tag组成"></a>tag组成</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tag type+tag data size+Timestamp+TimestampExtended+stream id+ tag data</div></pre></td></tr></table></figure>
</li>
<li><p>type 1个字节。8为Audio,9为Video,18为scripts</p>
</li>
<li>tag data size 3个字节。表示tag data的长度。从streamd id 后算起。</li>
<li>Timestreamp 3个字节。时间戳</li>
<li>TimestampExtended 1个字节。时间戳扩展字段</li>
<li>stream id 3个字节。总是0</li>
<li>tag data 数据部分</li>
</ul>
<p>图上第一个tag:</p>
<ul>
<li>type=0x12=18,表示是一个scripts,FLV中,header后的第一个tag是script tag,script tag内容是amf格式数据,包含两个amf.</li>
<li>size=0x00 0x01 0x74 = 372</li>
<li>timpestreamp = 0x00 0x00 0x00</li>
<li>TimestampExtended=0x00</li>
<li>streamid=0x00 0x00 0x00</li>
<li>tag data部分:
<img src="http://images.wodekouwei.com/M/F/flv2.png" alt="FLV-TAG"></li>
</ul>
<h5 id="tag的划分"><a href="#tag的划分" class="headerlink" title="tag的划分"></a>tag的划分</h5><p>图中红色部分是我标出”(“与”)”前后的的两个back-pointers，都是4个字节。而括号中间就是第一个TAG。那是怎么计算的呢？我们就以这个做个示例。</p>
<ul>
<li>首先第一个back-pointers是0x00000000，那是因为后面是第一个TAG。所以他为0。</li>
<li>然后根据我们我们前面格式获取到size是0x00 0x01 0x74 = 372。也就是说从stream id后面再加上372个字节就到了第一个TAG的末尾，我们数一下。tag header有11个字节。那么到第一个TAG，总共有372+11=383=0x17f。</li>
<li>接下来我们找到0x17f的地址，从工具上很容易找到，正好就是后括号”)”的前面。红0x00 0x00 0x01 0x7F=372，这代表的是上一个TAG的大小。</li>
<li>最后我们计算一下，上一个TAG数据部分是372个字节，前面type、stream id等字段占了11个字节。正好是匹配的。
上面我们已经知道了怎么取划分每个TAG。接下来我们就看TAG的具体内容:</li>
</ul>
<h5 id="tag的内容"><a href="#tag的内容" class="headerlink" title="tag的内容"></a>tag的内容</h5><p>前面已经提到tag分3种。我们一个个看</p>
<h6 id="script"><a href="#script" class="headerlink" title="script"></a>script</h6><p>脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。
首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。</p>
<p>一般来说，该Tag Data结构包含两个AMF包。AMF（Action Message Format）是Adobe设计的一种通用数据封装格式，在Adobe的很多产品中应用，简单来说，AMF将不同类型的数据用统一的格式来描述。第一个AMF包封装字符串类型数据，用来装入一个“onMetaData”标志，这个标志与Adobe的一些API调用有，在此不细述。第二个AMF包封装一个数组类型(srs返回为object类型)，这个数组中包含了音视频信息项的名称和值。具体说明如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Number type</td>
<td>8 Bypte Double</td>
</tr>
<tr>
<td>1</td>
<td>Boolean type</td>
<td>1 Bypte bool</td>
</tr>
<tr>
<td>2</td>
<td>String type</td>
<td>后面2个字节为长度</td>
</tr>
<tr>
<td>3</td>
<td>Object type</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>MovieClip type</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Null type</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>Undefined type</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Reference type</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ECMA array type</td>
<td>数组,类似Map</td>
</tr>
<tr>
<td>10</td>
<td>Strict array type</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>Date type</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>Long string type</td>
<td>后面4个字节为长度</td>
</tr>
</tbody>
</table>
<p><img src="http://images.wodekouwei.com/M/F/flv3.png" alt="FLV-script-1.png">
上图为第一个AMF包</p>
<ul>
<li>type=0x02对应String</li>
<li>size=0A=10</li>
<li>value=onMetaData 正好是10个字节。</li>
</ul>
<p><img src="http://images.wodekouwei.com/M/F/flv4.png" alt="FLV_script-2.png">
上图为第二个AMF</p>
<ul>
<li>type=0x08 对应ECMA array type。</li>
</ul>
<blockquote>
<p>表示数组，类似Map。后面4个字节为数组的个数。然后是键值对，第一个为键，2个字节为长度。后面跟具体的内容。接着3个字节表示值的类型，然后根据类型判断长度。
上图我们可以判断，总共有13个键值对。
第一个长度为8个字节是duration。值类型是0x004073，第一个字节是00，所以是double，8个字节。
第二个长度5个字节是width。值也是double类型，8个字节。
依次解析下去…</p>
</blockquote>
<h6 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h6><p><img src="http://images.wodekouwei.com/M/F/flv5.png" alt="flv-audio1">
<img src="http://images.wodekouwei.com/M/F/flv6.png" alt="flv-audio2">
<img src="http://images.wodekouwei.com/M/F/flv7.png" alt="flv-audio3">
<img src="http://images.wodekouwei.com/M/F/flv8.png" alt="flv-audio4">
视频中第二个tag为音频tag</p>
<p>stream-id之后:</p>
<ul>
<li>前4位为音频格式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Linear PCM, platform endian</td>
</tr>
<tr>
<td>1</td>
<td>ADPCM</td>
</tr>
<tr>
<td>2</td>
<td>MP3</td>
</tr>
<tr>
<td>3</td>
<td>Linear PCM, little endian</td>
</tr>
<tr>
<td>4</td>
<td>Nellymoser 16-kHz mono</td>
</tr>
<tr>
<td>5</td>
<td>Nellymoser 8-kHz mono</td>
</tr>
<tr>
<td>6</td>
<td>Nellymoser</td>
</tr>
<tr>
<td>7</td>
<td>G.711 A-law logarithmic PCM</td>
</tr>
<tr>
<td>8</td>
<td>G.711 mu-law logarithmic PCM</td>
</tr>
<tr>
<td>9</td>
<td>reserved</td>
</tr>
<tr>
<td>10</td>
<td>AAC</td>
</tr>
<tr>
<td>11</td>
<td>Speex</td>
</tr>
<tr>
<td>14</td>
<td>MP3 8-Khz</td>
</tr>
<tr>
<td>15</td>
<td>Device-specific sound</td>
</tr>
</tbody>
</table>
<ul>
<li>接着2位为采样率(对于AAC总是3)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>5.5-kHz</td>
</tr>
<tr>
<td>1</td>
<td>11-kHz</td>
</tr>
<tr>
<td>2</td>
<td>22-kHz</td>
</tr>
<tr>
<td>3</td>
<td>44-kHz</td>
</tr>
</tbody>
</table>
<ul>
<li>接着1位为采样的长度(压缩过的音视频都是16bit)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>snd8Bit</td>
</tr>
<tr>
<td>1</td>
<td>snd16Bit</td>
</tr>
</tbody>
</table>
<ul>
<li>接着1位为音频类型(对于AAC总是1)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>sndMono</td>
</tr>
<tr>
<td>1</td>
<td>sndStereo</td>
</tr>
</tbody>
</table>
<h6 id="video"><a href="#video" class="headerlink" title="video"></a>video</h6><p>由于kobe视频音频编码是pcm,查找视频tag太难,使用&lt;&lt;东风破&gt;&gt; mv视频
<img src="http://images.wodekouwei.com/M/F/flv9.png" alt="flv-video1"></p>
<ul>
<li>type=0x09=9。这里应该是一个video。</li>
<li>size=0x000030=48。长度为48。</li>
<li>timestreamp=0x000000。</li>
<li>TimestampExtended =0x00。</li>
<li>stream id =0x000000</li>
</ul>
<p>我们看到数据部分：
视频信息+数据
视频信息，1个字节。</p>
<blockquote>
<p>StreamId之后的数据就表示是VideoTagHeader,如果是avc,VideoTagHeader会多出4个字节的信息就是AVCPacketType和CompositionTime</p>
</blockquote>
<ul>
<li>前4位为帧类型Frame Type</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>keyframe (for AVC, a seekable frame) 关键帧</td>
</tr>
<tr>
<td>2</td>
<td>inter frame (for AVC, a non-seekable frame)</td>
</tr>
<tr>
<td>3</td>
<td>disposable inter frame (H.263 only)</td>
</tr>
<tr>
<td>4</td>
<td>generated keyframe (reserved for server use only)</td>
</tr>
<tr>
<td>5</td>
<td>video info/command frame</td>
</tr>
</tbody>
</table>
<ul>
<li>后4位为编码ID (CodecID)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>JPEG (currently unused)</td>
</tr>
<tr>
<td>2</td>
<td>Sorenson H.263</td>
</tr>
<tr>
<td>3</td>
<td>Screen video</td>
</tr>
<tr>
<td>4</td>
<td>On2 VP6</td>
</tr>
<tr>
<td>5</td>
<td>On2 VP6 with alpha channel</td>
</tr>
<tr>
<td>6</td>
<td>Screen video version 2</td>
</tr>
<tr>
<td>7</td>
<td>AVC</td>
</tr>
</tbody>
</table>
<p>特殊情况
视频的格式(CodecID)是AVC（H.264）的话，VideoTagHeader会多出4个字节的信息，AVCPacketType 和CompositionTime。</p>
<ul>
<li>AVCPacketType 占1个字节</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>AVCDecoderConfigurationRecord(AVC sequence header)</td>
</tr>
<tr>
<td>1</td>
<td>AVC NALU</td>
</tr>
<tr>
<td>2</td>
<td>AVC end of sequence (lower level NALU sequence ender is not required or supported)</td>
</tr>
</tbody>
</table>
<p>AVCDecoderConfigurationRecord.包含着是H.264解码相关比较重要的sps和pps信息，再给AVC解码器送数据流之前一定要把sps和pps信息送出，否则的话解码器不能正常解码。而且在解码器stop之后再次start之前，如seek、快进快退状态切换等，都需要重新送一遍sps和pps的信息.AVCDecoderConfigurationRecord在FLV文件中一般情况也是出现1次，也就是第一个video tag.</p>
<ul>
<li>CompositionTime 占3个字节</li>
</ul>
<table>
<thead>
<tr>
<th>条件</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVCPacketType ==1</td>
<td>Composition time offset</td>
</tr>
<tr>
<td>AVCPacketType !=1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>再看到第二个video tag
<img src="http://images.wodekouwei.com/M/F/flv10.png" alt="flv-video"></p>
<p>我们看到 AVCPacketType =1，而后面三个字节为000043。这是一个视频帧数据。
解析到的数据完全符合上面的理论。</p>
<p>sps pps
前面我们提到第一个video 一般存放的是sps和pps。这里我们具体解析下sps和pps内容。先看下存储的格）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x01+sps[1]+sps[2]+sps[3]+0xFF+0xE1+sps size+sps+01+pps size+pps</div></pre></td></tr></table></figure></p>
<p>sps[1]=0x64
sps[2]=00
sps[3]=0D
sps size=0x001B=27(占两个字节)
跳过27个字节后，是0x01
pps size=0x0005=118(占两个字节)
跳过5个字节，就到了back-pointers。</p>
<p>视频帧数据
解析出sps和pps tag后，后面的video tag就是真正的视频数据内容了
<img src="http://images.wodekouwei.com/M/F/flv11.png" alt="flv-video3">
这是第二个video tag其实和之前图一样，只是我圈出来关键信息。先看下格式
frametype=0x17=00010111
AVCPacketType =1
Composition Time=0x000043
后面就是NALU DATA</p>
<blockquote>
<p>引用:</p>
<p><a href="http://www.jianshu.com/p/7ffaec7b3be6" target="_blank" rel="external">flv格式详解+实例剖析</a></p>
<p><a href="http://blog.csdn.net/bsplover/article/details/7426511" target="_blank" rel="external">FLV视频封装格式详解</a></p>
<p><a href="https://blog.evanxia.com/2017/07/1378" target="_blank" rel="external">【总结】FLV（AAC/AVC）学习笔记</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932368" target="_blank" rel="external">将h.264视频流封装成flv格式文件（一.flv格式）</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932431" target="_blank" rel="external">将h.264视频流封装成flv格式文件（二.开始动手）</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932585" target="_blank" rel="external">RTMP协议中的AMF数据</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/8011362" target="_blank" rel="external">rtmp协议简单解析以及用其发送h264的flv文件</a></p>
<p><a href="https://chensi.moe/blog/2015/11/20/flv-format/" target="_blank" rel="external">FLV 文件格式解析</a></p>
<p><a href="http://www.cnblogs.com/lihaiping/p/5285166.html" target="_blank" rel="external">(原)从mp4,flv文件中解析出h264和aac,送解码器解码失败</a>:,avc1与H264区别在这里其实有人遇到了和我一样的问题：<a href="http://stackoverflow.com/questions/11330764/ffmpeg-cant-decode-h264-stream-frame-data" target="_blank" rel="external">http://stackoverflow.com/questions/11330764/ffmpeg-cant-decode-h264-stream-frame-data</a></p>
<p><a href="https://gitee.com/leixiaohua1020/simplest_mediadata_test" target="_blank" rel="external">simplest_mediadata_test</a></p>
<p><a href="https://github.com/runner365/rtmp_relay" target="_blank" rel="external">rtmp_relay</a>
<a href="https://github.com/gezhaoyou/RtmpMindmap" target="_blank" rel="external">RtmpMindmap</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流
    
    </summary>
    
      <category term="音视频封装" scheme="http://wodekouwei.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://wodekouwei.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="format" scheme="http://wodekouwei.com/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>Android APK动态更新技术</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-pluggable/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-pluggable/</id>
    <published>2017-12-05T09:15:57.000Z</published>
    <updated>2017-12-05T10:33:58.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有关APK更新的技术比较多，例如：增量更新、插件式开发、热修复、RN、静默安装。
下面简单介绍一下：
|更新方式|签名|
|—|—|
|增量更新|旧版本Apk（v1.0）和新（v2.0）、旧版本Apk（v1.0）生成的差分包（apk.patch 质量小）
合并成为新版本Apk（v2.0）安装。|
|插件式开发|给宿主APK提供插件，扩展（需要的时候再下载），可以动态地替换。主要技术是动态代理的知识。|
|热修复|通过NDK底层去修复，也是C/C++的技术。|
|RN|通过JS脚本去修复APK。|
|静默安装|需要root权限，适配不同手机ROM很麻烦。|</p>
<h3 id="1-增量更新"><a href="#1-增量更新" class="headerlink" title="1.增量更新"></a>1.增量更新</h3><p>增量更新就是原有app的基础上只更新发生变化的地方，其余保持原样。
与原来每次更新都要下载完整apk包的做法相比，这样做的好处显而易见：每次变化的地方总是比较少，因此更新包的体积就会小很多。</p>
<h4 id="1-1增量更新的流程"><a href="#1-1增量更新的流程" class="headerlink" title="1.1增量更新的流程"></a>1.1增量更新的流程</h4><ol>
<li>APP检测最新版本：把当前版本告诉服务端，服务端进行判断。
如果有新版本，服务端需要对当前版本的APK与最新版本的APK进行一次差分，产生patch差分文件。（或者新版本的APK上传到服务端的时候就已经差分好了）</li>
<li>APP在后台下载差分文件，进行文件的MD5校验，在本地进行合并（跟本地的data目录下面的APK文件合并），合并出最新的APK之后，提示用户安装。</li>
<li>增量更新的最终目的：省流量地更新宿主APK。</li>
</ol>
<p>差分的处理比较麻烦的地方就是要针对不同的应用市场渠道和众多不同版本进行差分。
注意：新版本有可能比旧版本小，差分只是把变化的部分记录下来。</p>
<h4 id="1-2服务器端行为（后台工程师操作）"><a href="#1-2服务器端行为（后台工程师操作）" class="headerlink" title="1.2服务器端行为（后台工程师操作）"></a>1.2服务器端行为（后台工程师操作）</h4><h5 id="1-2-1下载拆分和合并要用的第三方库（bsdiff、bzip2）"><a href="#1-2-1下载拆分和合并要用的第三方库（bsdiff、bzip2）" class="headerlink" title="1.2.1下载拆分和合并要用的第三方库（bsdiff、bzip2）"></a>1.2.1下载拆分和合并要用的第三方库（bsdiff、bzip2）</h5><p>我们使用到的第三方库是：Binary diff，简称bsdiff，这个库专门用来实现文件的差分和合并的，它的官网如下：<a href="http://www.daemonology.net/bsdiff/" target="_blank" rel="external">http://www.daemonology.net/bsdiff/</a></p>
<h5 id="1-2-2Java代码调用"><a href="#1-2-2Java代码调用" class="headerlink" title="1.2.2Java代码调用:"></a>1.2.2Java代码调用:</h5><p>创建Web项目，用来做APP的服务端。创建工具类专门用于产生差分包：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class BsDiff &#123;</div><div class="line">    /**</div><div class="line">     * 差分</div><div class="line">     * @param oldfile</div><div class="line">     * @param newfile</div><div class="line">     * @param patchfile</div><div class="line">     */</div><div class="line">    public native static void diff(String oldfile,String newfile,String patchfile);</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.loadLibrary(&quot;bsdiff&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中JNI的实现如下（该实现写在bsdiff.cpp中）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT void JNICALL Java_com_haocai_bsdiff_BsDiff_diff</div><div class="line">(JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr) &#123;</div><div class="line">    int argc = 4;</div><div class="line">    char* oldfile = (char*)env-&gt;GetStringUTFChars(oldfile_jstr, NULL);</div><div class="line">    char* newfile = (char*)env-&gt;GetStringUTFChars(newfile_jstr, NULL);</div><div class="line">    char* patchfile = (char*)env-&gt;GetStringUTFChars(patchfile_jstr, NULL);</div><div class="line"></div><div class="line">    //参数(第一个参数无效)</div><div class="line">    char *argv[4];</div><div class="line">    argv[0] = &#123; &quot;bsdiff&quot; &#125;;</div><div class="line">    argv[1] = oldfile;</div><div class="line">    argv[2] = newfile;</div><div class="line">    argv[3] = patchfile;</div><div class="line"></div><div class="line">    bsdiff_main(argc, argv);</div><div class="line"></div><div class="line">    env-&gt;ReleaseStringUTFChars(oldfile_jstr, oldfile);</div><div class="line">    env-&gt;ReleaseStringUTFChars(newfile_jstr, newfile);</div><div class="line">    env-&gt;ReleaseStringUTFChars(patchfile_jstr, patchfile);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过研究bsdiff的源码，我们发现bsdiff.cpp里面的main函数就是入口函数，避免歧义把函数名main改为bsdiff_main，然后通过JNI去调用。根据bsdiff.cpp中bsdiff_main函数方法中有以下关键语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (argc != 4) errx(1, &quot;usage: %s oldfile newfile patchfile\n&quot;, argv[0]);</div></pre></td></tr></table></figure></p>
<p>根据提示需要传入4个参数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">argv[0] = &quot;bsdiff&quot;;//这个参数没用</div><div class="line">argv[1] = oldPath;//旧APK文件路径</div><div class="line">argv[2] = newPath;/新APK文件路径</div><div class="line">argv[3] = patchPath;//APK差分文件路径</div></pre></td></tr></table></figure></p>
<p>然后我们准备两个APK文件，不同版本的，最好Java代码、资源都不一样。</p>
<p>写一个Java测试类生成差分包：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.haocai.bsdiff;</div><div class="line"></div><div class="line">public class ConstantsWin &#123;</div><div class="line"></div><div class="line">    //路径不能包含中文</div><div class="line">    public static final String OLD_APK_PATH = &quot;D:/android_apks/test_old.apk&quot;;</div><div class="line"></div><div class="line">    public static final String NEW_APK_PATH = &quot;D:/android_apks/test_new.apk&quot;;</div><div class="line"></div><div class="line">    public static final String PATCH_PATH = &quot;D:/android_apks/apk.patch&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.haocai.bsdiff;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Administrator on 2017/11/14.</div><div class="line"> */</div><div class="line">public class BsDiffTest &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //得到差分包</div><div class="line">        BsDiff.diff(ConstantsWin.OLD_APK_PATH,ConstantsWin.NEW_APK_PATH,ConstantsWin.PATCH_PATH);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>test_new.apk、test_old.apk 要先放在目标目录</li>
<li>bsdiff.cpp中生成差分包的程序方法是异步的，所以生成完整的apk.patch可能要等一下。apk.patch体积大小停止增长，表示生成结束。<h5 id="1-2-3简单搭建后台JavaWeb供Android前端下载apk-patch差分包"><a href="#1-2-3简单搭建后台JavaWeb供Android前端下载apk-patch差分包" class="headerlink" title="1.2.3简单搭建后台JavaWeb供Android前端下载apk.patch差分包"></a>1.2.3简单搭建后台JavaWeb供Android前端下载apk.patch差分包</h5></li>
</ul>
<h4 id="1-3Android客户端行为"><a href="#1-3Android客户端行为" class="headerlink" title="1.3Android客户端行为"></a>1.3Android客户端行为</h4><h5 id="1-3-1编译合并要用的第三方库（bsdiff、bzip2）"><a href="#1-3-1编译合并要用的第三方库（bsdiff、bzip2）" class="headerlink" title="1.3.1编译合并要用的第三方库（bsdiff、bzip2）"></a>1.3.1编译合并要用的第三方库（bsdiff、bzip2）</h5><p>对应的Java代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.haocai.app.update;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Xionghu on 2017/11/14.</div><div class="line"> * Desc:</div><div class="line"> */</div><div class="line"></div><div class="line">public class BsPatch &#123;</div><div class="line">    /**</div><div class="line">     * 合并</div><div class="line">     * @param oldfile</div><div class="line">     * @param newfile</div><div class="line">     * @param patchfile</div><div class="line">     */</div><div class="line">    public native static void patch(String oldfile,String newfile,String patchfile);</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.loadLibrary(&quot;bspatch&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Android端，我们需要把bzip2以及bsdiff的文件拷贝到jni目录里面，同样的，我们只需要编译一个bspatch.c源文件即可。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//合并</div><div class="line">JNIEXPORT void JNICALL Java_com_haocai_app_update_BsPatch_patch</div><div class="line">  (JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr)&#123;</div><div class="line">    int argc = 4;</div><div class="line">    char* oldfile = (char*)(*env)-&gt;GetStringUTFChars(env,oldfile_jstr, NULL);</div><div class="line">    char* newfile = (char*)(*env)-&gt;GetStringUTFChars(env,newfile_jstr, NULL);</div><div class="line">    char* patchfile = (char*)(*env)-&gt;GetStringUTFChars(env,patchfile_jstr, NULL);</div><div class="line"></div><div class="line">    //参数（第一个参数无效）</div><div class="line">    char *argv[4];</div><div class="line">    argv[0] = &quot;bspatch&quot;;</div><div class="line">    argv[1] = oldfile;</div><div class="line">    argv[2] = newfile;</div><div class="line">    argv[3] = patchfile;</div><div class="line"></div><div class="line">    bspatch_main(argc,argv);</div><div class="line"></div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,oldfile_jstr, oldfile);</div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,newfile_jstr, newfile);</div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,patchfile_jstr, patchfile);</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>代码v1.0差分包合并核心代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">package com.haocai.app.update;</div><div class="line"></div><div class="line">import android.Manifest;</div><div class="line">import android.content.pm.PackageManager;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Message;</div><div class="line">import android.support.annotation.NonNull;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.support.v4.app.ActivityCompat;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.text.format.Formatter;</div><div class="line">import android.widget.Toast;</div><div class="line">import com.lzy.okgo.OkGo;</div><div class="line">import com.lzy.okgo.callback.FileCallback;</div><div class="line">import com.lzy.okgo.model.Progress;</div><div class="line">import com.lzy.okgo.model.Response;</div><div class="line">import com.lzy.okgo.request.base.Request;</div><div class="line">import java.io.File;</div><div class="line">import java.text.NumberFormat;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final int REQUEST_PERMISSION_STORAGE = 0x01;</div><div class="line">    private Handler mHandler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            super.handleMessage(msg);</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case 0:</div><div class="line">                    Toast.makeText(MainActivity.this, &quot;您正在进行省流量更新&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    ApkUtils.installApk(MainActivity.this, Constants.NEW_APK_PATH);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    private NumberFormat numberFormat;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        setTitle(&quot;简单文件下载&quot;);</div><div class="line"></div><div class="line">        numberFormat = NumberFormat.getPercentInstance();</div><div class="line">        numberFormat.setMinimumFractionDigits(2);</div><div class="line"></div><div class="line">        checkSDCardPermission();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 因为后台没有写版本判断语句</div><div class="line">         * 在高版本下暂时先注释fileDownload(); 否则一直下载安装</div><div class="line">         *</div><div class="line">         * 低版本下运行fileDownload();</div><div class="line">         */</div><div class="line">         fileDownload();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 检查SD卡权限</div><div class="line">     */</div><div class="line">    protected void checkSDCardPermission() &#123;</div><div class="line">        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_PERMISSION_STORAGE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">        if (requestCode == REQUEST_PERMISSION_STORAGE) &#123;</div><div class="line">            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">                //获取权限</div><div class="line">                fileDownload();</div><div class="line">            &#125; else &#123;</div><div class="line">                Toast.makeText(getApplicationContext(), &quot;权限被禁止，无法下载文件！&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        //Activity销毁时，取消网络请求</div><div class="line">        OkGo.getInstance().cancelTag(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void fileDownload() &#123;</div><div class="line"></div><div class="line">        OkGo.&lt;File&gt;get(Constants.URL_PATCH_DOWNLOAD)//</div><div class="line">                .tag(this)//</div><div class="line">                .execute(new FileCallback(Constants.SD_CARD, Constants.PATCH_FILE) &#123;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onStart(Request&lt;File, ? extends Request&gt; request) &#123;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onSuccess(Response&lt;File&gt; response) &#123;</div><div class="line"></div><div class="line">                        new Thread(new Runnable() &#123;</div><div class="line">                            @Override</div><div class="line">                            public void run() &#123;</div><div class="line"></div><div class="line">                                try &#123;</div><div class="line">                                    //      File patchFile = new File(Constants.SD_CARD, Constants.PATCH_FILE);</div><div class="line">                                    String oldfile = ApkUtils.getSourceApkPath(MainActivity.this, getPackageName());</div><div class="line">                                    String newfile = Constants.NEW_APK_PATH;</div><div class="line">                                    String patchfile = Constants.SD_CARD + File.separator + Constants.PATCH_FILE;</div><div class="line">                                    BsPatch.patch(oldfile, newfile, patchfile);</div><div class="line"></div><div class="line">                                    mHandler.sendEmptyMessage(0);</div><div class="line">                                &#125; catch (Exception e) &#123;</div><div class="line">                                    e.printStackTrace();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;).start();</div><div class="line"></div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Response&lt;File&gt; response) &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void downloadProgress(Progress progress) &#123;</div><div class="line">                        System.out.println(progress);</div><div class="line"></div><div class="line">                        String downloadLength = Formatter.formatFileSize(getApplicationContext(), progress.currentSize);</div><div class="line">                        String totalLength = Formatter.formatFileSize(getApplicationContext(), progress.totalSize);</div><div class="line">                        String speed = Formatter.formatFileSize(getApplicationContext(), progress.speed);</div><div class="line">                        System.out.println(downloadLength);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：这里7.0可能会有问题，把路径暴露给别的app，需要FileProvider去实现（不难，这个留给大家去做吧）。</p>
<blockquote>
<p><a href="https://github.com/kpioneer123/DiffInstallApp" target="_blank" rel="external">源码下载</a>
作者: <a href="http://www.jianshu.com/p/4c80d732e7c3" target="_blank" rel="external">(简书)香沙小熊</a></p>
</blockquote>
<h3 id="2-插件化"><a href="#2-插件化" class="headerlink" title="2.插件化"></a>2.插件化</h3><p>主流插件之间对比
|特性|    DynamicLoadApk|    DynamicAPK|    Small|    DroidPlugin|    VirtualAPK|RePlugin|
|—|—|—|—|—|—|—|
|支持四大组件|    只支持Activity|    只支持Activity|    只支持Activity|    全支持|    全支持|全支持|
|组件无需在宿主manifest中预注册|    √|    ×|    √|    √|    √|√|
|插件可以依赖宿主|    √|    √    |√    |×    |√|√|
|支持PendingIntent|    ×|    ×|    ×    |√    |√|√|
|Android特性支持|    大部分|    大部分|    大部分|    几乎全部|    几乎全部|几乎全部|
|兼容性适配|    一般|    一般|    中等|    高|    高|高|
|插件构建|    无|    部署aapt|    Gradle插件|    无|    Gradle插件|Gradle插件|
|源码|<code>https://github.com/singwhatiwanna/dynamic-load-apk</code>|<code>https://github.com/CtripMobile/DynamicAPK</code>||<code>https://github.com/DroidPluginTeam/DroidPlugin</code>|<code>https://github.com/didi/VirtualAPK</code>|<code>https://github.com/Qihoo360/RePlugin</code>|
|开发者|singwhatiwanna|CtripMobile||Lody|滴滴|360|</p>
<h4 id="2-1DynamicLoadApk"><a href="#2-1DynamicLoadApk" class="headerlink" title="2.1DynamicLoadApk"></a>2.1DynamicLoadApk</h4><h4 id="2-2VirtualAPK"><a href="#2-2VirtualAPK" class="headerlink" title="2.2VirtualAPK"></a>2.2VirtualAPK</h4><h5 id="2-2-1特性"><a href="#2-2-1特性" class="headerlink" title="2.2.1特性"></a>2.2.1特性</h5><table>
<thead>
<tr>
<th>Feature</th>
<th>Detail</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supported components</td>
<td>Activity, Service, Receiver and Provider</td>
</tr>
<tr>
<td>Manually register components in AndroidManifest.xml</td>
<td>No need</td>
</tr>
<tr>
<td>Access host app classes and resources</td>
<td>Supported</td>
</tr>
<tr>
<td>PendingIntent</td>
<td>Supported</td>
</tr>
<tr>
<td>Supported Android features</td>
<td>Almost all features</td>
</tr>
<tr>
<td>Compatibility</td>
<td>Almost all devices</td>
</tr>
<tr>
<td>Building system</td>
<td>Gradle plugin</td>
</tr>
<tr>
<td>Supported Android versions</td>
<td>API Level 15+</td>
</tr>
</tbody>
</table>
<h5 id="2-2-2架构"><a href="#2-2-2架构" class="headerlink" title="2.2.2架构"></a>2.2.2架构</h5><p><img src="http://images.wodekouwei.com/technology/virtualapk_arch.png" alt="image"></p>
<h5 id="2-2-3原理"><a href="#2-2-3原理" class="headerlink" title="2.2.3原理"></a>2.2.3原理</h5><h6 id="2-2-3-1基本原理"><a href="#2-2-3-1基本原理" class="headerlink" title="2.2.3.1基本原理"></a>2.2.3.1基本原理</h6><ul>
<li>合并宿主和插件的ClassLoader 需要注意的是，插件中的类不可以和宿主重复</li>
<li>合并插件和宿主的资源 重设插件资源的packageId，将插件资源和宿主资源合并</li>
<li>去除插件包对宿主的引用 构建时通过Gradle插件去除插件对宿主的代码以及资源的引用<h5 id="2-2-3-2四大组件的实现原理"><a href="#2-2-3-2四大组件的实现原理" class="headerlink" title="2.2.3.2四大组件的实现原理"></a>2.2.3.2四大组件的实现原理</h5></li>
<li>Activity 采用宿主manifest中占坑的方式来绕过系统校验，然后再加载真正的activity；</li>
<li>Service 动态代理AMS，拦截service相关的请求，将其中转给Service Runtime去处理，Service Runtime会接管系统的所有操作；</li>
<li>Receiver 将插件中静态注册的receiver重新注册一遍；</li>
<li>ContentProvider 动态代理IContentProvider，拦截provider相关的请求，将其中转给Provider Runtime去处理，Provider Runtime会接管系统的所有操作。</li>
</ul>
<h4 id="2-3RePlugin"><a href="#2-3RePlugin" class="headerlink" title="2.3RePlugin"></a>2.3RePlugin</h4><h5 id="2-3-1特性"><a href="#2-3-1特性" class="headerlink" title="2.3.1特性"></a>2.3.1特性</h5><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>组件</td>
<td>四大组件（含静态Receiver）</td>
</tr>
<tr>
<td>升级无需改主程序Manifest</td>
<td>完美支持</td>
</tr>
<tr>
<td>Android特性</td>
<td>支持近乎所有（包括SO库等）</td>
</tr>
<tr>
<td>TaskAffinity &amp; 多进程</td>
<td>支持（坑位方案）</td>
</tr>
<tr>
<td>插件类型</td>
<td>支持自带插件（自识别）、外置插件</td>
</tr>
<tr>
<td>插件间耦合</td>
<td>支持Binder、Class Loader、资源等</td>
</tr>
<tr>
<td>进程间通讯</td>
<td>支持同步、异步、Binder、广播等</td>
</tr>
<tr>
<td>自定义Theme &amp; AppComat</td>
<td>支持</td>
</tr>
<tr>
<td>DataBinding</td>
<td>支持</td>
</tr>
<tr>
<td>安全校验</td>
<td>支持</td>
</tr>
<tr>
<td>资源方案</td>
<td>独立资源 + Context传递（相对稳定）</td>
</tr>
<tr>
<td>Android 版本</td>
<td>API Level 9+ （2.3及以上）</td>
</tr>
</tbody>
</table>
<h5 id="2-3-2架构"><a href="#2-3-2架构" class="headerlink" title="2.3.2架构"></a>2.3.2架构</h5><p><img src="http://images.wodekouwei.com/technology/RePluginFramePic.jpeg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;有关APK更新的技术比较多，例如：增量更新、插件式开发、热修复、RN、静默安装。
下面简单介绍一下：
|更新方式|签名|
|—|—|
|增量
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>(转)总结Android开发中必备的代码Review清单</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-review/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-review/</id>
    <published>2017-12-05T06:11:25.000Z</published>
    <updated>2017-12-05T06:50:12.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文收集了我自己工作以来提交代码前的所有检查点。事实证明，这样能有效提高自己的代码质量和功能的稳定性。所以推荐大家以后每次提交代码前，都可以看下这份Review清单哈。</p>
<p>此外，可能还有些检查点我并没有发现，欢迎大家踊跃在评论区补充哈～</p>
<h3 id="清理操作"><a href="#清理操作" class="headerlink" title="清理操作"></a>清理操作</h3><ol>
<li>页面退出时，是否完成必要的清理操作<ol>
<li>是否调用Handler的removeCallbacksAndMessages(null)来清空Handler里的消息；</li>
<li>是否取消了还没完成的请求；</li>
<li>在页面里注册的监听，是否反注册；</li>
<li>假如自己用到观察者模式，是否反注册；</li>
<li>假如用了RxJava的话，是否解除订阅；</li>
</ol>
</li>
<li><p>数据库的游标是否已经关闭
这个点一般人都知道，出问题一般在于，没有考虑到多线程并发时的情况下，Cursor没有被释放。
所以数据库的操作需要加上同步代码块
详细可参考：<a href="http://www.2cto.com/kf/201408/329574.html" target="_blank" rel="external">http://www.2cto.com/kf/201408/329574.html</a></p>
</li>
<li><p>打开过的文件流是否关闭</p>
</li>
<li><p>Android 3.0以下的版本，使用完的Bitmap是否调用recycle()，否则会一直占用内存
而Android 3.0及以上的版本不需要调用recycle()，因为这些版本的Bitmap全部放到虚拟机的堆内存中，让GC自动回收。</p>
</li>
<li><p>WebView使用完是否调用了其destory()函数</p>
</li>
</ol>
<h3 id="是否能进一步优化自己的代码"><a href="#是否能进一步优化自己的代码" class="headerlink" title="是否能进一步优化自己的代码"></a>是否能进一步优化自己的代码</h3><ol>
<li><p>保存在内存中的图片，是否做过压缩处理再保存在内存里
否则可能由于图片质量太高，导致OOM</p>
</li>
<li><p>Intent传递的数据太大，会导致页面跳转过慢。太大的数据可以通过持久化的形式传递，例如读写文件</p>
</li>
<li><p>频繁地操作同一个文件或者执行同一个数据库操作，是否考虑把它用静态变量或者局部变量的形式缓存在内存里。用空间换时间</p>
</li>
<li><p>放在主页面的控件，是否可以考虑用ViewStub来优化启动速度</p>
</li>
</ol>
<h3 id="要小心第三方包"><a href="#要小心第三方包" class="headerlink" title="要小心第三方包"></a>要小心第三方包</h3><ol>
<li><p>build.gradle远程依赖第三方包时，版本号建议写死，不要使用+号
避免由于新版本的第三方包引入了新的问题</p>
</li>
<li><p>导入第三方工程时，记得把编码转换成自己工程当前是用的编码</p>
</li>
<li><p>调用第三方的包或者JDK的方法时，要跳进他们的源码，看要不要加 try-catch
否则可能会导致自己应用的崩溃</p>
</li>
<li><p>使用第三方包时，是否加上其混淆规则
若漏掉加上第三方包的混淆规则，会导致第三方包不该混淆的代码被混淆。在Debug版本没有发现问题，但是Release版本就会出现问题</p>
</li>
<li><p>系统应用添加so时，是否在固件对应的Android.mk文件上加入新增的so，否则系统可能编译不过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@lib/armeabi/libcommon.so \</div><div class="line">@lib/armeabi/libabcdefg.so \</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意要成对出现的地方"><a href="#注意要成对出现的地方" class="headerlink" title="注意要成对出现的地方"></a>注意要成对出现的地方</h3><ol>
<li><p>系统的、自己写的，注册和反注册的方法，是否成对出现</p>
</li>
<li><p>在生命周期的回调里，创建和销毁的代码是否对应起来
比如：onCreate()里面创建了Adapter，那么对应Adapter的退出处理操作(比如清空Image缓存)，一般就要写在onDestory()，而不能写在onDestoryView()。</p>
</li>
</ol>
<p>类似的生命周期对应的代码有：
onStart()、onStop();
onCreate()、onDestory();
onResume()、onPause();
onCreateView()、onDestoryView()</p>
<ol>
<li>若ListView的item复用了，对Item里View的操作是否成对出现
比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">switch (type) &#123;</div><div class="line">    case ArticleListItem.TYPE_AD:</div><div class="line">        ......</div><div class="line">        mTitleView.setText(tencentAdBean.title);</div><div class="line">        mGreenLabelView.setVisibility(VISIBLE);</div><div class="line">        mRedLabelView.setText(&quot;&quot;);</div><div class="line">        mRedLabelView.setVisibility(GONE);</div><div class="line">        break;</div><div class="line">    case ArticleListItem.TYPE_ARTICLE:</div><div class="line">        ......</div><div class="line">        mTitleView.setText(mzAdBean.adData.getTitle());</div><div class="line">        mGreenLabelView.setVisibility(GONE);</div><div class="line">        mRedLabelView.setText(&quot;ABC&quot;);</div><div class="line">        mRedLabelView.setVisibility(VISIBLE);</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>比如以上对mTitleView、mGreenLabelView和mRedLabelView的操作，都是成对出现。否则ListView可能会由于Item复用，导致Item显示错乱问题</p>
<h3 id="防内存泄漏"><a href="#防内存泄漏" class="headerlink" title="防内存泄漏"></a>防内存泄漏</h3><ol>
<li><p>内部类，比如Handler、Listener、Callback是否是成static class
因为非静态内部类会持有外部类的引用。</p>
</li>
<li><p>假如子线程持有了Activity，要用弱引用来持有
比如Request的Activity就应该用弱引用的形式，防止内存泄漏。</p>
</li>
<li><p>要求传入Activity作为参数的函数，是否可以改用getApplicationContext()来作为参数</p>
</li>
</ol>
<h3 id="Handler相关"><a href="#Handler相关" class="headerlink" title="Handler相关"></a>Handler相关</h3><ol>
<li>使用View.post()是否会有问题
因为在View处于detached状态期间，post()里面的Runnable是不会被执行的。只有在此View处于attached状态时才会被执行。</li>
</ol>
<p>如果想改Runnable每次肯定会被执行，那么应该是用Handler.post来替代</p>
<ol>
<li>假如程序可能多次在同一个Handler里post同一个Runnable，每次post之前都应该先清空这个Handler中还没执行的该Runnable
如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (mCloudRun != null) &#123;</div><div class="line">    mHandler.removeCallbacks(mCloudRun);</div><div class="line">    mCloudRun = null;</div><div class="line">&#125;</div><div class="line">mCloudRun = new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        CloudAccelerateSwitchRequest request = new CloudAccelerateSwitchRequest();</div><div class="line">        request.setPriority(RequestTask.PRIORITY_LOW);</div><div class="line">        RequestQueue.getInstance().addRequest(request);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">mHandler.post(mCloudRun);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><p>多思考某些情况下，某变量是否会为空
而且在函数体内，处理参数前，必须加上判空语句</p>
</li>
<li><p>回调函数是否处理好
回调函数很容易出问题。比如网络请求的回调，需要判断此时的Aciivity等是否还存在，再进行调用。因为异步操作回来，Activity可能就消失不存在了。
而且还要对一些可能被回收的变量进行判空。</p>
</li>
<li><p>修改数据库后，是否把数据库的版本号+1</p>
</li>
<li><p>启动第三方的Activity时，是否判断了该Intent能否被解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent sendIntent = new Intent(mContext, Demo.class);</div><div class="line">// 这种方式判断是否存在</div><div class="line">if (sendIntent.resolveActivity(getPackageManager()) != null) &#123;</div><div class="line">    startActivity(sendIntent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>若Activity不存在，会出现ActivityNotFoundException的异常</p>
<ol>
<li>新注册的Activity、Service或Provider，若AndroidManifest.xml中exported属性为true，要考虑是否会引发安全性问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;com.inkenka.DemoActivity&quot;</div><div class="line">            android:exported=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为exported属性为true时，外部应用就可以直接调用起该Activity。
可能导致的问题：</p>
<ul>
<li>若外部应用直接启动详情页，从而让某些验证页面直接被绕过</li>
<li>若外部应用给该Activity传递乱七八糟的Intent，可能让该应用崩溃。也就是Android中的拒绝服务漏洞</li>
</ul>
<ol>
<li><p>除数是否做了非0判断</p>
</li>
<li><p>不要在Activity的onCreate里调用PopupWindow的showAsLoaction方法，由于Activity还没被加载完，会报错</p>
</li>
</ol>
<h3 id="功能完成后，自测时的检查点"><a href="#功能完成后，自测时的检查点" class="headerlink" title="功能完成后，自测时的检查点"></a>功能完成后，自测时的检查点</h3><ol>
<li>思考某些情况下，某个变量是否会造成空指针问题</li>
<li>把手机横屏，检查布局是否有Bug</li>
<li>在不同分辨率的机型上，检查布局是否有Bug</li>
<li>切换到英文等外文字体下，检查外文是否能完整显示</li>
<li>从低版本升级上来，会不会有问题,比如可能会出现数据库不兼容的问题</li>
<li>按下Home再返回是否正常</li>
<li>熄灭屏幕再打开是否正常</li>
<li>切换成其它应用再切换回来会怎样</li>
<li>利用手机的开发者选项中的 “调试GPU过度绘制” ，“GPU呈现模式分析” 和 “显示FPS和功耗” 功能，看自己的新功能是否会导致过度绘制、是否会掉帧</li>
<li>测试看是否影响启动速度<code>adb shell am start -W 包名/Activity</code></li>
<li>对比看APK大小是否有增大</li>
<li>跑1小时Monkey，测试其稳定性</li>
</ol>
<blockquote>
<p>转自:
<a href="http://www.jianshu.com/p/4b65967fe4a0" target="_blank" rel="external">良心推荐：总结Android开发中必备的代码Review清单</a></p>
</blockquote>
<h2 id="补充-总结工作中的Android内存泄漏问题"><a href="#补充-总结工作中的Android内存泄漏问题" class="headerlink" title="补充:总结工作中的Android内存泄漏问题"></a>补充:<a href="http://www.jianshu.com/p/973ab884c397" target="_blank" rel="external">总结工作中的Android内存泄漏问题</a></h2><h3 id="简单判断是否有内存泄漏"><a href="#简单判断是否有内存泄漏" class="headerlink" title="简单判断是否有内存泄漏"></a>简单判断是否有内存泄漏</h3><p>判断内存泄漏的定位的大单位是Activity。</p>
<p>可以通过反复进入退出一个Activity，然后用adb shell dumpsys meminfo + 包名 查看虚拟机的堆是否有不断地增长</p>
<h3 id="定位内存泄漏"><a href="#定位内存泄漏" class="headerlink" title="定位内存泄漏"></a>定位内存泄漏</h3><h4 id="1-使用Leak-Canary"><a href="#1-使用Leak-Canary" class="headerlink" title="1.使用Leak Canary"></a>1.使用Leak Canary</h4><p>在代码上加入Leak Canary，然后不断跑Monkey或者手动反复进出不同页面。若出现内存泄漏问题，会自动导出来，生成以下页面。</p>
<h4 id="2-使用DDMS导出hprof，并用MAT工具进行分析"><a href="#2-使用DDMS导出hprof，并用MAT工具进行分析" class="headerlink" title="2.使用DDMS导出hprof，并用MAT工具进行分析"></a>2.使用DDMS导出hprof，并用MAT工具进行分析</h4><ul>
<li>强烈建议先跑30分钟Monkey测试</li>
<li>使用eclipse的ddms找到对应的进程，触发一次gc后，dump出里面的内存快照hprof文件以分析当前应用内存的堆有什么东西</li>
<li>使用Android SDK 里的platform-tools文件夹的 hprof-conv工具，对刚才 hprof 文件进行转换，以至于 后面MAT工具能正常打开</li>
<li>使用MAT打开hprof文件，进入Histogram。输入自己猜测可能泄漏的Activity（项目中Activity不多时，可每个Activity都重复以下3、4、5步骤）</li>
<li>键该其中一项，打开菜单选择list objects -&gt;with incoming refs将列出该类的实例</li>
<li>右健Path to GC Roots–&gt;exclue all phantom/weak/soft etc. reference，找出这个实例GC后，还会存在什么对象的引用关系。</li>
</ul>
<h3 id="常见导致内存泄漏的几个点"><a href="#常见导致内存泄漏的几个点" class="headerlink" title="常见导致内存泄漏的几个点"></a>常见导致内存泄漏的几个点</h3><h4 id="生命周期的原因"><a href="#生命周期的原因" class="headerlink" title="生命周期的原因"></a>生命周期的原因</h4><p>比如：Activity中关联了一个生命周期超过Activity的Thread，这个Thread 若持有该Activity的引用，就会导致内存泄漏。</p>
<h4 id="内部类的原因"><a href="#内部类的原因" class="headerlink" title="内部类的原因"></a>内部类的原因</h4><p>因为内部类会隐式地持有外部类的引用，若内部类不被释放，外部类也是无法释放。常见的有内部的Listener、Callback、Handler等导致。</p>
<p>情景1：若外部类应该释放的时候，内部类还在执行里面的函数，会导致外部类无法释放。</p>
<p>情景2：若一个异步操作，会回调内部类的Listener、Callback、Handler。当外部类应该释放的时候，但是这个异步操作还存在，而这个异步操作类又持有了Listener、Callback、Handler，导致外部类无法被释放。PS：这个原因也属于生命周期的原因。</p>
<h4 id="静态变量的原因"><a href="#静态变量的原因" class="headerlink" title="静态变量的原因"></a>静态变量的原因</h4><p>单例类里包含Activity</p>
<p>静态变量的类里引用到Activity</p>
<h4 id="注册与反注册、打开与关闭没成对出现的原因"><a href="#注册与反注册、打开与关闭没成对出现的原因" class="headerlink" title="注册与反注册、打开与关闭没成对出现的原因"></a>注册与反注册、打开与关闭没成对出现的原因</h4><p>比如：注册广播接收器、注册观察者（典型的譬如数据库的监听）等。或者自己写的跟Activity引用有关的clear()函数没有成对出现</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="解决内部类的问题（以Handler作为例子）"><a href="#解决内部类的问题（以Handler作为例子）" class="headerlink" title="解决内部类的问题（以Handler作为例子）"></a>解决内部类的问题（以Handler作为例子）</h4><ol>
<li>onDestroy时候remove所有msgActivity finish后未处理的msg是问题根源，所以清空所有未被执行的msg<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mHandler.removeCallbacksAndMessages(null);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：比如Listener、Callback等其他内部类的问题，页面退出的时候，应该完成必要的清理操作，比如Cancel 请求</p>
<ol>
<li>使用静态内部类 + weakReference
静态内部类不会保留对外部类的引用，如果一定要引用外部类，使用weakReference<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class MyHandler extends Handler &#123;</div><div class="line">        WeakReference&lt;Activity &gt; mActivityReference;</div><div class="line">        MyHandler(Activity activity) &#123;</div><div class="line">            mActivityReference= new WeakReference&lt;Activity&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            final Activity activity = mActivityReference.get();</div><div class="line">            if (activity != null) &#123;</div><div class="line">                mImageView.setImageBitmap(mBitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PS:比如Listener、Callback等其他内部类的问题，也可以通过这个方法来解决</p>
<h4 id="单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期"><a href="#单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期" class="headerlink" title="单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期"></a>单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期</h4><h4 id="对象的注册与反注册要成对出现"><a href="#对象的注册与反注册要成对出现" class="headerlink" title="对象的注册与反注册要成对出现"></a>对象的注册与反注册要成对出现</h4><h4 id="不使用WebView对象时，应该调用它的destory-函数来销毁它，并释放其占用的内存"><a href="#不使用WebView对象时，应该调用它的destory-函数来销毁它，并释放其占用的内存" class="headerlink" title="不使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存"></a>不使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存</h4><h4 id="因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View"><a href="#因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View" class="headerlink" title="因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View"></a>因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文收集了我自己工作以来提交代码前的所有检查点。事实证明，这样能有效提高自己的代码质量和功能的稳定性。所以推荐大家以后每次提交代码前，都可以
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>android架构</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-arch/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-arch/</id>
    <published>2017-12-05T03:59:48.000Z</published>
    <updated>2017-12-05T06:52:09.888Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/zqlxtt/p/6887938.html" target="_blank" rel="external">Android官方架构组件介绍之LifeCycle</a>,Android架构组件一共包括以下几个：</p>
<ul>
<li>LifeCycle ： 与Activity和Fragment的生命周期有关</li>
<li>LiveData ：异步可订阅数据，也是生命周期感知</li>
<li>ViewModel ：视图数据持有模型，也是生命周期感知</li>
<li>Room ：SQLite抽象层，用于简化SQLite数据存储</li>
</ul>
<p><a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank" rel="external">官网</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zqlxtt/p/6887938.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android官方架构组件介绍之LifeCycle&lt;/a&gt;,Android架构组件一共包括以下几个：&lt;
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>linux批量操作文件</title>
    <link href="http://wodekouwei.com/2017/11/30/tips-linux-rename/"/>
    <id>http://wodekouwei.com/2017/11/30/tips-linux-rename/</id>
    <published>2017-11-30T10:25:22.778Z</published>
    <updated>2017-11-30T10:34:25.610Z</updated>
    
    <content type="html"><![CDATA[<p>一个批量将mp4文件转成gif文件的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;*.mp4&quot; |sed &apos;s/.mp4$//g&apos;|xargs -i ffmpeg -i &#123;&#125;.mp4 &#123;&#125;.gif</div></pre></td></tr></table></figure>
<p><code>sed &#39;s/.mp4$//g&#39;</code>使用sed命令将mp4文件名的<code>.mp4</code>全部替换成空.<code>/g</code>是全局替换.s是sed的替换命令,替换格式<code>&#39;s/原文/要替换成的/&#39;</code></p>
<p>或者:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for file in $(find . -name &quot;*.mp4&quot; -type f);do ffmpeg -i &quot;$file&quot; &quot;$&#123;file%.*&#125;.gif&quot;;done</div></pre></td></tr></table></figure></p>
<p>找到所有<code>.mp4</code>文件进行循环,file是mp4文件全名,<code>${file%.*}</code>是剔除从右边最小匹配,即将<code>.mp4</code>去掉</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个批量将mp4文件转成gif文件的命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
    
    </summary>
    
      <category term="linux管理" scheme="http://wodekouwei.com/categories/linux%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>mac下Core Dump文件的行程与分析</title>
    <link href="http://wodekouwei.com/2017/11/17/env-mac-debug-c/"/>
    <id>http://wodekouwei.com/2017/11/17/env-mac-debug-c/</id>
    <published>2017-11-17T08:31:12.000Z</published>
    <updated>2017-11-17T08:56:36.978Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mac下生成core-dump"><a href="#mac下生成core-dump" class="headerlink" title="mac下生成core dump"></a>mac下生成core dump</h4><ol>
<li>使用<code>ulimit -c</code>查看ulimit设置,显示<code>unlimited</code>表示开启,显示0表示关闭,通过<code>ulimit -c unlimited</code>打开设置;
但是这个只在当前窗口有效果。如果需要变成系统全局设置。
就需要去改/etc/profile文件，打开，然后加上<code>ulimit -c unlimited</code>就可以了，这样当产生Crash的时候就会自动产生dump文件。</li>
<li><p>之后需要配置一下dump产生的规则和路径:<code>sudo sysctl kern.corefile=/cores/core.%N.%P</code>,其中%N表示进程名字，%P表示进程id。Linux还有%S,%T分别表示最后一个信号和时间，在MAC上没找到对应的。(mac默认生成的core dump在<code>/cores/</code>下).</p>
</li>
<li><p>最后如何用lldb来查看一个core dump文件<code>lldb -c core.xxx</code>. 在lldb命令下输入<code>bt</code>查看报错代码.</p>
</li>
</ol>
<p>生成太多core文件会占用电脑磁盘,可以关闭全局的core dump生成配置:</p>
<ol>
<li>永久关闭，则在/etc/sysctl.conf中加入一行（如果存在，则将其值修改为0），重启后生效：<code>kern.coredump=0</code></li>
<li>零时关闭，当前生效，重启后失效：<code>sudo sysctl -w kern.coredump=0</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;mac下生成core-dump&quot;&gt;&lt;a href=&quot;#mac下生成core-dump&quot; class=&quot;headerlink&quot; title=&quot;mac下生成core dump&quot;&gt;&lt;/a&gt;mac下生成core dump&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;ulim
    
    </summary>
    
      <category term="env" scheme="http://wodekouwei.com/categories/env/"/>
    
    
      <category term="Mac" scheme="http://wodekouwei.com/tags/Mac/"/>
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="C" scheme="http://wodekouwei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>android兼容性</title>
    <link href="http://wodekouwei.com/2017/11/14/tips-android-compatibility/"/>
    <id>http://wodekouwei.com/2017/11/14/tips-android-compatibility/</id>
    <published>2017-11-14T06:48:39.000Z</published>
    <updated>2017-11-14T07:06:52.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="oppo-r9s无法浮层无法显示问题"><a href="#oppo-r9s无法浮层无法显示问题" class="headerlink" title="oppo r9s无法浮层无法显示问题"></a>oppo r9s无法浮层无法显示问题</h3><p>oppo r9s,系统版本6.0.1,<code>wmParams.type = WindowManager.LayoutParams.TYPE_TOAST;</code>时无法正常弹出,改成<code>wmParams.type = WindowManager.LayoutParams.TYPE_PHONE;</code>可显示.</p>
<p>在activity中弹出浮层后马上将activity movetoback导致oppo r9s 浮层无法显示,moveTaskToBack后延迟一秒显示浮层可解决问题.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//moveTaskToBack</div><div class="line">val intent = Intent(Intent.ACTION_MAIN)</div><div class="line">                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK// 注意</div><div class="line">                intent.addCategory(Intent.CATEGORY_HOME)</div><div class="line">                aty.startActivity(intent)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;oppo-r9s无法浮层无法显示问题&quot;&gt;&lt;a href=&quot;#oppo-r9s无法浮层无法显示问题&quot; class=&quot;headerlink&quot; title=&quot;oppo r9s无法浮层无法显示问题&quot;&gt;&lt;/a&gt;oppo r9s无法浮层无法显示问题&lt;/h3&gt;&lt;p&gt;oppo r
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>SQL查询案例</title>
    <link href="http://wodekouwei.com/2017/11/08/db-sql-query/"/>
    <id>http://wodekouwei.com/2017/11/08/db-sql-query/</id>
    <published>2017-11-08T07:47:36.000Z</published>
    <updated>2017-11-08T08:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>如下数据库表:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Student(S#,Sname,Sage,Ssex)学生表</div><div class="line">S#：学号</div><div class="line">Sname：学生姓名</div><div class="line">Sage：学生年龄</div><div class="line">Ssex：学生性别</div><div class="line">Course(C#,Cname,T#)课程表</div><div class="line">C#：课程编号</div><div class="line">Cname：课程名称</div><div class="line">T#：教师编号</div><div class="line">SC(S#,C#,score)成绩表</div><div class="line">S#：学号</div><div class="line">C#：课程编号</div><div class="line">score：成绩</div><div class="line">Teacher(T#,Tname)教师表</div><div class="line">T#：教师编号：</div><div class="line">Tname：教师名字</div></pre></td></tr></table></figure></p>
<ol>
<li><p>查询“001”课程比“002”课程成绩高的所有学生的学号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select a.S# from (select S#,score from SC where C#=&apos;001&apos;)a, (select s#,score from SC where c#=&apos;002&apos;)b Where a.score&gt;b.score</div></pre></td></tr></table></figure>
</li>
<li><p>查询平均成绩大于60分的同学的学号和平均成绩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">查询平均成绩大于60分的同学的学号和平均成绩</div></pre></td></tr></table></figure>
</li>
<li><p>查询所有同学的学号、姓名、选课数、总成绩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select student.S#, student.Sname, count(sc.C#), sum(score) from student left outer join SC on student.S# = SC.S# group by S</div></pre></td></tr></table></figure>
</li>
<li><p>查询姓‘李’的老师的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select count(distinct(Tname))</div><div class="line">from teacher</div><div class="line">where tname like &apos;李%&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>查询没有学过“叶平”老师可的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select student.S#, student.Sname</div><div class="line">from Student</div><div class="line">where S# not in (select distinct(SC.S#) from SC,Course,Teacher</div><div class="line">where sc.c#=course.c# AND teacher.T#=course.T# AND Teahcer.Tname =&apos;叶平&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>查询学过“叶平”老师所教的所有课的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select S#,Sname   from Student    </div><div class="line">where S# in (select S# from SC ,Course ,Teacher</div><div class="line">where SC.C#=Course.C# and Teacher.T#=Course.T#</div><div class="line">and Teacher.Tname=&apos;叶平&apos; group by S#</div><div class="line">having count(SC.C#)=(select count(C#) from Course,Teacher  </div><div class="line">where Teacher.T#=Course.T# and Tname=&apos;叶平&apos;));</div></pre></td></tr></table></figure>
</li>
<li><p>查询学过“011”并且也学过编号“002”课程的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select Student.S#,Student.Sname</div><div class="line">from Student,SC where Student.S#=SC.S#</div><div class="line">and SC.C#=&apos;001&apos;and</div><div class="line">exists( Select * from SC as SC_2 where SC_2.S#=SC.S# and SC_2.C#=&apos;002&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Select S#,Sname</div><div class="line">from (select Student.S#,Student.Sname,score ,</div><div class="line">(select score from SC SC_2 where SC_2.S#=Student.S# and SC_2.C#=&apos;002&apos;) score2    </div><div class="line">from Student,SC</div><div class="line">where Student.S#=SC.S# and C#=&apos;001&apos;) S_2</div><div class="line">where score2 &lt; score;</div></pre></td></tr></table></figure>
</li>
<li><p>查询所有课程成绩小于60的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select S#, sname</div><div class="line">from student</div><div class="line">where s# not in</div><div class="line">(select student.s# from student, sc where s.s# = sc.s# and score&gt;60);</div></pre></td></tr></table></figure>
</li>
<li><p>查询没有学全所有课的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select student.s#, student.sname</div><div class="line">from student, sc</div><div class="line">where student.s#=sc.s#</div><div class="line">group by student.s#, student.sname</div><div class="line">having count(c#)&lt;(select count(c#) from course);</div></pre></td></tr></table></figure>
</li>
<li><p>查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select s#, Sname</div><div class="line">from Student, SC</div><div class="line">where student.s# = sc.s#</div><div class="line">and c# in (select c# from SC where s#=&apos;1001&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select distinct sc.s# , sname</div><div class="line">from student, sc</div><div class="line">where student.s#=sc.s#</div><div class="line">and c# in (select C# from sc where s#=&apos;001&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Update Sc Set Score=(Select Avg(s2_Score) From sc s2 Where s2.c#=sc.c#)  </div><div class="line">Where c# IN</div><div class="line">(Select c# From sc cs INNER JOIN Teacher tc ON cs.t#=tc.t# WHERE tname =&apos;叶平&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p>查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select s# from sc where c#  in</div><div class="line">(select c# from sc where s#=&apos;1002&apos;)</div><div class="line">group by s# having count(*)=</div><div class="line">(select count(*) from sc where s#=&apos;1002&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>删除学习“叶平”老师课的SC表记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">delect sc</div><div class="line">from course, Teacher</div><div class="line">where course.c#=sc.c#</div><div class="line">and course.t#=teacher.t#</div><div class="line">and tname=&apos;叶平&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Insert SC select S#,&apos;002&apos;,</div><div class="line">(Select avg(score) from SC where C#=&apos;002&apos;)</div><div class="line">from Student where S# not in (Select S# from SC where C#=&apos;002&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示：学生ID，数据库，企业管理，英语，有效课程数，有效平均分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select s# as 学生ID,</div><div class="line">(select score from sc where sc.s#=t.s# and c#=&apos;004&apos;) as 数据库,</div><div class="line">(select score from sc where sc.s#=t.s# and c#=&apos;001&apos;) as 企业管理,</div><div class="line">(select score from sc where sc.s#=t.s# and c#=&apos;006&apos;) as 英语,</div><div class="line">count(*) as 有效课程数, avg(t.score) as 平局成绩</div><div class="line">from sc as t</div><div class="line">group by s#</div><div class="line">order by avg(t.score)</div></pre></td></tr></table></figure>
</li>
<li><p>查询各科成绩最高和最低的分： 以如下的形式显示：课程ID，最高分，最低分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">select L.c# as 课程ID, L.score as 最高分,</div><div class="line">R.score as 最低分</div><div class="line">from sc L, sc R</div><div class="line">where L.c# = R.c#</div><div class="line">and L.score = (select max(IL.score)</div><div class="line">        from sc IL, student as IM</div><div class="line">        where L.c#=IL.c# and IM.s#=IL.s#</div><div class="line">        group by IL.c#)</div><div class="line">and R.score = (select min(IR.score)</div><div class="line">        from sc as IR</div><div class="line">        where R.c#=IR.c#</div><div class="line">        group by IR.c#);</div></pre></td></tr></table></figure>
</li>
<li><p>按各科平均成绩从低到高和及格率的百分数从高到低顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT t.C# AS 课程号,</div><div class="line">max(course.Cname)AS 课程名,</div><div class="line">isnull(AVG(score),0) AS 平均成绩,</div><div class="line">100 * SUM(CASE WHEN  isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) AS 及格百分数     </div><div class="line">FROM SC T,Course     </div><div class="line">where t.C#=course.C#     </div><div class="line">GROUP BY t.C#      </div><div class="line">ORDER BY 100 * SUM(CASE WHEN  isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) DESC</div></pre></td></tr></table></figure>
</li>
<li><p>查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）：</p>
</li>
<li><p>查询不同老师所教不同课程平均分从高到低显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT max(Z.T#) AS 教师ID,</div><div class="line">MAX(Z.Tname) AS 教师姓名,</div><div class="line">C.C# AS 课程ID,</div><div class="line">AVG(Score) AS 平均成绩     </div><div class="line">FROM SC AS T,Course AS C ,Teacher AS Z    </div><div class="line">where T.C#=C.C# and C.T#=Z.T#   </div><div class="line">GROUP BY C.C#    </div><div class="line">ORDER BY AVG(Score) DESC</div></pre></td></tr></table></figure>
</li>
<li><p>查询如下课程成绩第3名到第6名的学生成绩单：企业管理(001)，马克思(002)，UML(003)，数据库(004)：</p>
</li>
<li><p>统计下列各科成绩，各分数段人数：课程ID，课程名称，[100-85],[85-70],[70-60],[ 小于60] ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT SC.C# as 课程ID, Cname as 课程名称,</div><div class="line">SUM(CASE WHEN score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS [100 - 85]  ,</div><div class="line">SUM(CASE WHEN score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS [85 - 70],</div><div class="line">SUM(CASE WHEN score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS [70 - 60],</div><div class="line">SUM(CASE WHEN score &lt; 60 THEN 1 ELSE 0 END) AS [60 -]     </div><div class="line">FROM SC,Course     </div><div class="line">where SC.C#=Course.C#     </div><div class="line">GROUP BY SC.C#,Cname;</div></pre></td></tr></table></figure>
</li>
<li><p>查询学生平均成绩及其名次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SELECT 1+(SELECT COUNT( distinct 平均成绩)                </div><div class="line">FROM (SELECT S#,AVG(score) AS 平均成绩                       </div><div class="line">FROM SC                   </div><div class="line">GROUP BY S#  ) AS T1  WHERE 平均成绩 &gt; T2.平均成绩) as 名次,       </div><div class="line">S# as 学生学号,平均成绩      </div><div class="line">FROM (SELECT S#,AVG(score) 平均成绩             </div><div class="line">FROM SC         </div><div class="line">GROUP BY S# ) AS T2      </div><div class="line">ORDER BY 平均成绩 desc;</div></pre></td></tr></table></figure>
</li>
<li><p>查询各科成绩前三名的记录（不考虑成绩并列情况）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SELECT t1.S# as 学生ID,t1.C# as 课程ID,Score as 分数       </div><div class="line">FROM SC t1        </div><div class="line">WHERE score IN</div><div class="line">(SELECT TOP 3 score               </div><div class="line">FROM SC               </div><div class="line">WHERE t1.C#= C#             </div><div class="line">ORDER BY score DESC)</div><div class="line">```        </div><div class="line">26. 查询每门课程被选修的学生数：</div></pre></td></tr></table></figure>
</li>
</ol>
<p>select c#, count(s#)
from sc
group by c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">27. 查询出只选修一门课程的全部学生的学号和姓名：</div></pre></td></tr></table></figure></p>
<p>select sc.s#, student.sname, count(c#) as 选课数
from sc,student
where sc.s# =student.s#
group by sc.s#,Student.sname
having count(c#)=1;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">28. 查询男生、女生人数：</div></pre></td></tr></table></figure></p>
<p>select count(Ssex) as 男生人数
from student
group by Ssex
having Ssex=’男’；
select count(Ssex) as 女生人数
from student
group by Ssex
having Ssex=’女’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">29. 查询姓“张”的学生名单：</div></pre></td></tr></table></figure></p>
<p>select sname
from student
where sname like ‘张%’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30. 查询同名同姓的学生名单，并统计同名人数：</div></pre></td></tr></table></figure></p>
<p>select sanme,count(<em>)
from student
group by sname
havang count(</em>)&gt;1;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">31. 1981年出生的学生名单（注：student表中sage列的类型是datetime）:</div></pre></td></tr></table></figure></p>
<p>select sname, convert(char(11),DATEPART(year,sage)) as age
from student
where convert(char(11),DATEPART(year,Sage))=’1981’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">32. 查询平均成绩大于85的所有学生的学号、姓名和平均成绩：</div></pre></td></tr></table></figure></p>
<p>select Sname,SC.S# ,avg(score)<br>from Student,SC<br>where Student.S#=SC.S#
group by SC.S#,Sname
having    avg(score)&gt;85;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">33. 查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列：</div></pre></td></tr></table></figure></p>
<p>select C#, avg(score)
from sc
group by c#
order by avg(score), c# desc;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">34. 查询课程名称为“数据库”，且分数低于60的学生名字和分数：</div></pre></td></tr></table></figure></p>
<p>select sname, isnull(score,0)
from student, sc ,course
where sc.s#=student.s#  and sc.c#=course.c# and course.cname=’数据库’ and score<60; <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">35. 查询所有学生的选课情况：</div></pre></td></tr></table></60;></p>
<p>select sc.s#,sc.c#,sname,cname
from sc,student course
where sc.s#=student.s# and sc.c#=course.c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">36. 查询任何一门课程成绩在70分以上的姓名、课程名称和分数：</div></pre></td></tr></table></figure></p>
<p>select distinct student.s#,student.sname,sc.c#,sc.score
from student,sc
where sc.score&gt;=70 and sc.s#=student.s#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">37. 查询不及格的课程，并按课程号从大到小的排列：</div></pre></td></tr></table></figure></p>
<p>select c#
from sc
where score<60 order="" by="" c#;="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">38. 查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名：</div></pre></td></tr></table></60></p>
<p>select sc.s#,student.sname
from sc,student
where sc.s#=student.s# and score&gt;80 and c#=’003’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">39. 求选了课程的学生人数：</div></pre></td></tr></table></figure></p>
<p>select count(*) from sc;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">40. 查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩：</div></pre></td></tr></table></figure></p>
<p>select student.sname,score
from student,sc,course c, teacher
where student.s#=sc.S# and sc.c#=c.c#
and c.T#=teacher.T#
and teacher.tname=’叶平’
and sc.score=(select max(score) from sc where c#=c.c#);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">41. 查询各个课程及相应的选修人数：</div></pre></td></tr></table></figure></p>
<p>select count(*) from sc group by c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">42. 查询不同课程成绩相同的学生和学号、课程号、学生成绩：</div></pre></td></tr></table></figure></p>
<p>select distinct a.s#,b.score
from sc a ,sc b
where a.score=b.score
and a.c#&lt;&gt;b.c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">43. 查询每门课程成绩最好的前两名：</div></pre></td></tr></table></figure></p>
<p>select t1.s# as 学生ID,t1.c#  课程ID, Score as 分数
from sc t1
where score in (select top 2 score from sc
        where t1.c#=c#
        order by score desc)
order by t1.c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">44. 统计每门课程的学生选修人数(超过10人的课程才统计)。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序：</div></pre></td></tr></table></figure></p>
<p>select c# as 课程号,count(<em>) as 人数
from sc
group by c#
order by count(</em>) desc c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">45. 检索至少选修两门课程的学生学号：</div></pre></td></tr></table></figure></p>
<p>select s#
from sc
group by s#
having count(*)&gt;=2;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">46. 查询全部学生选修的课程和课程号和课程名：</div></pre></td></tr></table></figure></p>
<p>select c# ,cname
from course
where c# in (select c# from sc group by c#);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">47. 查询没学过”叶平”老师讲授的任一门课程的学生姓名：</div></pre></td></tr></table></figure></p>
<p>select sname
from student
where s# not in (select s# from course,teacher,sc where course.t#=teacher.t# and sc.c#=course.c#
and tname=’叶平’);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">48. 查询两门以上不及格课程的同学的学号以及其平均成绩：</div></pre></td></tr></table></figure></p>
<p>select s#,avg(isnull(score,0))
from sc
where s# in (select s# from sc where score<60 group="" by="" s#="" having="" count(*)="">2)
group by s#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">49. 检索“004”课程分数小于60，按分数降序排列的同学学号：</div></pre></td></tr></table></figure></60></p>
<p>select s#
from sc
where c#=’004’
and score<60 order="" by="" score="" desc;="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">50. 删除“002”同学的“001”课程的成绩：</div></pre></td></tr></table></60></p>
<p>delect from sc
where s#=’002’
and c#=’001’;
```</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如下数据库表:
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;
    
    </summary>
    
      <category term="db" scheme="http://wodekouwei.com/categories/db/"/>
    
    
      <category term="sql" scheme="http://wodekouwei.com/tags/sql/"/>
    
      <category term="db" scheme="http://wodekouwei.com/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>android-phone-compatibility</title>
    <link href="http://wodekouwei.com/2017/11/02/android-phone-compatibility/"/>
    <id>http://wodekouwei.com/2017/11/02/android-phone-compatibility/</id>
    <published>2017-11-02T09:26:11.000Z</published>
    <updated>2017-11-02T09:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="系统摄像视频文件格式"><a href="#系统摄像视频文件格式" class="headerlink" title="系统摄像视频文件格式"></a>系统摄像视频文件格式</h4><p>一般手机使用摄像头录制视频格式为yuv420p,而小米5录制出的为yuvj420p.格式转换是yuvj420p当成yuv420p处理即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;系统摄像视频文件格式&quot;&gt;&lt;a href=&quot;#系统摄像视频文件格式&quot; class=&quot;headerlink&quot; title=&quot;系统摄像视频文件格式&quot;&gt;&lt;/a&gt;系统摄像视频文件格式&lt;/h4&gt;&lt;p&gt;一般手机使用摄像头录制视频格式为yuv420p,而小米5录制出的为yuvj4
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="compatibility" scheme="http://wodekouwei.com/tags/compatibility/"/>
    
  </entry>
  
  <entry>
    <title>ndk编译常见问题</title>
    <link href="http://wodekouwei.com/2017/11/01/issue-ndk-compile/"/>
    <id>http://wodekouwei.com/2017/11/01/issue-ndk-compile/</id>
    <published>2017-11-01T02:27:28.000Z</published>
    <updated>2017-11-01T04:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="depends-on-undefined-modules"><a href="#depends-on-undefined-modules" class="headerlink" title="depends on undefined modules"></a>depends on undefined modules</h4><p>问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Users/shenjunwei/program/android-ndk-r14b/build/core/build-binary.mk:687: Android NDK: Module magicsdk_fmod depends on undefined modules: cutils</div><div class="line">/Users/shenjunwei/program/android-ndk-r14b/build/core/build-binary.mk:700: *** Android NDK: Aborting (set APP_ALLOW_MISSING_DEPS=true to allow missing dependencies)    .  Stop.</div></pre></td></tr></table></figure></p>
<p>解决方案:
Android.mk中增加<code>APP_ALLOW_MISSING_DEPS=true</code></p>
<h4 id="shared-library-text-segment-is-not-shareable"><a href="#shared-library-text-segment-is-not-shareable" class="headerlink" title="shared library text segment is not shareable"></a>shared library text segment is not shareable</h4><p>问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/shenjunwei/program/android-ndk-r14b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/../../../../arm-linux-androideabi/bin/ld: warning: shared library text segment is not shareable</div><div class="line">/Users/shenjunwei/program/android-ndk-r14b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/../../../../arm-linux-androideabi/bin/ld: error: treating warnings as errors</div><div class="line">clang++: error: linker command failed with exit code 1 (use -v to see invocation)</div><div class="line">make: *** [/Users/shenjunwei/Documents/repository/wonxing/normandy_android_app/modules-int/magicsdk_core/src/main/obj/local/armeabi-v7a/libmagicsdk_ex.so] Error 1</div></pre></td></tr></table></figure></p>
<p>解决:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from Android NDK r11 you can use</div><div class="line"></div><div class="line">LOCAL_LDLIBS += -Wl,--no-warn-shared-textrel</div><div class="line">You can also use</div><div class="line"></div><div class="line">LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true</div></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/19986523/shared-library-text-segment-is-not-shareable" target="_blank" rel="external">shared library text segment is not shareable</a></p>
</blockquote>
<h4 id="has-text-relocations"><a href="#has-text-relocations" class="headerlink" title="has text relocations"></a>has text relocations</h4><p>问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/data/app/com.wonxing.touchfa-2/lib/arm/libmagicsdk_ex.so: has text relocations</div><div class="line">E/FileUtil: access inferno failed! /data/app/com.wonxing.touchfa-2/lib/arm/libmagicsdk_ex.so</div><div class="line">                                                             java.lang.UnsatisfiedLinkError: dlopen failed: /data/app/com.wonxing.touchfa-2/lib/arm/libmagicsdk_ex.so: has text relocations</div><div class="line">                                                                 at java.lang.Runtime.load0(Runtime.java:897)</div><div class="line">                                                                 at java.lang.System.load(System.java:1505)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.util.FileUtil$EXLibUtil.load(FileUtil.java:465)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.MagicRecorder.loadEXLibrary(MagicRecorder.java:280)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.MagicRecorder.prepare(MagicRecorder.java:471)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.MagicRecorder.prepare(MagicRecorder.java:352)</div><div class="line">                                                                 at com.wonxing.touchfa.ui.activity.VideoImportActivity.preparePlaySDK(VideoImportActivity.java:144)</div></pre></td></tr></table></figure></p>
<p>解决:</p>
<ol>
<li>方案一
This issue could be solved by checking the targetSDKVersion in the manifest file.</li>
</ol>
<p>Using “22” and not “23” as targetSDKVersion solved it. (See below)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;uses-sdk</div><div class="line">        android:minSdkVersion=&quot;15&quot;</div><div class="line">        android:targetSdkVersion=&quot;22&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>I also checked the build.gradle files for compile version and targetSDKversion:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">compileSdkVersion 22</div><div class="line">    buildToolsVersion &apos;22.0.1&apos;</div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        minSdkVersion 15</div><div class="line">        targetSdkVersion 22</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案二
It was caused by the ffmpeg, and it could also be solved by patching the latest ffmpeg code<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">libavcodec\arm\fft_fixed_neon.S</div><div class="line">libavcodec\arm\fft_neon.S</div><div class="line">libavcodec\arm\fft_vfp.S</div><div class="line">libavcodec\arm\mlpdsp_armv5te.S</div><div class="line">libutil\arm\asm.S</div></pre></td></tr></table></figure>
</li>
</ol>
<p>I took the latest from <a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">https://github.com/FFmpeg/FFmpeg</a></p>
<p>You will also need HAVE_SECTION_DATA_REL_RO declared somewhere in your build for the macro in asm.S to use the dynamic relocations option.</p>
<ol>
<li>方案三(Further informations:)
Previous versions of Android would warn if asked to load a shared library with text relocations:</li>
</ol>
<p>“libfoo.so has text relocations. This is wasting memory and prevents security hardening. Please fix.”.</p>
<p>Despite this, the OS will load the library anyway. Marshmallow rejects library if your app’s target SDK version is &gt;= 23. System no longer logs this because it assumes that your app will log the dlopen(3) failure itself, and include the text from dlerror(3) which does explain the problem. Unfortunately, lots of apps seem to catch and hide the UnsatisfiedLinkError throw by System.loadLibrary in this case, often leaving no clue that the library failed to load until you try to invoke one of your native methods and the VM complains that it’s not present.</p>
<p>You can use the command-line scanelf tool to check for text relocations. You can find advice on the subject on the internet; for example <a href="https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide" target="_blank" rel="external">https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide</a> is a useful guide.</p>
<p>And you can check if your shared lbirary has text relocations by doing this:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readelf -a path/to/yourlib.so | grep TEXTREL</div></pre></td></tr></table></figure></p>
<p>If it has text relocations, it will show you something like this:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x00000016 (TEXTREL)                    0x0</div></pre></td></tr></table></figure></p>
<p>If this is the case, you may recompile your shared library with the latest NDK version available:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ndk-build -B -j 8</div></pre></td></tr></table></figure>
<p>And if you check it again, the grep command will return nothing.</p>
<blockquote>
<p><a href="https://android-developers.googleblog.com/2016/06/android-changes-for-ndk-developers.html" target="_blank" rel="external">Android Developers Blog</a>
<a href="https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide#Introduction" target="_blank" rel="external">Hardened/Textrels Guide</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;depends-on-undefined-modules&quot;&gt;&lt;a href=&quot;#depends-on-undefined-modules&quot; class=&quot;headerlink&quot; title=&quot;depends on undefined modules&quot;&gt;&lt;/a&gt;de
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="NDK" scheme="http://wodekouwei.com/tags/NDK/"/>
    
      <category term="issue" scheme="http://wodekouwei.com/tags/issue/"/>
    
  </entry>
  
  <entry>
    <title>最近应用杀掉进程application不销毁问题探讨</title>
    <link href="http://wodekouwei.com/2017/10/31/tips-android-application-recent/"/>
    <id>http://wodekouwei.com/2017/10/31/tips-android-application-recent/</id>
    <published>2017-10-31T12:15:34.000Z</published>
    <updated>2017-10-31T12:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>建雨在芝士圈应用的application中使用了全局静态变量标志是否正在录制中,开启直播后将该变量设置为录制中,录制中一些操作将被屏蔽.但是对某些手机(如htc d816)当从”最近应用”杀掉进程后有时候application不被回收,该状态变量无法通过application的onCreate中重新初始化,同时通知栏也未消失.在<a href="http://www.jianshu.com/p/169bd25ce96e" target="_blank" rel="external">Android 应用被杀后Notification不取消问题及应用深杀和浅杀时Service生命周期情况</a>探讨中找到service的<strong>onTaskRemoved</strong>方法可以监听到应用被从最近应用中移除.</p>
<p>关于&lt;<android 应用被杀后notification不取消问题及应用深杀和浅杀时service生命周期情况="">&gt;摘要:
目中有如下需求：后台service进行导入操作，要更新Notification。当运行系统清理使应用被杀时，Notification无法取消，仍然在通知栏显示。为解决这个问题进行了如下探索：</android></p>
<p>首先想到利用service的startForeground()来更新通知栏，这样当应用被杀掉时候Notification可以一起被去掉。但针对项目的需求：service可以同时导入多个文件，并且会对应显示多个通知。这种情况下用service.startForeground()更新通知栏时候，当应用被杀时候之后cancel掉最后一次调用startForeground对应id的Notification，而其他通知仍然不能被取消。</p>
<p>继续探索用其他方式取消通知栏：在进程被杀掉的时候，会调用service的哪些生命周期函数呢？service的onDestroy()方法只有在调用Context的stopService()或Service的stopSelf()后才会被调用，在应用被杀时候Service的onDestroy()不会被执行。</p>
<p>我们发现service的 onTaskRemoved()方法，该方法何时被调用呢？方法的注释说明是这么写的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* This is called if the service is currently running and the user has</div><div class="line">* removed a task that comes from the service&apos;s application.  If you have</div><div class="line">* set &#123;@linkandroid.content.pm.ServiceInfo#FLAG_STOP_WITH_TASK ServiceInfo.FLAG_STOP_WITH_TASK&#125;</div><div class="line">* then you will not receive this callback; instead, the service will simply</div><div class="line">* be stopped.</div><div class="line">*</div><div class="line">*@paramrootIntentThe original root Intent that was used to launch</div><div class="line">* the task that is being removed.</div><div class="line">*/</div><div class="line"></div><div class="line">public void onTaskRemoved(Intent rootIntent) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释表明onTaskRemoved()方法在当用户移除应用的一个Task栈时被调用。也就是当用户在最近任务界面把该应用的一个task划掉时，或者在最近任务界面进行清理时。这两种情况下onTaskRemoved()都会被调用，但在大多Android机型上，这两种情况有所不同：第一种情况即应用被浅杀(用户只划掉这一个Task)，该Task栈会被清理，但如果有后台service在运行，该应用的进程不会被杀掉，后台service仍然在运行。第二种即应用被深杀(用户在最近任务界面直接按清理按钮)，该应用的进程会被直接杀掉，后台的service当然也停止了。对于不同的手机品牌和机型在最近任务进行各种清理时过程可能不太一样，但应用浅杀和深杀对于所有Android手机都是有普遍意义的。</p>
<p>下面我们分析在应用被浅杀和被深杀以及先浅杀再深杀后的生命周期：</p>
<p>浅杀：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">04-21 17:55:13.733 8264-8264/com.qintong.test D/qintong: vCardService onTaskRemoved.</div></pre></td></tr></table></figure></p>
<p>深杀：
会出现两种情况：
(a).
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">04-26 16:20:00.349 32674-32674/? D/qintong: Service onTaskRemoved.</div><div class="line">04-26 16:21:01.621 2936-2936/? D/qintong: Service is being created.</div><div class="line">04-26 16:21:01.628 2936-2936/? D/qintong: Service onStartCommand.</div></pre></td></tr></table></figure></p>
<p>(b).
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">04-21 17:59:58.397 8264-8264/com.qintong.test D/qintong: Service onCreate.</div><div class="line">04-21 17:59:58.404 8264-8264/com.qintong.test D/qintong: Service onTaskRemoved.</div></pre></td></tr></table></figure></p>
<p>浅杀＋深杀 （service 的 onStartCommand 返回 STICKY）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">04-21 18:05:12.717 8264-8264/com.qintong.test D/qintong: Service onTaskRemoved.</div><div class="line">04-21 18:05:29.214 9207-9207/com.qintong.test D/qintong: Service onCreate.</div><div class="line">04-21 18:05:29.223 9207-9207/com.qintong.test D/qintong: Service onStartCommand.</div></pre></td></tr></table></figure></p>
<p>我们来分析这几种情况：
(1).浅杀时:应用进程没被杀掉，service仍然在执行，service的onTaskRemoved()立即被调用。</p>
<p>(2).深杀时：有两种情况：第一种情况是深杀后直接调用onTaskRemoved()且service停止，过段时间后service重启调用其onCreate()和onStartCommand()。第二种是应用的进程被杀掉，过一会后service的onCreate()方法被调用，紧接着onTaskRemoved()被调用。由于被深杀后应用的进程立刻停止了，所以service的onTaskRemoved()无法被立即调用。而过若干秒后，service重启，onCreate()被调用，紧接着onTaskRemoved()被调用。而这里service的其他方法并没有被调用，即使onStartCommand()返回STICKY，service重启后onStartCommand()方法也没有被调用。</p>
<p>(3).浅杀+深杀时(service 的 onStartCommand 返回 STICKY)：onTaskRemoved()立刻被调用(浅杀后)，深杀后过段时间onCreate()和onStartCommand()相继被调用。执行浅杀Task被清理，应用的进程还在，onTaskRemoved()被调用，过程与(1)一样。再执行深杀：由于该应用的Task栈已经没有了，所有再深杀onTaskRemoved()不会再被调用，深杀后service停止。而由于实验时候onStartCommand()返回STICKY，所有service过段时间会被再次启动，执行了onCreate()方法和onStartCommand()方法。</p>
<p>所以综上所述，service的onTaskRemoved()在应用浅杀后会被立即调用而在service被深杀后，会直接调用onTaskRemoved或service会被重启并调用onTaskRemoved()。</p>
<p>回到我们的问题：应用被杀后，如何取消Notification：
我们先看最后的解决方案，在来分析为何能work。
service的代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onCreate() &#123;</div><div class="line">  super.onCreate();</div><div class="line">  mBinder=newMyBinder();</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService is being created.&quot;);</div><div class="line">  mNotificationManager= ((NotificationManager)getSystemService(NOTIFICATION_SERVICE));</div><div class="line">  initExporterParams();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public int onStartCommand(Intent intent, intflags, intid) &#123;</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService onStartCommand.&quot;);</div><div class="line">  mNotificationManager.cancelAll();</div><div class="line">  return START_STICKY;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onTaskRemoved(Intent rootIntent) &#123;</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService onTaskRemoved.&quot;);</div><div class="line">  mNotificationManager.cancelAll();</div><div class="line">  super.onTaskRemoved(rootIntent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上代码，在浅杀时候：只执行onTaskRemoved()，通知被取消，但service仍然在运行，所以还会继续发通知，正常运行。
深杀时：第一种情况直接调用onTaskRemoved()且service停止，通知被取消。第二种情况，进程被杀掉，几秒后service重启，onCreate() -&gt; onTaskRemoved()，运行结果就是深杀后过几秒后Notification被取消。
浅杀+深杀时：浅杀后onTaskRemoved()被调用，service仍在运行，通知仍然在更新。深杀时，onCreate() -&gt; onStartCommand()，在onStartCommand()时候取消通知。
另外，mNotificationManager.cancelAll()会清除应用的所有通知，如果应用想保留和该service无关其他通知，可以调用mNotificationManager.cancel(String tag, int id)或cancel(int id)清除指定通知。
当然，还可以有另一种方式：浅杀时后就把service后台执行的任务停止，并清理notification，我们可以根据需求来选择。</p>
<p>补充：
疑问：1.为啥有时候深杀不立即调用onTaskRemoved()，而是在重启之后调用的呢？
stackoverflow上的答复:<a href="https://stackoverflow.com/questions/32224233/ontaskremoved-called-after-oncreate-in-started-service-on-swipe-out-from-recent/41506752" target="_blank" rel="external">https://stackoverflow.com/questions/32224233/ontaskremoved-called-after-oncreate-in-started-service-on-swipe-out-from-recent/41506752</a>
大意是service执行较重UI操作时候service不会立即停止，而新的service会启动。不太确定这个解释的正确性……</p>
<blockquote>
<p>Calling onTaskRemoved of the running service(when app gets swiped out from recent apps) will be generally delayed if we are performing any heavy UI related stuff or broadcasting messages to receivers in service.
E.g , Assume you are downloading the file of size 50MB from web server, so from web server everytime you are reading 1024bytes of stream data as buffer and that data you are writing to a file in device.
Meanwhile you are updating the progress to the UI thread which means every KB you are updating to the UI thread, this will cause the application to freeze.
So in between if you swipe-out from recent app list , then the system will try to stop the service but since the service is in-contact with the UI thread, the system will be unable to stop that service, but it will create new service eventhough the old service is not yet stopped.
Once old service finishes the communication with the UI thread then onTaskRemoved() gets called and the old service will be stopped. The new service will be running in the background.
2.为何servive.startForeground()添加的Notification可以在service被杀死后去掉呢？我们分析源码：ActiveServices中killServicesLocked()-&gt;scheduleServiceRestartLocked()中调用了r.cancelNotification()，清除了notification:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public void cancelNotification() &#123;</div><div class="line">        if (foregroundId != 0) &#123;</div><div class="line">            // Do asynchronous communication with notification manager to</div><div class="line">            // avoid deadlocks.</div><div class="line">            final String localPackageName = packageName;</div><div class="line">            final int localForegroundId = foregroundId;</div><div class="line">            ams.mHandler.post(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    INotificationManager inm = NotificationManager.getService();</div><div class="line">                    if (inm == null) &#123;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                    try &#123;</div><div class="line">                        inm.cancelNotificationWithTag(localPackageName, null,</div><div class="line">                                localForegroundId, userId);</div><div class="line">                    &#125; catch (RuntimeException e) &#123;</div><div class="line">                        Slog.w(TAG, &quot;Error canceling notification for service&quot;, e);</div><div class="line">                    &#125; catch (RemoteException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建雨在芝士圈应用的application中使用了全局静态变量标志是否正在录制中,开启直播后将该变量设置为录制中,录制中一些操作将被屏蔽.但是对某些手机(如htc d816)当从”最近应用”杀掉进程后有时候application不被回收,该状态变量无法通过applicatio
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>(转)转使用C语言实现&quot;泛型&quot;链表</title>
    <link href="http://wodekouwei.com/2017/10/31/l-c-dllist/"/>
    <id>http://wodekouwei.com/2017/10/31/l-c-dllist/</id>
    <published>2017-10-31T12:13:42.000Z</published>
    <updated>2017-12-05T06:49:51.509Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题，你可能非常惊讶，C语言也能实现泛型链表？我们知道链表是我们非常常用的数据结构，但是在C中却没有像C++中的STL那样有一个list的模板类，那么我们是否可以用C语言实现一个像STL中的list那样的泛型链表呢？答案是肯定的。下面就以本人的一个用C语言设计的链表为例子，来分析说明一下本人的设计和实现要点，希望能给你一点有用的帮助。</p>
<h3 id="一、所用的链表类型的选择"><a href="#一、所用的链表类型的选择" class="headerlink" title="一、所用的链表类型的选择"></a>一、所用的链表类型的选择</h3><p>我们知道，链表也有非常多的类型，包括单链表、单循环链表、双链表、双向循环链表等。在我的设计中，我的链表使用的类型是双向循环链表，并带一个不保存真实数据的头结点。其原因如下：
1）单链表由于不能从后继定位到前驱，在操作时较为不方便
2）双链表虽然能方便找到前驱，但是如果总是在其尾部插入或删除结点，为了定位的方便和操作的统一（所有的删除和插入操作，都跟在中间插入删除结点的操作一样），还要为其增加一个尾结点，并且程序还要保存一个指向这个尾结点的指针，并管理这个指针，从而增加程序的复杂性。而使用带头结点的循环双向链表，就能方便的定位（其上一个元素为链表的最后一个元素，其下一个元素为链表的第0个元素），并使所有的插入和删除的操作统一，因为头结点也是尾结点。注：结点的下标从0开始，头结点不算入下标值。
3）接口的使用与C++中stl中list和泛型算法的使用大致相同。</p>
<h3 id="二、list类型的定义"><a href="#二、list类型的定义" class="headerlink" title="二、list类型的定义"></a>二、list类型的定义</h3><p>为了让大家一睹为快，下面就给出这个用C语言实现的“泛型”的定义，再来说明，我这样设计的原因及要点，其定义如下：
其定义在文件list_v2.c中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef struct node  </div><div class="line">&#123;  </div><div class="line">    //循环双链表的结点结构  </div><div class="line">    void* data;//数据域指针  </div><div class="line">    struct node *next;//指向当前结点的下一结点  </div><div class="line">    struct node *last;//指向当前结点的上一结点  </div><div class="line">&#125;Node;  </div><div class="line"></div><div class="line">struct list  </div><div class="line">&#123;  </div><div class="line">    struct node *head;//头指针，指向头结点  </div><div class="line">    int data_size;//链表对应的数据所占内存的大小  </div><div class="line">    int length;//链表list的长度  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其声明在文件list_v2.h中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">//泛型循环双链表，带头结点，结点下标从0开始，头结点不计入下标值  </div><div class="line"></div><div class="line"></div><div class="line">//定义结点指针Node*为List类型的迭代器  </div><div class="line">typedef struct node* Iterator;  </div><div class="line"></div><div class="line"></div><div class="line">//List类型的定义  </div><div class="line">typedef struct list* List;  </div><div class="line"></div><div class="line"></div><div class="line">//初始化链表,数据域所占内存的大小由data_size给出  </div><div class="line">int InitList(List *list, int data_size);  </div><div class="line"></div><div class="line"></div><div class="line">//把data的内容插入到链表list的末尾  </div><div class="line">//assign指定数据data间的赋值方法  </div><div class="line">Iterator Append(List list, void *data,  </div><div class="line">                void (*assign)(void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//把data的内容插入到链表的迭代器it_before的前面  </div><div class="line">//assign指定数据data间的赋值方法  </div><div class="line">Iterator Insert(List list, void *data, Iterator it_before,  </div><div class="line">                void (*assign)(void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//把链表A中迭代器it_a指向的结点移动到链表B中迭代器it_b_befroe的前面  </div><div class="line">Iterator MoveFromAtoB(List A, Iterator it_a,  </div><div class="line">                      List B, Iterator it_b_before);  </div><div class="line"></div><div class="line"></div><div class="line">//删除链表list中迭代器it指向的结点  </div><div class="line">int Remove(List list, Iterator it);  </div><div class="line"></div><div class="line"></div><div class="line">//删除链表list的第0个结点，下标从0开始  </div><div class="line">int RemoveFirst(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//删除链表list的最后一个结点  </div><div class="line">int RemoveLast(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//返回list中第index个数据的指针  </div><div class="line">void* At(List list, int index);  </div><div class="line"></div><div class="line"></div><div class="line">//在begin和end之间查找符合condition的第一个元素，  </div><div class="line">//比较函数由condition指向,比较的值由data指向  </div><div class="line">//当第一个参数的值小于第二个参数的值时，返回1，否则返回0  </div><div class="line">//根据condition函数的不同，可以查找第一个相等、大于或小于data的值  </div><div class="line">Iterator FindFirst(Iterator begin, Iterator end, void *data,  </div><div class="line">                       int (*condition)(const void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//查找list中第一个与data相等的元素的下标，  </div><div class="line">//equal函数，当第一个参数与第二个参数的值相等时，返回1，否则返回0  </div><div class="line">int IndexOf(List list, void *data,  </div><div class="line">            int (*equal)(const void*,const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//查找在begin和end之间的最小值，比较函数由less指向  </div><div class="line">//当第一个参数的值小于第二个参数的值时，返回1，否则返回0  </div><div class="line">Iterator GetMin(Iterator begin, Iterator end,  </div><div class="line">                int (*less)(const void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//查找在begin和end之间的最大值，比较函数由large指向  </div><div class="line">//当第一个参数的值大于第二个参数的值时，返回1，否则返回0  </div><div class="line">Iterator GetMax(Iterator begin, Iterator end,  </div><div class="line">                int (*large)(const void*, const void*));  </div><div class="line"></div><div class="line"></div><div class="line">//获取list的长度  </div><div class="line">int GetLength(List list);  </div><div class="line">//若list为空链表，则返回1，否则返回0  </div><div class="line">int IsEmpty(List list);  </div><div class="line">//销毁list  </div><div class="line">void DestroyList(List *list);  </div><div class="line"></div><div class="line"></div><div class="line">//获得list的首迭代器  </div><div class="line">Iterator Begin(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//获得list的尾迭代器，指向最后一个元素的下一个位置  </div><div class="line">Iterator End(List list);  </div><div class="line"></div><div class="line"></div><div class="line">//使it指向下一个位置，并返回指向下一个位置后的迭代器  </div><div class="line">Iterator Next(Iterator *it);  </div><div class="line"></div><div class="line"></div><div class="line">//使it指向上一个位置，并返回指向上一个位置后的迭代器  </div><div class="line">Iterator Last(Iterator *it);  </div><div class="line"></div><div class="line"></div><div class="line">//通过迭代器it获得数据，相当于*p  </div><div class="line">void* GetData(Iterator it);  </div><div class="line"></div><div class="line"></div><div class="line">//获取当前迭代器的下一个迭代器，注意，并不改变当前迭代器  </div><div class="line">Iterator GetNext(Iterator it);  </div><div class="line"></div><div class="line"></div><div class="line">//获取当前迭代器的上一个迭代器，注意，并不改变当前迭代器  </div><div class="line">Iterator GetLast(Iterator it);</div></pre></td></tr></table></figure></p>
<h3 id="三、如何实现隐藏链表的成员变量（即封装）"><a href="#三、如何实现隐藏链表的成员变量（即封装）" class="headerlink" title="三、如何实现隐藏链表的成员变量（即封装）"></a>三、如何实现隐藏链表的成员变量（即封装）</h3><p>首先，我们为什么需要封装呢？我觉得封装主要有三大好处。</p>
<ol>
<li>隔离变化，在程序中需要封装的通常是程序中最容易发生变化的地方，例如成员变量等，我们可以把它们封装起来，从而让它们的变化不会影响到系统的其他部分，也就是说，封装的是变化。</li>
<li>降低复杂度，因为我们把一个对象是如何实现的等细节封装起来，只留给用户一个最小依赖的接口，从而让系统变量简单明了，在一定程度降低了系统的复杂性，方便了用户的使用。</li>
<li>让用户只能按照我们设计好的接口来操作一个对象或类型，而不能自己直接对一个对象进行操作，从而减少了用户的误操作，提高了系统的稳定性。</li>
</ol>
<p>在面向对象的设计中，如果我们想要隐藏一个类的成员变量，我们可以把这些成员变量声明为私有的，而在C语言中，我们可以怎么实现呢？其实其实现是很简单的，我们在C语言中，当我们要使用一个自己定义的类型或函数时，我们会把声明它的头文件包含（include）过来，只要我们在文件中只声明其类型是一个结构体，而把它的实现写在.c文件中即可。</p>
<p>在本例子中，我把<code>struct list</code>和<code>struct node</code>定义在.c文件中，而在头文件中，只声明其指针类型，即<code>typedef struct node* Iterator</code>和<code>typedef struct list* List;</code>当我们要使用该类型时，只需要在所在的文件中，include该头文件即可。因为在编译时，编译器只要知道List和Iterator是一个指针类型就能知道其所占的内存大小，也就能为其分配内存，所以能够编译成功。而又因为该头文件中并没有该类型（struct list和struct node）的定义，所以我们在使用该类型时，只能通过我们提供的接口来操作对象。例如，我们并不能使用<code>List list; list-&gt;data</code>等等的操作，而只能通过已定义的接口GetData来获得。</p>
<p>###四、如何实现泛型
泛型，第一时间想起的可能是模板，但是在C语言中却没有这个东西。但是C语言中却有一个可以指向任何类型，在使用时，再根据具体的指针类型进行类型转换的指针类型，它就是<code>void*</code>。</p>
<p>为什么void<em>可以指向任何类型的数据？这还得从C语言对于数据类型的处理方式来说明。在C语言中，我们使用<code>malloc</code>等函数来申请内存，而从内存的角度来看，数据是没有类型的，它们都是一串的0或1，而程序则根据不同的类型来解释这个内存单元中的数据的意义，例如对于内存中的数据，<code>FFFFFFFF</code>，如果它是一个有符号整型数据，它代表的是<code>-1</code>，而如果它是一个无符号整型数据，它代表的则是<code>2^32-1</code>。进一步说，如果你用一个<code>int</code>的指针变量p指向该内存，则</em>p就是-1，如果你用<code>unsigned int</code>的指针<code>p</code>指向该内存，则<code>*p = 2^32-1</code>。</p>
<p>而我们使用<code>malloc</code>等函数时，也只需要说明申请的内存的大小即可，也不用说明申请的内存空间所存放的数据的类型，例如，我们申请一块内存空间来存放一个整型数据，则只需要<code>malloc(sizeof(int))</code>，即可，当然你完全可以把它当作一个具有4个单位的char数组来使用。所以我们可以使用void指针来指向我们申请的内存，申请内存的大小由链表中的成员data_size定义，它也是真正的data所占的内存大小。</p>
<h3 id="五、为什么需要赋值函数指针assign"><a href="#五、为什么需要赋值函数指针assign" class="headerlink" title="五、为什么需要赋值函数指针assign"></a>五、为什么需要赋值函数指针assign</h3><p>这里来说明一下，该链表的数据的插入方式，我们的插入方式是，新建一个结点，把data指向的数据复制到结点中，并把该结点插入到链表中。插入的函数定义如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Iterator Insert(List list, void *data, Iterator it_before,</div><div class="line">                void (*assign)(void*, const void*));</div></pre></td></tr></table></figure></p>
<p>从上面的解说中，我们可以看到链表中的成员data_size指示了链表中的数据所占的内存大小，那我们们就可以使用函数memcpy把data指向的数据复制到新建的结点的data所指向的内存即可。为什么还需要一个函数指针assign，来指向一个定义数据之间如何赋值的函数呢？其实这和面向对象语言中常说到的深复制和浅复制有关。</p>
<p>注：memcpy函数的原型为：<code>void * memcpy ( void * destination, const void * source, size_t num );</code></p>
<p>试想一下，假如你的链表的数据类型不是int型等基本类型，也不是不含有指针的结构体，而是一个这样的结构体，例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct student  </div><div class="line">&#123;  </div><div class="line">    char *name;  </div><div class="line">    char *no;  </div><div class="line">    int age;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>学生的姓名和学号都是能过动态分配内存而来的，并由student结构体中的name和no指针指向，那么当我们使用memcpy时，只能复制其指针，而不能复制其指向的数据，这样在很多情况下都会带来一定的问题。这个跟在C++中什么时候需要自己定义复制构造函数的情况类似。因为这种情况下，默认的复制构造函数并不能满足我们的需要，只能自己定义复制构造函数。</p>
<p>所以在插入一个结点时，需要assign函数指针的原理与C++中自己定义复制构造函数的原理一样。它用于定义如何根据一个已有的对象生成一个该对象的拷贝对象。当然，可能在大多数的情况下，我们需要用到的数据类型都没有包含指针，所以在Insert函数的实现中，其实我也是有用到memcpy函数的，就是当assign为NULL时，就使用memcpy函数进行数据对象间的赋值，它其实就相当于C++中的默认复制构造函数或默认赋值操作函数。assign为NULL表示使用默认的逐位复制方式，即浅复制。</p>
<h3 id="六、为什么不用typedef"><a href="#六、为什么不用typedef" class="headerlink" title="六、为什么不用typedef"></a>六、为什么不用typedef</h3><p>对于这个问题，其实很好回答。很多人实现一个通用链表是这样实现的，它们把node结构的实现如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct node  </div><div class="line">&#123;  </div><div class="line">    //循环双链表的结点结构  </div><div class="line">    DataType data;//数据域指针  </div><div class="line">    struct node *next;//指向当前结点的下一结点  </div><div class="line">    struct node *last;//指向当前结点的上一结点  </div><div class="line">&#125;Node;</div></pre></td></tr></table></figure></p>
<p>然后，当需要使用整型的链表时，就把DataType用typedef为int。其实这样做的一个最大的缺陷就是一个程序中只能存在着一个数据类型的链表，例如，如果我需要一个int型的链表和一个float型的链表，那么该把DataType定义为int呢还是float呢？所以这种看似可行的方式，其实只是虚有其表，在现象中是行不能的，虽然不少的数据结构的书都是这样实现的，但是它却没有什么实用价值。</p>
<p>而其本质的原因是把结点的数据域的数据类型与某一种特定的数据类型DataType绑定在一起，从而让链表不能独立地变化。</p>
<h3 id="七、为什么只把结点的指针定义为Iterator"><a href="#七、为什么只把结点的指针定义为Iterator" class="headerlink" title="七、为什么只把结点的指针定义为Iterator"></a>七、为什么只把结点的指针定义为Iterator</h3><p>在C++中iterator是一个类，为什么在这里，我只把结点的指针声明为一个Iterator呢？其实受STL的影响，我在一开始时，也是把Iterator实现为一个结构体，它只有一个数据成员，就是一个指向Node的指针。但在后来的实践中，发现其实并没有必要。在C++中为什么把iterator定义为一个类，是为了重载*，-&gt;等运行符，让iterator使用起来跟普通的指针一样。但是在C语言中，并没有重载运行符的做法，所以直接把Ierator声明为一个Node的指针最为方便、直接和好用，所有的比较运算都可以直接进行，而无需要借助函数。而把它声明为一个结构体反而麻烦、累赘。</p>
<h3 id="八、为什么查找需要两个Iterator"><a href="#八、为什么查找需要两个Iterator" class="headerlink" title="八、为什么查找需要两个Iterator"></a>八、为什么查找需要两个Iterator</h3><p>其实这是参考了STL中的泛型算法的思想。而且本人觉得这是一种比较好的实现。为什么FindFirst的函数原型不是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iterator FindFirst(List list,  int (*condition)(const void*, const void*));</div></pre></td></tr></table></figure></p>
<p>而是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iterator FindFirst(Iterator begin, Iterator end, void *data,int (*condition)(const void*, const void*));</div></pre></td></tr></table></figure></p>
<p>们可以试想一下，这个链表的为char链表，链表的元素为ABCBCBC，我们要在链表中找出所有的B，如果查找算法是使用第一种定义的话，它只能找出第一个B，而后面的两个B就无能为力了，而第二种定义，则可以通过循环改变其始末迭代器来在不同的序列段间查找目标字符B的位置。</p>
<blockquote>
<p>转自<a href="http://blog.csdn.net/ljianhui/article/details/18748657" target="_blank" rel="external">使用C语言实现“泛型”链表</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到这个标题，你可能非常惊讶，C语言也能实现泛型链表？我们知道链表是我们非常常用的数据结构，但是在C中却没有像C++中的STL那样有一个list的模板类，那么我们是否可以用C语言实现一个像STL中的list那样的泛型链表呢？答案是肯定的。下面就以本人的一个用C语言设计的链表
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="C" scheme="http://wodekouwei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin语法</title>
    <link href="http://wodekouwei.com/2017/10/31/l-kotlin/"/>
    <id>http://wodekouwei.com/2017/10/31/l-kotlin/</id>
    <published>2017-10-31T12:13:42.000Z</published>
    <updated>2017-12-05T03:54:43.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;chaychan&quot;</div><div class="line">println(str1 == str2)</div></pre></td></tr></table></figure>
<p>比较两个字符串，如果两个字符串的内容一致，在Java中使用 str1 == str2 时，是比较两个字符串的地址值，很清楚两个字符串的地址不一样，返回false，但是在kotlin中，则不是如此，比较的只是字符串的内容，而===相当于Java中的==，用来比较引用对象, 上述代码返回的是true。</p>
<p><strong>equal函数</strong></p>
<ol>
<li><code>equals(str:String)</code></li>
</ol>
<p>方法中的参数是与之对比的字符串，默认不忽略大小写，即大小写敏感，比如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;ChayChan&quot;</div><div class="line">println(str1.equals(str2))</div></pre></td></tr></table></figure></p>
<p>打印结果为false，因为不忽略大小写的话，两个字符串内容对比是不一致的，所以返回false。</p>
<ol>
<li><code>equals(str:String,ignoreCase:Boolean)</code>
方法中有两个参数，第一个参数是与之对比的字符串，第二个参数是布尔类型的值，是否忽略大小写，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;ChayChan&quot;</div><div class="line">println(str1.equals(str2,true))</div></pre></td></tr></table></figure>
</li>
</ol>
<p>返回结果为true。</p>
<h3 id="源码优化分析"><a href="#源码优化分析" class="headerlink" title="源码优化分析"></a>源码优化分析</h3><p><a href="https://github.com/googlesamples/android-architecture/tree/dev-todo-mvp-kotlin/" target="_blank" rel="external">源码</a></p>
<h4 id="1-Lateinit"><a href="#1-Lateinit" class="headerlink" title="1.Lateinit"></a>1.Lateinit</h4><p>在View声明阶段，都会需要使用lateinit来延迟声明变量。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class TaskActivity : AppCompatActivity()&#123;</div><div class="line">  private val CURRENT_FILTERING_KEY = &quot;CURRENT_FILTERING_KEY&quot;;</div><div class="line">  private lateinit var drawerLayout : DrawerLayout</div><div class="line">  private lateinit var tasksPresenter:TasksPresenter</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>kotlin中延迟声明还包括lazy的方式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val name:String by lazy &#123;&quot;cangwang&quot;&#125;</div><div class="line">lateinit var drawLayout:drawLayout</div></pre></td></tr></table></figure></p>
<p>区别在于:</p>
<ol>
<li>.lazy{}只能用再val类型,lateinit只能用在var类型</li>
<li>.lateinit不能用在可空的属性上和java的基本类型上<code>lateinit var name:String</code>会报错</li>
<li>.lateinit可以在任何位置初始化并且可以初始化多次,因为其衔接var变量.而lazy在第一次被调用时就被初始化,其衔接的是val常量,想要被改变只能重新定义</li>
</ol>
<h4 id="2-findViewById"><a href="#2-findViewById" class="headerlink" title="2.findViewById"></a>2.findViewById</h4><p>Api26前:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public View findViewById(@IdRes int id)&#123;</div><div class="line">  return getDelegate().findViewById(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Api26之后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;TypeParameterUnusedInFormals&quot;)</div><div class="line">@Override</div><div class="line">public &lt;T extends View&gt; T indViewById(@IdRes int id)&#123;</div><div class="line">  return getDelegate().findViewById(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="五个kotlin-Standard-kt里面的函数-apply-with-let-run-also"><a href="#五个kotlin-Standard-kt里面的函数-apply-with-let-run-also" class="headerlink" title="五个kotlin Standard.kt里面的函数:apply,with,let,run,also"></a>五个kotlin Standard.kt里面的函数:apply,with,let,run,also</h4><ol>
<li>apply作用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setSupportActionBar(findViewById&lt;Toolbar&gt;(R.id.toolbar))</div><div class="line">supportActionBar?.apply&#123;</div><div class="line">  setDisplayHomeAsUpEnabled(true)</div><div class="line">  setDisplayShowHomeEnabled(true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在函数内可以通过this指代该对象,返回值为该对象自己</p>
<ol>
<li>with函数
将某对象作为函数的参数,在函数内可以通过this指代该对象.返回值为函数块的最后一行或指定return表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">override fun getView(i:Int,view:View?,viewGroup:ViewGroup):View&#123;</div><div class="line">  val rowView=Vview?:LayoutInflater.from(viewGroup.context).inflate(R.layout.task_item,viewGroup,false)</div><div class="line">  val task = getItem(i)</div><div class="line">  with(rowView.findViewById&lt;TextView&gt;(R.id.title))&#123;</div><div class="line">    text = task.titleForList</div><div class="line">  &#125;</div><div class="line">  with(rowView.findViewById&lt;CheckBox&gt;(R.id.complete))&#123;</div><div class="line">    isChecked=task.isCompleted</div><div class="line">    rowView.setBackgroundDrawable(...)</div><div class="line">    setOnClickListener&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-lat函数"><a href="#3-lat函数" class="headerlink" title="3.lat函数"></a>3.lat函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private fun showMessage(message:String)&#123;</div><div class="line">  view?.let&#123;</div><div class="line">    Snackbar.make(it,message,Snackbar.LENGTH_LONG).show()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将对象作为函数参数,在函数块内可以通过it指代该对象.返回值为函数块的最后一行或指定return表达式</p>
<h4 id="4-run函数"><a href="#4-run函数" class="headerlink" title="4. run函数"></a>4. run函数</h4><p>其有两种表达式:</p>
<ul>
<li>第一种无参数输入</li>
<li>第二种会将对象本身this给函数调用
返回值为函数块最后一行,或者指定return表达式</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>单例对象是使用Object申明
Kotlin没有静态属性和方法,需要使用单例对象来实现类似的功能.</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>相当于java中定义的数据bean类,其可以直接在属性之后编写get和set方法</p>
<h3 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a><code>@JvmOverloads</code></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串比较&quot;&gt;&lt;a href=&quot;#字符串比较&quot; class=&quot;headerlink&quot; title=&quot;字符串比较&quot;&gt;&lt;/a&gt;字符串比较&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="kotlin" scheme="http://wodekouwei.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>tool-as3</title>
    <link href="http://wodekouwei.com/2017/10/31/tool-as3/"/>
    <id>http://wodekouwei.com/2017/10/31/tool-as3/</id>
    <published>2017-10-31T11:47:42.000Z</published>
    <updated>2017-10-31T12:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AndroidStudio3-0新特性"><a href="#AndroidStudio3-0新特性" class="headerlink" title="AndroidStudio3.0新特性"></a>AndroidStudio3.0新特性</h3><h4 id="支持Java8语言"><a href="#支持Java8语言" class="headerlink" title="支持Java8语言"></a>支持Java8语言</h4><p>由于AS3.0默认支持Java8语言，所以我们就可以移除build.gradle里面的jackOptions了
<del>jackOptions { true }</del></p>
<p>然后可以在build.gradle配置为Java8
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">  ...</div><div class="line">  compileOptions &#123;</div><div class="line">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">    targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果对Java8的一些特性存在问题,我们也可以在gradle.properties里面禁用Java8
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android.enableDesugar=false</div></pre></td></tr></table></figure></p>
<h4 id="配置产品渠道"><a href="#配置产品渠道" class="headerlink" title="配置产品渠道"></a>配置产品渠道</h4><p>AS3.0以前我们常用productFlavors配置不同的渠道包，比如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">        dev&#123;</div><div class="line">            applicationIdSuffix &quot;.dev&quot;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        prod  &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>AS3.0得新增flavorDimensions的配置，主要有以下 12 个构建变体：
构建变体：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[minApi24, minApi23, minApi21][Demo, Full][Debug, Release]</div></pre></td></tr></table></figure></p>
<p>对应 APK：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk</div></pre></td></tr></table></figure></p>
<p>比如这里创建一个构建方式
首先得在defaultConfig通过flavorDimensions配置构建变体，如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">       ...</div><div class="line">        flavorDimensions &quot;debug&quot;,&quot;release&quot;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后productFlavors的配置就可以如下:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">        demo &#123;</div><div class="line">            dimension &quot;debug&quot;</div><div class="line">            applicationIdSuffix &quot;.demo&quot;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">        prod  &#123;</div><div class="line">            dimension &quot;release&quot;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="改进的Android插件"><a href="#改进的Android插件" class="headerlink" title="改进的Android插件"></a>改进的Android插件</h4><ul>
<li>优化了多 module 的项目并行编译运行更详细Task的展示
构建变体的从属管理，比如上文的Flavors Dimensions配置新 api ，implementation依赖（替代compile ），compileOnly（替代provided）和runtimeOnly（替代 apk）</li>
<li>通过增量编译 优化多dex的app构建速度</li>
<li>优化了AAPT2增量资源化处理。如果要启用AAPT2,在gradle.properties文件添加代码：<code>android.enableAapt2=true</code></li>
<li>支持java8语言</li>
<li>增加测试工具，可通过dependencies依赖使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies&#123;</div><div class="line">        androidTestUtil“com.linkedin.testbutler：测试管家应用：1.3.0@apk”</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常见出错总结"><a href="#常见出错总结" class="headerlink" title="常见出错总结"></a>常见出错总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:Cause: getMainOutputFile is no longer supported.  Use getOutputFileName if you need to determine the file name of the output.</div></pre></td></tr></table></figure>
<p>或
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:Not valid.</div></pre></td></tr></table></figure></p>
<p>主要是AndResGuard1.2.3版本还没有兼容AS3.0
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:All flavors must now belong to a named flavor dimension. The flavor &apos;prod&apos; is not assigned to a flavor dimension. Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html</div></pre></td></tr></table></figure></p>
<p>AS3.0需要通过flavorDimensions来配置产品渠道，详细看上文。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AndroidStudio3-0新特性&quot;&gt;&lt;a href=&quot;#AndroidStudio3-0新特性&quot; class=&quot;headerlink&quot; title=&quot;AndroidStudio3.0新特性&quot;&gt;&lt;/a&gt;AndroidStudio3.0新特性&lt;/h3&gt;&lt;h4 i
    
    </summary>
    
      <category term="工具" scheme="http://wodekouwei.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://wodekouwei.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="AndroidStudio" scheme="http://wodekouwei.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>C/CPP中的编程技巧及其概念</title>
    <link href="http://wodekouwei.com/2017/10/17/tips-candcpp/"/>
    <id>http://wodekouwei.com/2017/10/17/tips-candcpp/</id>
    <published>2017-10-17T03:25:05.000Z</published>
    <updated>2017-10-17T04:24:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-Language"><a href="#C-Language" class="headerlink" title="C Language"></a>C Language</h3><h4 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h4><p>size_t的全称应该是size type，就是说“一种用来记录大小的数据类型”。属于C99标准，它所定义的变量可以进行加减乘除运算。因此函数中表示数据大小的变量，推荐使用这个类型！例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int xxx(voidvoid *p, size_t len);</div></pre></td></tr></table></figure></p>
<h4 id="指针的指针（双重指针）的作用："><a href="#指针的指针（双重指针）的作用：" class="headerlink" title="指针的指针（双重指针）的作用："></a>指针的指针（双重指针）的作用：</h4><ol>
<li>用来传递需要修改的指针参数到函数中；</li>
<li>用来动态生成多维数组；</li>
<li>多用于指针交换，可以避免数据复制，提升系统的性能，同时还可以让函数修改指针，例如扩充其大小，指向等一般指针的指针用作参数，大多用在需要函数改变指针(重新引用变量)而又不能通过返回值传递(例如返回值用于传递其他结果)时。</li>
</ol>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>以空间换时间。</p>
<h4 id="backtrace函数追踪函数调用堆栈以及定位段错误"><a href="#backtrace函数追踪函数调用堆栈以及定位段错误" class="headerlink" title="backtrace函数追踪函数调用堆栈以及定位段错误"></a>backtrace函数追踪函数调用堆栈以及定位段错误</h4><p>一般察看函数运行时堆栈的方法是使用GDB（bt命令）之类的外部调试器,但是,有些时候为了分析程序的BUG,(主要针对长时间运行程序的分析),在程序出错时打印出函数的调用堆栈是非常有用的</p>
<h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><h4 id="显示限定数组实参的原始个数"><a href="#显示限定数组实参的原始个数" class="headerlink" title="显示限定数组实参的原始个数"></a>显示限定数组实参的原始个数</h4><p>数组在作为函数参数传递时会退化为指针：</p>
<blockquote>
<p>A declaration of a parameter as “array of type” shall be adjusted to “qualified pointer to type”.</p>
</blockquote>
<p>以及前面已经提到的：</p>
<blockquote>
<p>int x[3][5];Here x is a 3 × 5 array of integers. When x appears in an expression, it is converted to a pointer to (the first of three) five-membered arrays of integers.</p>
</blockquote>
<p>这意味着数组作为参数传递时会丢失边界(C/C++的原生数组本来也就没有边界检查…)。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void funcA(int x[10])&#123;&#125;</div><div class="line">// Equivalent to</div><div class="line">void funcB(int *x)&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其对应的中间代码为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">; Function Attrs: nounwind uwtable</div><div class="line">define void @_Z5funcAPi(i32*) #4 &#123;</div><div class="line">  %2 = alloca i32*, align 8</div><div class="line">  store i32* %0, i32** %2, align 8</div><div class="line">  ret void</div><div class="line">&#125;</div><div class="line">; Function Attrs: nounwind uwtable</div><div class="line">define void @_Z5funcBPi(i32*) #4 &#123;</div><div class="line">  %2 = alloca i32*, align 8</div><div class="line">  store i32* %0, i32** %2, align 8</div><div class="line">  ret void</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果数组边界的精确数值非常重要，并且希望函数只接收含有特定数量的元素的数组，可以使用引用形参：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void funcC(int (&amp;x)[10])&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其中间代码为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">; Function Attrs: nounwind uwtable</div><div class="line">define void @_Z5funcCRA10_i([10 x i32]* dereferenceable(40)) #4 &#123;</div><div class="line">  %2 = alloca [10 x i32]*, align 8</div><div class="line">  store [10 x i32]* %0, [10 x i32]** %2, align 8</div><div class="line">  ret void</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们使用数组元素个数不等于10的数组传递给funcC,会导致编译错误：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// note: candidate function not viable: no known conversion from &apos;int [11]&apos; to &apos;int (&amp;)[10]&apos; for 1st argument.</div><div class="line">void funcC(int (&amp;x)[10])&#123;&#125;</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  int x[11]=&#123;0,1,2,3,4,5,6,7,8,9,10&#125;;</div><div class="line">  // error: no matching function for call to &apos;funcC&apos;.</div><div class="line">  funcC(x);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用函数模板参数来指定函数接收参数的数组大小：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;int arrSize&gt;</div><div class="line">void funcA(int x[arrSize])&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>使用时：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x[12]</div><div class="line">funcA&lt;12&gt;(x); // OK</div><div class="line">funcA&lt;13&gt;(x); //ERROR</div></pre></td></tr></table></figure></p>
<h4 id="启用编译器的改变符号的隐式类型转换警告"><a href="#启用编译器的改变符号的隐式类型转换警告" class="headerlink" title="启用编译器的改变符号的隐式类型转换警告"></a>启用编译器的改变符号的隐式类型转换警告</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if((unsigned int)4&lt;(unsigned int)(int)-1)&#123;</div><div class="line">  cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;</div><div class="line">&#125;else&#123;</div><div class="line">  cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>if中的那段表达式是为true的(输出yes)，而且编译时也不会发出警告。
虽然我们指定了(int)-1，但是当将unsigned int和int比较时会发生隐式转换。即：</p>
<blockquote>
<p>The usual arithmetic conversions are performed on operands of arithmetic or enumeration type.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((unsigned int)4&lt;(unsigned)(int)-1)==true</div></pre></td></tr></table></figure></p>
<p>Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless -Wsign-conversion is explicitly enabled.</p>
</blockquote>
<p>通过启用-Wsign-conversion就可以看到警告了(建议开启)。
该参数的作用为：</p>
<blockquote>
<p>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by -Wconversion.</p>
</blockquote>
<h4 id="断言-assert"><a href="#断言-assert" class="headerlink" title="断言(assert)"></a>断言(assert)</h4><p>assert Defined in header(c++)/(C)</p>
<blockquote>
<p>If NDEBUG is defined as a macro name at the point in the source code where <assert.h> is included, then assert does nothing.
If NDEBUG is not defined, then assert checks if its argument (which must have scalar type) compares equal to zero.</assert.h></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef NDEBUG</div><div class="line">#define assert(condition) ((void)0)</div><div class="line">#else</div><div class="line">#define assert(condition) /*implementation defined*/</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>assert只在Debug模式中有效，使用release模assert什么都不做了。
因为在VC++里面，release会在全局定义NDEBUG
下面的代码在VS中使用debug和release模式分别编译并输入&gt;100的数，会有不一样的结果(release不会)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">bool func(int x) &#123;</div><div class="line">  if (x &gt; 100) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">int main(void) &#123;</div><div class="line">  int i;</div><div class="line">  cin &gt;&gt; i;</div><div class="line">  assert(func(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="无效的引用"><a href="#无效的引用" class="headerlink" title="无效的引用"></a>无效的引用</h4><p>通常情况下我们创建的引用就是有效的，但是也可以人为因素使坏…
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">char* ident(char *p) &#123; return p; &#125;</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  char&amp; r &#123;*ident(nullptr)&#125;;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是UB的行为。</p>
<blockquote>
<p>in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the “object” obtained by indirection through a null pointer,which causes undefined behavior.</p>
</blockquote>
<h4 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void f(int(&amp;r)[4])&#123;</div><div class="line">  cout&lt;&lt;sizeof(r)&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">void g(void)&#123;</div><div class="line">  int a[]=&#123;1,2,3,4&#125;;</div><div class="line">  f(a); // OK</div><div class="line">  int b[]=&#123;1,2,3&#125;;</div><div class="line">  f(b); // 错误，元素个数有误</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于数组引用类型的从参数来说，元素个数也是其类型的一部分。通常只有在模板中才会使用数组引用，此时数组的引用可以通过推断得到。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template&lt;class T,int N&gt;</div><div class="line">void f(T(&amp;r)[N])&#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">int a1[10];</div><div class="line">double a2[100];</div><div class="line">void g()&#123;</div><div class="line">  f(a1);  // T是int，N是10</div><div class="line">  f(a2);  // T是double，N是100</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么做的后果是调用f()所用的不同类型的数组有多少个，对应定义的函数有多少个。</p>
<h4 id="忽略函数参数的顶层const"><a href="#忽略函数参数的顶层const" class="headerlink" title="忽略函数参数的顶层const"></a>忽略函数参数的顶层const</h4><p>为了与C语言兼容，在C++中会自动忽略参数类型的顶层const。</p>
<p>例如下面的函数在C++会报重定义错误，而不是重载：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 类型是int(int)</div><div class="line">int f(int x)&#123;&#125;</div><div class="line">// error: redefinition of &apos;f&apos;</div><div class="line">// 类型是int(int)</div><div class="line">int f(const int x)&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>不论对于哪种情况，允许修改实参也好，不允许修改实参也好，它都只是函数调用者提供的实参的一个副本。因此调用过程不会破坏调用上下文的数据安全性。</p>
<h4 id="char作为数组下标时当心unsigned-signed"><a href="#char作为数组下标时当心unsigned-signed" class="headerlink" title="char作为数组下标时当心unsigned/signed"></a>char作为数组下标时当心unsigned/signed</h4><p>当char类型用作数组下标时，一定要先转unsigned char（因为char通常是有符号的(依赖实现定义)）。不能直接转int或unsigned int，会数组下标越界。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void) &#123;</div><div class="line">  char ch=-1;</div><div class="line">    printf(&quot;%d %u %d&quot;, (int)ch, (unsigned)ch, (unsigned char)ch);</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line">// output</div><div class="line">// -1 4294967295 255</div></pre></td></tr></table></figure></p>
<h4 id="struct-tag-5-float"><a href="#struct-tag-5-float" class="headerlink" title="struct tag (*[5])(float)"></a><code>struct tag (*[5])(float)</code></h4><p>The type designated as <code>struct tag (*[5])(float)</code> has type ‘‘array of pointer to function returning struct tag’’. The array has length five and the function has a single parameter of type float. Its type category is array.</p>
<h4 id="new一个指针数组"><a href="#new一个指针数组" class="headerlink" title="new一个指针数组"></a>new一个指针数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int TEN=10;</div><div class="line">auto A=new (void(*[TEN])(void));</div><div class="line">delete[] A;</div></pre></td></tr></table></figure>
<h4 id="底层-Low-Level-const和顶层-Top-Level-const"><a href="#底层-Low-Level-const和顶层-Top-Level-const" class="headerlink" title="底层(Low-Level)const和顶层(Top-Level)const"></a>底层(Low-Level)const和顶层(Top-Level)const</h4><ul>
<li><strong>底层const(Low-Level const)</strong>:表示指针所指的对象是一个常量。</li>
<li><strong>顶层const(Top-Level const)</strong>:表示指针本身是个常量。顶层const可以表示任意的对象是常量，这对于任何数据类型都适用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int ival=0;</div><div class="line">int *const ivalp_1=&amp;ival; // 不能改变ivalp_1的值，这是一个顶层const</div><div class="line">const int ci=42;  // 不能改变ci的值，这是一个顶层const</div><div class="line">const int *ivalp_2=&amp;ci;;  // 允许改变ivalp_2的值，这是一个底层const</div><div class="line">const int *const ivalp_3=ivalp_2; //靠右的是顶层const，靠左的是底层const</div><div class="line">const int &amp;ref=ci;  // 用于声明引用的const都是底层const</div></pre></td></tr></table></figure>
</li>
</ul>
<p>其实我有一个简单的区分的方法：看const修饰的右边是什么。</p>
<ul>
<li>对于<code>int const *x=std::nullput;</code>，const修饰的是<em>x，因为x是指针，我们就暂且把此处的</em>x当做解引用来看，他就代表x所指向的对象，则它就是底层const。</li>
<li>反之亦然，<code>int * const x=std::nullptr;</code>，因为const修饰的是指针x，所以它就是顶层const。</li>
</ul>
<h4 id="在构造函数中传递this指针的危害"><a href="#在构造函数中传递this指针的危害" class="headerlink" title="在构造函数中传递this指针的危害"></a>在构造函数中传递this指针的危害</h4><p>如果我们在构造函数中将this指针传递给其它的函数，有可能会引发这样的问题：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct C;</div><div class="line">void no_opt(C*);</div><div class="line">struct C &#123;</div><div class="line">	int c;</div><div class="line">	C() : c(0) &#123; no_opt(this); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>看起来上面的代码似乎没什么问题，但是我们构造一个const C的时候，有可能会出现这样的问题：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const C cobj;</div><div class="line">void no_opt(C* cptr) &#123;</div><div class="line">	int i = cobj.c * 100; // value of cobj.c is unspecified</div><div class="line">	cout&lt;&lt;i&lt;&lt;endl;</div><div class="line">	cout &lt;&lt; cobj.c * 100 // value of cobj.c is unspecified</div><div class="line">	&lt;&lt; &apos;\n&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码会编译通过并可以在no_opt中修改常量对象cobj的成员i的值。
在一个常量对象构造的时候将其this指针传递给其他函数，这意味着我们可以修改该常量中的对象的值，这是不合乎标准的。</p>
<blockquote>
<p>During the construction of a const object, if the value of the object or any of its subobjects is accessed through a glvalue that is not obtained, directly or indirectly, from the constructor’s this pointer, the value of the object or subobject thus obtained is unspecified.</p>
</blockquote>
<p>所以还是不要在构造函数中写将this指针传递出类外的东西(最好还是只初始化数据成员吧)…</p>
<h4 id="获取当前执行程序的绝对路径"><a href="#获取当前执行程序的绝对路径" class="headerlink" title="获取当前执行程序的绝对路径"></a>获取当前执行程序的绝对路径</h4><p>有两种方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;direct.h&gt;</div><div class="line">char buffer[MAXPATH];</div><div class="line">getcwd(buffer, MAXPATH);</div><div class="line">cout&lt;&lt;buffer&lt;&lt;endl;</div></pre></td></tr></table></figure></p>
<p>这种方法有一个弊端：如果将可执行程序添加至系统的PATH路径，则获取到的是在某个目录执行时该目录的路径。</p>
<p>另一种方法是通过Windows API来获取：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const string getTheProgramAbsPath(void)&#123;</div><div class="line">    TCHAR exeFullPath[MAX_PATH]; // MAX_PATH在WINDEF.h中定义了，等于260</div><div class="line">    memset(exeFullPath,0,MAX_PATH);</div><div class="line">    GetModuleFileName(NULL,exeFullPath,MAX_PATH);</div><div class="line">    return &#123;exeFullPath&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在此种方式下不论是否将该程序添加至系统的PATH路径以及在何处执行，都会获取该可执行程序在系统中存放的绝对路径。</p>
<h4 id="一个奇葩的using用法"><a href="#一个奇葩的using用法" class="headerlink" title="一个奇葩的using用法"></a>一个奇葩的using用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">using foofunc=void(int);</div><div class="line">foofunc foo;</div><div class="line">int main()&#123;</div><div class="line">  foo(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码里：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foofunc foo;</div></pre></td></tr></table></figure></p>
<p>是声明一个函数foo，可以看一下目标文件中的符号信息(省去无关细节)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ clang++ -c testusing.cc -o testusing.o -std=c++11</div><div class="line">$ llvm-nm testusing.o</div><div class="line">-------- U _Z3fooi</div><div class="line">-------- U __main</div><div class="line">-------- U atexit</div><div class="line">00000050 T main</div></pre></td></tr></table></figure></p>
<p>通过gcc工具链中的c++filt可以还原目标文件中的符号：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ c++filt _Z3fooi</div><div class="line">foo(int)</div></pre></td></tr></table></figure></p>
<p>但是并没有定义，直接链接会产生未定义错误。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int x=123;</div><div class="line">int &amp;&amp;y=x+1;</div></pre></td></tr></table></figure>
<p>其IR代码为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 使用值123初始化x</div><div class="line">%2 = alloca i32, align 4</div><div class="line">store i32 123, i32* %2, align 4</div><div class="line"># y</div><div class="line">%3 = alloca i32*, align 8</div><div class="line"># 存放x+1产生的临时对象</div><div class="line">%4 = alloca i32, align 4</div><div class="line"># 计算x+1</div><div class="line">%5 = load i32, i32* %2, align 4</div><div class="line">%6 = add nsw i32 %5, 1</div><div class="line"># x+1 产生一个临时值，该临时值为%4</div><div class="line">store i32 %6, i32* %4, align 4</div><div class="line"># 将该临时值的地址绑定到%3(y)</div><div class="line">store i32* %4, i32** %3, align 8</div></pre></td></tr></table></figure></p>
<p>从而实现非拷贝行为，其行为类似于将一个对象的地址赋值给一个指针。
其实右值引用的作用就是给临时对象续命——将引用绑定到一个临时对象，不会带来额外的拷贝操作。
实现同样续命行为的还有<code>const T&amp;</code>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int x=123;</div><div class="line">const int &amp;y=x+1;</div></pre></td></tr></table></figure></p>
<p>和上面的示例在LLVM下会产生一模一样的IR代码。</p>
<h4 id="一个数组名字例子"><a href="#一个数组名字例子" class="headerlink" title="一个数组名字例子"></a>一个数组名字例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a[]=&#123;1,2,3,4,5&#125;;</div><div class="line">int *p=(int*)(&amp;a+1);</div><div class="line">printf(&quot;%d,%d\n&quot;,*(a+1),*(p-1));</div><div class="line">// output: 2,5</div></pre></td></tr></table></figure>
<h4 id="到底有几种传参方式"><a href="#到底有几种传参方式" class="headerlink" title="到底有几种传参方式"></a>到底有几种传参方式</h4><p>大多数人都觉得在C++函数中有以下三种传参方式：</p>
<ul>
<li>传值(by value)：形参的值是实参的拷；</li>
<li>传引用(by reference)：形参是实参的别名；</li>
<li>传指针(by pointer)：传递指向对象的指针给形参；
实际上，C++中只有两种传参方式：传值、传引用。
因为传指针(by pointer)也是传值的一种，形参的值也只是实参的一份拷贝，只是形参和实参都是指针而已。
在C++之父的著作：《The C++ Programming Language 4th》中写道：<blockquote>
<p>Unless a formal argument(parameter) is a reference, a copy of the actual argument is passed to the function.</p>
</blockquote>
</li>
</ul>
<p>传指针(by value)只是一种利用指针的性质来实现防止拷贝带来开销的一种技巧，而不是一种传参方式。</p>
<h4 id="定义拷贝-赋值与析构函数的三大法则"><a href="#定义拷贝-赋值与析构函数的三大法则" class="headerlink" title="定义拷贝/赋值与析构函数的三大法则"></a>定义拷贝/赋值与析构函数的三大法则</h4><blockquote>
<p>如果一个类需要自定义的拷贝构造函数、拷贝赋值操作符、析构函数中的任何一个，那么他往往同时需要三者。</p>
</blockquote>
<p>因为编译器生成的隐式定义的copy constructor和operator=语义是逐成员拷贝(memberwise)的，所以如果编译器生成的操作不能够满足类的拷贝需求(比如类成员是具有管理某种资源的句柄)，使用编译器的隐式定义会具有浅拷贝，导致两个对象进入某种共享状态。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  A():memory(nullptr)&#123;&#125;</div><div class="line">  void getMemory(std::size_t memSize)&#123;</div><div class="line">    memory=(char*)malloc(memSize);</div><div class="line">  &#125;</div><div class="line">  ~A()&#123; free(memory); &#125;</div><div class="line">private:</div><div class="line">  char* memory;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  A x;</div><div class="line">  x.getMemory(12);</div><div class="line">  A y;</div><div class="line">  y=x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用编译器生成的语义会使对象x和y内部共享一块内存，所以需要用户自己定义拷贝构造和拷贝赋值操作符，同样的原因，因为类成员持有某种资源，也需要用户自定义一个析构函数。</p>
<h4 id="引用的实现"><a href="#引用的实现" class="headerlink" title="引用的实现"></a>引用的实现</h4><p>C++标准中是这么解释引用的:</p>
<blockquote>
<p>[ISO/IEC 14882:2014 §8.3.2]A reference can be thought of as a name of an object.</p>
</blockquote>
<p>但是标准中并没有要求应该如何实现引用这一行为(这一点标准中比比皆是)，不过多数编译器底层都是使用指针来实现的。
看下列代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a=123;</div><div class="line">int &amp;ra=a;</div><div class="line">int *pc=&amp;a;</div></pre></td></tr></table></figure></p>
<p>然后将其编译为LLVM-IR来看编译器的实际行为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">%2 = alloca i32, align 4</div><div class="line">%3 = alloca i32*, align 8</div><div class="line">%4 = alloca i32*, align 8</div><div class="line">store i32 123, i32* %2, align 4</div><div class="line">store i32* %2, i32** %3, align 8</div><div class="line">store i32* %2, i32** %4, align 8</div></pre></td></tr></table></figure></p>
<p>可以看到，指针和引用在经过编译器之后具有了完全相同的行为。</p>
<h4 id="适当使用编译器生成操作"><a href="#适当使用编译器生成操作" class="headerlink" title="适当使用编译器生成操作"></a>适当使用编译器生成操作</h4><p>在特殊成员函数的隐式声明及其标准行为中提到了编译器会隐式生成和定义六种特殊的成员函数的行为。
因为编译器生成的copy constructor和copy assigment operator均是具有memberwise行为的。所以当我们撰写的类使用浅拷贝可以满足的时候(值语义)，没必要自己费劲再写相关的操作了，因为编译器生成的和你手写的一样好，而且不容易出错。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  A(int a=0,double b=0.0):x(a),y(b)&#123;&#125;</div><div class="line">  A(const A&amp;)=default;</div><div class="line">  A&amp; operator=(const A&amp;)=default;</div><div class="line">  int x;</div><div class="line">  double y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然当你没有显式定义一个copy constructor和copy assignment operator的时候编译器就会隐式定义，但是最好还是自己手动使用=delete指定。
编译器生成的和下面这样手写的一样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  A(int a=0,double b=0.0):x(a),y(b)&#123;&#125;</div><div class="line">  A(const A&amp; r)&#123;</div><div class="line">    x=r.x;</div><div class="line">    y=r.y;</div><div class="line">  &#125;</div><div class="line">  A&amp; operator=(const A&amp; r)&#123;</div><div class="line">    x=r.x;</div><div class="line">    y=r.y;</div><div class="line">    return *this;</div><div class="line">  &#125;</div><div class="line">  int x;</div><div class="line">  double y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>显然自己手写容易出错，这样的行为可以放心地交给编译器来做。</p>
<h4 id="STL容器中压缩容量和真正地删除元素"><a href="#STL容器中压缩容量和真正地删除元素" class="headerlink" title="STL容器中压缩容量和真正地删除元素"></a>STL容器中压缩容量和真正地删除元素</h4><p>摘取自《C++编程规范：101条规则/准则与最佳实践》第82条。</p>
<h5 id="压缩容器容量：swap魔术"><a href="#压缩容器容量：swap魔术" class="headerlink" title="压缩容器容量：swap魔术"></a>压缩容器容量：swap魔术</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; x&#123;1,2,3,4,5,6,7&#125;;</div><div class="line">// ...</div><div class="line">vector&lt;int&gt;(x).swap(x); // 压缩到合适容量</div><div class="line">vector&lt;int&gt;().swap(x); // 删除所有元素</div></pre></td></tr></table></figure>
<h5 id="真正地删除元素：std-remove并不执行删除操作"><a href="#真正地删除元素：std-remove并不执行删除操作" class="headerlink" title="真正地删除元素：std::remove并不执行删除操作"></a>真正地删除元素：std::remove并不执行删除操作</h5><p>STL中的std::remove算法并不真正地从容器中删除元素。因为std::remove属于algorithm，只操作迭代器范围，不掉用容器的成员函数，所以是不可能从容器中真正删除元素的。
来看一下SGISTL中的实现(SGISTL的实现太老，没有用到std::move)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template &lt;class _InputIter, class _Tp&gt;</div><div class="line">inline _InputIter find(_InputIter __first, _InputIter __last, const _Tp&amp; __val)</div><div class="line">&#123;</div><div class="line">  while (__first != __last &amp;&amp; !(*__first == __val))</div><div class="line">    ++__first;</div><div class="line">  return __first;</div><div class="line">&#125;</div><div class="line">template &lt;class _InputIter, class _OutputIter, class _Tp&gt;</div><div class="line">_OutputIter remove_copy(_InputIter __first, _InputIter __last, _OutputIter __result, const _Tp&amp; __value) &#123;</div><div class="line">  for ( ; __first != __last; ++__first)</div><div class="line">    if (!(*__first == __value)) &#123;</div><div class="line">      *__result = *__first;</div><div class="line">      ++__result;</div><div class="line">    &#125;</div><div class="line">  return __result;</div><div class="line">&#125;</div><div class="line">template &lt;class _ForwardIter, class _Tp&gt;</div><div class="line">_ForwardIter remove(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __value) &#123;</div><div class="line">  __first = find(__first, __last, __value);</div><div class="line">  _ForwardIter __i = __first;</div><div class="line">  return __first == __last ? __first : remove_copy(++__i, __last, __first, __value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到它们只是移动元素的位置，并非真正地把元素删除，只是将不该删除的元素移动到容器的首部，然后返回新的结束位置迭代器。
等于是把删除的部分移动到了元素的尾部，所以要真正地删除容器中所有匹配的元素，需要用erase-remove惯用法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.erase(std::remove(c.begin(),c.end(),value),c.end()); // 删除std::remove之后容器尾部的元素</div></pre></td></tr></table></figure></p>
<h4 id="谨防隐藏基类中的重载函数"><a href="#谨防隐藏基类中的重载函数" class="headerlink" title="谨防隐藏基类中的重载函数"></a>谨防隐藏基类中的重载函数</h4><p>如果基类中具有一个虚函数func但是其又重载了几个非虚函数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  virtual void func()&#123;</div><div class="line">    cout&lt;&lt;&quot;A::func()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  void func(int)&#123;</div><div class="line">    cout&lt;&lt;&quot;A::func(int)&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  void func(double)&#123;</div><div class="line">    cout&lt;&lt;&quot;A::func(double)&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">struct B:public A&#123;</div><div class="line">  virtual void func()&#123;</div><div class="line">    cout&lt;&lt;&quot;B::func()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果我们想要在B对象中使用非虚版本的func函数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B x;</div><div class="line">// error: too many arguments to function call, expected 0, have 1</div><div class="line">x.func(123);</div></pre></td></tr></table></figure></p>
<p>这是由于派生类在覆盖基类虚函数的时候会隐藏其他的重载函数，需要在B中显式引入：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct B:public A&#123;</div><div class="line">  virtual void func()&#123;</div><div class="line">    cout&lt;&lt;&quot;B::func()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  // 将A::func的重载函数引入作用域</div><div class="line">  using A::func;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="宏的替代"><a href="#宏的替代" class="headerlink" title="宏的替代"></a>宏的替代</h4><p>宏在预处理阶段被替换，此时C++的语法和语义规则还没有生效，宏能做的只是简单的文本替换，是极其生硬的工具。
C++中几乎从不需要宏。可以用const和enum定义易于理解的常量。用inline来避免函数调用的开销，用template指定函数系列和类型系列，用namespace避免名字冲突。
除非在条件编译时使用，其他任何时候都没有在C++中使用宏的正当理由。</p>
<h4 id="类内内存分配函数"><a href="#类内内存分配函数" class="headerlink" title="类内内存分配函数"></a>类内内存分配函数</h4><p>C++中类内的内存分配函数都是static成员函数:</p>
<blockquote>
<p>Any allocation function for a class T is a static member (even if not explicitly declared static).</p>
</blockquote>
<p>这意味着operator new/operator delete以及operator new[]/operator delete[]都被隐式声明为static成员函数。</p>
<h4 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h4><ol>
<li>析构函数、operator new、operator delete不能抛出异常</li>
<li>swap操作不要抛出异常</li>
<li>首先做任何可能抛出异常的事情(但不会改变对象重要的状态)，然后以不会抛出异常的操作结束。</li>
<li>当一个被抛出的异常从throw表达式奔向catch子句时，所经之路任何一个部分执行的函数比从执行堆栈上移除其激活记录之前，都必须清理他所控制的任何资源。</li>
<li>不要在代码中插入可能会提前返回的代码、调用可能会抛出异常的函数、或者插入其他一些东西从而使得函数末尾的资源释放得不到执行。</li>
</ol>
<h4 id="指向类成员函数指针的cv版本"><a href="#指向类成员函数指针的cv版本" class="headerlink" title="指向类成员函数指针的cv版本"></a>指向类成员函数指针的cv版本</h4><p>如果我们具有一个类A，其中具有重载的成员函数func，而他们的区别只是该成员函数是否为const，那么在定义一个指向成员函数的指针时如何分别？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct A&#123;</div><div class="line">  void func()const&#123;</div><div class="line">    std::cout&lt;&lt;&quot;void func()const&quot;&lt;&lt;std::endl;</div><div class="line">  &#125;</div><div class="line">  void func()&#123;</div><div class="line">    std::cout&lt;&lt;&quot;void func()&quot;&lt;&lt;std::endl;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果我们只是创建一个A::func的指针，指向的只是non-const版本。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(A::*funcP)()=&amp;A::func;</div></pre></td></tr></table></figure></p>
<p>想要指定const的版本，就需要在声明时指定const:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(A::*funcConstP)()const=&amp;A::func;</div></pre></td></tr></table></figure></p>
<p>对于const的A对象要使用const的版本，对于non-const的A对象要使用non-const的版本，不能混用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const A x;</div><div class="line">(x.*funcP)(); // ERROR!</div><div class="line">(x.*funcConstP)(); // OK</div><div class="line">A y;</div><div class="line">(y.*funcConstP)(); // ERROR!</div><div class="line">(y.*funcP)(); // OK</div></pre></td></tr></table></figure></p>
<h4 id="STL中的compare操作实现"><a href="#STL中的compare操作实现" class="headerlink" title="STL中的compare操作实现"></a>STL中的compare操作实现</h4><p>不同于C语言中的宏，使用C++中的模板(template)和谓词(Predicates)可以很轻易的写出泛型的比较操作。
在宏定义中还要注意参数的副作用，因为宏只是简单的替换，比如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define MAX(a,b) a&gt;=b?a:b;</div><div class="line">MAX(--a,++b);</div><div class="line">// 被替换为</div><div class="line">--a&gt;=++b?--a:++b;</div></pre></td></tr></table></figure></p>
<p>但是这个宏的实际操作这并不是我们所期待的行为。
幸运的是，在C++中我们可以使用模板来避免这种丑陋的宏定义，而且也可以传递一个自定义的谓词来实现我们的判断行为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct Compare&#123;</div><div class="line">  template&lt;typename T&gt;</div><div class="line">  bool operator()(const T&amp; a,const T&amp; b)&#123;</div><div class="line">    return a&lt;b?false:true;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">template&lt;class T, class Compare&gt;</div><div class="line">const T&amp; max(const T&amp; a, const T&amp; b, Compare comp)</div><div class="line">&#123;</div><div class="line">    return (comp(a, b)) ? b : a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="计算性构造函数"><a href="#计算性构造函数" class="headerlink" title="计算性构造函数"></a>计算性构造函数</h4><p>在某些情况下，可以通过创建构造函数的方式来提高成员函数的执行效率。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct String&#123;</div><div class="line">  String(const char* init);</div><div class="line">  const String operator+(const String&amp; l,const String&amp; r)&#123;</div><div class="line">    return String(l.s_,r.s_);</div><div class="line">  &#125;</div><div class="line">private:</div><div class="line">  String(const char* a,const char* b)&#123;</div><div class="line">    s_=new char[strlen(a)+strlen(b)+1];</div><div class="line">    strcat(strcpy(s_,a),b);</div><div class="line">  &#125;</div><div class="line">  char *s_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="自身类型的using成员"><a href="#自身类型的using成员" class="headerlink" title="自身类型的using成员"></a>自身类型的using成员</h4><p>怎么定义一个类的成员中能够获取到当前类类型的成员呢？
可以用下面这种写法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">struct base&#123;</div><div class="line">  using selfType=T;</div><div class="line">&#125;;</div><div class="line">template&lt;typename T&gt;</div><div class="line">struct foo:public base&lt;foo&lt;T&gt;&gt;&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然有种强行搞事的意思…</p>
<h4 id="std-vector的随机访问"><a href="#std-vector的随机访问" class="headerlink" title="std::vector的随机访问"></a>std::vector的随机访问</h4><p>std::vector可以随机访问，因为其重载了[]操作符，以及有at成员函数，则通常有下面两种方式：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void f(std::vector&lt;T&gt;&amp; x)&#123;</div><div class="line">  x[0];</div><div class="line">  x.at(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上两种随机访问方式有什么区别？</p>
<blockquote>
<p>顺序容器的at(size_type)要求有范围检查。
[ISO/IEC 14882:2014]The member function at() provides bounds-checked access to container elements. at() throws out_of_range if n &gt;= a.size().
而operator[]标准中则没有任何要求。</p>
</blockquote>
<p>可以来看一下一些STL实现(SGISTL)的源码对std::vector的operator[size_type]和at(size_type)的实现：
首先是at(size_type)的实现
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// at(size_type)的实现</div><div class="line">#ifdef __STL_THROW_RANGE_ERRORS</div><div class="line">void _M_range_check(size_type __n) const &#123;</div><div class="line">  if (__n &gt;= this-&gt;size())</div><div class="line">    __stl_throw_range_error(&quot;vector&quot;);</div><div class="line">&#125;</div><div class="line">reference at(size_type __n)</div><div class="line">  &#123; _M_range_check(__n); return (*this)[__n]; &#125;</div><div class="line">const_reference at(size_type __n) const</div><div class="line">  &#123; _M_range_check(__n); return (*this)[__n]; &#125;</div><div class="line">#endif /* __STL_THROW_RANGE_ERRORS */</div><div class="line">​`</div></pre></td></tr></table></figure></p>
<p>再看一下operator[] (size_type)的实现：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// operator[](size_type)的实现</div><div class="line">reference operator[](size_type __n) &#123; return *(begin() + __n); &#125;</div><div class="line">const_reference operator[](size_type __n) const &#123; return *(begin() + __n); &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，operator[]的随机访问并没有范围检查。
即上面的问题：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x[0];</div><div class="line">x.at(0);</div></pre></td></tr></table></figure></p>
<p>这两个的区别在于，若x不为空，则行为相同，若x为空，x.at(0)则抛出一个std::out_of_range异常(C++标准规定)，而x[0]是未定义行为。</p>
<h4 id="注意typedef和-define的区别"><a href="#注意typedef和-define的区别" class="headerlink" title="注意typedef和#define的区别"></a>注意typedef和#define的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef int* INTPTR;</div><div class="line">#define INTPTR2 int*</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  INTPTR i1,i2;</div><div class="line">  INTPTR2 i3,i4;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是直接从IR代码来看吧：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">%6 = alloca i32*, align 8</div><div class="line">%7 = alloca i32*, align 8</div><div class="line">%8 = alloca i32*, align 8</div><div class="line">%9 = alloca i32, align 4</div></pre></td></tr></table></figure></p>
<p>注意<code>%9</code>不是<code>i32*</code>,它是一个i32的对象。
因为<code>#define</code>只是编译期的简单替换，所以在编译期展开的时候会变成这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define INTPTR2 int*</div><div class="line">INTPTR2 i3,i4;</div><div class="line">// 编译期展开</div><div class="line">int* i3,i4;</div></pre></td></tr></table></figure></p>
<p>即只有i3为<code>int*</code>，而i4则为int</p>
<h4 id="为什么const-object不是编译时常量？"><a href="#为什么const-object不是编译时常量？" class="headerlink" title="为什么const object不是编译时常量？"></a>为什么const object不是编译时常量？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const int x=10;</div><div class="line">int y[x]=&#123;0&#125;;</div></pre></td></tr></table></figure>
<p>这里是可以的，在编译器优化下x会直接被替换为10
其中间代码如下:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%6 = alloca i32, align 4</div><div class="line">%7 = alloca [10 x i32], align 16</div><div class="line">store i32 10, i32* %6, align 4</div><div class="line">%8 = bitcast [10 x i32]* %7 to i8*</div><div class="line">call void @llvm.memset.p0i8.i64(i8* %8, i8 0, i64 40, i32 16, i1 false)</div></pre></td></tr></table></figure></p>
<p>可以看到<code>%7</code>的分配时并没有使用%6，所以也并不依赖x这个对象，这个对象是编译期已知的。
但是，当我们这么写时，又如何编译期可知：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int x;</div><div class="line">cin&gt;&gt;x;</div><div class="line">const int y=x;</div><div class="line">// error: variable-sized object may not be initialized</div><div class="line">int z[y]=&#123;0&#125;;</div></pre></td></tr></table></figure></p>
<p>这里是由于编译器扩展，所以C++也支持VLA。但是可以看到const是没办法为编译期常量的。</p>
<h4 id="继承层次中的类查询"><a href="#继承层次中的类查询" class="headerlink" title="继承层次中的类查询"></a>继承层次中的类查询</h4><p>在类的继承层次中，可能具有同一基类的几个不同的派生类，他们之间可能又互相继承派生出了几个继承层次，在这样的情况下如何判断某一个派生类的层次中是否继承自某一个类呢？</p>
<p>可以使用dynamic_cast来实现我们的要求，关于C++类型转换的部分可以看我之前的一篇文章：详细分析下C++中的类型转换。下面先来看一下dynamic_cast在C++标准中的描述(ISO/IEC 14882:2014)：</p>
<blockquote>
<p>The result of the expression dynamic_cast<t>(v) is the result of converting the expression v to type T. T shall be a pointer or reference to a complete class type, or “pointer to cv void.” The dynamic_cast operator shall not cast away constness (5.2.11).</t></p>
</blockquote>
<p>If C is the class type to which T points or refers, the run-time check logically executes as follows:</p>
<ul>
<li>If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class subobject of a C object, and if only one object of type C is derived from the subobject pointed (referred) to by v the result points (refers) to that C object.</li>
<li>Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the type of the most derived object has a base class, of type C, that is unambiguous and public, the result points (refers) to the C subobject of the most derived object.</li>
<li>Otherwise, the run-time check fails.</li>
</ul>
<blockquote>
<p>The value of a failed cast to pointer type is the null pointer value of the required result type. A failed cast to reference type throws an exception (15.1) of a type that would match a handler (15.3) of type std::bad_cast (18.7.2).</p>
</blockquote>
<p>所以我们可以对继承层次中的类指针执行dynamic_cast转换，检查是否转换成功，从而判断继承层次中是否具有某个类。
一个代码的例子如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">struct Shape&#123;</div><div class="line">  virtual void draw()=0;</div><div class="line">  virtual ~Shape()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">struct Roll&#123;</div><div class="line">  virtual void roll()&#123;cout&lt;&lt;&quot;Roll:roll()&quot;&lt;&lt;endl;&#125;</div><div class="line">  virtual ~Roll()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">struct Circle:public Shape,public Roll&#123;</div><div class="line">  void draw()&#123;</div><div class="line">    cout&lt;&lt;&quot;Circle::draw&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  void roll()&#123;</div><div class="line">    cout&lt;&lt;&quot;Circle::roll()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  ~Circle()=default;</div><div class="line">&#125;;</div><div class="line">struct Square:public Shape&#123;</div><div class="line">  void draw()&#123;</div><div class="line">    cout&lt;&lt;&quot;Square::draw()&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  ~Square()=default;</div><div class="line">&#125;;</div><div class="line">int main(int argc,char* argv[])</div><div class="line">&#123;</div><div class="line">  Shape *a=new Square;</div><div class="line">  Roll *b=dynamic_cast&lt;Roll*&gt;(a);</div><div class="line">  if(b!=NULL)&#123;</div><div class="line">    cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;</div><div class="line">  &#125;else&#123;</div><div class="line">    cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  delete a;</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line">// output: no</div></pre></td></tr></table></figure></p>
<p>面的继承层次比较简单，但是当假设我们不知道Cricle和Square的具体继承层次时，那么如何判断Square中是否存在某一基类(如Roll)？
解决的办法就是上面提到的dynamic_cast！通过dynamic_cast转换到转换到要检测的类类型的指针，如果转换成功，dynamic_cast会返回从源类型转换到目标类型的指针，如果失败会返回一个空指针(之所以不使用引用是因为要处理可能会抛出异常的潜在威胁)，这种转换并非是向上或者向下转型，而是横向转型。所以我们需要对dynamic_cast返回的对象(指针)作一个判断就可以得出检测目标的继承层次中是否存在要检测的类型。</p>
<p>但是，我觉得这种行为的适用场景十分狭窄，在良好的类设计下几乎不必要，如果你对自己所实现的类层次感到失控，那一定是糟糕的设计。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://imzlp.me/posts/1756/" target="_blank" rel="external">C/C++中的编程技巧及其概念</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C-Language&quot;&gt;&lt;a href=&quot;#C-Language&quot; class=&quot;headerlink&quot; title=&quot;C Language&quot;&gt;&lt;/a&gt;C Language&lt;/h3&gt;&lt;h4 id=&quot;size-t&quot;&gt;&lt;a href=&quot;#size-t&quot; class=&quot;
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="C" scheme="http://wodekouwei.com/tags/C/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>l-c-skill</title>
    <link href="http://wodekouwei.com/2017/10/12/l-c-skill/"/>
    <id>http://wodekouwei.com/2017/10/12/l-c-skill/</id>
    <published>2017-10-12T09:51:08.000Z</published>
    <updated>2017-11-17T08:48:21.083Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Segmentation-fault段错误调试总结"><a href="#Segmentation-fault段错误调试总结" class="headerlink" title="Segmentation fault段错误调试总结"></a>Segmentation fault段错误调试总结</h3><p>Segmetation fault也叫做段错误，引发的原因有好多，这里我们只说一下段错误发生时的调试方法。</p>
<h4 id="方法1：加打印printf。"><a href="#方法1：加打印printf。" class="headerlink" title="方法1：加打印printf。"></a>方法1：加打印printf。</h4><p>这是最基本的往往也很有效的方法，在哪里Core掉就会在哪里停止打印–一目了然。同时这种方法也存在一个致命缺陷：如果恰巧Core掉的地方没加打印而程序代码又非常庞大又可能是多线程的，那查找问题等同于大海捞针。</p>
<h4 id="方法2：gdb调试。"><a href="#方法2：gdb调试。" class="headerlink" title="方法2：gdb调试。"></a>方法2：gdb调试。</h4><p>加gdb调试往往能在Core dump时抓到，甚至能抓到哪一个文件哪个类哪个函数哪一行，甚是精确。要确保GDB能抓到可用信息要做一些准备：</p>
<ul>
<li>加-g 参数，这样才会有调试信息。 我想是个程序员就应该知道吧。</li>
<li>在Makefile 中加上 -fstack-protector 和-fstack-protector-all 信息，确保函数调用栈不丢失，当然只能是一定程度的不丢失，要完成保留住是不太可能的，但起码可以得到栈顶函数。</li>
</ul>
<p>有了上面两点对大多数的Segmentation fault都能抓住，但是函数调用栈彻底乱掉或者在动态库so中Core而这个库编译时没有加-g参数，这些情况就gdb就无能为力了。</p>
<h4 id="方法3：手动获取函数调用栈。"><a href="#方法3：手动获取函数调用栈。" class="headerlink" title="方法3：手动获取函数调用栈。"></a>方法3：手动获取函数调用栈。</h4><p>这种方法其实是借住两个系统函数backtrace和backtrace_symbol来获取函数调用栈的，把这两个函数放在信号处理函数中：当收到 SIGSEG时在信号处理函数中调用这两个函数打印函数调用栈，在没用GDB调试的时候这种方法可以代替gdb的一部分功能，这听起来是不是非常酷啊，来看一看实现吧：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#include &lt;signal.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;execinfo.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">static void SignalHandle(int sig)</div><div class="line">&#123;</div><div class="line">    void *array[20];</div><div class="line">    size_t size;</div><div class="line">    char **strings;</div><div class="line">    int i;</div><div class="line">    size = backtrace(array, 10);</div><div class="line">    strings = backtrace_symbols(array, size);</div><div class="line">    printf(&quot;SIGNAL ocurre %d, stack tarce:\n&quot;, sig);</div><div class="line">    printf(&quot;obtained %d stack frames.\n&quot;, size);</div><div class="line"></div><div class="line">    for (i = 0; i &lt; size; i++)</div><div class="line">        printf(&quot;%s\n&quot;, strings);</div><div class="line"></div><div class="line">    free(strings);</div><div class="line">    printf(&quot;stack trace over!\n&quot;);</div><div class="line">    exit(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    signal(SIGSEGV, SignalHandle);</div><div class="line">    //...程序主体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这种方法在没有GDB时候会大显身手，经过实验就是有gdb的时候这种方法有时比gdb抓到调用栈要多一层；当然这种方法和用gdb调试一样要加<code>-g</code>和栈保护参数<code>-fstack-protector</code> 和 <code>-fstack-protector-all</code>。其缺点就是抓到的调用栈无效，这是什么意思呢？有时发生core dump,能定位到甚至哪一行，但是那一行根本没有明显的错误；或者追到没有调试信息的动态库里如glibc。当然这些情况大多数调试方法都无能为力，只能依靠程序员的经验了。</p>
<h4 id="方法4：经验之谈。"><a href="#方法4：经验之谈。" class="headerlink" title="方法4：经验之谈。"></a>方法4：经验之谈。</h4><p>如果我们的程序是多线程的，发生core dump用以上方法均无效，除了仔细排查代码外，还有这么一方法让我们缩小范围。</p>
<p><a href="https://coolshell.cn/articles/10115.html" target="_blank" rel="external">c语言全局变量那些事</a>
<a href="https://coolshell.cn/articles/9543.html" target="_blank" rel="external">“C++的数组不支持多态”？</a></p>
<p><a href="https://coolshell.cn/articles/7886.html" target="_blank" rel="external">代码执行的效率</a></p>
<p><a href="https://coolshell.cn/articles/5761.html" target="_blank" rel="external">深入理解C语言</a></p>
<p><a href="https://coolshell.cn/articles/5202.html" target="_blank" rel="external">对象的消息模型</a></p>
<p><a href="https://coolshell.cn/articles/4626.html" target="_blank" rel="external">读书笔记：对线程模型的批评</a></p>
<p><a href="https://coolshell.cn/articles/945.html" target="_blank" rel="external">C语言的谜题</a></p>
<p><a href="https://coolshell.cn/articles/3572.html" target="_blank" rel="external">C语言函数实现的另类方法</a></p>
<p><a href="https://coolshell.cn/articles/873.html" target="_blank" rel="external">谁说C语言很简单？</a></p>
<p><a href="https://coolshell.cn/articles/551.html" target="_blank" rel="external">C语言下的错误处理的问题</a></p>
<p><a href="https://coolshell.cn/articles/11377.html" target="_blank" rel="external">C语言结构体里的成员数组和指针</a></p>
<p><a href="http://blog.csdn.net/haoel/article/details/6212499" target="_blank" rel="external">C技巧：结构体参数转成不定参数</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Segmentation-fault段错误调试总结&quot;&gt;&lt;a href=&quot;#Segmentation-fault段错误调试总结&quot; class=&quot;headerlink&quot; title=&quot;Segmentation fault段错误调试总结&quot;&gt;&lt;/a&gt;Segmentatio
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="C" scheme="http://wodekouwei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>arithmetic-kmp</title>
    <link href="http://wodekouwei.com/2017/10/12/arithmetic-kmp/"/>
    <id>http://wodekouwei.com/2017/10/12/arithmetic-kmp/</id>
    <published>2017-10-12T09:48:52.000Z</published>
    <updated>2017-10-12T09:56:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fr=aladdin" target="_blank" rel="external">https://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fr=aladdin</a></p>
<p><a href="http://blog.csdn.net/yutianzuijin/article/details/11954939/" target="_blank" rel="external">http://blog.csdn.net/yutianzuijin/article/details/11954939/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://baike.baidu.com/i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>(转)从头开始写项目makefile</title>
    <link href="http://wodekouwei.com/2017/10/10/course-makefile-project-practice/"/>
    <id>http://wodekouwei.com/2017/10/10/course-makefile-project-practice/</id>
    <published>2017-10-10T09:58:27.000Z</published>
    <updated>2017-10-11T03:10:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1. 基本规则"></a>1. 基本规则</h3><p>一般一个稍大的linux项目会有很多个源文件组成，最终的可执行程序也是由这许多个源文件编译链接而成的。编译是把一个.c或.cpp文件编译成中间代码.o文件，链接是就使用这些中间代码文件生成可执行文件。比如在当前项目目录下有如下源文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ls  </div><div class="line">common.h  debug.c  debug.h  ipc.c  ipc.h  main.c  tags  timer.c  timer.h  tools.c  tools.h   </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>以上源代码可以这样编译：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># gcc -o target_bin main.c debug.c ipc.c timer.c tools.c</div></pre></td></tr></table></figure></p>
<p>如果之后修改了其中某一个文件（如tools.c），再执行一下上一行代码即可，但如果有成千上万个源文件这样编译肯定是不够合理的。此时我们可以按下面步骤来编译：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># gcc -c debug.c  </div><div class="line"># gcc -c ipc.c  </div><div class="line"># gcc -c main.c  </div><div class="line"># gcc -c timer.c  </div><div class="line"># gcc -c tools.c  </div><div class="line"># gcc -o target_bin main.o debug.o ipc.o timer.o tools.o</div></pre></td></tr></table></figure></p>
<p>如果其中tools.c修改了，只需要编译该文件，再执行最后生成可执行文件的操作，也就是做如下两步操作即可：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -c tools.c  </div><div class="line"># gcc -o target_bin main.o debug.o ipc.o timer.o tools.o</div></pre></td></tr></table></figure></p>
<p>这样做看上去应该很合理了。但是如果修改了多个文件，就很可能忘了编译某一文件，那么运行时就很有可能出错。如果是common.h文件修改了，那么包含该头文件的所有.c文件都需要重新编译，这样一来的话就更复杂更容易出错了。看来这种方法也不够好，手动处理很容易出错。那有没有一种自动化的处理方式呢？有的，那就是写一个Makefile来处理编译过程。
下面给一个简单的Makefile，在源代码目录下建一个名为Makefile的文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">main.o: main.c common.h                                                                                                                                                                     </div><div class="line">&gt;---gcc -c main.c  </div><div class="line"></div><div class="line">debug.o: debug.c debug.h common.h  </div><div class="line">&gt;---gcc -c debug.c  </div><div class="line"></div><div class="line">ipc.o: ipc.c ipc.h common.h  </div><div class="line">&gt;---gcc -c ipc.c  </div><div class="line"></div><div class="line">timer.o: timer.c timer.h common.h  </div><div class="line">&gt;---gcc -c timer.c  </div><div class="line"></div><div class="line">tools.o: tools.c tools.h common.h  </div><div class="line">&gt;---gcc -c tools.c</div></pre></td></tr></table></figure></p>
<p>然后在命令行上执行命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># make   </div><div class="line">gcc -c main.c  </div><div class="line">gcc -c debug.c  </div><div class="line">gcc -c ipc.c  </div><div class="line">gcc -c timer.c  </div><div class="line">gcc -c tools.c  </div><div class="line">gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line">#  </div><div class="line"># ls  </div><div class="line">common.h  common.h~  debug.c  debug.h  debug.o  ipc.c  ipc.h  ipc.o  main.c  main.o  Makefile  Makefile~  tags  target_bin  timer.c  timer.h  timer.o  tools.c  tools.h  tools.o  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>可见在该目录下生成了.o文件以及target_bin可执行文件。现在我们只需要执行一个make命令就可以完成所有编译工作，无需像之前一样手动执行所有动作，make命令会读取当前目录下的Makefile文件然后完成编译步骤。从编译过程输出到屏幕的内容看得到执行make命令之后所做的工作，其实就是我们之前手动执行的那些命令。现在来说一下什么是Makefile？
所谓Makefile我的理解其实就是由一组组编译规则组成的文件，每条规则格式大致为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target ... : prerequisites ...   </div><div class="line">&gt;---command  </div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>其中target是目标文件，可以为可执行文件、<code>*.o</code>文件或标签。Prerequisites是产生target所需要的源文件或<code>*.o</code>文件，可以是另一条规则的目标。commond是要产生该目标需要执行的操作系统命令，该命令必须以tab（文中以&gt;—标示tab字符）开头，不可用空格代替。
说白了就是要产生target，需要依赖后面的prerequisites文件，然后执行commond来产生来得到target。这和我们之前手动执行每条编译命令是一样的，其实就是定义好一个依赖关系，我们把产生每个文件的依赖文件写好，最终自动执行编译命令。
比如在我们给出的Makefile例子中target_bin main.o等就是target，main.o debug.o ipc.o timer.o tools.o是target_bin的prerequisites，gcc -o target_bin main.o debug.o ipc.o timer.o tools.o就是commond，把所有的目标文件编译为最终的可执行文件target，而main.c common.h是main.o的prerequisites，其gcc -c main.c命令生成target所需要的main.o文件。
在该例子中，Makefile工作过程如下：</p>
<ol>
<li>首先查找第一条规则目标，第一条规则的目标称为缺省目标，只要缺省目标更新了就算完成任务了，其它工作都是为这个目的而做的。 该Makefile中第一条规则的目标target_bin，由于我们是第一次编译，target_bin文件还没生成，显然需要更新，但此时依赖文件main.o debug.o ipc.o timer.o tools.o都没有生成，所以需要先更新这些文件，然后才能更新target_bin。</li>
<li>所以make会进一步查找以这些依赖文件main.o debug.o ipc.o timer.o tools.o为目标的规则。首先找main.o，该目标也没有生成，该目标依赖文件为main.c common.h，文件存在，所以执行规则命令gcc -c main.c，生成main.o。其他target_bin所需要的依赖文件也同样操作。</li>
<li>最后执行gcc -o target_bin main.o debug.o ipc.o timer.o tools.o，更新target_bin。</li>
</ol>
<p>在没有更改源代码的情况下，再次运行make：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make  </div><div class="line">make: `target_bin&apos; is up to date.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>得到提示目标target_bin已经是最新的了。
如果修改文件main.c之后，再运行make：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># vim main.c  </div><div class="line"># make  </div><div class="line">gcc -c main.c  </div><div class="line">gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>此时make会自动选择受影响的目标重新编译：
首先更新缺省目标，先检查target_bin是否需要更新，这需要检查其依赖文件main.o debug.o ipc.o timer.o tools.o是否需要更新。
其次发现main.o需要更新，因为main.o目标的依赖文件main.c最后修改时间比main.o晚，所以需要执行生成目标main.o的命令：gcc -c main.c更新main.o。
最后发现目标target_bin的依赖文件main.o有更新过，所以执行相应命令gcc -o target_bin main.o debug.o ipc.o timer.o tools.o更新target_bin。
总结下，执行一条规则步骤如下：</p>
<ol>
<li>先检查它的依赖文件，如果依赖文件需要更新，则执行以该文件为目标的的规则。如果没有该规则但找到文件，那么该依赖文件不需要更新。如果没有该规则也没有该文件，则报错退出。</li>
<li>再检查该文件的目标，如果目标不存在或者目标存在但依赖文件修改时间比他要晚或某依赖文件已更新，那么执行该规则的命令。
由此可见，Makefile可以自动发现更新过的文件，自动重新生成目标，使用Makefile比自己手动编译比起来，不仅效率高，还减少了出错的可能性。</li>
</ol>
<p>Makefile中有很多目标，我们可以编译其中一个指定目标，只需要在make命令后面带上目标名称即可。如果不指定编译目标的话make会编译缺省的目标，也就是第一个目标，在本文给出的Makefile第一个目标为target_bin。如果只修改了tools.c文件的话，我们可能只想看看我们的更改的源代码是否有语法错误而又不想重新编译这个工程的话可以执行如下命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make tools.o   </div><div class="line">gcc -c tools.c  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>编译成功，这里又引出一个问题，如果继续执行同样的命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make tools.o  </div><div class="line">make: `tools.o&apos; is up to date.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>我们先手动删掉tools.o文件再执行就可以了，怎么又是手动呢？我们要自动，要自动！！好吧，我们加一个目标来删除这些编译过程中产生的临时文件，该目标为clean。
我们在上面Makefile最后加上如下内容：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<p>当我们直接make命令时不会执行到该目标，因为没有被默认目标target_bin目标或以target_bin依赖文件为目标的目标包含在内。我们要执行该目标需要在make时指定目标即可。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make clean  </div><div class="line">rm *.o target_bin  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>可见clean目标被执行到了，再执行make时make就会重新生成所有目标对应的文件，因为执行make clean时，那些文件被清除了。
clean目标应该存在与你的Makefile当中，它既可以方便你的二次编译，又可以保持的源文件的干净。该目标一般放在最后，不可放在最开头，否则会被当做缺省目标被执行，这很可能不是你的意愿。
最后总结一下，Makefile只是告诉了make命令如何来编译和链接程序，告诉make命令生成目标文件需要的文件，具体的编译链接工作是你的目标对应的命令在做。
给一个今天完整的makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">main.o: main.c common.h                                                                                                                                                                     </div><div class="line">&gt;---gcc -c main.c  </div><div class="line"></div><div class="line">debug.o: debug.c debug.h common.h  </div><div class="line">&gt;---gcc -c debug.c  </div><div class="line"></div><div class="line">ipc.o: ipc.c ipc.h common.h  </div><div class="line">&gt;---gcc -c ipc.c  </div><div class="line"></div><div class="line">timer.o: timer.c timer.h common.h  </div><div class="line">&gt;---gcc -c timer.c  </div><div class="line"></div><div class="line">tools.o: tools.c tools.h common.h  </div><div class="line">&gt;---gcc -c tools.c  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<h3 id="2-隐含规则自动推导"><a href="#2-隐含规则自动推导" class="headerlink" title="2. 隐含规则自动推导"></a>2. 隐含规则自动推导</h3><p>上一节的Makefile勉强可用，但还写的比较繁琐，不够简洁。对每一个.c源文件，都需要写一个生成其对应的.o目标文件的规则，如果有几百个或上千个源文件，都手动来写，还不是很麻烦，这也不够自动化啊。
这样，我们把生成.o目标文件的规则全部删除掉，就是这样一个Makefile文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<p>这下简洁了不少，这样也能用吗？试试看吧先，make一下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># make  </div><div class="line">cc    -c -o main.o main.c  </div><div class="line">cc    -c -o debug.o debug.c  </div><div class="line">cc    -c -o ipc.o ipc.c  </div><div class="line">cc    -c -o timer.o timer.c  </div><div class="line">cc    -c -o tools.o tools.c  </div><div class="line">gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>原来酱紫都可以啊！！target_bin后面那一群依赖文件怎么生成呢？不是没有生成*.o目标文件的规则了吗？再看屏幕编译输出内容：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cc    -c -o main.o main.c  </div><div class="line">cc    -c -o debug.o debug.c  </div><div class="line">cc    -c -o ipc.o ipc.c  </div><div class="line">cc    -c -o timer.o timer.c  </div><div class="line">cc    -c -o tools.o tools.c</div></pre></td></tr></table></figure></p>
<p>怎么长的和之前不太一样呢，尤其是前面那个cc是何物？
其实make可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个*.o文件后都写上类似的命令，因为，我们的 make 会自动推导依赖文件，并根据隐含规则自己推导命令。所以上面.o文件是由于make自动推导出的依赖文件以及命令来生成的。
下面来看看make是如何推导的。
命令make –p可以打印出很多默认变量和隐含规则。Makefile变量可以理解为C语言的宏，直接展开即可（后面会讲到）。取出我们关心的部分：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># default  </div><div class="line">OUTPUT_OPTION = -o $@  </div><div class="line"># default  </div><div class="line">CC = cc  </div><div class="line"># default  </div><div class="line">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) –c  </div><div class="line"># Implicit Rules  </div><div class="line">%.o: %.c  </div><div class="line">#  commands to execute (built-in):  </div><div class="line">&gt;---$(COMPILE.c) $(OUTPUT_OPTION) $&lt;</div></pre></td></tr></table></figure></p>
<p>其中cc是一个符号链接，指向gcc，这就可以解释为什么我们看到的编译输出为cc，其实还是使用gcc在编译。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ll /usr/bin/cc    </div><div class="line">lrwxrwxrwx. 1 root root 3 Dec  3  2013 /usr/bin/cc -&gt; gcc  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>变量<code>$(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)</code>都为空。所以<code>%.o: %.c</code>规则命令展开为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc    -c -o $@ $&lt;</div></pre></td></tr></table></figure></p>
<p>再看屏幕输出编译内容，摘取一条：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc    -c -o main.o main.c</div></pre></td></tr></table></figure></p>
<p>不是看出点什么？<code>$@</code>和main.o对应，<code>$&lt;</code>和main.c对应。其实<code>$@</code>和<code>$&lt;</code>是两个变量。<code>$@</code>为规则中的目标，<code>$&lt;</code>为规则中的第一个依赖文件。<code>%.o:%.c</code>是一种称为模式规则的特殊规则。因为main.o符合该模模式，再推导出依赖文件main.c，最终推导出整个规则为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">main.o : main.c：  </div><div class="line">&gt;--- cc    -c -o main.o main.c</div></pre></td></tr></table></figure></p>
<p>其余几个目标也同样推导。make自动推导的功能为我们减少了不少的Makefile代码，尤其是对源文件比较多的大型工程，我们的Makefile可以不用写得那么繁琐了。
最后，今天的Makefile相对于上一节进化成这个样子了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm *.o target_bin</div></pre></td></tr></table></figure></p>
<h3 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3. 变量的使用"></a>3. 变量的使用</h3><p>仔细研究我们的之前Makefile发现，我们还有改进的地方，就是此处：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">target_bin : main.o debug.o ipc.o timer.o tools.o  </div><div class="line">&gt;---gcc -o target_bin main.o debug.o ipc.o timer.o tools.o</div></pre></td></tr></table></figure></p>
<p>如果增加一个源文件xx.c的话，需要在两处或多处增加xx.o文件。我们可以使用变量来解决这个问题。之前说过，Makefile的变量就像C语言的宏一样，使用时在其位置上直接展开。变量在声明时赋予初值，在引用变量时需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。
默认目标target_bin也在多处出现了，该文件也可以使用变量代替。
修改我们的Makefile如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SRC_OBJ = main.o debug.o ipc.o timer.o tools.o  </div><div class="line">SRC_BIN = target_bin  </div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---gcc -o $(SRC_BIN) $(SRC_OBJ)  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---rm $(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>这样每次有新增的文件是只需要在SRC_OBJ变量里面增加一个文件即可。要修改最终目标的名字是可以只修改变量SRC_BIN。
其实在之前还说过特殊变量：</p>
<ul>
<li><code>$@</code>，表示规则中的目标。</li>
<li><code>$&lt;</code>，表示规则中的第一个依赖文件。</li>
<li><code>$?</code>，表示规则中所有比目标新的条件，组成一个列表，以空格分隔。
<code>$^</code>:，表示规则中的所有条件，组成一个列表，以空格分隔。
上一节我们看到make -p有很多自定义的变量，比如CC。其中很多变量我们可以直接使用或修改其变量值或增加值。我们的Makefile中可以使用CC（默认值为cc）、RM（默认值为rm -f）。</li>
</ul>
<p>由此可见我们的Makefile还可以进一步修改：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SRC_OBJ = main.o debug.o ipc.o timer.o tools.o  </div><div class="line">SRC_BIN = target_bin  </div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^                                                                                                                                           </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>这样的Makefile编译也是可用的。
但是这样的Makefile还是需要我们手动添加文件，还是不够自动化，最好增删文件都要修改Makefile。伟大的人类真是太懒了！！于是乎，他们发明了一个函数<code>wilcard</code>（函数后面会讲到），它可以用来获取指定目录下的所有的.c文件列表。这样的话我们可以自动获取当前目录下所有.c源文件，然后通过其他方法再得到.o文件列表，这样的话就不需要在每次增删文件时去修改Makefile了。所谓其他方法这里给出两种：</p>
<ol>
<li>使用patsubst函数。在<code>$(patsubst %.c,%.o,$(dir) )</code>中，patsubst把$(dir)中的变量符合后缀是.c的全部替换成.o。</li>
<li>变量值的替换。 我们可以替换变量中的共有的部分，其格式是<code>“$(var:a=b)”</code>或<code>“${var:a=b}”</code>，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。</li>
</ol>
<p>修改后的Makefile如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))                                                                                                                                          </div><div class="line"></div><div class="line">SRC = $(wildcard *.c)  </div><div class="line">SRC_OBJ = $(SRC:.c=.o)  </div><div class="line">SRC_BIN = target_bin  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>其中# 后面的内容为注释。
这样终于满足了那些懒人的想法了。可见在使用变量时，的确可以是编译变得更自动化。</p>
<p>其实变量的定义有三种运算符<code>=、:=、?=、+=</code>。</p>
<ol>
<li><code>=</code>运算符可以读取到后面定义的变量。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VAR = $(VAR2)  </div><div class="line">VAR2 = hello_make  </div><div class="line"></div><div class="line">all:  </div><div class="line">&gt;---@echo =====$(VAR)=====</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#  </div><div class="line">=====hello_make=====  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>但是这种定义可能会导致并非我们意愿的事发生，并不是很符合C语言的编程习惯。</p>
<ol>
<li><code>:=</code>运算符在遇到变量定义时立即展开。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VAR := $(VAR2)                                                                                         </div><div class="line">VAR2 = hello_make  </div><div class="line"></div><div class="line">all:  </div><div class="line">&gt;---@echo =====$(VAR)=====</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#  </div><div class="line">==========  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<ol>
<li><code>?=</code>运算符在复制之前先做判断变量是否已经存在。例如<code>var1 ?= $(var2)</code>的意思是：如果var1没有定义过，那么<code>?=</code>相当于<code>=</code>，如果var1先前已经定义了，则什么也不做，不会给var重新赋值。</li>
<li><code>+=</code>运算符是给变了追加值。如果变量还没有定义过就直接用+=赋值，那么<code>+=</code>相当于<code>=</code></li>
</ol>
<p>如何使用这几个运算符要看实际情况，有时一个大的工程可能有许多Makefile组成，变量可能在多个Makefile中都在使用，这时可能使用<code>+=</code>比较好。使用<code>:=</code>有时可能比要好。
有时在编译程序时，我们需要编译器给出警告，或加入调试信息，或告知编译器优化可执行文件。编译时C编译器的选项CFLAGS使用的较多，默认没有提供值，我们可以给该变量赋值。有时我们还需要使用链接器选项LFLAGS告诉链接器链接时需要的库文件。可能我们还需要给出包含头文件的路径，因为头文件很可能和源文件不再同一目录。所以，我们今天的Makefile加上部分注释又更新了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># A commonMakefile for c programs, version 1.0  </div><div class="line"># Copyright (C)2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall-Werror -O2  </div><div class="line">CPPFLAGS += -I.-I./inc                                                                                                                                                                    </div><div class="line">LDFLAGS +=-lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ =$(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES =$(wildcard *.c)  </div><div class="line">SRC_OBJ =$(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN =target_bin  </div><div class="line"></div><div class="line">$(SRC_BIN) :$(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@$^ $(LDFLAGS)  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<p>编译：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># make  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o debug.odebug.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o ipc.oipc.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o main.omain.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o timer.otimer.c  </div><div class="line">cc -g -Wall-Werror -O2 -I. -I./inc  -c -o tools.otools.c  </div><div class="line">cc -o target_bindebug.o ipc.o main.o timer.o tools.o -lpthread  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>可见我们的预编译选项，编译选项都用到了，之前我们说过make的使用隐含规则自动推导：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) –c</div></pre></td></tr></table></figure></p>
<p>其中变量CFLAGS 和 CPPFLAGS均是我们给出的，变量$(TARGET_ARCH)未给，所以在编译输出可以看到-c前面有2个空，最早未给变量是有四个空。
目前给出的Makefile基本上可以适用于那些源代码全部在同一目录下的简单项目，并且基本上在增删文件时不需要再去手动修改Makefile代码。在新的一个项目只需要把该Makefile拷贝到源代码目录下，再修改一下你需要编译的可执行文件名称以及你需要的编译连接选项即可。
后面章节将会讲到如何写多目录源代码工程下的Makefile。
最后，今天的最终Makefile是这样的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># A commonMakefile for c programs, version 1.0  </div><div class="line"># Copyright (C)2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall-Werror -O2  </div><div class="line">CPPFLAGS += -I.-I./inc                                                                                                                                                                    </div><div class="line">LDFLAGS +=-lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ =$(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES =$(wildcard *.c)  </div><div class="line">SRC_OBJ =$(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN =target_bin  </div><div class="line"></div><div class="line">$(SRC_BIN) :$(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@$^ $(LDFLAGS)  </div><div class="line"></div><div class="line">clean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_BIN)</div></pre></td></tr></table></figure></p>
<h3 id="3-伪目标"><a href="#3-伪目标" class="headerlink" title="3. 伪目标"></a>3. 伪目标</h3><p>一般情况下，Makefile都会有一个clean目标，用于清除编译过程中产生的二进制文件。我们在第一节的Makefile就用到了这个 clean目标，该目标没有任何依赖文件，并且该目标对应的命令执行后不会生产clean文件。
像这种特点目标，它的规则所定义的命令不是去创建文件，而仅仅通过make指定目标来执行一些特定系统命令或其依赖为目标的规则（如all），称为伪目标。
一个Makefile一般都不会只有一个伪目标，如果按Makefile的“潜规则”以及其约定俗成的名字来说的话，在较大的项目的Makefile中比较常用的为目标有这些：</p>
<ul>
<li>all：执行主要的编译工作，通常用作缺省目标，放在最前面。</li>
<li>Install：执行编译后的安装工作，把可执行文件、配置文件、文档等分别拷到不同的安装目录。</li>
<li>clean：删除编译生成的二进制文件。</li>
<li>distclean：删除除源文件之外的所有中间生成文件，如配置文件，文档等。</li>
<li>tags：为vim等编辑器生成tags文件。</li>
<li>help：打印当前Makefile的帮助信息，比如有哪些目标可以有make指定去执行。
等。</li>
</ul>
<p>make处理Makefile时，首先读取所有规则，建立关系依赖图。然后从缺省目标（第一个目标）或指定的目标开始执行。像clean，tags这样的目标一般不会作为缺省目标，也不会跟缺省目标有任何依赖关系，所以 make 无法生成它的依赖关系和决定它是否要执行。所以要执行这样的目标时，必须要显示的指定make该目标。就像前面我们清楚便已产生的中间二进制文件一样，需要显示执行命令：make clean。
伪目标也可以作为默认目标（如all），并且可以为其指定依赖文件。
我们先将version 1.0的Makefile完善下，我们可以加入帮助信息，tags等功能。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># A common Makefile for c programs, version 1.1  </div><div class="line"></div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc  </div><div class="line">LDFLAGS += -lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard *.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN = target_bin  </div><div class="line"></div><div class="line">all : $(SRC_BIN)  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)  </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefile for cprograms==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163 \dotcom&quot;  </div><div class="line">&gt;---@echo &quot;The following targets are support:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all             - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj             - just compile, without link&quot;  </div><div class="line">&gt;---@echo &quot; clean           - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean       - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags            - create ctags for vim editor&quot;  </div><div class="line">&gt;---@echo &quot; help            - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make [target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version 1.1=======================&quot;  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe tags *~</div></pre></td></tr></table></figure></p>
<p>make会把执行的命令打印在屏幕上，如果我们不想把命令打印在屏幕上，只显示命令结果时，直接在命令前面加上符号“@”就可以实现。如上面help目标一样，只显示命令结果。一般我们会在make时都会输出“Compiling xxx.c…”,不输出编译时的命令。我们在后面写Makefile时可以模仿。
如果当前目录下存在一个和伪目标同名的文件时（如clean），此时如果执行命令make clean后出现如下结果：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># touch clean  </div><div class="line"># make clean  </div><div class="line">make: `clean&apos; is up to date.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>这是因为clean文件没有依赖文件，make认为目标clean是最新的不会去执行规则对应的命令。为了解决这个问题，我们可以明确地将该目标声明为伪目标。将一个目标声明为伪目标需要将它作为特殊目标.PHONY”的依赖。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.PHONY : clean</div></pre></td></tr></table></figure></p>
<p>这条规则写在clean:规则的后面也行，也能起到声明clean是伪目标的作用
这样修改一下之前Makefile，将所有伪目标都作为.PHONY的依赖：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.PHONY : all obj tag help clean disclean</div></pre></td></tr></table></figure></p>
<p>这样在当前目录下存在文件clean时执行:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make clean  </div><div class="line">rm -f debug.o ipc.o main.o timer.o tools.o target_bin target_bin.exe  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>发现问题解决。
最后，给出今天最终的Makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"># A common Makefile for c programs, version 1.1                                                                                                                                            </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc  </div><div class="line">LDFLAGS += -lpthread  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard *.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_BIN = target_bin  </div><div class="line"></div><div class="line">all : $(SRC_BIN)  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)  </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line">tag:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefile for cprograms==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163 \dotcom&quot;  </div><div class="line">&gt;---@echo &quot;The following targets are support:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all             - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj             - just compile, without link&quot;  </div><div class="line">&gt;---@echo &quot; clean           - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean       - clean target and other information&quot;  </div><div class="line">&gt;---@echo &quot; tags            - create ctags for vim editor&quot;  </div><div class="line">&gt;---@echo &quot; help            - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make [target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version 1.1=======================&quot;  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe tags *~  </div><div class="line"></div><div class="line">.PHONY : all obj tag help clean disclean</div></pre></td></tr></table></figure></p>
<h3 id="5-嵌套执行"><a href="#5-嵌套执行" class="headerlink" title="5. 嵌套执行"></a>5. 嵌套执行</h3><p>在大一些的项目里面，所有源代码不会只放在同一个目录，一般各个功能模块的源代码都是分开的，各自放在各自目录下，并且头文件和.c源文件也会有各自的目录，这样便于项目代码的维护。这样我们可以在每个功能模块目录下都写一个Makefile，各自Makefile处理各自功能的编译链接工作，这样我们就不必把所有功能的编译链接都放在同一个Makefile里面，这可使得我们的Makefile变得更加简洁，并且编译的时候可选择编译哪一个模块，这对分块编译有很大的好处。
现在我所处于工程目录树如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">.  </div><div class="line"></div><div class="line">├── include  </div><div class="line">│   ├── common.h  </div><div class="line">│   ├── ipc  </div><div class="line">│   │   └── ipc.h  </div><div class="line">│   └── tools  </div><div class="line">│       ├── base64.h  </div><div class="line">│       ├── md5.h  </div><div class="line">│       └── tools.h  </div><div class="line">├── Makefile  </div><div class="line">├── src  </div><div class="line">│   ├── ipc  </div><div class="line">│   │   ├── inc  </div><div class="line">│   │   ├── Makefile  </div><div class="line">│   │   └── src  </div><div class="line">│   │       └── ipc.c  </div><div class="line">│   ├── main  </div><div class="line">│   │   ├── inc  </div><div class="line">│   │   ├── Makefile  </div><div class="line">│   │   └── src  </div><div class="line">│   │       ├── main.c  </div><div class="line">│   │       └── main.c~  </div><div class="line">│   └── tools  </div><div class="line">│       ├── inc  </div><div class="line">│       ├── Makefile  </div><div class="line">│       └── src  </div><div class="line">│           ├── base64.c  </div><div class="line">│           ├── md5.c  </div><div class="line">│           └── tools.c  </div><div class="line">└── tags  </div><div class="line"></div><div class="line">13 directories, 16 files</div></pre></td></tr></table></figure></p>
<p>这样组织项目源码要比之前合理一些，那这样怎么来写Makefile呢？我们可以在每个目录下写一个Makefile，通过最顶层的Makefile一层一层的向下嵌套执行各层Makefile。那么我们最顶层的Makefile简单点的话可以这样写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># top Makefile for xxx  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---$(MAKE) -C src  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---$(MAKE) -C src clean  </div><div class="line"></div><div class="line">.PHONY : all clean tags</div></pre></td></tr></table></figure></p>
<p>命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;---$(MAKE) -C src</div></pre></td></tr></table></figure></p>
<p>就是进入src目录继续执行该目录下的Makefile。然后src目录下的Makefile在使用同样的方法进入下一级目录tools、main、ipc，再执行该目录下的Makefile。其实这样有些麻烦，我们可以直接从顶层目录进入最后的目录执行make。再加入一些伪目标完善下，我们的顶层Makefile就出来了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"># Top Makefile for C program  </div><div class="line"></div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---$(MAKE) -C src/ipc  </div><div class="line">&gt;---$(MAKE) -C src/tools  </div><div class="line">&gt;---$(MAKE) -C src/main  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefilefor c programs==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163\dot com&quot;  </div><div class="line">&gt;---@echo &quot;The following targets aresupport:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all              - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj              - just compile, withoutlink&quot;  </div><div class="line">&gt;---@echo &quot; clean            - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean        - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags             - create ctags for vimeditor&quot;  </div><div class="line">&gt;---@echo &quot; help             - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make[target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version2.0 =======================&quot;  </div><div class="line"></div><div class="line">obj:  </div><div class="line">&gt;---$(MAKE) -C src/ipc obj  </div><div class="line">&gt;---$(MAKE) -C src/tools obj  </div><div class="line">&gt;---$(MAKE) -C src/main obj  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---$(MAKE) -C src/ipc clean  </div><div class="line">&gt;---$(MAKE) -C src/tools clean  </div><div class="line">&gt;---$(MAKE) -C src/main clean  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(MAKE) -C src/ipc distclean  </div><div class="line">&gt;---$(MAKE) -C src/tools distclean  </div><div class="line">&gt;---$(MAKE) -C src/main distclean  </div><div class="line"></div><div class="line">.PHONY : all clean distclean tags help</div></pre></td></tr></table></figure></p>
<p>当我们这样组织源代码时，最下面层次的Makefile怎么写呢？肯定不可以将我们上一节的Makefile（version 1.1）直接拷贝到功能模块目录下，需要稍作修改。不能所有的模块都最终生成各自的可执行文件吧，我们目前是一个工程，所以最后只会生成一个可执行程序。我们这样做，让主模块目录生成可执行文件，其他模块目录生成静态库文件，主模块链接时要用其他模块编译产生的库文件来生成最终的程序。将上一节Makefile稍作修改得出编译库文件Makefile和编译可执行文件Makefile分别如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># A Makefile to generate archive file  </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc -I../../include  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard src/*.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_LIB = libtools.a  </div><div class="line"></div><div class="line">all : $(SRC_LIB)  </div><div class="line"></div><div class="line">$(SRC_LIB) : $(SRC_OBJ)  </div><div class="line">&gt;---$(AR) rcs $@ $^  </div><div class="line">&gt;---cp $@ ../../libs  </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB)  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB) tags *~  </div><div class="line"></div><div class="line">.PHONY : all obj clean disclean</div></pre></td></tr></table></figure></p>
<p>====================</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># A Makefile to generate executive file                                                                                                                                                     </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">CFLAGS += -g -Wall -Werror -O2  </div><div class="line">CPPFLAGS += -I. -I./inc -I../../include  </div><div class="line">LDFLAGS += -lpthread -L../../libs -ltools -lipc  </div><div class="line"></div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard src/*.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)    </div><div class="line">SRC_BIN = target_bin            </div><div class="line"></div><div class="line">all : $(SRC_BIN)  </div><div class="line"></div><div class="line">$(SRC_BIN) : $(SRC_OBJ)         </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)   </div><div class="line"></div><div class="line">obj : $(SRC_OBJ)  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_BIN) $(SRC_BIN).exe tags*~  </div><div class="line"></div><div class="line">.PHONY : all obj clean disclean</div></pre></td></tr></table></figure>
<p>最后在顶层执行：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># make clean  </div><div class="line"></div><div class="line">make -C src/ipc clean  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">rm -f src/ipc.o libipc.a  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">make -C src/tools clean  </div><div class="line">make[1]: Entering directory `/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">rm -f src/base64.o src/md5.o src/tools.o libtools.a  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">make -C src/main clean  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line">rm -f src/main.o target_bin target_bin.exe  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line"># make  </div><div class="line">make -C src/ipc  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/ipc.osrc/ipc.c  </div><div class="line">ar rcs libipc.a src/ipc.o  </div><div class="line">cp libipc.a ../../libs  </div><div class="line">make[1]: Leaving directory `/home/Myprojects/example_make/version-3.0/src/ipc&apos;  </div><div class="line">make -C src/tools  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/base64.osrc/base64.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc -I../../include  -c -o src/md5.o src/md5.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/tools.osrc/tools.c  </div><div class="line">ar rcs libtools.a src/base64.o src/md5.o src/tools.o  </div><div class="line">cp libtools.a ../../libs  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/tools&apos;  </div><div class="line">make -C src/main  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/main.osrc/main.c  </div><div class="line">cc -o target_bin src/main.o -lpthread -L../../libs -ltools-lipc  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-3.0/src/main&apos;  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>最后生成了可执行程序文件。这样的话一个工程的各个模块就变得独立出来了，不但源码分开了，而且各自有各自的Makefile，并且各个功能模块是可独立编译的。
我们发现顶层Makefile还有可以改进的地方，就是在进入下一层目录是要重复写多次，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;---$(MAKE) -C src/ipc  </div><div class="line">&gt;---$(MAKE) -C src/tools  </div><div class="line">&gt;---$(MAKE) -C src/main</div></pre></td></tr></table></figure></p>
<p>每增加一个目录都要在多个伪目标里面加入一行，这样不够自动化啊，于是我们想到shell的循环语 句，我们可以在每条规则的命令处使用for循环。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DIR = src  </div><div class="line">SUBDIRS = $(shell ls $(DIR))  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---@for subdir in $(SUBDIRS); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir; \                                                                                                                                             </div><div class="line">&gt;---done</div></pre></td></tr></table></figure></p>
<p>这样懒人有可以高兴很久了。不过还有问题：
上面for循环会依次进入系统命令ls列出的目录，但我们对每个目录的make顺序可能有要求，在该项目当中，main目录下的Makefile必须最后执行，因为最终的链接需要其他目录编译生成的库文件，否则会执行失败。并且在当前的Makefile中，当子目录执行make出现错误时，make不会退出。在最终执行失败的情况下，我们很难根据错误的提示定位出具体是是那个目录下的Makefile出现错误。这给问题定位造成了很大的困难。为了避免这样的问题，在命令执行错误后make退出。
所以将刚才的Makefile修改为如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DIR = src  </div><div class="line">SUBDIRS = $(shell ls $(DIR))  </div><div class="line"></div><div class="line">all :  </div><div class="line">&gt;---@for subdir in $(SUBDIRS); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir || exit 1; \                                                                                                                                             </div><div class="line">&gt;---done</div></pre></td></tr></table></figure></p>
<p>这样在执行出错时立马退出，但这样还是没有解决问题，编译错误还是会出现。那怎么解决呢？
我们可以通过增加规则来限制make执行顺序，这样就要用到伪目标，对每一个模块我们都为他写一条规则，每个模块名称是目标，最后需要执行的模块目标又是其他模块的目标，这样就限制了make顺序。在执行到最后需要执行的目标时，发现存在依赖，于是先更新依赖的目标，这样就不会出错了。并且这样的话，我们还可以对指定模块进行编译，比如我只修改了tools模块，我只想看看我修改的这个模块代码是否可以编译通过，我可以在编译时这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># make tools  </div><div class="line">make -C src/tools  </div><div class="line">make[1]: Entering directory`/home/Myprojects/example_make/version-2.1/src/tools&apos;  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/base64.o src/base64.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/md5.osrc/md5.c  </div><div class="line">cc -g -Wall -Werror -O2 -I. -I./inc-I../../include  -c -o src/tools.osrc/tools.c  </div><div class="line">ar rcs libtools.a src/base64.o src/md5.o src/tools.o  </div><div class="line">cp libtools.a ../../libs  </div><div class="line">make[1]: Leaving directory`/home/Myprojects/example_make/version-2.1/src/tools&apos;  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>还有另外一种方法也可以解决此问题，就是手动列出需要进入执行的模块名称（这里就是目录了），把最后需要执行的模块放在最后，这样for循环执行时最后需要编译链接的模块就放在最后了，不会像我们之前那样make是按照使用系统命令ls列出模块目录的顺序来执行。ls列出目录是按照每个目录的名称来排序的，我们总不能要求写代码的时候最后执行的模块的名称必须是以z开头的吧，总之不现实。
 我们的顶层Makefile又进化了，也是这一节最终Makefile：
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"># Top Makefile for C program  </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">DIR = src  </div><div class="line">MODULES = $(shell ls $(DIR))  </div><div class="line"># MODULES = ipc main tools  </div><div class="line"></div><div class="line">all : $(MODULES)  </div><div class="line"></div><div class="line">$(MODULES):  </div><div class="line">&gt;---$(MAKE) -C $(DIR)/$@  </div><div class="line"></div><div class="line">main:tools ipc  </div><div class="line"></div><div class="line">obj:  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefilefor c programs==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163\dot com&quot;  </div><div class="line">&gt;---@echo &quot;The following targets aresupport:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all              - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; obj              - just compile, withoutlink&quot;  </div><div class="line">&gt;---@echo &quot; clean            - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean        - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags             - create ctags for vimeditor&quot;  </div><div class="line">&gt;---@echo &quot; help             - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make[target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version2.0 =======================&quot;  </div><div class="line"></div><div class="line">.PHONY : all clean distclean tags help</div></pre></td></tr></table></figure></p>
<h3 id="6-参数传递、条件判断、include"><a href="#6-参数传递、条件判断、include" class="headerlink" title="6.参数传递、条件判断、include"></a>6.参数传递、条件判断、include</h3><p> 在多个Makefile嵌套调用时，有时我们需要传递一些参数给下一层Makefile。比如我们在顶层Makefile里面定义的打开调试信息变量DEBUG_SYMBOLS，我们希望在进入子目录执行子Makefile时该变量仍然有效，这是需要将该变量传递给子Makefile，那怎么传递呢？这里有两种方法：</p>
<ol>
<li><p>在上层Makefile中使用”export”关键字对需要传递的变量进行声明。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DEBUG_SYMBOLS = TRUE  </div><div class="line">export DEBUG_SYMBOLS</div></pre></td></tr></table></figure>
<p>当不希望将一个变量传递给子 make 时，可以使用指示符 “unexport”来声明这个变量。
export一般用法是在定义变量的同时对它进行声明。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export DEBUG_SYMBOLS = TRUE</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>在命令行上指定变量。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(MAKE) -C xxx DEBUG_SYMBOLS = TRUE</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样在进入子目录xxx执行make时该变量也有效。</p>
<p>像编程语言一样，Makefile也有自己的条件语句。条件语句可以根据一个变量值来控制make的执行逻辑。比较常用的条件语句是ifeq –else-endif、ifneq-else-endif、ifdef-else-endif。
ifeq关键字用来判断参数是否相等。
比如判断是否生成调试信息可以这么用：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifeq ($(DEBUG_SYMBOLS), TRUE)  </div><div class="line">&gt;---CFLAGS += -g -Wall -Werror -O0  </div><div class="line">else  </div><div class="line">&gt;---CFLAGS += -Wall -Werror -O2  </div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>Ifneq和ifeq作用相反，此关键字是用来判断参数是否不相等。
ifdef关键字用来判断一个变量是否已经定义。
后两个关键字用法和ifeq类似。</p>
<p>现在我们继续改进我们上一节的Makefile，上一节的Makefile完成Makefile的嵌套调用，每一个模块都有自己的Makefile。其实每个模块的Makefile都大同小异，只需要改改最后编译成生成的目标名称或者编译链接选项，规则都差不多，那么我们是否可以考虑将规则部分提取出来，每个模块只需修改各自变量即可。这样是可行的，我们将规则单独提取出来，写一个Makefile.rule，将他放在顶层Makefile同目录下，其他模块内部的Makefile只需要include该Makefile就可以了。如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include $(SRC_BASE)/Makefile.rule</div></pre></td></tr></table></figure></p>
<p>include类似于C语言的头文件包含，你把它理解为为本替换就什么都明白了。
这样以后规则有修改的话我们直接修改该Makefile就可以了，就不用进入每一个模块去修改，这样也便于维护。
这样我们今天顶层Makefile稍作修改：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># Top Makefile for C program                                                                                                                                                               </div><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">export DEBUG_SYMBOLS = TRUE  </div><div class="line"></div><div class="line">DIR = src  </div><div class="line">MODULES = $(shell ls $(DIR))  </div><div class="line"># MODULES = ipc main tools  </div><div class="line"></div><div class="line">all : $(MODULES)  </div><div class="line"></div><div class="line">$(MODULES):  </div><div class="line">&gt;---$(MAKE) -C $(DIR)/$@  </div><div class="line"></div><div class="line">main:tools ipc  </div><div class="line"></div><div class="line">clean :  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---@for subdir in $(MODULES); \  </div><div class="line">&gt;---do $(MAKE) -C $(DIR)/$$subdir $@; \  </div><div class="line">&gt;---done  </div><div class="line"></div><div class="line">tags:  </div><div class="line">&gt;---ctags -R  </div><div class="line"></div><div class="line">help:  </div><div class="line">&gt;---@echo &quot;===============A common Makefilefor c programs==============&quot;  </div><div class="line">&gt;---@echo &quot;Copyright (C) 2014 liuy0711 \at 163\dot com&quot;  </div><div class="line">&gt;---@echo &quot;The following targets aresupport:&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot; all              - (==make) compile and link&quot;  </div><div class="line">&gt;---@echo &quot; clean            - clean target&quot;  </div><div class="line">&gt;---@echo &quot; distclean        - clean target and otherinformation&quot;  </div><div class="line">&gt;---@echo &quot; tags             - create ctags for vimeditor&quot;  </div><div class="line">&gt;---@echo &quot; help             - print help information&quot;  </div><div class="line">&gt;---@echo  </div><div class="line">&gt;---@echo &quot;To make a target, do &apos;make[target]&apos;&quot;  </div><div class="line">&gt;---@echo &quot;========================= Version2.2 =======================&quot;  </div><div class="line"></div><div class="line">.PHONY : all clean distclean tags help</div></pre></td></tr></table></figure></p>
<p>目前我们顶层目录下的目录树为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">.  </div><div class="line">├── include  </div><div class="line">│   ├── common.h  </div><div class="line">│   ├── ipc  </div><div class="line">│   │   └── ipc.h  </div><div class="line">│   └── tools  </div><div class="line">│       ├── base64.h  </div><div class="line">│       ├── md5.h  </div><div class="line">│       └── tools.h  </div><div class="line">├── libs  </div><div class="line">├── Makefile  </div><div class="line">├── Makefile.rule  </div><div class="line">└── src  </div><div class="line">    ├── ipc  </div><div class="line">    │  ├──inc  </div><div class="line">    │  ├──Makefile  </div><div class="line">    │  └──src  </div><div class="line">    │       └── ipc.c  </div><div class="line">    ├── main  </div><div class="line">    │  ├──inc  </div><div class="line">    │  ├──Makefile  </div><div class="line">    │  └──src  </div><div class="line">    │       ├── main.c  </div><div class="line">    │       └── main.c~  </div><div class="line">    └── tools  </div><div class="line">        ├── inc  </div><div class="line">        ├── Makefile  </div><div class="line">        └── src  </div><div class="line">            ├── base64.c  </div><div class="line">            ├── md5.c  </div><div class="line">            └── tools.c  </div><div class="line"></div><div class="line">14 directories, 16 files</div></pre></td></tr></table></figure></p>
<p>每个子模块下的Makefile删除规则后修改为如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SRC_BASE = ../..  </div><div class="line"></div><div class="line">CFLAGS +=  </div><div class="line">CPPFLAGS += -I. -I./inc -I$(SRC_BASE)/include  </div><div class="line"></div><div class="line"># SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))  </div><div class="line">SRC_FILES = $(wildcard src/*.c)  </div><div class="line">SRC_OBJ = $(SRC_FILES:.c=.o)  </div><div class="line">SRC_LIB = libtools.a  </div><div class="line"></div><div class="line">include $(SRC_BASE)/Makefile.rule</div></pre></td></tr></table></figure></p>
<p>而处于顶层目录下的Makefile.rule专门处理各模块编译链接时需要的规则。内容如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># Copyright (C) 2014 shallnew \at 163 \dot com                                                                                                                                             </div><div class="line"></div><div class="line">ifeq ($(DEBUG_SYMBOLS), TRUE)  </div><div class="line">&gt;---CFLAGS += -g -Wall -Werror -O0  </div><div class="line">else  </div><div class="line">&gt;---CFLAGS += -Wall -Werror -O2  </div><div class="line">endif  </div><div class="line"></div><div class="line">all : $(SRC_BIN) $(SRC_LIB)  </div><div class="line"></div><div class="line">ifneq ($(SRC_BIN),)  </div><div class="line">$(SRC_BIN) : $(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@ $^ $(LDFLAGS)  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifneq ($(SRC_LIB),)  </div><div class="line">$(SRC_LIB) : $(SRC_OBJ)  </div><div class="line">&gt;---$(AR) rcs $@ $^  </div><div class="line">&gt;---cp $@ $(SRC_BASE)/libs  </div><div class="line">endif  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB) $(SRC_BIN)$(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM) $(SRC_OBJ) $(SRC_LIB) $(SRC_BIN)$(SRC_BIN).exe $(SRC_BASE)/libs/* $(SRC_BASE)/tags *~  </div><div class="line"></div><div class="line">.PHONY : all clean disclean  </div><div class="line">~</div></pre></td></tr></table></figure></p>
<p>我们将Makefile.rule放在顶层有可能会一不小心在命令行上面执行了该Makefile，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make -f Makefile.rule  </div><div class="line">make: Nothing tobe done for `all&apos;.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>由于我们没有定义变量<code>$(SRC_BIN)</code>和<code>$(SRC_LIB)</code>，伪目标all没有任何依赖，所以编译是无法成功的。这里我们我们应该禁止直接执行该Makefile。
在make里面有这样一个变量：MAKELEVEL，它在多级调用的 make 执行过程中。变量代表了调用的深度。在 make 一级级的执行过程中变量MAKELEVEL的值不断的发生变化，通过它的值我们可以了解当前make 递归调用的深度。顶层的MAKELEVEL的值为“0” 、下一级时为“1” 、再下一级为“2”…….，所以我们希望一个子目录的Makefile必须被上层 make 调用才可以执行，而不允许直接执行，我们可以判断变量MAKELEVEL来控制。所以我们这一节最终的Makefile.rule为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># Copyright (C)2014 shallnew \at 163 \dot com  </div><div class="line"></div><div class="line">ifeq ($(DEBUG_SYMBOLS),TRUE)  </div><div class="line">&gt;---CFLAGS +=-g -Wall -Werror -O0  </div><div class="line">else  </div><div class="line">&gt;---CFLAGS +=-Wall -Werror -O2  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifeq($(MAKELEVEL), 0)                                                                                                                                                                     </div><div class="line">all : msg  </div><div class="line">else  </div><div class="line">all : $(SRC_BIN)$(SRC_LIB)  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifneq ($(SRC_BIN),)  </div><div class="line">$(SRC_BIN) :$(SRC_OBJ)  </div><div class="line">&gt;---$(CC) -o $@$^ $(LDFLAGS)  </div><div class="line">endif  </div><div class="line"></div><div class="line">ifneq($(SRC_LIB),)  </div><div class="line">$(SRC_LIB) :$(SRC_OBJ)  </div><div class="line">&gt;---$(AR) rcs$@ $^  </div><div class="line">&gt;---cp $@$(SRC_BASE)/libs  </div><div class="line">endif  </div><div class="line"></div><div class="line">msg:  </div><div class="line">&gt;---@echo&quot;You cannot directily execute this Makefile! This Makefile should calledby toplevel Makefile.&quot;  </div><div class="line"></div><div class="line"># clean target  </div><div class="line">clean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_LIB) $(SRC_BIN) $(SRC_BIN).exe  </div><div class="line"></div><div class="line">distclean:  </div><div class="line">&gt;---$(RM)$(SRC_OBJ) $(SRC_LIB) $(SRC_BIN) $(SRC_BIN).exe $(SRC_BASE)/libs/*$(SRC_BASE)/tags *~  </div><div class="line"></div><div class="line">.PHONY : all cleandisclean</div></pre></td></tr></table></figure></p>
<p>此时再直接执行该Makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># make -f Makefile.rule  </div><div class="line">You cannot directily execute this Makefile! This Makefile should called by toplevel Makefile.  </div><div class="line">#</div></pre></td></tr></table></figure></p>
<h3 id="7-统一目标输出目录"><a href="#7-统一目标输出目录" class="headerlink" title="7. 统一目标输出目录"></a>7. 统一目标输出目录</h3><p>上一节我们把规则单独提取出来，方便了Makefile的维护，每个模块只需要给出关于自己的一些变量，然后再使用统一的规则Makefile。这一节我们继续改进我们的Makefile，到目前为止我们的Makefile编译链接输出的目标都在源文件同目录下或模块Makefile同一目录下，当一个项目大了之后，这样会显得很乱，寻找编译输出的文件也比较困难。既然Makefile本身就是按照我们的的规则来编译链接程序，那么我们就可以指定其编译链接目标的目录，这样，我们可以清楚输出文件的地方，并且在清除已编译的目标时直接删除指定目录即可，不需要一层一层的进入源代码目录进行删除，这样又提高了效率。</p>
<p>既然要统一目标输出目录，那么该目录就需要存在，所以我们可以增加一条规则来创建这些目录，包括创建可执行文件的目录、链接库文件的目录以及.o文件的目录。并且目录还可以通过条件判断根据是否产生调试信息来区分开相应的目标文件。一般一个工程的顶层目录下都会有一个build目录来存放编译的目标文件结果，目前我的工程目录下通过Makefile创建的目录build的目录树如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">build/            //build根目录  </div><div class="line">├── unix        //unix平台项目下不带调试信息输出目录  </div><div class="line">│   ├── bin    //存放可执行文件目录  </div><div class="line">│   ├── lib    //存放可文件目录  </div><div class="line">│   └── obj    //存放.o文件目录，该目录下将每个模块生成的.o文件各自的目录下面  </div><div class="line">│       ├── ipc  </div><div class="line">│       ├── main  </div><div class="line">│       └── tools  </div><div class="line">└── unix_dbg   ////unix平台项目下带调试信息输出目录  </div><div class="line">    ├── bin  </div><div class="line">    ├── lib  </div><div class="line">    └── obj  </div><div class="line">        ├── ipc  </div><div class="line">        ├── main  </div><div class="line">        └── tools  </div><div class="line"></div><div class="line">14 directories, 0 files</div><div class="line">```    </div><div class="line">以上目录中bin和lib目录在顶层Makefile中创建，obj及其下面模块子目录在各模块的Makefile里面创建。</div><div class="line">顶层Makefile创建目录如下：</div></pre></td></tr></table></figure></p>
<p>ifeq ($(DEBUG_SYMBOLS), TRUE)  </p>
<blockquote>
<p>—BUILDDIR = ./build/$(PLATFORM)_dbg<br>else<br>—BUILDDIR = ./build/$(PLATFORM)<br>endif  </p>
</blockquote>
<p>all : $(BUILDDIR) $(MODULES)  </p>
<p>$(BUILDDIR):  </p>
<blockquote>
<p>—@echo “    Create directory $@ …”<br>—mkdir -p $(BUILDDIR)/bin $(BUILDDIR)/lib<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">我们在all目标里面增加了其依赖目标BUILDDIR，该目标对应的规则为创建bin目录和lib目录。这样每次编译之前都会创建目录。</div><div class="line"></div><div class="line">各模块内部Makefile创建生成.O文件的目录，如上目录树所示。类似于顶层Makefile，各模块内部Makefile需要根据平台、编译调试信息、以及模块名称来生成需要的目录名称，然后再增加创建该目录的规则。因为每个模块都会做这些处理，所以我们将这部分写在规则Makefile(Makefile.rule)里面，如下：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>……  </p>
<h1 id="define-a-root-build-directory-base-on-the-platform"><a href="#define-a-root-build-directory-base-on-the-platform" class="headerlink" title="define a root build directory base on the platform"></a>define a root build directory base on the platform</h1><h1 id="if-without-a-SRC-BASE-defined-just-use-local-src-directory"><a href="#if-without-a-SRC-BASE-defined-just-use-local-src-directory" class="headerlink" title="if without a SRC_BASE defined, just use local src directory"></a>if without a SRC_BASE defined, just use local src directory</h1><p>ifeq ($(SRC_BASE),)  </p>
<blockquote>
<p>—BUILDDIR = $(MOD_SRC_DIR)<br>—OBJDIR = $(MOD_SRC_DIR)<br>—LIBDIR = $(MOD_SRC_DIR)<br>—BINDIR = $(MOD_SRC_DIR)<br>else<br>—ifeq ($(DEBUG_SYMBOLS), TRUE)<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)_dbg<br>—else<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)<br>—endif<br>—OBJDIR = $(BUILDDIR)/obj/$(MODULE)<br>—LIBDIR = $(BUILDDIR)/lib<br>—BINDIR = $(BUILDDIR)/bin<br>endif<br>……<br>ifeq ($(MAKELEVEL), 0)<br>all : msg<br>else<br>all : lib bin<br>endif  </p>
</blockquote>
<p>lib : $(OBJDIR) $(SRC_LIB)  </p>
<p>bin : $(OBJDIR) $(SRC_BIN)                                                                                                                         </p>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—@echo “   MKDIR $(notdir $@)…”<br>—@mkdir -p $@<br>……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">此时我们编译一下后查看build目录：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>build/<br>└── unix_dbg<br>    ├── bin<br>    ├── lib<br>    └── obj<br>        ├── ipc<br>        ├── main<br>        └── tools  </p>
<p>7 directories, 0 files<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">由于我们是开启了调试信息，所以创建了unix_dbg目录，并且该目录下创建了bin、lib、obj目录及其模块目录，但我们没有发现有文件存放在里面。</div><div class="line"></div><div class="line">到目前为止，这一节仅仅讲述如何创建统一的目标文件存放目录，但是要想将编译生成的目标文件自动生成到这些目录还没有完成。其实我们只需要给目标加上路径即可，但还是有一些详细的地方需要处理，具体的我们会在下一节中讲到，这一节暂不给出最后的Makefile。</div><div class="line"></div><div class="line">### 8. 模式规则</div><div class="line">上一节讲到目录创建成功，目标文件没有生产到对应目录下，这里我们先给目标文件加上对应目录，这样的话产生对应的目标文件会直接生成到对应目录。我们先给库文件目标和可执行文件目标加上路径，如下：</div></pre></td></tr></table></figure></p>
<p>lib : $(OBJDIR) $(LIBDIR)/$(SRC_LIB)  </p>
<p>bin : $(OBJDIR) $(BINDIR)/$(SRC_BIN)  </p>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—@echo “   MKDIR $(notdir $@)…”<br>—@mkdir -p $@  </p>
</blockquote>
<p>ifneq ($(SRC_BIN),)<br>$(BINDIR)/$(SRC_BIN) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(CC) -o $@ $^ $(LDFLAGS)<br>endif  </p>
</blockquote>
<p>ifneq ($(SRC_LIB),)<br>$(LIBDIR)/$(SRC_LIB) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(AR) rcs $@ $^<br>—cp $@ $(SRC_BASE)/libs<br>endif<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">此时再执行make，完成后查看build目录树：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>build/<br>└── unix_dbg<br>    ├── bin<br>    │   └── target_bin<br>    ├── lib<br>    │   ├── libipc.a<br>    │   └── libtools.a<br>    └── obj<br>        ├── ipc<br>        ├── main<br>        └── tools<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以看到，生成的目标是在对应目录下。我们乘胜追击，把.o文件也将其修改了。我们之前的每个模块Makefile大致是这样写的：</div></pre></td></tr></table></figure></p>
<p>SRC_BASE = ../..                                                                               </p>
<p>CFLAGS +=<br>CPPFLAGS += -I. -I./inc -I$(SRC_BASE)/include                                                  </p>
<h1 id="SRC-OBJ-patsubst-c-o-wildcard-c"><a href="#SRC-OBJ-patsubst-c-o-wildcard-c" class="headerlink" title="SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))"></a>SRC_OBJ = $(patsubst %.c, %.o, $(wildcard *.c))</h1><p>SRC_FILES = $(wildcard src/*.c)<br>SRC_OBJ = $(SRC_FILES:.c=.o)<br>SRC_LIB = xx.a                                           </p>
<p>include $(SRC_BASE)/Makefile.rule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中SRC_OBJ在此处给出，然后再在Makefile.rule中使用，此处的.o文件会在.c文件相同目录下生成，所以我们现在需要将.o文件加上路径，由于取得路径是在Makefile.rule里面，所以我们可以统一在Makefile.rule里面给变量SRC_OBJ赋值，大致如下：</div></pre></td></tr></table></figure></p>
<p>SRC_OBJ = $(patsubst %.c, $(OBJDIR)/%.o, $(notdir $(SRC_FILES)))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这里用到函数patsubst、notdir，关于函数会在后面讲到。这样.o文件作为目标生成之后就会生成到相应目录里面了。</div><div class="line">此时再编译：</div></pre></td></tr></table></figure></p>
<h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-2.9/src/ipc&#39;  
make[1]: *** No rule to make target</code>../../build/unix_dbg/obj/ipc/ipc.o’, needed by <code>../../build/unix_dbg/lib/libipc.a&#39;.  Stop.  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-2.9/src/ipc’<br>make: <em>*</em> [ipc] Error 2  </p>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">发现出错了，并且是在生成目标文件ipc.o时没有成功，查看build目录树也没有生成.o文件。为什么会生成失败呢？</div><div class="line">我们没有给出生成.o目标的规则，之前可以生成是因为make有通过隐含规则来自动推导的能力（这个之前有讲到，链接过去）。在我们没有修改之前，生成.o通过隐含规则来完成：</div></pre></td></tr></table></figure>
<p>%.o: %.c  </p>
<h1 id="commands-to-execute-built-in"><a href="#commands-to-execute-built-in" class="headerlink" title="commands to execute (built-in):"></a>commands to execute (built-in):</h1><blockquote>
<p>—$(COMPILE.c) $(OUTPUT_OPTION) $&lt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">该模式规则中目标文件是$(OBJDIR)/%.o，那么现在有了符合生成我们需要的.o文件的规则了，编译一下：</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="make-1"><a href="#make-1" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-2.9/src/ipc&#39;  
make[1]: *** No rule to make target</code>../../build/unix_dbg/obj/ipc/ipc.o’, needed by <code>../../build/unix_dbg/lib/libipc.a&#39;.  Stop.  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-2.9/src/ipc’<br>make: <em>*</em> [ipc] Error 2<br>#
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">发现还是不对，不是已经增加了模式规则了吗，为何还是没有生成.o文件。</div><div class="line">我们这里先说说静态模式规则：</div><div class="line"></div><div class="line">一个规则中可以有多个目标，规则所定义的命令对所有的目标有效。一个具有多目标的规则相当于多个规则。 规则的命令对不同的目标的执行效果不同， 因为在规则的命令中可能使用了自动化变量 `“$@”` 。 多目标规则意味着所有的目标具有相同的依赖文件。多目标通常用在以下两种情况：虽然在多目标的规则中， 可以根据不同的目标使用不同的命令 （在命令行中使用自动化变量 `“$@”` ）。但是， 多目标的规则并不能做到根据目标文件自动改变依赖文件 （像上边例子中使用自动化变量“$@”改变规则的命令一样） 。需要实现这个目的是，要用到make的静态模式。</div><div class="line"></div><div class="line">静态模式规则是这样一个规则：规则存在多个目标， 并且不同的目标可以根据目标文件的名字来自动构造出依赖文件。静态模式规则比多目标规则更通用， 它不需要多个目标具有相同的依赖。但是静态模式规则中的依赖文件必须是相类似的而不是完全相同的。静态模式规则语法如下：</div></pre></td></tr></table></figure></p>
<p><targets ...="">: <target-pattern>: <prereq-patterns ...="">    </prereq-patterns></target-pattern></targets></p>
<p><commands><br>….<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">比如下面是一个静态模式规则：</div></pre></td></tr></table></figure></commands></p>
<p>objects = foo.o bar.o  </p>
<p>all: $(objects)  </p>
<p>$(objects): %.o: %.c<br>$(CC) -c $(CFLAGS) $&lt; -o $@
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">该规则描述了所有的.o文件的依赖文件为对应的.c文件，对于目标“foo.o” ，取其茎“foo”替代对应的依赖模式“%.c”中的模式字符“%”之后可得到目标的依赖文件“foo.c”。这就是目标“foo.o”的依赖关系“foo.o: foo.c”，规则的命令行描述了如何完成由“foo.c”编译生成目标“foo.o” 。命令行中“$&lt;”和“$@”是自动化变量，“$&lt;” 表示规则中的第一个依赖文件， “$@” 表示规则中的目标文件。上边的这个规则描述了以下两个具体的规则：</div></pre></td></tr></table></figure></p>
<p>foo.o : foo.c  </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) foo.c -o foo.o<br>bar.o : bar.c<br>—$(CC) -c $(CFLAGS) bar.c -o bar.o<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">注：该示例与其相关描述摘抄于互联网，描述很不错，估计比我讲的详细）</div><div class="line"></div><div class="line">那静态模式规则和普通的模式规则（非静态模式规则）有什么去区别呢？两者都是用目标模式和依赖模式来构建目标的规则中的文件依赖关系，两者不同的地方是 make 在执行时使用它们的时机。</div><div class="line">静态模式规则只能用在规则中明确指出的那些文件的重建过程中。不能用在除此之外的任何文件的重建过程中，并且它对指定的每一个目标来说是唯一的。如果一个目标存在于两个规则，并且这两个规则都定义了命令， make 执行时就会提示错误。</div><div class="line">非静态模式规则可被用在任何和它相匹配的目标上，当一个目标文件同时符合多个目标模式时，make将会把第一个目标匹配的模式规则作为重建它的规则。</div><div class="line"></div><div class="line">那有没有想过如果我们指定了模式规则后，那还有隐含规则呢，那怎么选择执行哪一个模式规则呢？Makefile中明确指定的模式规则会覆盖隐含模式规则。就是说如果在Makefile中出现了一个对目标文件合适可用的模式规则，那么make就不会再为这个目标文件寻找其它隐含规则，而直接使用在Makefile中出现的这个规则。在使用时，明确规则永远优先于隐含规则。</div><div class="line"></div><div class="line">我们继续说之前的那个问题，我们定义了模式规则后还是没有生成.o文件，我们现在将其改为静态规则再试试就看，如下：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : %.c                                                            </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行后：</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="make-2"><a href="#make-2" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-2.9/src/ipc&#39;  
make[1]: *** No rule to make target</code>ipc.c’, needed by <code>../../build/unix_dbg/obj/ipc/ipc.o&#39;.  Stop.  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-2.9/src/ipc’<br>make: <em>*</em> [ipc] Error 2<br>#
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">发现提示没有文件ipc.c，这说明没有生成.o的原因是没有.c文件，我很好奇的是为何使用非静态模式为何不提示呢？（还没搞懂，再研究研究，知道的可以给个提示哈~~）</div><div class="line"></div><div class="line">缺少依赖文件，为何没有*.c文件，仔细想想我们的.o文件没有和.c文件在同一目录。在我们工程中，将源代码和二进制文件（.o 文件和可执行文件）安排在不同的目录来进行区分管理。这种情况下，我们可以使用 make 提供的目录搜索依赖文件功能。该功能在下一节讲述，这一节说的够多了，有点累了。可惜最终还是没有给出一个可用的Makefile，在下一节将会给出。</div><div class="line"></div><div class="line">### 9. 目标搜索</div><div class="line">在一个较大的工程中，一般会将源代码和二进制文件（.o 文件和可执行文件）安排在不同的目录来进行区分管理。这种情况下，我们可以使用 make 提供的目录搜索依赖文件功能（在指定的若干个目录下自动搜索依赖文件）。在Makefile中，使用依赖文件的目录搜索功能。当工程的目录结构发生变化后，就可以做到不更改 Makefile的规则，只更改依赖文件的搜索目录。</div><div class="line"></div><div class="line">在我们上一节出现的问题当中，我们将.c文件统一放在src目录下，没有和Makefile目录在同一目录下，因此没有办法寻找到.o文件的依赖文件。make程序有一个特殊的变量VPATH，该变量可以指定依赖文件的搜索路径，当规则的依赖文件在当前目录不存在时，make 会在此变量所指定的目录下去寻找这些依赖文件。通常我们都是用此变量来指定规则的依赖文件的搜索路径。</div><div class="line">定义变量 “VPATH”时，使用空格或者冒号（:）将多个需要搜索的目录分开。make搜索目录的顺序是按照变量“VPATH”定义中的目录顺序进行的，当前目录永远是第一搜索目录。例如如下定义</div></pre></td></tr></table></figure></p>
<p>VPATH += ./src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">指定了依赖搜索目录为当前目录下的src目录，我们可以在Makefile.rules里面添加给VPATH变量赋值，而在包含该Makefile.rules之前给出当前模块.c文件所在目录。</div><div class="line"></div><div class="line">其实我们也可以直接指定依赖文件的路径，这样也是可以的，如下：</div></pre></td></tr></table></figure></p>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : $(MOD_SRC_DIR)/%.c                             </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是这样在我们更改了工程目录结构之后，对应的依赖文件没有在同一目录下，又变得麻烦了，所以还不如直接给VPATH变量赋值，我们只需要指定源码所在的目录即可。</div><div class="line"></div><div class="line">其实我们还有另外一种搜索文件路径方法：使用vpath关键字（注意不是VPATH变量）， 它和VPATH类似，但是它可以为不同类型的文件（由文件名区分）指定不同的搜索目录。使用方法有三种：</div><div class="line">1. vpath PATTERN DIRECTORIES</div><div class="line">为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES” 。多个目录使用空格或者冒号（：）分开。</div><div class="line">2. vpath PATTERN</div><div class="line">清除之前为符合模式“PATTERN”的文件设置的搜索路径。</div><div class="line">3. vpath</div><div class="line">清除所有已被设置的文件搜索路径。</div><div class="line"></div><div class="line">vapth 使用方法中的“PATTERN”需要包含模式字符“%”；例如上面的定义：</div></pre></td></tr></table></figure></p>
</blockquote>
<p>VPATH += ./src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以写为：</div></pre></td></tr></table></figure></p>
<p>vpath %.c ./src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在给一个我们的Makefile.rules：</div></pre></td></tr></table></figure></p>
<h1 id="Copyright-C-2014-shallnew-at-163-dot-com"><a href="#Copyright-C-2014-shallnew-at-163-dot-com" class="headerlink" title="Copyright (C) 2014 shallnew \at 163 \dot com"></a>Copyright (C) 2014 shallnew \at 163 \dot com</h1><h1 id="if-without-a-platform-defined-give-value-“unknow”-to-PLATFORM"><a href="#if-without-a-platform-defined-give-value-“unknow”-to-PLATFORM" class="headerlink" title="if without a platform defined, give value “unknow” to PLATFORM"></a>if without a platform defined, give value “unknow” to PLATFORM</h1><p>ifndef PLATFORM  </p>
<blockquote>
<p>—PLATFORM = unknow<br>endif  </p>
</blockquote>
<h1 id="define-a-root-build-directory-base-on-the-platform-1"><a href="#define-a-root-build-directory-base-on-the-platform-1" class="headerlink" title="define a root build directory base on the platform"></a>define a root build directory base on the platform</h1><h1 id="if-without-a-SRC-BASE-defined-just-use-local-src-directory-1"><a href="#if-without-a-SRC-BASE-defined-just-use-local-src-directory-1" class="headerlink" title="if without a SRC_BASE defined, just use local src directory"></a>if without a SRC_BASE defined, just use local src directory</h1><p>ifeq ($(SRC_BASE),)  </p>
<blockquote>
<p>—BUILDDIR = $(MOD_SRC_DIR)<br>—OBJDIR = $(MOD_SRC_DIR)<br>—LIBDIR = $(MOD_SRC_DIR)<br>—BINDIR = $(MOD_SRC_DIR)<br>else<br>—ifeq ($(DEBUG_SYMBOLS), TRUE)<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)_dbg<br>—else<br>—&gt;—BUILDDIR = $(SRC_BASE)/build/$(PLATFORM)<br>—endif<br>—OBJDIR = $(BUILDDIR)/obj/$(MODULE)<br>—LIBDIR = $(BUILDDIR)/lib<br>—BINDIR = $(BUILDDIR)/bin<br>endif  </p>
</blockquote>
<h1 id="update-compilation-flags-base-on-“DEBUG-SYMBOLS”"><a href="#update-compilation-flags-base-on-“DEBUG-SYMBOLS”" class="headerlink" title="update compilation flags base on “DEBUG_SYMBOLS”"></a>update compilation flags base on “DEBUG_SYMBOLS”</h1><p>ifeq ($(DEBUG_SYMBOLS), TRUE)  </p>
<blockquote>
<p>—CFLAGS += -g -Wall -Werror -O0<br>else<br>—CFLAGS += -Wall -Werror -O2<br>endif  </p>
</blockquote>
<p>VPATH += $(MOD_SRC_DIR)  </p>
<p>SRC_OBJ = $(patsubst %.c, $(OBJDIR)/%.o, $(notdir $(SRC_FILES)))  </p>
<p>ifeq ($(MAKELEVEL), 0)<br>all : msg<br>else<br>all : lib bin<br>endif  </p>
<p>lib : $(OBJDIR) $(LIBDIR)/$(SRC_LIB)  </p>
<p>bin : $(OBJDIR) $(BINDIR)/$(SRC_BIN)  </p>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—mkdir -p $@  </p>
</blockquote>
<p>ifneq ($(SRC_BIN),)<br>$(BINDIR)/$(SRC_BIN) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(CC) -o $@ $^ $(LDFLAGS)<br>endif  </p>
</blockquote>
<p>ifneq ($(SRC_LIB),)<br>$(LIBDIR)/$(SRC_LIB) : $(SRC_OBJ)  </p>
<blockquote>
<p>—$(AR) rcs $@ $^<br>—cp $@ $(SRC_BASE)/libs<br>endif  </p>
</blockquote>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : %.c  </p>
<blockquote>
<p>—$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@  </p>
</blockquote>
<p>msg:  </p>
<blockquote>
<p>—@echo “You cannot directily execute this Makefile! This Makefile should called by toplevel Makefile.”  </p>
</blockquote>
<h1 id="clean-target"><a href="#clean-target" class="headerlink" title="clean target"></a>clean target</h1><p>clean:<br>ifneq ($(SRC_LIB),)  </p>
<blockquote>
<p>—&gt;—$(RM) $(SRC_OBJ) $(LIBDIR)/$(SRC_LIB)<br>endif<br>ifneq ($(SRC_BIN),)<br>—&gt;—$(RM) $(SRC_OBJ) $(BINDIR)/$(SRC_BIN)<br>endif  </p>
</blockquote>
<p>.PHONY : all clean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 10. make内嵌函数及make命令显示</div><div class="line">这一节我们讲一下make的函数，在之前的章节已经讲到了几个函数：wildcard、patsubst、notdir、shell等。一般函数的调用格式如下：</div><div class="line">`$(funcname arguments)`</div><div class="line">或</div><div class="line">`$(funcname arguments)`</div><div class="line">其中funcname是需要调用函数的函数名称，应该是make内嵌函数；arguments是函数参数，参数和函数名之间使用空格分割，如果存在多个参数时，参数之间使用逗号“,”分开。函数调用以“$”开头，使用成对的圆括号或花括号把函数名和参数括起，一般使用圆括号。</div><div class="line">下面来看一下常用的一些函数：</div><div class="line"></div><div class="line">1.    获取匹配模式文件名函数—wildcard 。</div><div class="line">用法：`$(wildcard PATTERN)`</div><div class="line">该函数会列出当前目录下所有符合模式“PATTERN”格式的文件名。返回空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名。</div><div class="line">例如：</div></pre></td></tr></table></figure></p>
<p>SRC_FILES = $(wildcard src/*.c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">返回src目录下所有.c文件列表。</div><div class="line">2.    字符串替换函数—subst。</div><div class="line">用法：`$(subst FROM,TO,TEXT)`</div><div class="line">该函数把字串“TEXT”中的“FROM”字符替换为“TO”，返回替换后的新字符串。</div><div class="line">3.    模式替换函数—patsubst。</div><div class="line">用法：`$(patsubst PATTERN,REPLACEMENT,TEXT)`</div><div class="line">该函数搜索“TEXT”中以空格分开的单词，将符合模式“TATTERN”替换为“REPLACEMENT” 。参数“PATTERN”中可以使用模式通配符“%”，来代表一个单词中的若干字符。如果参数“REPLACEMENT”中也包含一个“%” ，那么“REPLACEMENT”中的“%”将是“TATTERN”中的那个“%”所代表的字符串。</div><div class="line">例如：</div></pre></td></tr></table></figure></p>
<p>SRC_OBJ = $(patsubst %.c, %.o, $(SRC_FILES))
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">将SRC_FILES中所有.c文件替换为.o返回给变量SRC_OBJ。</div><div class="line">此函数功能类似之前讲过的变量替换，http://blog.csdn.net/shallnet/article/details/37529935</div><div class="line">变量替换格式是“$(var:a=b)”或“$&#123;var:a=b&#125;”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。</div><div class="line">例如我们存在一个代表所有.c 文件的变量。定义为“src_files = a.c b.c c.c” 。</div><div class="line">为了得到这些.c文件所对应的.o源文件。如下两种使用可以得到同一种结果：</div></pre></td></tr></table></figure></p>
<p>$(objects:.c=.o)<br>$(patsubst %.c,%.o,$( src_files))
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">4.    过滤函数—filter。</div><div class="line">用法：$(filter PATTERN…,TEXT)</div><div class="line">该函数过滤掉字串“TEXT”中所有不符合模式“PATTERN”的单词，保留所有符合此模式的单词。可以使用多个模式。模式中一般需要包含模式字符“%” 。存在多个模式时，模式表达式之间使用空格分割。返回空格分割的“TEXT”字串中所有符合模式“PATTERN”的字串。</div><div class="line">5.    反过滤函数—filter-out。</div><div class="line">用法：`$(filter-out PATTERN...,TEXT)`</div><div class="line">和“filter”函数实现的功能相反。过滤掉字串“TEXT”中所有符合模式“PATTERN” 的单词， 保留所有不符合此模式的单词。 可以有多个模式。存在多个模式时，模式表达式之间使用空格分割。</div><div class="line">6.    取目录函数—dir。</div><div class="line">用法：`$(dir NAMES…)`</div><div class="line">从文件名序列“NAMES…”中取出各个文件名的目录部分。文件名的目录部分就是包含在文件名中的最后一个斜线`（ “/” ）` （包括斜线）之前的部分。返回空格分割的文件名序列“NAMES…”中每一个文件的目录部分。如果文件名中没有斜线，认为此文件为当前目录`（ “./” ）`下的文件。</div><div class="line">7.    取文件名函数——notdir。</div><div class="line">用法：`$(notdir NAMES…)`</div><div class="line">从文件名序列“NAMES…”中取出非目录部分。目录部分是指最后一个斜线`（ “/” ）` （包括斜线）之前的部分。删除所有文件名中的目录部分，只保留非目录部分。文件名序列“NAMES…”中每一个文件的非目录部分。</div><div class="line">8.    取后缀函数—suffix。</div><div class="line">用法：`$(suffix NAMES…) `</div><div class="line">函数从文件名序列“NAMES…”中取出各个文件名的后缀。后缀是文件名中最后一个以点“.”开始的（包含点号）部分，如果文件名中不包含一个点号，则为空。 返回以空格分割的文件名序列“NAMES…”中每一个文件的后缀序列。</div><div class="line">9.    取前缀函数—basename。</div><div class="line">用法：`$(basename NAMES…)`</div><div class="line">从文件名序列“NAMES…”中取出各个文件名的前缀部分（点号之后的部分） 。前缀部分指的是文件名中最后一个点号之前的部分。 返回空格分割的文件名序列“NAMES…”中各个文件的前缀序列。如果文件没有前缀，则返回空字串。</div><div class="line"></div><div class="line">这里仅仅讲到一些常用的函数，还有一些函数没有讲到，用到的时候可以去翻翻makefile手册。</div><div class="line"></div><div class="line">通常情况下make在编译时会打印出当前正在执行的命令，当编译链接选项很长时，会输出很多东西在屏幕上，如果我 不想再屏幕上看到很多东西，我们可以在命令前面加上@，这样命令就不会输出到屏幕了。我们这样尝试修改下：</div></pre></td></tr></table></figure></p>
<h1 id="make-3"><a href="#make-3" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/ipc&#39;  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/ipc’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/tools&#39;  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/tools’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/main&#39;  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/main’  </p>
<h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">发现只有进入目录和退出目录的显示，这样很难知道目前编译过程。其实我们可以在规则命令处加入一行类似打印：</div><div class="line">`@echo &quot;do something......&quot;`</div><div class="line">这样可以输出目前正在做的事，又不会输出正在执行命令。现在将规则修改下如下：</div></pre></td></tr></table></figure>
<p>$(OBJDIR) :  </p>
<blockquote>
<p>—@echo “   MKDIR $(notdir $@)…”<br>—@mkdir -p $@  </p>
</blockquote>
<p>ifneq ($(SRC_BIN),)<br>$(BINDIR)/$(SRC_BIN) : $(SRC_OBJ)  </p>
<blockquote>
<p>—@echo “   LINK $(notdir $@)…”<br>—@$(CC) -o $@ $^ $(LDFLAGS)<br>endif  </p>
</blockquote>
<p>ifneq ($(SRC_LIB),)<br>$(LIBDIR)/$(SRC_LIB) : $(SRC_OBJ)  </p>
<blockquote>
<p>—@echo “    ARCHIVE $(notdir $@)…”<br>—@$(AR) rcs $@ $^<br>—@echo “    COPY $@ to $(SRC_BASE)/libs”<br>—@cp $@ $(SRC_BASE)/libs<br>endif  </p>
</blockquote>
<p>$(SRC_OBJ) : $(OBJDIR)/%.o : %.c  </p>
<blockquote>
<p>—@echo “    COMPILE $(notdir $&lt;)…”<br>—@$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">编译输出如下：</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="make-4"><a href="#make-4" class="headerlink" title="make"></a>make</h1><p>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/ipc&#39;  
    COMPILE ipc.c...  
    ARCHIVE libipc.a...  
    COPY ../../build/unix_dbg/lib/libipc.a to ../../libs  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/ipc’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/tools&#39;  
    COMPILE base64.c...  
    COMPILE md5.c...  
    COMPILE tools.c...  
    ARCHIVE libtools.a...  
    COPY ../../build/unix_dbg/lib/libtools.a to ../../libs  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/tools’<br>make[1]: Entering directory <code>/home/Myprojects/example_make/version-3.1/src/main&#39;  
    COMPILE main.c...  
   LINK target_bin...  
make[1]: Leaving directory</code>/home/Myprojects/example_make/version-3.1/src/main’  </p>
<h1 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">其中目录切换的输出仍然很多，我们可以将其关闭，这需要使用到make的参数，在make -C是指定--no-print-</div><div class="line">directory参数。我们将顶层目录下Makefile规则修改如下：</div></pre></td></tr></table></figure>
<p>$(BUILDDIR):  </p>
<blockquote>
<p>—@echo “    Create directory $@ …”<br>—mkdir -p $(BUILDDIR)/bin $(BUILDDIR)/lib  </p>
</blockquote>
<p>$(MODULES):  </p>
<blockquote>
<p>—@$(MAKE) -C $(DIR)/$@ MODULE=$@ –no-print-directory  </p>
</blockquote>
<p>main:tools ipc  </p>
<p>clean :  </p>
<blockquote>
<p>—@for subdir in $(MODULES); \<br>—do $(MAKE) -C $(DIR)/$$subdir MODULE=$$subdir $@ –no-print-directory; \<br>—done<br>编译输出：  </p>
<h1 id="make-5"><a href="#make-5" class="headerlink" title="make"></a>make</h1><pre><code>COMPILE ipc.c...  
ARCHIVE libipc.a...  
COPY ../../build/unix_dbg/lib/libipc.a to ../../libs  
COMPILE base64.c...  
COMPILE md5.c...  
COMPILE tools.c...  
ARCHIVE libtools.a...  
COPY ../../build/unix_dbg/lib/libtools.a to ../../libs  
COMPILE main.c...  
</code></pre><p>   LINK target_bin…  </p>
<h1 id="make-clean"><a href="#make-clean" class="headerlink" title="make clean"></a>make clean</h1><p>rm -f  ../../build/unix_dbg/obj/ipc/ipc.o ../../build/unix_dbg/lib/libipc.a<br>rm -f  ../../build/unix_dbg/obj/main/main.o ../../build/unix_dbg/bin/target_bin<br>rm -f  ../../build/unix_dbg/obj/tools/base64.o  ../../build/unix_dbg/obj/tools/md5.o<br>../../build/unix_dbg/obj/tools/tools.o ../../build/unix_dbg/lib/libtools.a  </p>
</blockquote>
<p>#
```
这样看上去输出清爽多了。其实我们也可以使用make -s 来全面禁止命令的显示。</p>
<blockquote>
<p>【版权声明：转载请保留出处：<a href="http://blog.csdn.net/shallnet/article/details/37358655】" target="_blank" rel="external">http://blog.csdn.net/shallnet/article/details/37358655】</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-基本规则&quot;&gt;&lt;a href=&quot;#1-基本规则&quot; class=&quot;headerlink&quot; title=&quot;1. 基本规则&quot;&gt;&lt;/a&gt;1. 基本规则&lt;/h3&gt;&lt;p&gt;一般一个稍大的linux项目会有很多个源文件组成，最终的可执行程序也是由这许多个源文件编译链接而成的。编
    
    </summary>
    
      <category term="makefile" scheme="http://wodekouwei.com/categories/makefile/"/>
    
    
      <category term="makefile" scheme="http://wodekouwei.com/tags/makefile/"/>
    
      <category term="course" scheme="http://wodekouwei.com/tags/course/"/>
    
  </entry>
  
</feed>
