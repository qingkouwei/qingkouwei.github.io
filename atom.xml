<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老司机种菜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wodekouwei.com/"/>
  <updated>2017-04-16T14:07:31.000Z</updated>
  <id>http://wodekouwei.com/</id>
  
  <author>
    <name>轻口味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MarkDown中嵌入LaTex</title>
    <link href="http://wodekouwei.com/2017/04/16/latex/"/>
    <id>http://wodekouwei.com/2017/04/16/latex/</id>
    <published>2017-04-16T09:17:15.000Z</published>
    <updated>2017-04-16T14:07:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>MarkDown中使用标识符<code>$$</code>和<code>$$$$</code>即可引入LaTeX语法,前者使用时不换行,即在所使用位置使用LaTeX的格式,后者会换行后居中</p>
<h3 id="部分希腊字母"><a href="#部分希腊字母" class="headerlink" title="部分希腊字母"></a>部分希腊字母</h3><table>
<thead>
<tr>
<th>命令</th>
<th>显示</th>
<th></th>
<th>命令</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td>\alpha</td>
<td>α</td>
<td></td>
<td>A</td>
<td>A</td>
</tr>
<tr>
<td>\beta</td>
<td>β</td>
<td></td>
<td>B</td>
<td>B</td>
</tr>
<tr>
<td>\gamma</td>
<td>γ</td>
<td></td>
<td>\Gamma \varGamma</td>
<td>Γ  Γ</td>
</tr>
<tr>
<td>delta</td>
<td>δ</td>
<td></td>
<td>\Delta \varDelta</td>
<td>Δ  Δ</td>
</tr>
<tr>
<td>\epsilon</td>
<td>ϵ</td>
<td></td>
<td>E</td>
<td>E</td>
</tr>
<tr>
<td>\eta</td>
<td>η</td>
<td></td>
<td>H</td>
<td>H</td>
</tr>
<tr>
<td>\theta</td>
<td>θ</td>
<td></td>
<td>\Theta \varTheta</td>
<td>Θ  Θ</td>
</tr>
<tr>
<td>\kappa</td>
<td>κ</td>
<td></td>
<td>K</td>
<td>K</td>
</tr>
<tr>
<td>\lambda</td>
<td>λ</td>
<td></td>
<td>\Lambda \varLambda</td>
<td>Λ  Λ</td>
</tr>
<tr>
<td>\mu</td>
<td>μ</td>
<td></td>
<td>M</td>
<td>M</td>
</tr>
<tr>
<td>\nu</td>
<td>ν</td>
<td></td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>\pi</td>
<td>π</td>
<td></td>
<td>\Pi \varPi</td>
<td>Π  Π</td>
</tr>
<tr>
<td>\rho</td>
<td>ρ</td>
<td></td>
<td>P</td>
<td>P</td>
</tr>
<tr>
<td>\sigma</td>
<td>σ</td>
<td></td>
<td>\Sigma \varSigma</td>
<td>Σ  Σ</td>
</tr>
<tr>
<td>\tau</td>
<td>τ</td>
<td></td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>\phi \varphi</td>
<td>ϕ  φ</td>
<td></td>
<td>\Phi \varPhi</td>
<td>Φ  Φ</td>
</tr>
<tr>
<td>\omega</td>
<td>ω</td>
<td></td>
<td>\Omega \varOmega</td>
<td>Ω  Ω</td>
</tr>
</tbody>
</table>
<h3 id="部分运算符"><a href="#部分运算符" class="headerlink" title="部分运算符"></a>部分运算符</h3><table>
<thead>
<tr>
<th>命令</th>
<th>显示</th>
<th></th>
<th>命令</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td>\pm</td>
<td>±</td>
<td></td>
<td>\mp</td>
<td>∓</td>
</tr>
<tr>
<td>\times</td>
<td>×</td>
<td></td>
<td>\div</td>
<td>÷</td>
</tr>
<tr>
<td>\circ</td>
<td>∘</td>
<td></td>
<td>\bullet</td>
<td>∙</td>
</tr>
<tr>
<td>\cdot</td>
<td>⋅</td>
<td></td>
<td>\cup</td>
<td>∪</td>
</tr>
<tr>
<td>\cap</td>
<td>∩</td>
<td></td>
<td>\subset</td>
<td>⊂</td>
</tr>
<tr>
<td>\supset</td>
<td>⊃</td>
<td></td>
<td>\subseteq</td>
<td>⊆</td>
</tr>
<tr>
<td>\supseteq</td>
<td>⊇</td>
<td></td>
<td>\leq</td>
<td>≤</td>
</tr>
<tr>
<td>\geq</td>
<td>≥</td>
<td></td>
<td>\propto</td>
<td>∝</td>
</tr>
</tbody>
</table>
<h3 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h3><table>
<thead>
<tr>
<th>命令</th>
<th>显示</th>
<th></th>
<th>命令</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td>\cdotp</td>
<td>⋅</td>
<td></td>
<td>\cdots</td>
<td>⋯</td>
</tr>
<tr>
<td>\ddots</td>
<td>⋱</td>
<td></td>
<td>\infty</td>
<td>∞</td>
</tr>
<tr>
<td>\partial</td>
<td>∂</td>
<td></td>
<td>\bot</td>
<td>⊥</td>
</tr>
<tr>
<td>\hat{a}</td>
<td>â</td>
<td></td>
<td>\tilde{a}</td>
<td>ã</td>
</tr>
<tr>
<td>\bar{a}</td>
<td>a¯</td>
<td></td>
<td>\vec{a}</td>
<td>a⃗</td>
</tr>
<tr>
<td>\dot{a}</td>
<td>a˙</td>
<td></td>
<td>\sqrt{a}</td>
<td>a‾‾√</td>
</tr>
<tr>
<td>\sqrt[3]{2}</td>
<td>a‾‾√3</td>
<td></td>
<td>a^{3}</td>
<td>a3</td>
</tr>
<tr>
<td>\frac{1}{a}</td>
<td>1a</td>
<td></td>
<td>\lim_{x \to 0}</td>
<td>lima→0</td>
</tr>
</tbody>
</table>
<h3 id="集合关系符号"><a href="#集合关系符号" class="headerlink" title="集合关系符号"></a>集合关系符号</h3><table>
<thead>
<tr>
<th>说明</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>集合的大括号</td>
<td>{ …   }\</td>
</tr>
<tr>
<td>集合中的竖线</td>
<td>\mid</td>
</tr>
<tr>
<td>属于</td>
<td>\in</td>
</tr>
<tr>
<td>不属于</td>
<td>\not\in</td>
</tr>
<tr>
<td>A包含于B</td>
<td>A\subset B</td>
</tr>
<tr>
<td>A真包含于B</td>
<td>A\subsetneqq B</td>
</tr>
<tr>
<td>A包含B</td>
<td>A\supset B</td>
</tr>
<tr>
<td>A真包含B</td>
<td>A\supsetneqq B</td>
</tr>
<tr>
<td>A不包含于B</td>
<td>A\not\subset B</td>
</tr>
<tr>
<td>A交B</td>
<td>A\cap B</td>
</tr>
<tr>
<td>A并B</td>
<td>A\cup B</td>
</tr>
<tr>
<td>A的闭包</td>
<td>\overline{A}</td>
</tr>
<tr>
<td>A减去B</td>
<td>A\setminus B</td>
</tr>
<tr>
<td>实数集合</td>
<td>\mathbb{R}</td>
</tr>
<tr>
<td>空集</td>
<td>\emptyset</td>
</tr>
</tbody>
</table>
<blockquote>
<p>表格中竖线用<code>&amp;#124;</code></p>
</blockquote>
<h3 id="括号总结"><a href="#括号总结" class="headerlink" title="括号总结"></a>括号总结</h3><table>
<thead>
<tr>
<th>功能</th>
<th>语法</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td>不好看</td>
<td><code>( \frac{1}{2} )</code></td>
<td>$(\frac{1}{2})$</td>
</tr>
<tr>
<td>好一点</td>
<td><code>\left( \frac{1}{2} \right)</code></td>
<td>$\left ( \frac{1}{2} \right )$</td>
</tr>
</tbody>
</table>
<p>可以使用<code>\left</code>和<code>\right</code>来显示不同的括号：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>语法</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td>圆括号，小括号</td>
<td><code>\left( \frac{a}{b} \right)</code></td>
<td>$\left( \frac{a}{b} \right)$</td>
</tr>
<tr>
<td>方括号，中括号</td>
<td>\left[ \frac{a}{b} \right]</td>
<td>$\left[ \frac{a}{b} \right]$</td>
</tr>
<tr>
<td>花括号，大括号</td>
<td><code>\left\{ \frac{a}{b} \right\}</code></td>
<td>$    \left{ \frac{a}{b} \right}$</td>
</tr>
<tr>
<td>角括号</td>
<td><code>\left \langle \frac{a}{b} \right \rangle</code></td>
<td>$\left\langle \frac{a}{b} \right \rangle$</td>
</tr>
<tr>
<td>单竖线，绝对值</td>
<td>\left 竖线 \frac{a}{b} \right 竖线</td>
<td></td>
</tr>
<tr>
<td>双竖线，范</td>
<td>\left \ 竖线 \frac{a}{b} \right \ 竖线</td>
<td></td>
</tr>
<tr>
<td>取整函数</td>
<td><code>（Floor function）    \left \lfloor \frac{a}{b} \right \rfloor</code></td>
<td>$    \left \lfloor \frac{a}{b} \right \rfloor$</td>
</tr>
<tr>
<td>取顶函数</td>
<td><code>（Ceiling function)    \left \lceil \frac{c}{d} \right \rceil</code></td>
<td>$    \left \lceil \frac{c}{d} \right \rceil$</td>
</tr>
<tr>
<td>斜线与反斜线</td>
<td><code>\left / \frac{a}{b} \right \backslash</code></td>
<td>$    \left / \frac{a}{b} \right \backslash$</td>
</tr>
<tr>
<td>上下箭头</td>
<td><code>\left \uparrow \frac{a}{b} \right \downarrow</code> <code>\left \Uparrow \frac{a}{b} \right \Downarrow</code> <code>\left \updownarrow \frac{a}{b} \right \Updownarrow</code></td>
<td>$\left \uparrow \frac{a}{b} \right \downarrow$ $\left \Uparrow \frac{a}{b} \right \Downarrow$ $\left \updownarrow \frac{a}{b} \right \Updownarrow$</td>
</tr>
<tr>
<td>混合括号</td>
<td><code>\left [ 0,1 \right )</code> <code>\left \langle \psi )</code></td>
<td>$\left [ 0,1 \right )$ $ \left \langle \psi \right)$</td>
</tr>
<tr>
<td>单左括号</td>
<td><code>\left \{ \frac{a}{b} \right .</code></td>
<td>$\left { \frac{a}{b} \right .$</td>
</tr>
<tr>
<td>单右括号</td>
<td><code>\left . \frac{a}{b} \right \}</code></td>
<td>$\left . \frac{a}{b} \right }$</td>
</tr>
</tbody>
</table>
<p>备注：
可以使用<code>\big, \Big, \bigg, \Bigg</code>控制括号的大小，比如代码<code>\Bigg ( \bigg [ \Big \{ \big \langle \left | \| \frac{a}{b} \| \right | \big \rangle \Big \} \bigg ] \Bigg )</code>显示</p>
<p>$$\Bigg ( \bigg [ \Big { \big \langle \left | | x | \right | \big \rangle \Big } \bigg ] \Bigg )$$</p>
<h2 id="矩阵和表达式"><a href="#矩阵和表达式" class="headerlink" title="矩阵和表达式"></a>矩阵和表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\left[ \begin&#123;matrix&#125;</div><div class="line">	b_&#123;1&#125;&amp;c_&#123;1&#125;&amp; &amp; &amp; &amp;0 \\</div><div class="line">	a_&#123;2&#125;&amp;b_&#123;2&#125;&amp;c_&#123;2&#125;&amp; &amp; &amp; \\</div><div class="line">	 &amp;a_&#123;3&#125;&amp;b_&#123;3&#125;&amp;\ddots&amp; &amp;  \\</div><div class="line">	 &amp; &amp;\ddots&amp;\ddots&amp;c_&#123;n-1&#125; &amp; \\</div><div class="line">	0&amp; &amp; &amp; &amp;a_&#123;n&#125;&amp;b_&#123;n&#125;</div><div class="line">\end&#123;matrix&#125;\right]</div><div class="line">\left[ \begin&#123;matrix&#125;</div><div class="line">	x_&#123;1&#125; \\</div><div class="line">	x_&#123;2&#125; \\</div><div class="line">	x_&#123;3&#125; \\</div><div class="line">	\vdots\\</div><div class="line">	x_&#123;n&#125;</div><div class="line">\end&#123;matrix&#125;\right]  =</div><div class="line">\left[ \begin&#123;matrix&#125;</div><div class="line">	d_&#123;1&#125; \\</div><div class="line">	d_&#123;2&#125; \\</div><div class="line">	d_&#123;3&#125; \\</div><div class="line">	\vdots\\</div><div class="line">	d_&#123;n&#125;</div><div class="line">\end&#123;matrix&#125;\right]</div><div class="line">\tag&#123;2&#125;</div><div class="line">$$</div><div class="line"></div><div class="line">$$ c&apos;_i =</div><div class="line">\begin&#123;cases&#125;</div><div class="line">\begin&#123;array&#125;&#123;lcl&#125;</div><div class="line">  \cfrac&#123;c_i&#125;&#123;b_i&#125;                   &amp; &amp; ; i = 1 \\</div><div class="line">  \cfrac&#123;c_i&#125;&#123;b_i - a_i c&apos;_&#123;i - 1&#125;&#125;  &amp; &amp; ; i = 2, 3, \dots, n-1 \\</div><div class="line">\end&#123;array&#125;</div><div class="line">\end&#123;cases&#125;</div><div class="line">\tag&#123;3&#125;$$</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$
\left[ \begin{matrix}
    b<em>{1}&amp;c</em>{1}&amp; &amp; &amp; &amp;0 \
    a<em>{2}&amp;b</em>{2}&amp;c<em>{2}&amp; &amp; &amp; \
     &amp;a</em>{3}&amp;b<em>{3}&amp;\ddots&amp; &amp;  \
     &amp; &amp;\ddots&amp;\ddots&amp;c</em>{n-1} &amp; \
    0&amp; &amp; &amp; &amp;a<em>{n}&amp;b</em>{n}
\end{matrix}\right]
\left[ \begin{matrix}
    x<em>{1} \
    x</em>{2} \
    x<em>{3} \
    \vdots\
    x</em>{n}
\end{matrix}\right]  =
\left[ \begin{matrix}
    d<em>{1} \
    d</em>{2} \
    d<em>{3} \
    \vdots\
    d</em>{n}
\end{matrix}\right]
\tag{2}
$$</p>
<p>$$ c’_i =
\begin{cases}
\begin{array}{lcl}
  \cfrac{c_i}{b_i}                   &amp; &amp; ; i = 1 \
  \cfrac{c_i}{b_i - a<em>i c’</em>{i - 1}}  &amp; &amp; ; i = 2, 3, \dots, n-1 \
\end{array}
\end{cases}
\tag{3}$$
$$</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MarkDown中使用标识符&lt;code&gt;$$&lt;/code&gt;和&lt;code&gt;$$$$&lt;/code&gt;即可引入LaTeX语法,前者使用时不换行,即在所使用位置使用LaTeX的格式,后者会换行后居中&lt;/p&gt;
&lt;h3 id=&quot;部分希腊字母&quot;&gt;&lt;a href=&quot;#部分希腊字母&quot; clas
    
    </summary>
    
      <category term="工具" scheme="http://wodekouwei.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://wodekouwei.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="MarkDown" scheme="http://wodekouwei.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>高数1.函数与极限</title>
    <link href="http://wodekouwei.com/2017/04/13/am-function-and-limitaion/"/>
    <id>http://wodekouwei.com/2017/04/13/am-function-and-limitaion/</id>
    <published>2017-04-13T14:34:04.000Z</published>
    <updated>2017-04-16T05:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-映射与函数"><a href="#1-映射与函数" class="headerlink" title="1.映射与函数"></a>1.映射与函数</h2><h3 id="1-1-集合"><a href="#1-1-集合" class="headerlink" title="1.1 集合"></a>1.1 集合</h3><h4 id="1-1-1-集合的概念"><a href="#1-1-1-集合的概念" class="headerlink" title="1.1.1 集合的概念"></a>1.1.1 集合的概念</h4><p>集合(集)是指具有某种特定性质的事物的总体,组成这个集合的事物成为该集合的元素(简称元)</p>
<p>表示:用大写拉丁字母A,B,C…表示集合,小写拉丁字母表示集合的元素</p>
<p>分类:</p>
<ul>
<li>有限集</li>
<li>无限集</li>
</ul>
<p>表示数集的字母的右上角标<code>*</code>表示该数集内排除0的集,标上<code>+</code>来表示数集内排除0和负数的集</p>
<p>常用表示</p>
<ol>
<li>N={0, 1, 2, 3…};全体非负整数即自然数的集合</li>
<li>N<sup>+</sup>={1,2,3,…n,….};全体正整数的集合</li>
<li>Z={…,-n,…-3, -2,-1, 0, 1, 2, 3,…,n…};全体整数的集合</li>
<li>$Q=\lbrace \frac{p}{q}|p \in Z,q \in N^{+} \rbrace$;全体有理数集</li>
</ol>
<p>全体实数记做R,R<sup>*</sup>为排除0的实数集,R<sup>+</sup>为全体正实数集.</p>
<p>子集概念:</p>
<ul>
<li>子集</li>
<li>真子集</li>
<li>集合相等:互为子集</li>
<li>空集 $\emptyset$<h4 id="1-1-2-集合的运算"><a href="#1-1-2-集合的运算" class="headerlink" title="1.1.2 集合的运算"></a>1.1.2 集合的运算</h4></li>
</ul>
<h4 id="1-1-3-区间和领域"><a href="#1-1-3-区间和领域" class="headerlink" title="1.1.3 区间和领域"></a>1.1.3 区间和领域</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-映射与函数&quot;&gt;&lt;a href=&quot;#1-映射与函数&quot; class=&quot;headerlink&quot; title=&quot;1.映射与函数&quot;&gt;&lt;/a&gt;1.映射与函数&lt;/h2&gt;&lt;h3 id=&quot;1-1-集合&quot;&gt;&lt;a href=&quot;#1-1-集合&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="高数" scheme="http://wodekouwei.com/categories/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="math" scheme="http://wodekouwei.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Android线程使用总结</title>
    <link href="http://wodekouwei.com/2017/04/10/tips-android-thread/"/>
    <id>http://wodekouwei.com/2017/04/10/tips-android-thread/</id>
    <published>2017-04-10T10:39:43.000Z</published>
    <updated>2017-04-10T10:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Threading-Performance"><a href="#1-Threading-Performance" class="headerlink" title="1. Threading Performance"></a>1. Threading Performance</h3><p>在程序开发的实践当中，为了让程序表现得更加流畅，我们肯定会需要使用到多线程来提升程序的并发执行性能。但是编写多线程并发的代码一直以来都是一个相对棘手的问题，所以想要获得更佳的程序性能，我们非常有必要掌握多线程并发编程的基础技能。
众所周知，Android 程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI 绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>
<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的 UI 绘制等等。我们知道，为了让屏幕的刷新帧率达到 60fps，我们需要确保 16ms 内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到 20fps 左右，用户就可以明显感知到卡顿不流畅了)。</p>
<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>
<p>为主线程减轻负的多线程方案有哪些呢？这些方案分别适合在什么场景下使用？Android 系统为我们提供了若干组工具类来帮助解决这个问题。</p>
<ul>
<li>AsyncTask: 为 UI 线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li>HandlerThread: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li>ThreadPool: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li>IntentService: 适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。</li>
</ul>
<p>了解这些系统提供的多线程工具类分别适合在什么场景下，可以帮助我们选择合适的解决方案，避免出现不可预期的麻烦。虽然使用多线程可以提高程序的并发量，但是我们需要特别注意因为引入多线程而可能伴随而来的内存问题。举个例子，在 Activity 内部定义的一个 AsyncTask，它属于一个内部类，该类本身和外面的 Activity 是有引用关系的，如果 Activity 要销毁的时候，AsyncTask 还仍然在运行，这会导致 Activity 没有办法完全释放，从而引发内存泄漏。所以说，多线程是提升程序性能的有效手段之一，但是使用多线程却需要十分谨慎小心，如果不了解背后的执行机制以及使用的注意事项，很可能引起严重的问题。</p>
<h3 id="2-Understanding-Android-Threading"><a href="#2-Understanding-Android-Threading" class="headerlink" title="2. Understanding Android Threading"></a>2. Understanding Android Threading</h3><p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>
<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>
<p>所幸的是，Android 系统为我们提供了 Looper，Handler，MessageQueue 来帮助实现上面的线程任务模型：</p>
<ul>
<li><p>Looper: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>
</li>
<li><p>Handler: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>
</li>
<li><p>MessageQueue: 使用 Intent，Message，Runnable 作为任务的载体在不同的线程之间进行传递。</p>
</li>
</ul>
<p>把上面三个组件打包到一起进行协作，这就是 HandlerThread
我们知道，当程序被启动，系统会帮忙创建进程以及相应的主线程，而这个主线程其实就是一个 HandlerThread。这个主线程会需要处理系统事件，输入事件，系统回调的任务，UI绘制等等任务，为了避免主线程任务过重，我们就会需要不断的开启新的工作线程来处理那些子任务。</p>
<h3 id="3-Memory-amp-Threading"><a href="#3-Memory-amp-Threading" class="headerlink" title="3. Memory &amp; Threading"></a>3. Memory &amp; Threading</h3><p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，ABA 问题等等。为了解决这些问题，我们会需要引入锁的概念。
在 Android 系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI 对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>
<p>另外，在非 UI 线程中直接持有 UI 对象的引用也很可能出现问题。例如Work线程中持有某个 UI 对象的引用，在 Work 线程执行完毕之前，UI 对象在主线程中被从 ViewHierarchy 中移除了，这个时候 UI 对象的任何属性都已经不再可用了，另外对这个 UI 对象的更新操作也都没有任何意义了，因为它已经从 ViewHierarchy 中被移除，不再绘制到画面上了。</p>
<p>不仅如此，View 对象本身对所属的 Activity 是有引用关系的，如果工作线程持续保有 View 的引用，这就可能导致 Activity 无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在 Activity 里面定义的一个 AsyncTask，这种类型的 AsyncTask 与外部的 Activity 是存在隐式引用关系的，只要 Task 没有结束，引用关系就会一直存在，这很容易导致 Activity 的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>
<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非 UI 线程里面去持有 UI 对象的引用。系统为了确保所有的 UI 对象都只会被 UI 线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当 Activity 被销毁的时候，由该 Activity 所触发的非 UI 线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止 UI 对象被错误的使用。</p>
<h3 id="4-Good-AsyncTask-Hunting"><a href="#4-Good-AsyncTask-Hunting" class="headerlink" title="4. Good AsyncTask Hunting"></a>4. Good AsyncTask Hunting</h3><p>AsyncTask 是一个让人既爱又恨的组件，它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对 AsyncTask 使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。
举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给 UI 更新到画面上。</p>
<p>AsyncTask 的出现就是为了快速的实现上面的使用场景，AsyncTask 把在主线程里面的准备工作放到 onPreExecute()方法里面进行执行，doInBackground()方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用 onPostExecute()方法返回到主线程。</p>
<p>使用 AsyncTask 需要注意的问题有哪些呢？请关注以下几点：
首先，默认情况下，所有的 AsyncTask 任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个 AsyncTask，一旦其中的某个 AsyncTask 执行时间过长，队列中的其他剩余 AsyncTask 都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。</p>
<p>为了解决上面提到的线性队列等待的问题，我们可以使用 AsyncTask.executeOnExecutor()强制指定 AsyncTask 使用线程池并发调度任务。</p>
<p>其次，如何才能够真正的取消一个 AsyncTask 的执行呢？我们知道 AsyncTaks 有提供 cancel()的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在 doInBackground()的代码中不断的添加程序是否被中止的判断逻辑.</p>
<p>一旦任务被成功中止，AsyncTask 就不会继续调用 onPostExecute()，而是通过调用 onCancelled()的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是 onPostExecute 还是 onCancelled）来决定是对 UI 进行正常的更新还是把对应的任务所占用的内存进行销毁等。
最后，使用 AsyncTask 很容易导致内存泄漏，一旦把 AsyncTask 写成 Activity 的内部类的形式就很容易因为 AsyncTask 生命周期的不确定而导致 Activity 发生泄漏。</p>
<p>综上所述，AsyncTask 虽然提供了一种简单便捷的异步机制，但是我们还是很有必要特别关注到他的缺点，避免出现因为使用错误而导致的严重系统性能问题。</p>
<h3 id="5-Getting-a-HandlerThread"><a href="#5-Getting-a-HandlerThread" class="headerlink" title="5. Getting a HandlerThread"></a>5. Getting a HandlerThread</h3><p>大多数情况下，AsyncTask 都能够满足多线程并发的场景需要（在工作线程执行任务并返回结果到主线程），但是它并不是万能的。例如打开相机之后的预览帧数据是通过 onPreviewFrame()的方法进行回调的，onPreviewFrame()和 open()相机的方法是执行在同一个线程的。</p>
<p>如果这个回调方法执行在 UI 线程，那么在 onPreviewFrame()里面将要执行的数据转换操作将和主线程的界面绘制，事件传递等操作争抢系统资源，这就有可能影响到主界面的表现性能。</p>
<p>我们需要确保 onPreviewFrame()执行在工作线程。如果使用 AsyncTask，会因为 AsyncTask 默认的线性执行的特性(即使换成并发执行)会导致因为无法把任务及时传递给工作线程而导致任务在主线程中被延迟，直到工作线程空闲，才可以把任务切换到工作线程中进行执行。</p>
<p>所以我们需要的是一个执行在工作线程，同时又能够处理队列中的复杂任务的功能，而 HandlerThread 的出现就是为了实现这个功能的，它组合了 Handler，MessageQueue，Looper 实现了一个长时间运行的线程，不断的从队列中获取任务进行执行的功能。</p>
<p>回到刚才的处理相机回调数据的例子，使用 HandlerThread 我们可以把 open()操作与 onPreviewFrame()的操作执行在同一个线程，同时还避免了 AsyncTask 的弊端。如果需要在 onPreviewFrame()里面更新 UI，只需要调用 runOnUiThread()方法把任务回调给主线程就够了。</p>
<p>HandlerThread 比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给 HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。
另外很重要的一点是，一旦我们使用了 HandlerThread，需要特别注意给 HandlerThread 设置不同的线程优先级，CPU 会根据设置的不同线程优先级对所有的线程进行调度优化。</p>
<p>掌握 HandlerThread 与 AsyncTask 之间的优缺点，可以帮助我们选择合适的方案。</p>
<h3 id="6-Swimming-in-Threadpools"><a href="#6-Swimming-in-Threadpools" class="headerlink" title="6. Swimming in Threadpools"></a>6. Swimming in Threadpools</h3><p>线程池适合用在把任务进行分解，并发进行执行的场景。通常来说，系统里面会针对不同的任务设置一个单独的守护线程用来专门处理这项任务。例如使用 Networking Thread 用来专门处理网络请求的操作，使用 IO Thread 用来专门处理系统的 <code>I\O</code> 操作。针对那些场景，这样设计是没有问题的，因为对应的任务单次执行的时间并不长而且可以是顺序执行的。但是这种专属的单线程并不能满足所有的情况，例如我们需要一次性 decode 40张图片，每个线程需要执行 4ms 的时间，如果我们使用专属单线程的方案，所有图片执行完毕会需要花费 160ms(40*4)，但是如果我们创建10个线程，每个线程执行4个任务，那么我们就只需要16ms就能够把所有的图片处理完毕。</p>
<p>为了能够实现上面的线程池模型，系统为我们提供了 ThreadPoolExecutor 帮助类来简化实现，剩下需要做的就只是对任务进行分解就好了。</p>
<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为 CPU 只能同时执行固定数量的线程数，一旦同时并发的线程数量超过 CPU 能够同时执行的阈值，CPU 就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>
<p>一旦同时并发的线程数量达到一定的量级，这个时候 CPU 在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少 64K+ 的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor 为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>
<p>另外需要关注的一个问题是：Runtime.getRuntime().availableProcesser()方法并不可靠，他返回的值并不是真实的 CPU 核心数，因为 CPU 会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的 CPU 核心数。</p>
<h3 id="7-The-Zen-of-IntentService"><a href="#7-The-Zen-of-IntentService" class="headerlink" title="7. The Zen of IntentService"></a>7. The Zen of IntentService</h3><p>默认的 Service 是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的 AsyncTask 与 HandlerThread，我们还可以选择使用 IntentService 来实现异步操作。IntentService 继承自普通 Service 同时又在内部创建了一个 HandlerThread，在 onHandlerIntent()的回调里面处理扔到 IntentService 的任务。所以 IntentService 就不仅仅具备了异步线程的特性，还同时保留了 Service 不受主页面生命周期影响的特点。</p>
<p>如此一来，我们可以在 IntentService 里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>
<p>使用 IntentService 需要特别留意以下几点：</p>
<ul>
<li>首先，因为 IntentService 内置的是 HandlerThread 作为异步线程，所以每一个交给 IntentService 的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到 IntentService 的时候，我们会结合使用 BroadcastReceiver 把工作线程的任务执行结果返回给主 UI 线程。使用广播容易引起性能问题，我们可以使用 LocalBroadcastManager 来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用 runOnUiThread() 快速回调到主 UI 线程。</li>
<li>最后，包含正在运行的 IntentService 的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>
<h3 id="8-Threading-and-Loaders"><a href="#8-Threading-and-Loaders" class="headerlink" title="8. Threading and Loaders"></a>8. Threading and Loaders</h3><p>当启动工作线程的 Activity 被销毁的时候，我们应该做点什么呢？为了方便的控制工作线程的启动与结束，Android 为我们引入了 Loader 来解决这个问题。我们知道 Activity 有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在 Activity 不停的创建与销毁的过程当中，很有可能因为工作线程持有 Activity 的 View 而导致内存泄漏(因为工作线程很可能持有 View 的强引用，另外工作线程的生命周期还无法保证和 Activity 的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在 Activity 被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>
<p>Loader 的出现就是为了确保工作线程能够和 Activity 的生命周期保持一致，同时避免出现前面提到的问题。</p>
<p>LoaderManager 会对查询的操作进行缓存，只要对应 Cursor 上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader  可以直接把缓存的数据回调到 onLoadFinished()，从而避免重新查询数据。另外系统会在 Loader 不再需要使用到的时候(例如使用 Back 按钮退出当前页面)回调 onLoaderReset()方法，我们可以在这里做数据的清除等等操作。
在 Activity 或者 Fragment 中使用 Loader 可以方便的实现异步加载的框架，Loader 有诸多优点。但是实现 Loader 的这套代码还是稍微有点点复杂，Android 官方为我们提供了使用 Loader 的示例代码进行参考学习。</p>
<h3 id="9-The-Importance-of-Thread-Priority"><a href="#9-The-Importance-of-Thread-Priority" class="headerlink" title="9. The Importance of Thread Priority"></a>9. The Importance of Thread Priority</h3><p>理论上来说，我们的程序可以创建出非常多的子线程一起并发执行的，可是基于 CPU 时间片轮转调度的机制，不可能所有的线程都可以同时被调度执行，CPU 需要根据线程的优先级赋予不同的时间片。</p>
<p>Android 系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为 forground 的那部分线程会大致占用掉 CPU 的90%左右的时间片，background 的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为 forground 的程序本身的优先级就更高，理应得到更多的执行时间。</p>
<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主 UI 线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占 CPU 资源，需要把这些线程的优先级进行降低处理，这样才能给帮组 CPU 识别主次，提高主线程所能得到的系统资源。</p>
<p>在 Android 系统里面，我们可以通过 android.os.Process.setThreadPriority(int) 设置线程的优先级，参数范围从-20到19，数值越小优先级越高。Android 系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>
<p>大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用 THREAD_PRIORITY_LESS_FAVORABLE 或者 THREAD_PRIORITY_MORE_FAVORABLE 来控制线程的优先级。</p>
<p>Android 系统里面的 AsyncTask 与 IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>
<h3 id="10-Profile-GPU-Rendering-M-Update"><a href="#10-Profile-GPU-Rendering-M-Update" class="headerlink" title="10. Profile GPU Rendering : M Update"></a>10. Profile GPU Rendering : M Update</h3><p>从 Android M 系统开始，系统更新了 GPU Profiling 的工具来帮助我们定位 UI 的渲染性能问题。早期的 CPU Profiling 工具只能粗略的显示出 Process，Execute，Update 三大步骤的时间耗费情况。
但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在 Android M 版本开始，GPU Profiling 工具把渲染操作拆解成如下8个详细的步骤进行显示。</p>
<p>旧版本中提到的 Proces，Execute，Update 还是继续得到了保留，他们的对应关系如下：</p>
<p>接下去我们看下其他五个步骤分别代表了什么含义：</p>
<ul>
<li>Sync &amp; Upload：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</li>
<li>Measure &amp; Layout：这里表示的是布局的 onMeasure 与 onLayout 所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</li>
<li>Animation：表示的是计算执行动画所需要花费的时间，包含的动画有 ObjectAnimator，ViewPropertyAnimator，Transition 等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</li>
<li>Input Handling：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</li>
<li>Misc/Vsync Delay：如果稍加注意，我们可以在开发应用的 Log 日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致 UI 渲染跟不上 vSync 的信号而出现掉帧的情况。</li>
</ul>
<p>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling 工具会显示 16ms 的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。</p>
<blockquote>
<p><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=1022" target="_blank" rel="external">http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=1022</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Threading-Performance&quot;&gt;&lt;a href=&quot;#1-Threading-Performance&quot; class=&quot;headerlink&quot; title=&quot;1. Threading Performance&quot;&gt;&lt;/a&gt;1. Threading Per
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="多线程" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>MP4格式解析</title>
    <link href="http://wodekouwei.com/2017/04/09/m-f-mp4/"/>
    <id>http://wodekouwei.com/2017/04/09/m-f-mp4/</id>
    <published>2017-04-09T03:31:46.000Z</published>
    <updated>2017-04-12T07:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前MP4的概念被炒得很火，也很乱。最开始MP4指的是音频（MP3的升级版），即MPEG-2 AAC标准。随后MP4概念被转移到视频上，对应的是MPEG-4标准。而现在我们流行的叫法，多半是指能播放MPEG-4标准编码格式视频的播放器。但是这篇文章介绍的内容跟上面这些都无关，我们要讨论的是MP4文件封装格式，对应的标准为ISO/IEC 14496-12，即信息技术 视听对象编码的第12部分：ISO 基本媒体文件格式（Information technology Coding of audio-visual objects Part 12: ISO base media file format）。ISO/IEC组织指定的标准一般用数字表示，ISO/IEC 14496即MPEG-4标准。</p>
<p>MP4视频文件封装格式是基于QuickTime容器格式定义的，因此参考QuickTime的格式定义对理解MP4文件格式很有帮助。MP4文件格式是一个十分开放的容器，几乎可以用来描述所有的媒体结构，MP4文件中的媒体描述与媒体数据是分开的，并且媒体数据的组织也很自由，不一定要按照时间顺序排列，甚至媒体数据可以直接引用其他文件。同时，MP4也支持流媒体。MP4目前被广泛用于封装h.264视频和AAC音频，是高清视频的代表。MP4格式的官方文件后缀名是“.mp4”，还有其他的以mp4为基础进行的扩展或者是缩水版本的格式，包括：M4V,  3GP, F4V等。</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>MP4文件中的所有数据都装在box（QuickTime中为atom）中，也就是说MP4文件由若干个box组成，每个box有类型和长度，可以将box理解为一个数据对象块。box中可以包含另一个box，这种box称为container box。一个MP4文件首先会有且只有一个“ftyp”类型的box，作为MP4格式的标志并包含关于文件的一些信息；之后会有且只有一个“moov”类型的box（Movie Box），它是一种container box，子box包含了媒体的metadata信息；MP4文件的媒体数据包含在“mdat”类型的box（Midia Data Box）中，该类型的box也是container box，可以有多个，也可以没有（当媒体数据全部引用其他文件时），媒体数据的结构由metadata进行描述。</p>
<p>下面是一些概念：</p>
<ul>
<li>track  表示一些sample的集合，对于媒体数据来说，track表示一个视频或音频序列。</li>
<li>hint track  这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。</li>
<li>sample  对于非hint track来说，video sample即为一帧视频，或一组连续视频帧，audio sample即为一段连续的压缩音频，它们统称sample。对于hint track，sample定义一个或多个流媒体包的格式。</li>
<li>sample table  指明sampe时序和物理布局的表。</li>
<li>chunk 一个track的几个sample组成的单元。</li>
</ul>
<p>不讨论涉及hint的内容，只关注包含媒体数据的本地MP4文件。下图为一个典型的MP4文件的结构树。
<img src="http://images.wodekouwei.com/M/F/mp4_box_struct1.jpeg" alt="MP4文件结构树"></p>
<h3 id="2-Box"><a href="#2-Box" class="headerlink" title="2.Box"></a>2.Box</h3><p>box中的字节序为网络字节序，也就是大端字节序（Big-Endian），简单的说，就是一个32位的4字节整数存储方式为高位字节在内存的低端。Box由header和body组成，其中header统一指明box的大小和类型，body根据类型有不同的意义和格式。</p>
<p>标准的box开头的4个字节（32位）为box size，该大小包括box header和box body整个box的大小，这样我们就可以在文件中定位各个box。如果size为1，则表示这个box的大小为large size，真正的size值要在largesize域上得到。（实际上只有“mdat”类型的box才有可能用到large size。）如果size为0，表示该box为文件的最后一个box，文件结尾即为该box结尾。（同样只存在于“mdat”类型的box中。）size后面紧跟的32位为box type，一般是4个字符，如“ftyp”、“moov”等，这些box type都是已经预定义好的，分别表示固定的意义。如果是“uuid”，表示该box为用户扩展类型。如果box type是未定义的，应该将其忽略。</p>
<h3 id="3-File-Type-Box-ftyp"><a href="#3-File-Type-Box-ftyp" class="headerlink" title="3.File Type Box(ftyp)"></a>3.File Type Box(ftyp)</h3><p>该box有且只有1个，并且只能被包含在文件层，而不能被其他box包含。该box应该被放在文件的最开始，指示该MP4文件应用的相关信息。
“ftyp” body依次包括1个32位的major brand（4个字符），1个32位的minor version（整数）和1个以32位（4个字符）为单位元素的数组compatible brands。这些都是用来指示文件应用级别的信息。该box的字节实例如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">00000000h: 00 00 00 18 66 74 79 70 6D 70 34 32 00 00 00 01 ; ....ftypmp42....</div><div class="line">00000010h: 6D 70 34 32 6D 70 34 31 00 00 5A EB 6D 6F 6F 76 ; mp42mp41..Zmoov</div></pre></td></tr></table></figure></p>
<h3 id="4-Movie-Box-moov"><a href="#4-Movie-Box-moov" class="headerlink" title="4.Movie Box(moov)"></a>4.Movie Box(moov)</h3><p>该box包含了文件媒体的metadata信息，“moov”是一个container box，具体内容信息由子box诠释。同File Type Box一样，该box有且只有一个，且只被包含在文件层。一般情况下，“moov”会紧随“ftyp”出现。</p>
<p>一般情况下（限于篇幅，本文只讲解常见的MP4文件结构），“moov”中会包含1个“mvhd”和若干个“trak”。其中“mvhd”为header box，一般作为“moov”的第一个子box出现（对于其他container box来说，header box都应作为首个子box出现）。“trak”包含了一个track的相关信息，是一个container box。下图为部分“moov”的字节实例，其中红色部分为box header，绿色为“mvhd”，黄色为一部分“trak”。
<img src="http://images.wodekouwei.com/M/F/mp4_box_moov.png" alt="moov box"></p>
<h4 id="4-1-Movie-Header-Box-mvhd"><a href="#4-1-Movie-Header-Box-mvhd" class="headerlink" title="4.1 Movie Header Box(mvhd)"></a>4.1 Movie Header Box(mvhd)</h4><p>“mvhd”接口如下表:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>box size</td>
<td>4</td>
<td>box大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box版本，0或1，一般为0。（以下字节数均按version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>creation time</td>
<td>4</td>
<td>创建时间（相对于UTC时间1904-01-01零点的秒数）</td>
</tr>
<tr>
<td>modification time</td>
<td>4</td>
<td>修改时间</td>
</tr>
<tr>
<td>time scale</td>
<td>4</td>
<td>文件媒体在1秒时间内的刻度值，可以理解为1秒长度的时间单元数</td>
</tr>
<tr>
<td>duration</td>
<td>4</td>
<td>该track的时间长度，用duration和time scale值可以计算track时长，比如audio track的time scale = 8000, duration = 560128，时长为70.016，video track的time scale = 600, duration = 42000，时长为70</td>
</tr>
<tr>
<td>rate</td>
<td>4</td>
<td>推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放</td>
</tr>
<tr>
<td>volume</td>
<td>2</td>
<td>与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量</td>
</tr>
<tr>
<td>reserved</td>
<td>10</td>
<td>保留位</td>
</tr>
<tr>
<td>matrix</td>
<td>36</td>
<td>视频变换矩阵</td>
</tr>
<tr>
<td>pre-defined</td>
<td>24</td>
</tr>
<tr>
<td>next track id</td>
<td>4</td>
<td>下一个track使用的id号</td>
</tr>
</tbody>
</table>
<p><img src="http://images.wodekouwei.com/M/F/mp4_box_mvhd.png" alt="mvhd"></p>
<h4 id="4-2Track-Box-trak"><a href="#4-2Track-Box-trak" class="headerlink" title="4.2Track Box(trak)"></a>4.2Track Box(trak)</h4><p>“trak”也是一个container box，其子box包含了该track的媒体数据引用和描述（hint track除外）。一个MP4文件中的媒体可以包含多个track，且至少有一个track，这些track之间彼此独立，有自己的时间和空间信息。“trak”必须包含一个“tkhd”和一个“mdia”，此外还有很多可选的box（略）。其中“tkhd”为track header box，“mdia”为media box，该box是一个包含一些track媒体数据信息box的container box。</p>
<table>
<tr>
<th colspan="6">box类型</th><th colspan="6">说明</th>
</tr>
<tr>
<td>ftype</td><td></td><td></td><td></td><td></td><td></td><td colspan="6">file type,说明文件类型</td>
</tr>
<tr>
<td>moov</td><td></td><td></td><td></td><td></td><td></td><td colspan="6">metadata container,存放媒体信息的地方</td>
</tr>
<tr>
<td></td><td>mvhd</td><td></td><td></td><td></td><td></td><td colspan="6">movie header,文件的总体信息,如时长,创建时间等</td>
</tr>
<tr>
<td></td><td>mvhd</td><td></td><td></td><td></td><td></td><td colspan="6">movie header,文件的总体信息,如时长,创建时间等</td>
</tr>
<tr>
<td></td><td>trak</td><td></td><td></td><td></td><td></td><td colspan="6">track or stream container,存放视频/音频流的容器</td>
</tr>
<tr>
<td></td><td></td><td>tkhd</td><td></td><td></td><td></td><td colspan="6">track header,track的总体信息,如时长,宽高等</td>
</tr>
<td></td><td></td><td>media</td><td></td><td></td><td></td><td colspan="6">trak media information container</td>

<tr>
<td></td><td></td><td></td><td>mdhd</td><td></td><td></td><td colspan="6">media header,定义TimeScale,trak需要通过TimeScale转换成真实时间</td>
</tr>
<tr>
<td></td><td></td><td></td><td>hdlr</td><td></td><td></td><td colspan="6">handler,表明本trak类型,指明是<code>video/audio/还是hint</code></td>
</tr>
<tr>
<td></td><td></td><td></td><td>minf</td><td></td><td></td><td colspan="6">media information container,数据在子box中</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td>stbl</td><td></td><td colspan="6">sample table box,存放时间/偏移的映射关系表,数据在子box中</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>stsd</td><td colspan="6">sample descriptions</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>stts</td><td colspan="6">(decoding)time-to-sample,”时戳-sample序号”的映射表</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>stsc</td><td colspan="6">sample-to-chunk,sample和chunk的映射表,这里的算法比较巧妙</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>stsz</td><td colspan="6">sample size,每个sample的大小</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>stz2</td><td colspan="6">sample size,另一种sample size的存储算法,更节省空间</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>stss</td><td colspan="6">sync sample table,可随机访问的sample列表(关键帧列表)</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>stco</td><td colspan="6">chunk offset,每个chunk的偏移,sample的偏移可根据其他box推算出来</td>
</tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td>co64</td><td colspan="6">64-bit chunk offset</td>
</tr>
<tr>
<td>mdat</td><td></td><td></td><td></td><td></td><td></td><td colspan="6">media data container,具体的媒体数据</td>
</tr>
</table>  


<h3 id="Mdat-Box"><a href="#Mdat-Box" class="headerlink" title="Mdat Box"></a>Mdat Box</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前MP4的概念被炒得很火，也很乱。最开始MP4指的是音频（MP3的升级版），即MPEG-2 AAC标准。随后MP4概念被转移到视频上，对应的是MPEG-4标准。而现在我们流行的叫法，多半是指能播放MPEG-4标准编码格式视频的播放器。但是这篇文章介绍的内容跟上面这些都无关
    
    </summary>
    
      <category term="音视频封装" scheme="http://wodekouwei.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://wodekouwei.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="format" scheme="http://wodekouwei.com/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>欢迎</title>
    <link href="http://wodekouwei.com/2017/03/13/welcome/"/>
    <id>http://wodekouwei.com/2017/03/13/welcome/</id>
    <published>2017-03-13T03:10:58.000Z</published>
    <updated>2017-04-08T14:31:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎写小说"><a href="#欢迎写小说" class="headerlink" title="欢迎写小说"></a>欢迎写小说</h1><h1 id="开始写小说了啊"><a href="#开始写小说了啊" class="headerlink" title="开始写小说了啊"></a>开始写小说了啊</h1><ul>
<li>@阿杰</li>
<li>@吕超</li>
</ul>
<p><img src="http://images.wodekouwei.com/C9B8A983F49C0F5EA4C5AB65CC6AA4E4.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;欢迎写小说&quot;&gt;&lt;a href=&quot;#欢迎写小说&quot; class=&quot;headerlink&quot; title=&quot;欢迎写小说&quot;&gt;&lt;/a&gt;欢迎写小说&lt;/h1&gt;&lt;h1 id=&quot;开始写小说了啊&quot;&gt;&lt;a href=&quot;#开始写小说了啊&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="小说" scheme="http://wodekouwei.com/categories/%E5%B0%8F%E8%AF%B4/"/>
    
    
      <category term="demo" scheme="http://wodekouwei.com/tags/demo/"/>
    
      <category term="小说" scheme="http://wodekouwei.com/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
</feed>
