<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老司机种菜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wodekouwei.com/"/>
  <updated>2019-04-04T06:38:39.770Z</updated>
  <id>http://wodekouwei.com/</id>
  
  <author>
    <name>轻口味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gerrit工具介绍</title>
    <link href="http://wodekouwei.com/2019/04/04/util-gerrit/"/>
    <id>http://wodekouwei.com/2019/04/04/util-gerrit/</id>
    <published>2019-04-04T02:56:50.000Z</published>
    <updated>2019-04-04T06:38:39.770Z</updated>
    
    <content type="html"><![CDATA[<p>Gerrit的gerrit query命令就是要查询Gerrit的changes数据库。</p>
<p>默认，查询结果是根据changes的更新时间，由近及远排序。</p>
<p>对于有多个patch set的change，默认查询结果只包含最后的patch set。</p>
<p>如果查询结果有很大，则默认只返回有限个查询结果，可以设置limit:参数指定查询结果包含的changes数量。</p>
<h3 id="1-gerrit-query命令用法："><a href="#1-gerrit-query命令用法：" class="headerlink" title="1. gerrit query命令用法："></a>1. gerrit query命令用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ssh -p &lt;port&gt; &lt;host&gt; gerrit query</div><div class="line">  [--format &#123;TEXT | JSON&#125;]</div><div class="line">  [--current-patch-set]</div><div class="line">  [--patch-sets | --all-approvals]</div><div class="line">  [--files]</div><div class="line">  [--comments]</div><div class="line">  [--commit-message]</div><div class="line">  [--dependencies]</div><div class="line">  [--submit-records]</div><div class="line">  [--all-reviewers]</div><div class="line">  [--start &lt;n&gt; | -S &lt;n&gt;]</div><div class="line">  &lt;query&gt;</div><div class="line">  [limit:&lt;n&gt;]</div></pre></td></tr></table></figure>
<p>常见选项说明：</p>
<ul>
<li>–format=TEXT，默认</li>
<li>–format=JSON</li>
<li>–current-patch-set，给出当前patch set的信息</li>
<li>–patch-sets，给出所有patch set的信息</li>
<li>–commit-message，给出change的完整commit message</li>
<li>–all-reviewers，给出所有reviewer的name和email
<code>&lt;query&gt;</code>说明：</li>
<li>status:open等价于status:pending, is:open, is:pending</li>
<li>owner:self等价于is:owner</li>
<li>reviewer:self等价于is:reviewer</li>
<li>project:bbauto/bba或p:bbauto/bba</li>
<li>projects:bb</li>
<li>branch:develop或branch:refs/heads/develop</li>
<li>change:2311176或change:I03369813660369e983b56dcabe4cb48839be4de0</li>
<li>commit:4e8ea8d43ab22273e4949348e1e7316f88cd54e3</li>
<li>ref:refs/changes/76/2311176/1</li>
<li>message:my_commit_message</li>
<li>is:visible</li>
<li>label:Code-Review=2或label:Code-Review=+2或label:Code-Review+2</li>
<li>label:Verified+1
补充：</li>
<li>属性值除了bare words (数字、大小写字母和@-_.)之外，必须使用””或{}包含</li>
<li>多个属性之间默认为and关系，还有or关系，或者取反not/-</li>
</ul>
<p>查询Gerrit指定状态的patch set,并保存到文件。采用分段查看首先查看最近500条的，再查看最近500-1000条的。</p>
<p><code>alias gerrit=&quot;ssh -p 29418 gerrit.yourdomain.com gerrit&quot;</code>
<code>gerrit review &lt;id&gt; --abandon</code> 放弃某个commit(id是commit id不是change id)</p>
<p><code>ssh -p 29418 192.168.1.127 gerrit review --submit a6b548272aa754857b4</code> 提交某个commit
循环放弃脚本:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">alias gerrit=&quot;ssh -p 29418 gerrit.lianjia.com gerrit&quot; </div><div class="line"></div><div class="line">for c in $(gerrit query project:mars --start 500 --current-patch-set| grep &quot;revision&quot;);do</div><div class="line">    if [ $c != &apos;revision:&apos; ];then</div><div class="line">        gerrit review $c --abandon;</div><div class="line">        echo $c</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h3 id="2-参考文献："><a href="#2-参考文献：" class="headerlink" title="2.参考文献："></a>2.参考文献：</h3><p><a href="https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/cmd-query.html" target="_blank" rel="external">https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/cmd-query.html</a>
<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/json.html" target="_blank" rel="external">https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/json.html</a>
<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/user-search.html" target="_blank" rel="external">https://gerrit-documentation.storage.googleapis.com/Documentation/2.13.7/user-search.html</a></p>
<h3 id="3-gerrit-不经代码审核直接push进库的方法"><a href="#3-gerrit-不经代码审核直接push进库的方法" class="headerlink" title="3.gerrit 不经代码审核直接push进库的方法"></a>3.gerrit 不经代码审核直接push进库的方法</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h4><p>gerrit 代码审核将代码入库权限收起,可以有效控制代码质量.</p>
<p>但同时弊端也是明显的: 对于频繁改动的项目(比如新项目),每段代码都审核会明显拖慢工作效率.</p>
<p>这时可以给某个组配置不经审核直接push权限.</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h4><p>管理员账号,到 projects -&gt; access 页面下配置 reference 权限.
其他 reference 的权限配置依旧, 给如下 reference 增加权限:
refs/for/refs/heads/master
配置 submit 权限给某个具体的组即可.</p>
<p>该组用户需要忽略审核时,执行如下命令:
git push origin HEAD:refs/for/master%submit
就是在原有 push 命令基础上加上 %submit 这个后缀即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gerrit的gerrit query命令就是要查询Gerrit的changes数据库。&lt;/p&gt;
&lt;p&gt;默认，查询结果是根据changes的更新时间，由近及远排序。&lt;/p&gt;
&lt;p&gt;对于有多个patch set的change，默认查询结果只包含最后的patch set。&lt;/p
    
    </summary>
    
      <category term="工具" scheme="http://wodekouwei.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://wodekouwei.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>tips-android-sqlite</title>
    <link href="http://wodekouwei.com/2019/03/27/tips-android-sqlite/"/>
    <id>http://wodekouwei.com/2019/03/27/tips-android-sqlite/</id>
    <published>2019-03-27T01:57:57.000Z</published>
    <updated>2019-03-27T02:00:29.225Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">08-30 20:27:36.751 E/CursorWindow(  760): Could not allocate CursorWindow &apos;/data/data/com.android.providers.media/databases/external.db&apos; of size 2097152 due to error -12.</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760): *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760): android.database.CursorWindowAllocationException: Cursor window allocation of 2048 kb failed. # Open Cursors=781 (# cursors opened by pid 3105=781)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.CursorWindow.&lt;init&gt;(CursorWindow.java:104)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.AbstractWindowedCursor.clearOrCreateWindow(AbstractWindowedCursor.java:198)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.sqlite.SQLiteCursor.fillWindow(SQLiteCursor.java:162)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.sqlite.SQLiteCursor.getCount(SQLiteCursor.java:156)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.database.CursorToBulkCursorAdaptor.count(CursorToBulkCursorAdaptor.java:184)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:117)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at android.os.Binder.execTransact(Binder.java:338)</div><div class="line">08-30 20:27:36.771 E/JavaBinder(  760):  at dalvik.system.NativeStart.run(Native Method)</div></pre></td></tr></table></figure>
<p>错误原因
CursorWindow缓存数据达到最大限制（2Ｍ不同的机器和SQLite版本其值可能不同）后，仍有查询结果集需要缓存，在申请内存分配时申请失败发生了OOM内存溢出；SQLite查询出的数据集cursor，都由native层的CursorWindow进行数据管理，包括内存空间的申请和数据的填充。CursorWindow实际上是共享内存的抽象，以实现跨进程，跨应用数据共享（ContentProvider作为数据通道，也支持跨进程，跨应用的数据访问）
在ContentProvider端透过SQLiteDatabase的封装查询到的数据集保存在CursorWindow所指向的共享内存中，然后通过Binder把这片共享内存传递到ContentResolver端，即查询端。这样客户就可以通过Cursor来访问这块共享内存中的数据集了。
解决办法
保证CursorWindow不会达到最大限制）：</p>
<ol>
<li>只查询需要的字段；根据UI显示需要，或实际需要查询的字段进行查询，尽量不会表查询</li>
<li>二进制文件不要存在数据库中；数据库仅适用于保存一些较短文字，整数，布尔，浮点数等一些，易于查询和操作的轻量级的数据，目的也是在于快速搜索和查询。对于像图片，较长的文字（如文章）等大数据，最好直接以文件形式存储在硬盘中，然后在数据库保存它们的访问路径</li>
<li>对于大数据量的查询采用分段查询方式；无论表中的一条记录数据量如何的小，当条数达到5000级或者万级或者更多的时候，还是会达到最大的限制</li>
<li>正确的关闭Cursor，释放CursorWindow中不用的资源（需手动调用释放native中的资源，类似3.0之前的Bitmap需要手动释放。调用close的必要性：</li>
</ol>
<p><a href="https://blog.csdn.net/u011453773/article/details/50731250" target="_blank" rel="external">从源码看ANDROID中SQLITE是怎么通过CURSORWINDOW读DB的</a></p>
<h3 id="Sqlite性能优化"><a href="#Sqlite性能优化" class="headerlink" title="Sqlite性能优化"></a>Sqlite性能优化</h3><p>(1)编译SQL语句
Sqlite想要执行操作，需要将程序中的sql语句编译成对应的SQLiteStatement,比如select * from record这一句，被执行100次就需要编译100次。对于批量处理插入或者更新的操作，我们可以使用显示编译来做到重用SQLiteStatement。</p>
<p>想要做到重用SQLiteStatement也比较简单，基本如下：</p>
<p>编译sql语句获得SQLiteStatement对象，参数使用?代替 
在循环中对SQLiteStatement对象进行具体数据绑定，bind方法中的index从1开始，不是0</p>
<p>如下向person表中插入100条数据：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void insertBatchPreCompile() &#123;</div><div class="line">        long start = SystemClock.currentThreadTimeMillis();</div><div class="line">        String sql = &quot;insert into &quot; + TAB_PERSON + &quot; values (?,&apos;test&apos;,&apos;1&apos;);&quot;;</div><div class="line">        SQLiteStatement sqLiteStatement = getReadableDatabase().compileStatement(sql);</div><div class="line">        int count = 0;</div><div class="line">        while (count &lt; 100) &#123;</div><div class="line">            count++;</div><div class="line">            sqLiteStatement.clearBindings();</div><div class="line">            sqLiteStatement.bindLong(1, count);</div><div class="line">            sqLiteStatement.executeInsert();</div><div class="line">        &#125;</div><div class="line">        Log.e(TAG, &quot;insert recompile use time &quot; + (SystemClock.currentThreadTimeMillis() - start));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>（2）显示使用事务
在Android中，无论是使用SQLiteDatabase的insert,delete等方法还是execSQL都开启了事务，来确保每一次操作都具有原子性，使得结果要么是操作之后的正确结果，要么是操作之前的结果。</p>
<p>然而事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。既然属于文件，就符合Unix的文件范型(Open-Read/Write- Close)，因而对于批量的修改操作会出现反复打开文件读写再关闭的操作。然而好在，我们可以显式使用事务，将批量的数据库更新带来的journal文件打开关闭降低到1次。</p>
<p>具体的实现代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void insertWithTransaction() &#123;</div><div class="line">        long start = SystemClock.currentThreadTimeMillis();</div><div class="line">        int count = 0;</div><div class="line">        try &#123;</div><div class="line">            getWritableDatabase().beginTransaction();</div><div class="line">            while (count++ &lt; 100) &#123;</div><div class="line">                insert(count, &quot;test&quot;, 1);</div><div class="line">            &#125;</div><div class="line">            getWritableDatabase().setTransactionSuccessful();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            getWritableDatabase().endTransaction();</div><div class="line">        &#125;</div><div class="line">        Log.e(TAG, &quot;insert traceaction use time &quot; + (SystemClock.currentThreadTimeMillis() - start));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>使用这两种方式分别优化，对比效果如下： </p>
<p>从图中可以看到在插入100条的情况下，使用预编译的方式可以稍微提升性能，但是使用事务，能够使性能提升大概8倍，所以可以看出频繁的IO操作还是比较耗时的。同时使用两种方式进行优化，可以提升17倍，优化效果非常明显。</p>
<p>（3）建立索引
a.索引的概念
索引，使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>在关系数据库中，索引是一种与表有关的数据库结构，它可以使对应于表的SQL语句执行得更快。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。 
索引是一个单独的、物理的数据库结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。</p>
<p>索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引的方式与您使用书籍中的索引的方式很相似：它搜索索引以找到特定值，然后顺指针找到包含该值的行。</p>
<p>b.建立索引
创建索引的基本语法：</p>
<p>CREATE INDEX index_name ON table_name;
1
创建单列索引</p>
<p>CREATE INDEX index_name ON table_name;
1
c.索引的利弊
毋庸置疑，索引加速了我们检索数据表的速度。然而正如西方谚语 “There are two sides of a coin”，索引亦有缺点：</p>
<p>对于增加，更新和删除来说，使用了索引会变慢，比如你想要删除字</p>
<p>列表内容典中的一个字，那么你同时也需要删除这个字在拼音索引和部首索引中的信息。
建立索引会增加数据库的大小，比如字典中的拼音索引和部首索引实际上是会增加字典的页数，让字典变厚的。
为数据量比较小的表建立索引，往往会事倍功半。
所以使用索引需要考虑实际情况进行利弊权衡，对于查询操作量级较大，业务对要求查询要求较高的，还是推荐使用索引的。</p>
<p>（4）查询数据优化
按需获取列信息</p>
<p>db.query(TableDefine.TABLE_RECORD, null, null, null, null, null, null) ;
1
其中上面方法的第二个参数类型为String[]，意思是返回结果参考的colum信息，传递null表明需要获取全部的column数据。如果我们不需要所有列的信息，最好指定一下需要的列。</p>
<p>提前获取索引 
例如下面的代码，我们可以把获取列索引的代码cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME)放到循环外，这样不需要每次获取。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> private void badQueryWithLoop(SQLiteDatabase db) &#123;</div><div class="line">    Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]&#123;TableDefine.COLUMN_INSERT_TIME&#125;, null, null, null, null, null) ;</div><div class="line">    while (cursor.moveToNext()) &#123;</div><div class="line">        long insertTime = cursor.getLong(cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（5）ContentValues的容量调整
SQLiteDatabase提供了方便的ContentValues简化了我们处理列名与值的映射，ContentValues内部采用了 HashMap来存储Key-Value数据，ContentValues的初始容量是8，如果当添加的数据超过8之前，则会进行双倍扩容操作，因此建议对ContentValues填入的内容进行估量，设置合理的初始化容量，减少不必要的内部扩容操作。</p>
<p>（6）及时关闭Cursor
（7）耗时异步化
数据库的操作，属于本地IO，通常比较耗时，如果处理不好，很容易导致ANR,因此建议将这些耗时操作放入异步线程中处理</p>
<p><a href="https://blog.csdn.net/u014608640/article/details/52511310" target="_blank" rel="external">Android 性能优化之数据库优化(一)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-android-file</title>
    <link href="http://wodekouwei.com/2019/03/27/tips-android-file/"/>
    <id>http://wodekouwei.com/2019/03/27/tips-android-file/</id>
    <published>2019-03-27T01:51:43.000Z</published>
    <updated>2019-03-27T01:53:34.877Z</updated>
    
    <content type="html"><![CDATA[<p>文件句柄泄露
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime: FATAL EXCEPTION: main</div><div class="line"></div><div class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime: Process: com.Android56, PID: 7437</div><div class="line"></div><div class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime: java.lang.RuntimeException: Could not read input channel file descriptors from parcel.</div><div class="line"></div><div class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime:    at android.view.InputChannel.nativeReadFromParcel(Native Method)</div><div class="line"></div><div class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime:    at android.view.InputChannel.readFromParcel(InputChannel.java:148)</div><div class="line"></div><div class="line">10-27 00:35:32.141  7437  7437 E AndroidRuntime:    at android.view.InputChannel$1.createFromParcel(InputChannel.java:39)</div></pre></td></tr></table></figure></p>
<p>这里有一句Could not read input channel file descriptors from parcel，然后我们在这句话的上面又发现一个有价值的信息。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Caused by: java.io.IOException: Too many open files</div></pre></td></tr></table></figure></p>
<p>通过网上搜索，基本判断这是一个文件句柄泄漏的问题。
那么我们该如何查找文件句柄泄漏的地方呢。
首先我们需要做到监控文件句柄数，由于android是linux的内核，所以，系统为每一个进程都有一个文件句柄的目录。
我们先通过ps命令，获取到我们app的进程id。
然后找到一个root过的手机，或者使用andorid模拟器，然后用adb连接到手机，通过shell命令进入到/proc/进程id/fd这个目录。由于linux关于系统的管理都是用文件方式，所以这个文件夹下面就是所有被打开的句柄。
我们可以在app运行的过程中，不断的进入到这个目录中，然后用ls -l 命令列出所有的文件句柄，这样就能看到文件句柄有哪些是增长的。然后再根据不同类型的文件句柄，初步定位是什么在泄漏。
在排查的过程中，为了方便获取某个进程的句柄数，我写了一个简单的shell脚本。有需要的同学可以拿去使用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">echo &apos;查询进程占用文件句柄数&apos;</div><div class="line">set `adb shell ps |grep com.Android56 |grep -v channel |grep -v Daemon`</div><div class="line">pidnum=$2</div><div class="line">index=0</div><div class="line">while true</div><div class="line">do</div><div class="line">index=$[index+1]</div><div class="line">echo &apos;##################&apos;</div><div class="line">echo &apos;第&apos;$index&apos;次查询&apos;</div><div class="line">echo &apos;总句柄&apos;</div><div class="line">adb shell ls -l /proc/$pidnum/fd |grep &quot;&quot; -c</div><div class="line">echo &apos;anon句柄&apos;</div><div class="line">adb shell ls -l /proc/$pidnum/fd |grep anon -c</div><div class="line">echo &apos;##################&apos;</div><div class="line">sleep 2</div><div class="line">done</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件句柄泄露
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="http://wodekouwei.com/2019/03/26/tool-markdown/"/>
    <id>http://wodekouwei.com/2019/03/26/tool-markdown/</id>
    <published>2019-03-26T14:00:20.000Z</published>
    <updated>2019-04-04T06:38:37.409Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown Preview Enhanced 内部支持 mermaid, PlantUML, WaveDrom, GraphViz，Vega &amp; Vega-lite，Ditaa 图像渲染。 
你也可以通过使用 Code Chunk 来渲染 TikZ, Python Matplotlib, Plotly 等图像。</p>
<h3 id="基本流程图"><a href="#基本流程图" class="headerlink" title="基本流程图"></a>基本流程图</h3><p>Markdown常用的元素有以下几种：</p>
<ul>
<li>start</li>
<li>end</li>
<li>operation</li>
<li>condition</li>
<li>inputoutput</li>
<li>subroutine</li>
</ul>
<p>以简单的登录场景为例，流程图代码</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>注意：冒号和名称之间需要有一个空格。</p>
<p>方向调整
绘制流程图有时会出现比较一言难尽的情况</p>
<div id="flowchart-1" class="flow-chart"></div>
这种情况下可以使用left、right和bottom关键字来调整线条的位置使流程图更加清晰，例如此处给operation4元素添加right关键字，就可以分离重叠的线条。
<div id="flowchart-2" class="flow-chart"></div>
如果给condition元素添加这些关键字的话会调整整个分支的方向：
<div id="flowchart-3" class="flow-chart"></div>

<p>状态标记
Markdown会使用不同的颜色来标记状态，状态主要有以下几种：</p>
<ul>
<li>past</li>
<li>current</li>
<li>future</li>
<li>approved</li>
<li>rejected</li>
<li>invalid</li>
</ul>
<p>以软件生命周期的一部分为例：</p>
<div id="flowchart-4" class="flow-chart"></div>
箭头高亮
可以通过高亮某些箭头来标记出主流程：
<div id="flowchart-5" class="flow-chart"></div>

<p>流程图语法详解
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">## 操作块(格式为:变量=&gt;操作块: 备注名)</div><div class="line">st=&gt; start: 开始</div><div class="line">e=&gt;end: 结束</div><div class="line">#普通操作块 opration</div><div class="line">op1=&gt;opration: 第一个操作块</div><div class="line">op2=&gt;opration: 第二个操作块</div><div class="line">#判断块 condition</div><div class="line">cond1=&gt;condition: 第一个判断</div><div class="line">cond2=&gt;condition: 第二个判断</div><div class="line">  </div><div class="line">#输入输出块 inputoutput[平行四边形]</div><div class="line">io1=&gt;inputoutput: 输入输出块1</div><div class="line">io2=&gt;inputoutput: 输入输出块2</div><div class="line">#子任务块</div><div class="line">sub1=&gt;subroutine: 子任务1</div><div class="line">sub2=&gt;subroutine: 子任务2</div><div class="line">  </div><div class="line">## 判断和位置控制</div><div class="line">#判断流程控制</div><div class="line">cond1(yes)-&gt;op1  #yes 的时候回到 op1</div><div class="line">cond1(no)-&gt;e   #no 的时候 去结束</div><div class="line">  </div><div class="line">#位置指定</div><div class="line">cond1(no)-&gt;op2(right)-&gt;op1 #控制 op2 位置置于右边，再由op2 返回 op1 (好像不能向左)</div><div class="line">#还可以这样 cond1(no,right)</div><div class="line">cond1(yes)-&gt;e </div><div class="line">  </div><div class="line">## 流程控制</div><div class="line">#分着写</div><div class="line">st-&gt;op1</div><div class="line">op1-&gt;e</div><div class="line">  </div><div class="line">#合着写</div><div class="line">st-&gt;op1-&gt;e</div><div class="line">  </div><div class="line">#判断也是一样：</div><div class="line">st-&gt;cond</div><div class="line">cond(yes)-&gt;io</div><div class="line">cond(no)-&gt;op1</div></pre></td></tr></table></figure></p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>注意:其实时序图使用platuml也可以画的很美观
<a href="http://plantuml.com/zh/sequence-diagram" target="_blank" rel="external">platuml-sequence</a></p>
<ul>
<li>sequence代码块中的内容将会被js-sequence-diagrams渲染</li>
<li>支持两个主题simple(default)和hand</li>
</ul>
<div id="sequence-0"></div>

<h3 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h3><p>Mermaid可以用来渲染流程图和时序图</p>
<ul>
<li>mermaid代码块中的内容将会被渲染mermaid图像</li>
<li><a href="https://mermaidjs.github.io/" target="_blank" rel="external">mermaid-docs图像文档</a></li>
</ul>
<p>注意:{code_block=true}会影藏图像
Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。</p>
<p>定义节点
|表述|说明|
|—|—|
|id[文字]|    矩形节点|
|id(文字)|    圆角矩形节点|
|id((文字))    |圆形节点|
|id&gt;文字]|    旗帜状节点|
|id{文字}|    菱形节点|
定义连线
|表述|    说明|
|—|—|
|&gt;|    添加尾部箭头|
|-|    不添加尾部箭头|
|–    |单线|
|–text–|    单线上加文字|
|==|    粗线|
|==text==|    粗线加文字|
|-.-|    虚线|
|-.text.-|    虚线加文字|</p>
<p>流程图方向有下面几个值</p>
<ul>
<li>TB 从上到下</li>
<li>BT 从下到上</li>
<li>RL 从右到左</li>
<li>LR 从左到右</li>
<li>TD 同TB</li>
</ul>
<p>子流程图
格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">subgraph title</div><div class="line">    graph definition</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>示例:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">graph TB</div><div class="line">    c1--&gt;a2</div><div class="line">    subgraph one</div><div class="line">    a1--&gt;a2</div><div class="line">    end</div><div class="line">    subgraph two</div><div class="line">    b1--&gt;b2</div><div class="line">    end</div><div class="line">    subgraph three</div><div class="line">    c1--&gt;c2</div><div class="line">    end</div></pre></td></tr></table></figure></p>
<p>自定义样式</p>
<p>语法：style id 具体样式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">graph LR</div><div class="line">    id1(Start)--&gt;id2(Stop)</div><div class="line">    style id1 fill:#f9f,stroke:#333,stroke-width:4px,fill-opacity:0.5</div><div class="line">    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 10,5</div></pre></td></tr></table></figure></p>
<h3 id="plantuml创建各种图形"><a href="#plantuml创建各种图形" class="headerlink" title="plantuml创建各种图形"></a>plantuml创建各种图形</h3><ul>
<li>可以安装graphviz来辅助生成各种图形</li>
<li>puml或plantuml代码中的内容将会被PlantUML渲染
注意：也可以为图像的容器添加属性，例如居中{align=”center”}</li>
</ul>
<h3 id="使用graphviz来绘制各种图形"><a href="#使用graphviz来绘制各种图形" class="headerlink" title="使用graphviz来绘制各种图形"></a>使用graphviz来绘制各种图形</h3><p>使用Viz.js来渲染dot语言图形。</p>
<ul>
<li>viz或者dot代码块中的内容将会被<a href="https://github.com/mdaines/viz.js" target="_blank" rel="external">Viz.js</a>渲染</li>
<li>可以通过{engine=”…”}来选择不同的渲染引擎。引擎circo,dot,neato,osage,或者twopi.</li>
</ul>
<p>注意:默认的dot是二叉树，twopi是依赖树，两种常用的类型</p>
<h3 id="vega和vega-lite的支持的静态图像"><a href="#vega和vega-lite的支持的静态图像" class="headerlink" title="vega和vega-lite的支持的静态图像"></a>vega和vega-lite的支持的静态图像</h3><ul>
<li>vega代码块中的内容会被vega渲染</li>
<li>vega-lite代码中的内容会被vega-lite渲染</li>
<li>支持JSON和YAML的数据源输入
<a href="https://vega.github.io/vega-lite/examples/" target="_blank" rel="external">vega-lite-docs</a>
<a href="https://www.jianshu.com/p/a9bd83b768d5" target="_blank" rel="external">vega-docs</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;$schema&quot;: &quot;https://vega.github.io/schema/vega-lite/v2.json&quot;,</div><div class="line">  &quot;description&quot;: &quot;A simple bar chart with embedded data.&quot;,</div><div class="line">  &quot;data&quot;: &#123;</div><div class="line">    &quot;values&quot;: [</div><div class="line">      &#123;&quot;a&quot;: &quot;A&quot;,&quot;b&quot;: 28&#125;, &#123;&quot;a&quot;: &quot;B&quot;,&quot;b&quot;: 55&#125;, &#123;&quot;a&quot;: &quot;C&quot;,&quot;b&quot;: 43&#125;,</div><div class="line">      &#123;&quot;a&quot;: &quot;D&quot;,&quot;b&quot;: 91&#125;, &#123;&quot;a&quot;: &quot;E&quot;,&quot;b&quot;: 81&#125;, &#123;&quot;a&quot;: &quot;F&quot;,&quot;b&quot;: 53&#125;,</div><div class="line">      &#123;&quot;a&quot;: &quot;G&quot;,&quot;b&quot;: 19&#125;, &#123;&quot;a&quot;: &quot;H&quot;,&quot;b&quot;: 87&#125;, &#123;&quot;a&quot;: &quot;I&quot;,&quot;b&quot;: 52&#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  &quot;mark&quot;: &quot;bar&quot;,</div><div class="line">  &quot;encoding&quot;: &#123;</div><div class="line">    &quot;x&quot;: &#123;&quot;field&quot;: &quot;a&quot;, &quot;type&quot;: &quot;ordinal&quot;&#125;,</div><div class="line">    &quot;y&quot;: &#123;&quot;field&quot;: &quot;b&quot;, &quot;type&quot;: &quot;quantitative&quot;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/diagrams" target="_blank" rel="external">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/diagrams</a></p>
<h3 id="hexo中支持流程图"><a href="#hexo中支持流程图" class="headerlink" title="hexo中支持流程图"></a>hexo中支持流程图</h3><ol>
<li>hexo-filter-mermaid-diagrams:
brew install yarn
进入到博客的根目录，一定要在博客的根目录执行<code>yarn add hexo-filter-mermaid-diagrams</code>
执行完成后在博客根目录下的node_modules种看下有没有hexo-filter-mermaid-diagrams这个插件文件夹，如果没有，说明没安装成功，安装成功后执行下一步，打开博客根目录下面的_config.yml文件，在底部插入以下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># mermaid chart</div><div class="line">mermaid: ## mermaid url https://github.com/knsv/mermaid</div><div class="line">  enable: true  # default true</div><div class="line">  version: &quot;7.1.2&quot; # default v7.1.2</div><div class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</div><div class="line">    #startOnload: true  // default true</div></pre></td></tr></table></figure>
</li>
</ol>
<p>完成上一步操作之后打开主题目录的themes/next/layout/_partials/footer.swig，这里因为我用的是next主题，其他主题应该大同小异，在footer.swig文件最后加上以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;% if theme.mermaid.enable %&#125;</div><div class="line">  &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">    if (window.mermaid) &#123;</div><div class="line">      mermaid.initialize(&#123;theme: &apos;forest&apos;&#125;);</div><div class="line">    &#125;</div><div class="line">  &lt;/script&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>添加完成后，回到博客根目录的_config.yml，把external_link的值改为false，默认的为true，这一步绝大多数教程中都没有写
Hexo中引入Mermaid流程图：<a href="https://tyloafer.github.io/2018/04/21/hexo-mermaid/" target="_blank" rel="external">点击查看</a>
hexo-filter-mermaid-diagrams插件开发杂谈:<a href="https://webappdevelp.github.io/2018/0%E4%B8%89/hexo-filter-mermaid-diagrams%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/" target="_blank" rel="external">点击查看</a>
插件官方位置:<a href="https://www.npmjs.com/package/hexo-filter-mermaid-diagrams" target="_blank" rel="external">点击查看</a>
插件官方使用教程:<a href="https://mermaidjs.github.io/flowchart.html" target="_blank" rel="external">点击查看</a></p>
<ol>
<li>hexo-filter-flowchart
npm install –save hexo-filter-flowchart</li>
<li>hexo-filter-sequence
npm install –save hexo-filter-sequence
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">start=>start: 开始
loginInfo=>inputoutput: 登录数据
verifyLogin=>subroutine: 登录验证
isSuccess=>condition: 验证成功？
respondSuccess=>operation: 响应成功
responseFailure=>operation: 响应失败
end=>end: 结束

start->loginInfo->verifyLogin->isSuccess
isSuccess(yes)->respondSuccess->end
isSuccess(no)->responseFailure->end</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">start=>start: start
operation1=>operation: operation1
isSuccess=>condition: success?
operation2=>operation: operation2
operation3=>operation: operation3
operation4=>operation: operation4
end=>end: 结束

start->operation1->isSuccess
isSuccess(yes)->operation2->end
isSuccess(no)->operation3->operation4->operation1</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">start=>start: start
operation1=>operation: operation1
isSuccess=>condition: success?
operation2=>operation: operation2
operation3=>operation: operation3
operation4=>operation: operation4
end=>end: 结束

start->operation1->isSuccess
isSuccess(yes)->operation2->end
isSuccess(no)->operation3->operation4(right)->operation1</textarea><textarea id="flowchart-2-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">start=>start: start
operation1=>operation: operation1
isSuccess=>condition: success?
operation2=>operation: operation2
operation3=>operation: operation3
operation4=>operation: operation4
end=>end: 结束

start->operation1->isSuccess
isSuccess(yes)->operation2->end
isSuccess(no,left)->operation3->operation4(left)->operation1</textarea><textarea id="flowchart-3-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">start=>start: 开始|past
requirementAnalysis=>operation: 需求分析|past
design=>operation: 软件设计|past
coding=>operation: 编码|past
selfTestingPased=>condition: 自测通过？|approved
debug=>operation: debug|invalid
submitTestingPased=>condition: 提测通过？|rejected
modifyBug=>operation: 修bug|current
deploy=>operation: 部署|future
end=>end: 结束|future

start->requirementAnalysis->design->coding->selfTestingPased
selfTestingPased(no)->debug(right)->selfTestingPased
selfTestingPased(yes)->submitTestingPased
submitTestingPased(yes)->deploy->end
submitTestingPased(no)->modifyBug(right)->submitTestingPased</textarea><textarea id="flowchart-4-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script><textarea id="flowchart-5-code" style="display: none">start=>start: 开始
loginInfo=>inputoutput: 登录数据
verifyLogin=>subroutine: 登录验证
isSuccess=>condition: 验证成功？
respondSuccess=>operation: 响应成功
responseFailure=>operation: 响应失败
end=>end: 结束

start->loginInfo->verifyLogin->isSuccess
isSuccess(yes)->respondSuccess->end
isSuccess(no)->responseFailure->end

start@>loginInfo({"stroke":"Red"})@>verifyLogin({"stroke":"Red"})@>isSuccess({"stroke":"Red"})@>respondSuccess({"stroke":"Red"})@>end({"stroke":"Red","stroke-width":6,"arrow-end":"classic-wide-long"})</textarea><textarea id="flowchart-5-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-5-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-5-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-5", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">bgbiao-> bianbian: good morning
note left of bgbiao: man
bianbian -> bgbiao: eat something
note right of bianbian: woman
  
note over bgbiao: test</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown Preview Enhanced 内部支持 mermaid, PlantUML, WaveDrom, GraphViz，Vega &amp;amp; Vega-lite，Ditaa 图像渲染。 
你也可以通过使用 Code Chunk 来渲染 TikZ, Pyth
    
    </summary>
    
      <category term="工具" scheme="http://wodekouwei.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://wodekouwei.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>tips-net-socket</title>
    <link href="http://wodekouwei.com/2019/03/13/tips-net-socket/"/>
    <id>http://wodekouwei.com/2019/03/13/tips-net-socket/</id>
    <published>2019-03-13T12:05:55.000Z</published>
    <updated>2019-03-25T06:35:48.376Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div></pre></td><td class="code"><pre><div class="line">FCNTL(2)                    BSD System Calls Manual                   FCNTL(2)</div><div class="line"></div><div class="line">NAME</div><div class="line">     fcntl -- file control</div><div class="line"></div><div class="line">SYNOPSIS</div><div class="line">     #include &lt;fcntl.h&gt;</div><div class="line"></div><div class="line">     int</div><div class="line">     fcntl(int fildes, int cmd, ...);</div><div class="line"></div><div class="line">DESCRIPTION</div><div class="line">     fcntl() provides for control over descriptors.  The argument fildes is a descriptor to be operated on</div><div class="line">     by cmd as follows:</div><div class="line"></div><div class="line">     F_DUPFD            Return a new descriptor as follows:</div><div class="line"></div><div class="line">                            o   Lowest numbered available descriptor greater than or equal to arg.</div><div class="line">                            o   Same object references as the original descriptor.</div><div class="line">                            o   New descriptor shares the same file offset if the object was a file.</div><div class="line">                            o   Same access mode (read, write or read/write).</div><div class="line">                            o   Same file status flags (i.e., both file descriptors share the same file</div><div class="line">                                status flags).</div><div class="line">                            o   The close-on-exec flag associated with the new file descriptor is cleared</div><div class="line">                                so that the descriptor remains open across an execv(2) system call.</div><div class="line"></div><div class="line">     F_DUPFD_CLOEXEC    Like F_DUPFD, except that the close-on-exec flag associated with the new file</div><div class="line">                        descriptor is set.</div><div class="line"></div><div class="line">     F_GETFD            Get the flags associated with the file descriptor fildes, as described below (arg</div><div class="line">                        is ignored).</div><div class="line"></div><div class="line">     F_SETFD            Set the file descriptor flags to arg.</div><div class="line"></div><div class="line">     F_GETFL            Get descriptor status flags, as described below (arg is ignored).</div><div class="line"></div><div class="line">     F_SETFL            Set descriptor status flags to arg.</div><div class="line"></div><div class="line">     F_GETOWN           Get the process ID or process group currently receiving SIGIO and SIGURG signals;</div><div class="line">                        process groups are returned as negative values (arg is ignored).</div><div class="line"></div><div class="line">     F_SETOWN           Set the process or process group to receive SIGIO and SIGURG signals; process</div><div class="line">                        groups are specified by supplying arg as negative, otherwise arg is interpreted as</div><div class="line">                        a process ID.</div><div class="line"></div><div class="line">     F_GETPATH          Get the path of the file descriptor Fildes.  The argument must be a buffer of size</div><div class="line">                        MAXPATHLEN or greater.</div><div class="line"></div><div class="line">     F_PREALLOCATE      Preallocate file storage space. Note: upon success, the space that is allocated</div><div class="line">                        can be the size requested, larger than the size requested, or (if the</div><div class="line">                        F_ALLOCATEALL flag is not provided) smaller than the space requested.</div><div class="line"></div><div class="line">     F_PUNCHHOLE        Deallocate a region and replace it with a hole. Subsequent reads of the affected</div><div class="line">                        region will return bytes of zeros that are usually not backed by physical blocks.</div><div class="line">                        This will not change the actual file size. Holes must be aligned to file system</div><div class="line">                        block boundaries. This will fail on file systems that do not support this inter-</div><div class="line">                        face.</div><div class="line"></div><div class="line">     F_SETSIZE          Truncate a file without zeroing space.  The calling process must have root privi-</div><div class="line">                        leges.</div><div class="line"></div><div class="line">     F_RDADVISE         Issue an advisory read async with no copy to user.</div><div class="line"></div><div class="line">     F_RDAHEAD          Turn read ahead off/on.  A zero value in arg disables read ahead.  A non-zero</div><div class="line">                        value in arg turns read ahead on.</div><div class="line"></div><div class="line">     F_READBOOTSTRAP    Read bootstrap from disk.</div><div class="line"></div><div class="line">     F_WRITEBOOTSTRAP   Write bootstrap on disk.  The calling process must have root privileges.</div><div class="line"></div><div class="line">     F_NOCACHE          Turns data caching off/on. A non-zero value in arg turns data caching off.  A</div><div class="line">                        value of zero in arg turns data caching on.</div><div class="line"></div><div class="line">     F_LOG2PHYS         Get disk device information.  Currently this only returns the disk device address</div><div class="line">                        that corresponds to the current file offset. Note that the system may return -1 as</div><div class="line">                        the disk device address if the file is not backed by physical blocks. This is sub-</div><div class="line">                        ject to change.</div><div class="line"></div><div class="line">     F_LOG2PHYS_EXT     Variant of F_LOG2PHYS that uses the passed in file offset and length.</div><div class="line"></div><div class="line">     F_FULLFSYNC        Does the same thing as fsync(2) then asks the drive to flush all buffered data to</div><div class="line">                        the permanent storage device (arg is ignored).  This is currently implemented on</div><div class="line">                        HFS, MS-DOS (FAT), and Universal Disk Format (UDF) file systems.  The operation</div><div class="line">                        may take quite a while to complete.  Certain FireWire drives have also been known</div><div class="line">                        to ignore the request to flush their buffered data.</div><div class="line"></div><div class="line">     F_SETNOSIGPIPE     Determines whether a SIGPIPE signal will be generated when a write fails on a pipe</div><div class="line">                        or socket for which there is no reader.  If arg is non-zero, SIGPIPE generation is</div><div class="line">                        disabled for descriptor fildes, while an arg of zero enables it (the default).</div><div class="line"></div><div class="line">     F_GETNOSIGPIPE     Returns whether a SIGPIPE signal will be generated when a write fails on a pipe or</div><div class="line">                        socket for which there is no reader.  The semantics of the return value match</div><div class="line">                        those of the arg of F_SETNOSIGPIPE.</div><div class="line"></div><div class="line">     The flags for the F_GETFD and F_SETFD commands are as follows:</div><div class="line"></div><div class="line">           FD_CLOEXEC   Close-on-exec; the given file descriptor will be automatically closed in the suc-</div><div class="line">                        cessor process image when one of the execv(2) or posix_spawn(2) family of system</div><div class="line">                        calls is invoked.</div><div class="line"></div><div class="line">     The flags for the F_GETFL and F_SETFL commands are as follows:</div><div class="line"></div><div class="line">           O_NONBLOCK   Non-blocking I/O; if no data is available to a read call, or if a write operation</div><div class="line">                        would block, the read or write call returns -1 with the error EAGAIN.</div><div class="line"></div><div class="line">           O_APPEND     Force each write to append at the end of file; corresponds to the O_APPEND flag of</div><div class="line">                        open(2).</div><div class="line"></div><div class="line">           O_ASYNC      Enable the SIGIO signal to be sent to the process group when I/O is possible,</div><div class="line">                        e.g., upon availability of data to be read.</div><div class="line"></div><div class="line">     Several commands are available for doing advisory file locking; they all operate on the following</div><div class="line">     structure:</div><div class="line"></div><div class="line">             struct flock &#123;</div><div class="line">                 off_t       l_start;    /* starting offset */</div><div class="line">                 off_t       l_len;      /* len = 0 means until end of file */</div><div class="line">                 pid_t       l_pid;      /* lock owner */</div><div class="line">                 short       l_type;     /* lock type: read/write, etc. */</div><div class="line">                 short       l_whence;   /* type of l_start */</div><div class="line">             &#125;;</div><div class="line"></div><div class="line">     The commands available for advisory record locking are as follows:</div><div class="line"></div><div class="line">     F_GETLK    Get the first lock that blocks the lock description pointed to by the third argument, arg,</div><div class="line">                taken as a pointer to a struct flock (see above).  The information retrieved overwrites</div><div class="line">                the information passed to fcntl in the flock structure.  If no lock is found that would</div><div class="line">                prevent this lock from being created, the structure is left unchanged by this function</div><div class="line">                call except for the lock type which is set to F_UNLCK.</div><div class="line"></div><div class="line">     F_SETLK    Set or clear a file segment lock according to the lock description pointed to by the third</div><div class="line">                argument, arg, taken as a pointer to a struct flock (see above).  F_SETLK is used to</div><div class="line">                establish shared (or read) locks (F_RDLCK) or exclusive (or write) locks, (F_WRLCK), as</div><div class="line">                well as remove either type of lock (F_UNLCK).  If a shared or exclusive lock cannot be</div><div class="line">                set, fcntl returns immediately with EAGAIN.</div><div class="line"></div><div class="line">     F_SETLKW   This command is the same as F_SETLK except that if a shared or exclusive lock is blocked</div><div class="line">                by other locks, the process waits until the request can be satisfied.  If a signal that is</div><div class="line">                to be caught is received while fcntl is waiting for a region, the fcntl will be inter-</div><div class="line">                rupted if the signal handler has not specified the SA_RESTART (see sigaction(2)).</div><div class="line"></div><div class="line">     When a shared lock has been set on a segment of a file, other processes can set shared locks on that</div><div class="line">     segment or a portion of it.  A shared lock prevents any other process from setting an exclusive lock</div><div class="line">     on any portion of the protected area.  A request for a shared lock fails if the file descriptor was</div><div class="line">     not opened with read access.</div><div class="line"></div><div class="line">     An exclusive lock prevents any other process from setting a shared lock or an exclusive lock on any</div><div class="line">     portion of the protected area.  A request for an exclusive lock fails if the file was not opened with</div><div class="line">     write access.</div><div class="line"></div><div class="line">     The value of l_whence is SEEK_SET, SEEK_CUR, or SEEK_END to indicate that the relative offset,</div><div class="line">     l_start bytes, will be measured from the start of the file, current position, or end of the file,</div><div class="line">     respectively.  The value of l_len is the number of consecutive bytes to be locked.  If l_len is nega-</div><div class="line">     tive, the result is undefined.  The l_pid field is only used with F_GETLK to return the process ID of</div><div class="line">     the process holding a blocking lock.  After a successful F_GETLK request, the value of l_whence is</div><div class="line">     SEEK_SET.</div><div class="line"></div><div class="line">     Locks may start and extend beyond the current end of a file, but may not start or extend before the</div><div class="line">     beginning of the file.  A lock is set to extend to the largest possible value of the file offset for</div><div class="line">     that file if l_len is set to zero. If l_whence and l_start point to the beginning of the file, and</div><div class="line">     l_len is zero, the entire file is locked.  If an application wishes only to do entire file locking,</div><div class="line">     the flock(2) system call is much more efficient.</div><div class="line"></div><div class="line">     There is at most one type of lock set for each byte in the file.  Before a successful return from an</div><div class="line">     F_SETLK or an F_SETLKW request when the calling process has previously existing locks on bytes in the</div><div class="line">     region specified by the request, the previous lock type for each byte in the specified region is</div><div class="line">     replaced by the new lock type.  As specified above under the descriptions of shared locks and exclu-</div><div class="line">     sive locks, an F_SETLK or an F_SETLKW request fails or blocks respectively when another process has</div><div class="line">     existing locks on bytes in the specified region and the type of any of those locks conflicts with the</div><div class="line">     type specified in the request.</div><div class="line"></div><div class="line">     This interface follows the completely stupid semantics of System V and IEEE Std 1003.1-1988</div><div class="line">     (``POSIX.1&apos;&apos;) that require that all locks associated with a file for a given process are removed when</div><div class="line">     any file descriptor for that file is closed by that process.  This semantic means that applications</div><div class="line">     must be aware of any files that a subroutine library may access.  For example if an application for</div><div class="line">     updating the password file locks the password file database while making the update, and then calls</div><div class="line">     getpwname(3) to retrieve a record, the lock will be lost because getpwname(3) opens, reads, and</div><div class="line">     closes the password database.  The database close will release all locks that the process has associ-</div><div class="line">     ated with the database, even if the library routine never requested a lock on the database.  Another</div><div class="line">     minor semantic problem with this interface is that locks are not inherited by a child process created</div><div class="line">     using the fork(2) function.  The flock(2) interface has much more rational last close semantics and</div><div class="line">     allows locks to be inherited by child processes.  Flock(2) is recommended for applications that want</div><div class="line">     to ensure the integrity of their locks when using library routines or wish to pass locks to their</div><div class="line">     children.  Note that flock(2) and fcntl(2) locks may be safely used concurrently.</div><div class="line"></div><div class="line">     All locks associated with a file for a given process are removed when the process terminates.</div><div class="line"></div><div class="line">     A potential for deadlock occurs if a process controlling a locked region is put to sleep by attempt-</div><div class="line">     ing to lock the locked region of another process.  This implementation detects that sleeping until a</div><div class="line">     locked region is unlocked would cause a deadlock and fails with an EDEADLK error.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">     The F_PREALLOCATE command operates on the following structure:</div><div class="line"></div><div class="line">             typedef struct fstore &#123;</div><div class="line">                 u_int32_t fst_flags;      /* IN: flags word */</div><div class="line">                 int       fst_posmode;    /* IN: indicates offset field */</div><div class="line">                 off_t     fst_offset;     /* IN: start of the region */</div><div class="line">                 off_t     fst_length;     /* IN: size of the region */</div><div class="line">                 off_t     fst_bytesalloc; /* OUT: number of bytes allocated */</div><div class="line">             &#125; fstore_t;</div><div class="line"></div><div class="line">     The flags (fst_flags) for the F_PREALLOCATE command are as follows:</div><div class="line"></div><div class="line">           F_ALLOCATECONTIG   Allocate contiguous space.</div><div class="line"></div><div class="line">           F_ALLOCATEALL      Allocate all requested space or no space at all.</div><div class="line"></div><div class="line">     The position modes (fst_posmode) for the F_PREALLOCATE command indicate how to use the offset field.</div><div class="line">     The modes are as follows:</div><div class="line"></div><div class="line">           F_PEOFPOSMODE   Allocate from the physical end of file.</div><div class="line"></div><div class="line">           F_VOLPOSMODE    Allocate from the volume offset.</div><div class="line"></div><div class="line">     The F_PUNCHHOLE command operates on the following structure:</div><div class="line"></div><div class="line">             typedef struct fpunchhole &#123;</div><div class="line">                 u_int32_t fp_flags;     /* unused */</div><div class="line">                 u_int32_t reserved;     /* (to maintain 8-byte alignment) */</div><div class="line">                 off_t     fp_offset;    /* IN: start of the region */</div><div class="line">                 off_t     fp_length;    /* IN: size of the region */</div><div class="line">             &#125; fpunchhole_t;</div><div class="line"></div><div class="line">     The F_RDADVISE command operates on the following structure which holds information passed from the</div><div class="line">     user to the system:</div><div class="line"></div><div class="line">             struct radvisory &#123;</div><div class="line">                off_t   ra_offset;  /* offset into the file */</div><div class="line">                int     ra_count;   /* size of the read     */</div><div class="line">             &#125;;</div><div class="line"></div><div class="line">     The F_READBOOTSTRAP and F_WRITEBOOTSTRAP commands operate on the following structure.</div><div class="line"></div><div class="line">             typedef struct fbootstraptransfer &#123;</div><div class="line">                 off_t fbt_offset;       /* IN: offset to start read/write */</div><div class="line">                 size_t fbt_length;      /* IN: number of bytes to transfer */</div><div class="line">                 void *fbt_buffer;       /* IN: buffer to be read/written */</div><div class="line">             &#125; fbootstraptransfer_t;</div><div class="line"></div><div class="line">     The F_LOG2PHYS command operates on the following structure:</div><div class="line"></div><div class="line">             struct log2phys &#123;</div><div class="line">                 u_int32_t l2p_flags;        /* unused so far */</div><div class="line">                 off_t     l2p_contigbytes;  /* unused so far */</div><div class="line">                 off_t     l2p_devoffset;    /* bytes into device */</div><div class="line">             &#125;;</div><div class="line"></div><div class="line">     The F_LOG2PHYS_EXT command operates on the same structure as F_LOG2PHYS but treats it as an in/out:</div><div class="line"></div><div class="line">             struct log2phys &#123;</div><div class="line">                 u_int32_t l2p_flags;        /* unused so far */</div><div class="line">                 off_t     l2p_contigbytes;  /* IN: number of bytes to be queried;</div><div class="line">                                                OUT: number of contiguous bytes allocated at this position */</div><div class="line">                 off_t     l2p_devoffset;    /* IN: bytes into file;</div><div class="line">                                                OUT: bytes into device */</div><div class="line">             &#125;;</div><div class="line"></div><div class="line">     If fildes is a socket, then the F_SETNOSIGPIPE and F_GETNOSIGPIPE commands are directly analogous,</div><div class="line">     and fully interoperate with the SO_NOSIGPIPE option of setsockopt(2) and getsockopt(2) respectively.</div><div class="line"></div><div class="line">RETURN VALUES</div><div class="line">     Upon successful completion, the value returned depends on cmd as follows:</div><div class="line"></div><div class="line">           F_DUPFD    A new file descriptor.</div><div class="line"></div><div class="line">           F_GETFD    Value of flag (only the low-order bit is defined).</div><div class="line"></div><div class="line">           F_GETFL    Value of flags.</div><div class="line"></div><div class="line">           F_GETOWN   Value of file descriptor owner.</div><div class="line"></div><div class="line">           other      Value other than -1.</div><div class="line"></div><div class="line">     Otherwise, a value of -1 is returned and errno is set to indicate the error.</div><div class="line"></div><div class="line">ERRORS</div><div class="line">     The fcntl() system call will fail if:</div><div class="line"></div><div class="line">     [EAGAIN]           The argument cmd is F_SETLK, the type of lock (l_type) is a shared lock (F_RDLCK)</div><div class="line">                        or exclusive lock (F_WRLCK), and the segment of a file to be locked is already</div><div class="line">                        exclusive-locked by another process; or the type is an exclusive lock and some</div><div class="line">                        portion of the segment of a file to be locked is already shared-locked or exclu-</div><div class="line">                        sive-locked by another process.</div><div class="line"></div><div class="line">     [EACCESS]          The argument cmd is either F_SETSIZE or F_WRITEBOOTSTRAP and the calling process</div><div class="line">                        does not have root privileges.</div><div class="line"></div><div class="line">     [EBADF]            Fildes is not a valid open file descriptor.</div><div class="line"></div><div class="line">                        The argument cmd is F_SETLK or F_SETLKW, the type of lock (l_type) is a shared</div><div class="line">                        lock (F_RDLCK), and fildes is not a valid file descriptor open for reading.</div><div class="line"></div><div class="line">                        The argument cmd is F_SETLK or F_SETLKW, the type of lock (l_type) is an exclusive</div><div class="line">                        lock (F_WRLCK), and fildes is not a valid file descriptor open for writing.</div><div class="line"></div><div class="line">                        The argument cmd is F_PREALLOCATE and the calling process does not have file write</div><div class="line">                        permission.</div><div class="line"></div><div class="line">                        The argument cmd is F_LOG2PHYS or F_LOG2PHYS_EXT and fildes is not a valid file</div><div class="line">                        descriptor open for reading.</div><div class="line"></div><div class="line">     [EDEADLK]          The argument cmd is F_SETLKW, and a deadlock condition was detected.</div><div class="line"></div><div class="line">     [EINTR]            The argument cmd is F_SETLKW, and the function was interrupted by a signal.</div><div class="line"></div><div class="line">     [EINVAL]           Cmd is F_DUPFD and arg is negative or greater than the maximum allowable number</div><div class="line">                        (see getdtablesize(2)).</div><div class="line"></div><div class="line">                        The argument cmd is F_GETLK, F_SETLK, or F_SETLKW and the data to which arg points</div><div class="line">                        is not valid, or fildes refers to a file that does not support locking.</div><div class="line"></div><div class="line">                        The argument cmd is F_PREALLOCATE and the fst_posmode is not a valid mode, or when</div><div class="line">                        F_PEOFPOSMODE is set and fst_offset is a non-zero value, or when F_VOLPOSMODE is</div><div class="line">                        set and fst_offset is a negative or zero value.</div><div class="line"></div><div class="line">                        The argument cmd is F_PUNCHHOLE and either fp_offset or fp_length are negative, or</div><div class="line">                        both fp_offset and fp_length are not multiples of the file system block size.</div><div class="line"></div><div class="line">                        The argument cmd is either F_READBOOTSTRAP or F_WRITEBOOTSTRAP and the operation</div><div class="line">                        was attempted on a non-HFS disk type.</div><div class="line"></div><div class="line">     [EMFILE]           Cmd is F_DUPFD and the maximum allowed number of file descriptors are currently</div><div class="line">                        open.</div><div class="line"></div><div class="line">     [EMFILE]           The argument cmd is F_DUPED and the maximum number of file descriptors permitted</div><div class="line">                        for the process are already in use, or no file descriptors greater than or equal</div><div class="line">                        to arg are available.</div><div class="line"></div><div class="line">     [ENOLCK]           The argument cmd is F_SETLK or F_SETLKW, and satisfying the lock or unlock request</div><div class="line">                        would result in the number of locked regions in the system exceeding a system-</div><div class="line">                        imposed limit.</div><div class="line"></div><div class="line">     [ENOSPC]           The argument cmd is F_PREALLOCATE and either there is no space available on the</div><div class="line">                        volume containing fildes or fst_flags contains F_ALLOCATEALL and there is not</div><div class="line">                        enough space available on the volume containing fildes to satisfy the entire</div><div class="line">                        request.</div><div class="line"></div><div class="line">                        The argument cmd is F_PUNCHHOLE and there is not enough space available on the</div><div class="line">                        volume containing fildes to satisfy the request. As an example, a filesystem that</div><div class="line">                        supports cloned files may return this error if punching a hole requires the cre-</div><div class="line">                        ation of a clone and there is not enough space available to do so.</div><div class="line"></div><div class="line">     [EOVERFLOW]        A return value would overflow its representation.  For example, cmd is F_GETLK,</div><div class="line">                        F_SETLK, or F_SETLKW and the smallest (or, if l_len is non-zero, the largest) off-</div><div class="line">                        set of a byte in the requested segment will not fit in an object of type off_t.</div><div class="line"></div><div class="line">     [EPERM]            The argument cmd is F_PUNCHHOLE and the calling process does not have file write</div><div class="line">                        permission.</div><div class="line"></div><div class="line">     [ESRCH]            Cmd is F_SETOWN and the process ID given as argument is not in use.</div><div class="line"></div><div class="line">SEE ALSO</div><div class="line">     close(2), execve(2), flock(2), getdtablesize(2), open(2), pipe(2), socket(2), setsockopt(2),</div><div class="line">     sigaction(3)</div><div class="line"></div><div class="line">HISTORY</div><div class="line">     The fcntl() function call appeared in 4.2BSD.</div><div class="line"></div><div class="line">4.2 Berkeley Distribution       August 24, 2017      4.2 Berkeley Distribution</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">GETSOCKOPT(2)               BSD System Calls Manual              GETSOCKOPT(2)</div><div class="line"></div><div class="line">NAME</div><div class="line">     getsockopt, setsockopt -- get and set options on sockets</div><div class="line"></div><div class="line">SYNOPSIS</div><div class="line">     #include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">     int</div><div class="line">     getsockopt(int socket, int level, int option_name, void *restrict option_value,</div><div class="line">         socklen_t *restrict option_len);</div><div class="line"></div><div class="line">     int</div><div class="line">     setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);</div><div class="line"></div><div class="line">DESCRIPTION</div><div class="line">     getsockopt() and setsockopt() manipulate the options associated with a socket.  Options may exist at</div><div class="line">     multiple protocol levels; they are always present at the uppermost ``socket&apos;&apos; level.</div><div class="line"></div><div class="line">     When manipulating socket options the level at which the option resides and the name of the option</div><div class="line">     must be specified.  To manipulate options at the socket level, level is specified as SOL_SOCKET.  To</div><div class="line">     manipulate options at any other level the protocol number of the appropriate protocol controlling the</div><div class="line">     option is supplied.  For example, to indicate that an option is to be interpreted by the TCP proto-</div><div class="line">     col, level should be set to the protocol number of TCP; see getprotoent(3).</div><div class="line"></div><div class="line">     The parameters option_value and option_len are used to access option values for setsockopt().  For</div><div class="line">     getsockopt() they identify a buffer in which the value for the requested option(s) are to be</div><div class="line">     returned.  For getsockopt(), option_len is a value-result parameter, initially containing the size of</div><div class="line">     the buffer pointed to by option_value, and modified on return to indicate the actual size of the</div><div class="line">     value returned.  If no option value is to be supplied or returned, option_value may be NULL.</div><div class="line"></div><div class="line">     option_name and any specified options are passed uninterpreted to the appropriate protocol module for</div><div class="line">     interpretation.  The include file &lt;sys/socket.h&gt; contains definitions for socket level options,</div><div class="line">     described below.  Options at other protocol levels vary in format and name; consult the appropriate</div><div class="line">     entries in section 4 of the manual.</div><div class="line"></div><div class="line">     Most socket-level options utilize an int parameter for option_value.  For setsockopt(), the parameter</div><div class="line">     should be non-zero to enable a boolean option, or zero if the option is to be disabled.  SO_LINGER</div><div class="line">     uses a struct linger parameter, defined in &lt;sys/socket.h&gt;, which specifies the desired state of the</div><div class="line">     option and the linger interval (see below).  SO_SNDTIMEO and SO_RCVTIMEO use a struct timeval parame-</div><div class="line">     ter, defined in &lt;sys/time.h&gt;.</div><div class="line"></div><div class="line">     The following options are recognized at the socket level.  Except as noted, each may be examined with</div><div class="line">     getsockopt() and set with setsockopt().</div><div class="line"></div><div class="line">           SO_DEBUG        enables recording of debugging information</div><div class="line">           SO_REUSEADDR    enables local address reuse</div><div class="line">           SO_REUSEPORT    enables duplicate address and port bindings</div><div class="line">           SO_KEEPALIVE    enables keep connections alive</div><div class="line">           SO_DONTROUTE    enables routing bypass for outgoing messages</div><div class="line">           SO_LINGER       linger on close if data present</div><div class="line">           SO_BROADCAST    enables permission to transmit broadcast messages</div><div class="line">           SO_OOBINLINE    enables reception of out-of-band data in band</div><div class="line">           SO_SNDBUF       set buffer size for output</div><div class="line">           SO_RCVBUF       set buffer size for input</div><div class="line">           SO_SNDLOWAT     set minimum count for output</div><div class="line">           SO_RCVLOWAT     set minimum count for input</div><div class="line">           SO_SNDTIMEO     set timeout value for output</div><div class="line">           SO_RCVTIMEO     set timeout value for input</div><div class="line">           SO_TYPE         get the type of the socket (get only)</div><div class="line">           SO_ERROR        get and clear error on the socket (get only)</div><div class="line">           SO_NOSIGPIPE    do not generate SIGPIPE, instead return EPIPE</div><div class="line">           SO_NREAD        number of bytes to be read (get only)</div><div class="line">           SO_NWRITE       number of bytes written not yet sent by the protocol (get only)</div><div class="line">           SO_LINGER_SEC   linger on close if data present with timeout in seconds</div><div class="line"></div><div class="line">     SO_DEBUG enables debugging in the underlying protocol modules.</div><div class="line"></div><div class="line">     SO_REUSEADDR indicates that the rules used in validating addresses supplied in a bind(2) call should</div><div class="line">     allow reuse of local addresses.</div><div class="line"></div><div class="line">     SO_REUSEPORT allows completely duplicate bindings by multiple processes if they all set SO_REUSEPORT</div><div class="line">     before binding the port.  This option permits multiple instances of a program to each receive UDP/IP</div><div class="line">     multicast or broadcast datagrams destined for the bound port.</div><div class="line"></div><div class="line">     SO_KEEPALIVE enables the periodic transmission of messages on a connected socket.  Should the con-</div><div class="line">     nected party fail to respond to these messages, the connection is considered broken and processes</div><div class="line">     using the socket are notified via a SIGPIPE signal when attempting to send data.</div><div class="line"></div><div class="line">     SO_DONTROUTE indicates that outgoing messages should bypass the standard routing facilities.</div><div class="line">     Instead, messages are directed to the appropriate network interface according to the network portion</div><div class="line">     of the destination address.</div><div class="line"></div><div class="line">     SO_LINGER controls the action taken when unsent messages are queued on socket and a close(2) is per-</div><div class="line">     formed.  If the socket promises reliable delivery of data and SO_LINGER is set, the system will block</div><div class="line">     the process on the close attempt until it is able to transmit the data or until it decides it is</div><div class="line">     unable to deliver the information (a timeout period, termed the linger interval, is specified in the</div><div class="line">     setsockopt() call when SO_LINGER is requested).  If SO_LINGER is disabled and a close is issued, the</div><div class="line">     system will process the close in a manner that allows the process to continue as quickly as possible.</div><div class="line"></div><div class="line">     SO_LINGER_SEC is the same option as SO_LINGER except the linger time is in seconds for SO_LINGER_SEC.</div><div class="line"></div><div class="line">     The option SO_BROADCAST requests permission to send broadcast datagrams on the socket.  Broadcast was</div><div class="line">     a privileged operation in earlier versions of the system.</div><div class="line"></div><div class="line">     With protocols that support out-of-band data, the SO_OOBINLINE option requests that out-of-band data</div><div class="line">     be placed in the normal data input queue as received; it will then be accessible with recv or read</div><div class="line">     calls without the MSG_OOB flag.  Some protocols always behave as if this option is set.</div><div class="line"></div><div class="line">     SO_SNDBUF and SO_RCVBUF are options to adjust the normal buffer sizes allocated for output and input</div><div class="line">     buffers, respectively.  The buffer size may be increased for high-volume connections, or may be</div><div class="line">     decreased to limit the possible backlog of incoming data.  The system places an absolute limit on</div><div class="line">     these values.</div><div class="line"></div><div class="line">     SO_SNDLOWAT is an option to set the minimum count for output operations.  Most output operations</div><div class="line">     process all of the data supplied by the call, delivering data to the protocol for transmission and</div><div class="line">     blocking as necessary for flow control.  Nonblocking output operations will process as much data as</div><div class="line">     permitted (subject to flow control) without blocking, but will process no data if flow control does</div><div class="line">     not allow the smaller of the low-water mark value or the entire request to be processed.  A select(2)</div><div class="line">     operation testing the ability to write to a socket will return true only if the low-water mark amount</div><div class="line">     could be processed.  The default value for SO_SNDLOWAT is set to a convenient size for network effi-</div><div class="line">     ciency, often 2048.</div><div class="line"></div><div class="line">     SO_RCVLOWAT is an option to set the minimum count for input operations.  In general, receive calls</div><div class="line">     will block until any (non-zero) amount of data is received, then return with the smaller of the</div><div class="line">     amount available or the amount requested.  The default value for SO_RCVLOWAT is 1.  If SO_RCVLOWAT is</div><div class="line">     set to a larger value, blocking receive calls normally wait until they have received the smaller of</div><div class="line">     the low-water mark value or the requested amount.  Receive calls may still return less than the low-</div><div class="line">     water mark if an error occurs, a signal is caught, or the type of data next in the receive queue is</div><div class="line">     different than that returned.</div><div class="line"></div><div class="line">     SO_SNDTIMEO is an option to set a timeout value for output operations.  It accepts a struct timeval</div><div class="line">     parameter with the number of seconds and microseconds used to limit waits for output operations to</div><div class="line">     complete.  If a send operation has blocked for this much time, it returns with a partial count or</div><div class="line">     with the error EWOULDBLOCK if no data were sent.  In the current implementation, this timer is</div><div class="line">     restarted each time additional data are delivered to the protocol, implying that the limit applies to</div><div class="line">     output portions ranging in size from the low-water mark to the high-water mark for output.</div><div class="line"></div><div class="line">     SO_RCVTIMEO is an option to set a timeout value for input operations.  It accepts a struct timeval</div><div class="line">     parameter with the number of seconds and microseconds used to limit waits for input operations to</div><div class="line">     complete.  In the current implementation, this timer is restarted each time additional data are</div><div class="line">     received by the protocol, and thus the limit is in effect an inactivity timer.  If a receive opera-</div><div class="line">     tion has been blocked for this much time without receiving additional data, it returns with a short</div><div class="line">     count or with the error EWOULDBLOCK if no data were received.  The struct timeval parameter must rep-</div><div class="line">     resent a positive time interval; otherwise, setsockopt() returns with the error EDOM.</div><div class="line"></div><div class="line">     SO_NOSIGPIPE is an option that prevents SIGPIPE from being raised when a write fails on a socket to</div><div class="line">     which there is no reader; instead, the write to the socket returns with the error EPIPE when there is</div><div class="line">     no reader.</div><div class="line"></div><div class="line">     Finally, SO_TYPE, SO_ERROR, SO_NREAD, and SO_NWRITE are options used only with getsockopt().</div><div class="line"></div><div class="line">     SO_TYPE returns the type of the socket, such as SOCK_STREAM; it is useful for servers that inherit</div><div class="line">     sockets on startup.</div><div class="line"></div><div class="line">     SO_ERROR returns any pending error on the socket and clears the error status.  It may be used to</div><div class="line">     check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</div><div class="line"></div><div class="line">     SO_NREAD returns the amount of data in the input buffer that is available to be received.  For data-</div><div class="line">     gram oriented sockets, SO_NREAD returns the size of the first packet -- this differs from the ioctl()</div><div class="line">     command FIONREAD that returns the total amount of data available.</div><div class="line"></div><div class="line">     SO_NWRITE returns the amount of data in the output buffer not yet sent by the protocol.</div><div class="line"></div><div class="line">RETURN VALUES</div><div class="line">     Upon successful completion, the value 0 is returned; otherwise the value -1 is returned and the</div><div class="line">     global variable errno is set to indicate the error.</div><div class="line"></div><div class="line">ERRORS</div><div class="line">     The getsockopt() and setsockopt() system calls will succeed unless:</div><div class="line"></div><div class="line">     [EBADF]            The argument socket is not a valid file descriptor.</div><div class="line"></div><div class="line">     [EFAULT]           The address pointed to by option_value is not in a valid part of the process</div><div class="line">                        address space.  For getsockopt(), this error may also be returned if option_len is</div><div class="line">                        not in a valid part of the process address space.</div><div class="line"></div><div class="line">     [EINVAL]           The option is invalid at the level indicated.</div><div class="line"></div><div class="line">     [ENOBUFS]          Insufficient system resources available for the call to complete.</div><div class="line"></div><div class="line">     [ENOMEM]           Insufficient memory available for the system call to complete.</div><div class="line"></div><div class="line">     [ENOPROTOOPT]      The option is unknown at the level indicated.</div><div class="line"></div><div class="line">     [ENOTSOCK]         The argument socket is not a socket (e.g., a plain file).</div><div class="line"></div><div class="line">     The setsockopt() system call will succeed unless:</div><div class="line"></div><div class="line">     [EDOM]             The argument option_value is out of bounds.</div><div class="line"></div><div class="line">     [EISCONN]          socket is already connected and a specified option cannot be set while this is the</div><div class="line">                        case.</div><div class="line"></div><div class="line">     [EINVAL]           The socket has been shut down.</div><div class="line"></div><div class="line">LEGACY SYNOPSIS</div><div class="line">     #include &lt;sys/types.h&gt;</div><div class="line">     #include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">     The include file &lt;sys/types.h&gt; is necessary.</div><div class="line"></div><div class="line">SEE ALSO</div><div class="line">     socket(2), bind(2), ioctl(2), getprotoent(3), protocols(5)</div><div class="line"></div><div class="line">BUGS</div><div class="line">     Several of the socket options should be handled at lower levels of the system.</div><div class="line"></div><div class="line">HISTORY</div><div class="line">     The getsockopt() system call appeared in 4.2BSD.</div><div class="line"></div><div class="line">4.3-Reno Berkeley Distribution  April 19, 1994  4.3-Reno Berkeley Distribution</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android微信智能心跳方案</title>
    <link href="http://wodekouwei.com/2019/03/12/tips-net-mars-heartbeat/"/>
    <id>http://wodekouwei.com/2019/03/12/tips-net-mars-heartbeat/</id>
    <published>2019-03-12T07:54:04.000Z</published>
    <updated>2019-03-12T09:01:10.883Z</updated>
    
    <content type="html"><![CDATA[<p>前言：在13年11月中旬时，因为基础组件组人手紧张，Leo安排我和春哥去广州轮岗支援。刚到广州的时候，Ray让我和春哥对Line和WhatsApp的心跳机制进行分析。我和春哥抓包测试了差不多两个多礼拜，在我们基本上摸清了Line和WhatsApp的心跳机制后，Ray才告诉我们真正的任务——对微信的固定心跳进行优化，并告诉我们这不是一件容易的事情。于是我和春哥开始构思第一个方案，我们开始想用统计的方法来解决问题，当我们拿着第一个方案和Ray讨论时，发现不能优雅应对Ray的所有提问：1、测试环境的准确性，失败到底是因为网络的特性导致还是因为用户当前的环境变化导致的暂时失败。2、临界值界定，如果方案选中的心跳值是临界值，我们该怎么办。Ray和组件组同事在网络方面有极其丰富的经验，虽然他没有给我们指出明确的方向，但提出的问题帮助我们更快的补齐需要面对的核心问题。这两个问题让我和春哥意识到如果能很好的解决，就可以给出一个比较好的心跳方案。第一个问题我和春哥开始就意识到，第二个问题我们确实在一开始时疏忽了。但直接解决这两个问题确实不容易，这着实让我和春哥迷茫了几天，有两三天在纺园我都没怎么睡着，因为想不到更好的方法。直到有一天思路发生了一些转变，既然最优解比较复杂，为什么不绕过去，使用有损服务理念找次优解呢。让复杂的事情简单化，好了，想到这里突然有一种拨开云雾的感觉。</p>
<p>思路对了，方案就可以做到简单并且可靠，大家可以看到最终的方案是比较简单的，并且效果还挺好的。在方案描述之前大概讲一下减低问题复杂度的方法：</p>
<ol>
<li>延迟心跳测试法：这是测试结果准确的前提保障，我们认为长连接建立后连续三次成功的短心跳就可以很大程度的保证下一次心跳环境是正常的。</li>
<li>成功一次认定，失败连续累积认定：成功是绝对的，连续失败多次才可能是失败。</li>
<li>临界值避免：我们使用比计算出的心跳稍微小一点的值做为稳定心跳避免临界值。</li>
<li>动态调整：即使在一次完整的智能心跳计算过程中，我们没有找到最好的值，我们还有机会来进行校正。</li>
</ol>
<p>当我和春哥想出第二个简单易行的方案后，我们心里就很有底了，去找Ray讨论，Ray听完后一次通过，然后Ray约了Harvey，给Harvey讲完后，Harvey说听起来可以，可以试试。</p>
<p>然后就开始动手，分析竞品加确定方案花了差不多两个月。写心跳的主要代码，只花了一天时间，我记得那天是年会后的一天。回过头来再看这个方案花费的时间还是值得的，后来灰度的统计数据显示，70%用户都可以达到我们的心跳上限。</p>
<p>搞完智能心跳后一段时间在广州没事干，我就跟Ray商量，Ray让我去测试下WebView的性能瓶颈。然后我跟周斯基一起来做这件事，搞完了安卓客户端WebView性能瓶颈测试后，因为怀孕的老婆一个人在深圳，领导就安排我先回深圳了。春哥坚守着把GCM部分完成后才回深圳。</p>
<p>等我们的心跳版本正式发布后，一年前我在公司km上分享了智能心跳方案，吸引不少做push的同事加入了讨论，感觉这方面的交流还是很有必要的。</p>
<p>好了，废话了很多，下面分享一下微信的智能心跳方案细节。由于字数比较多，建议大家使用PC版微信查看。</p>
<h2 id="1-主要目标"><a href="#1-主要目标" class="headerlink" title="1.主要目标"></a>1.主要目标</h2><p>本方案的主要目标是，在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令TCP连接的尽可能大的心跳间隔，从而达到减少安卓微信因心跳引起的空中信道资源消耗，减少心跳Server的负载，以及减少部分因心跳引起的耗电。</p>
<p>主要方法是参考WhatsApp和Line中有价值的做法，结合影响TCP连接寿命的因素，实现Android微信后台自适应心跳算法，同时使用GCM作为辅助通道增加新消息通知的可靠性。</p>
<h2 id="2-WhatsApp、Line、微信的Push策略分析"><a href="#2-WhatsApp、Line、微信的Push策略分析" class="headerlink" title="2. WhatsApp、Line、微信的Push策略分析"></a>2. WhatsApp、Line、微信的Push策略分析</h2><h3 id="2-1-WhatsApp"><a href="#2-1-WhatsApp" class="headerlink" title="2.1 WhatsApp"></a>2.1 WhatsApp</h3><p>在不支持GCM的设备上，采用和微信类似的长连接+心跳策略，WIFI和手机网络下的心跳间隔都为4分45秒，心跳5次后，主动断开连接再重连。</p>
<p>在支持GCM的设备上，主要靠GCM来激活WhatsApp，WhatsApp启动后，会建立一个与服务器的长连接，直接通过此长连接发送Push消息，这个长连接10分钟无消息就会主动断掉，且这十分钟内不做心跳，断掉后WhatsApp客户端和它的服务器不再有连接。当有消息时候，服务器发现没有长连接会发送GCM消息，手机收到GCM消息后，会重新建立长连接来收取消息，10分钟无消息会再断开，如此循环。</p>
<h3 id="2-2-Line"><a href="#2-2-Line" class="headerlink" title="2.2 Line"></a>2.2 Line</h3><p>从测试中发现Line在国内、台湾、美国使用了不同的策略。</p>
<h4 id="2-2-1美国（使用GCM）："><a href="#2-2-1美国（使用GCM）：" class="headerlink" title="2.2.1美国（使用GCM）："></a>2.2.1美国（使用GCM）：</h4><p>启动时，会保持7分钟心跳（CDMA2000网络）维持长连接半小时，之后主动断开长连接。当有消息时，服务器会发送GCM消息，Line客户端接收到GCM消息后，重新建立长连接，并再次用心跳维持半个小时。</p>
<h4 id="2-2-2国内（不使用GCM）："><a href="#2-2-2国内（不使用GCM）：" class="headerlink" title="2.2.2国内（不使用GCM）："></a>2.2.2国内（不使用GCM）：</h4><p>在国内，同样帐号在相同网络，不同的手机上测出了两种策略：</p>
<ul>
<li>长连接+心跳策略（在Galaxy S3上使用），心跳间隔WIFI下是3分20秒，手机网络是7分钟。</li>
<li>轮询策略（在红米和Nexus S上使用），如图2-1所示。与心跳策略的主要区别用红色标出，客户端在长连接建立后也会定时发送请求，Server会回复并且同时关闭长连接。客户端等待轮询间隔T1后再次建立TCP连接。Line会根据手机的活跃状态动态调整T1，调整范围是从最小1分到最大到2小时半。而长连接存活时间T2比较固定，在WIFI下4分钟，手机网络7分钟。如果在T2时收到新消息会延长T2的时间。
<img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312164217.png" alt="图2-1 Line在国内的轮询策略"></li>
</ul>
<h4 id="2-2-3台湾（不使用GCM）："><a href="#2-2-3台湾（不使用GCM）：" class="headerlink" title="2.2.3台湾（不使用GCM）："></a>2.2.3台湾（不使用GCM）：</h4><p>从IBG同事win和guang提供的测试数据中看到，台湾使用的策略跟国内的轮询策略类似。</p>
<h3 id="2-3-微信"><a href="#2-3-微信" class="headerlink" title="2.3 微信"></a>2.3 微信</h3><p>微信没有使用GCM，自己维护TCP长连接，使用固定心跳。</p>
<h3 id="2-4心跳典型值"><a href="#2-4心跳典型值" class="headerlink" title="2.4心跳典型值"></a>2.4心跳典型值</h3><table>
<thead>
<tr>
<th></th>
<th>WhatsApp</th>
<th>Line</th>
<th>GCM</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIFI</td>
<td>4分45秒</td>
<td>3分20秒</td>
<td>15分钟</td>
</tr>
<tr>
<td>手机网络</td>
<td>4分45秒</td>
<td>7分钟</td>
<td>28分钟</td>
</tr>
</tbody>
</table>
<h3 id="2-5Line、WhatsApp、微信Push策略的优点"><a href="#2-5Line、WhatsApp、微信Push策略的优点" class="headerlink" title="2.5Line、WhatsApp、微信Push策略的优点"></a>2.5Line、WhatsApp、微信Push策略的优点</h3><ol>
<li>微信：当前心跳间隔比竞品短，所以微信在新消息提醒上会最及时。</li>
<li>使用GCM：Line和WhatsApp使用GCM策略的最大优点就是省电，以及减轻系统负荷（减少后台应用数目）。</li>
<li>Line：Line的轮询策略，优点是当Line处于活跃状态时，及时收消息。当Line处于不活跃状态时，省电。</li>
</ol>
<h3 id="2-6Line、WhatsApp微信Push策略的不足"><a href="#2-6Line、WhatsApp微信Push策略的不足" class="headerlink" title="2.6Line、WhatsApp微信Push策略的不足"></a>2.6Line、WhatsApp微信Push策略的不足</h3><ol>
<li>微信当前心跳频率相对竞品较大，在耗电、耗流量，占用信令通道等方面有所影响。</li>
<li>Line的轮询策略，导致的问题是消息可能会延迟接收，测试发现最大延迟间隔到2.5小时。</li>
<li>WhatsApp和Line使用Push拉起一个定时长连接策略，缺点是要依赖Google的Push服务，如果Google的Push服务不稳定，消息也会延迟接收。</li>
<li>在国内的移动和联通2G网络下，由于运营商的策略，GCM长连接频繁断连，WhatsApp的Push消息很不及时，体验非常差。</li>
</ol>
<h2 id="3-GCM研究"><a href="#3-GCM研究" class="headerlink" title="3. GCM研究"></a>3. GCM研究</h2><h3 id="3-1-GCM特点"><a href="#3-1-GCM特点" class="headerlink" title="3.1 GCM特点"></a>3.1 GCM特点</h3><ol>
<li>Android2.2以下的手机不支持GCM，2.2到3.0需要安装Google Store并设置Google帐号，4.04及以上版本不需要设置帐号也能支持。</li>
<li>GCM只传递数据（可以传递小于4kb的数据），对这些数据的处理可以全部由开发者控制。</li>
<li>Android应用不需要运行就可以接收消息(通过Android广播)。</li>
<li>GCM不保证发送的消息的顺序，也不保证消息一定能够推送到手机。</li>
</ol>
<h3 id="3-2-GCM心跳策略以及存在的问题"><a href="#3-2-GCM心跳策略以及存在的问题" class="headerlink" title="3.2 GCM心跳策略以及存在的问题"></a>3.2 GCM心跳策略以及存在的问题</h3><ol>
<li>用心跳保活长连接，心跳间隔为WIFI下15分钟，数据网络下28分钟。</li>
<li>Google可以改变所有Android设备的心跳间隔值（目前还未改变过）。</li>
<li>GCM由于心跳间隔固定，并且较长，所以在NAT aging-time设置较小的网络（如联通2G，或有些WIFI环境下）会导致TCP长连接在下一次心跳前被网关释放。造成Push延迟接收。</li>
</ol>
<h3 id="3-3-GCM的可用性及稳定性"><a href="#3-3-GCM的可用性及稳定性" class="headerlink" title="3.3 GCM的可用性及稳定性"></a>3.3 GCM的可用性及稳定性</h3><p>目前测试发现GCM在国内可用性不高，原因有：</p>
<ol>
<li>Android很多被手机厂商定制化，厂商可能会去掉GCM服务。</li>
<li>Android2.2到3.0之间需要安装Google Store并设置Google帐号。</li>
<li>由于国内2G和移动3G的NAT超时时间都小于GCM心跳时间(28分钟)，TCP长连接必然无法保活，每次都要等28分钟心跳失败重连后才能收到Push。</li>
<li>某些运营商可能限制了5228端口，移动3G/2G下，发现几乎无法连接上GCM服务器，也就无法获得GCM通知，WhatsApp放后台10分钟后，经常很长时间都收不到Push消息。</li>
</ol>
<p>在美国3G网络下抓包的24小时，GCM的连接极其稳定，24小时内GCM长连接未曾断过，在台湾3G网络下抓包14个小时，GCM连接也只断过一次。WhatsApp用户在此类地区网络下客户端可以获得很及时的Push通知。</p>
<p>在中国电信3G下抓包，大部分时间GCM连接都比较稳定，只会因为偶尔的DHCP造成断连现象，由于频率很低(平均数小时才发生一次)，对Push体验的影响不大。</p>
<h3 id="3-4-GCM-Server类型"><a href="#3-4-GCM-Server类型" class="headerlink" title="3.4 GCM Server类型"></a>3.4 GCM Server类型</h3><p>GCM提供两种Server模型：</p>
<ol>
<li>HTTP Server : 使用同步接口发送HTTP请求，一次请求可以发给最多1000个设备。</li>
<li>XMPP Server :使用异步接口发送请求，只支持对单个设备（或同一个用户的多个关联设备发送），发送请求并发数须小于1000，支持设备到云端Server发送数据。需要Google将我们的发送Server加入白名单。</li>
</ol>
<h2 id="4-微信可能的改进点探讨"><a href="#4-微信可能的改进点探讨" class="headerlink" title="4.微信可能的改进点探讨"></a>4.微信可能的改进点探讨</h2><p>微信Push的优化主要有几个优化点：</p>
<ol>
<li>公共Push通道</li>
<li>使用GCM Push作为辅助通道</li>
<li>自适应心跳间隔优化</li>
</ol>
<h3 id="4-1-公共Push通道"><a href="#4-1-公共Push通道" class="headerlink" title="4.1 公共Push通道"></a>4.1 公共Push通道</h3><p>由于GCM在国内的可靠性很低，现在国内Android上的Push基本上是各自为政，很多软件都自己实现Push。导致手机被经常性的唤醒，耗电耗流量严重。</p>
<p>市面上已经有很多第三方的公共推送服务，大家可以选择一个适合自己应用的推送服务。腾讯也有信鸽和维纳斯组件，大家在选择方案的时候可以对比下。</p>
<p>最终因为我们国内外使用一套方案，并且是辅助公道，所以我们选择使用GCM。</p>
<h3 id="4-2-使用GCM-Push作为辅助通道"><a href="#4-2-使用GCM-Push作为辅助通道" class="headerlink" title="4.2 使用GCM Push作为辅助通道"></a>4.2 使用GCM Push作为辅助通道</h3><p>当前使用GCM的成本不大，可以使用GCM作为辅助通道来增加新消息的及时性。</p>
<p>使用GCM作为辅助通道，在支持GCM的设备上微信上传自己的注册GCM ID给微信Server。</p>
<p>微信Server在发现长连接失效的情况下，可以使用GCM 作为辅助通道通知客户端有新消息，客户端收到push通知后做一次sync。</p>
<p>只利用GCM来激活微信，不传递消息的具体数据，要控制给同一设备发送GCM通知的时间间隔(如五分钟)。</p>
<h3 id="4-3-自适应心跳间隔优化"><a href="#4-3-自适应心跳间隔优化" class="headerlink" title="4.3 自适应心跳间隔优化"></a>4.3 自适应心跳间隔优化</h3><h4 id="4-3-1影响TCP连接寿命的因素"><a href="#4-3-1影响TCP连接寿命的因素" class="headerlink" title="4.3.1影响TCP连接寿命的因素"></a>4.3.1影响TCP连接寿命的因素</h4><p>在Android下，不管是GCM，还是微信，都是通过TCP长连接来进行Push消息的，TCP长连接存活，消息Push就及时，所以要对影响TCP连接寿命的因素进行研究。</p>
<h5 id="1、NAT超时"><a href="#1、NAT超时" class="headerlink" title="1、NAT超时"></a>1、NAT超时</h5><p>大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断（NAT超时的更多描述见附录6.1）。NAT超时是影响TCP连接寿命的一个重要因素(尤其是国内)，所以客户端自动测算NAT超时时间，来动态调整心跳间隔，是一个重要的优化点。</p>
<h5 id="2、DHCP的租期（lease-time）"><a href="#2、DHCP的租期（lease-time）" class="headerlink" title="2、DHCP的租期（lease time）"></a>2、DHCP的租期（lease time）</h5><p>目前测试发现安卓系统对DHCP的处理有Bug，DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。（租期问题的具体描述见附录6.2）。</p>
<h5 id="3、网络状态变化"><a href="#3、网络状态变化" class="headerlink" title="3、网络状态变化"></a>3、网络状态变化</h5><p>手机网络和WIFI网络切换、网络断开和连上等情况有网络状态的变化，也会使长连接变为无效连接，需要监听响应的网络状态变化事件，重新建立Push长连接。</p>
<h4 id="4-3-2-心跳范围选择"><a href="#4-3-2-心跳范围选择" class="headerlink" title="4.3.2 心跳范围选择"></a>4.3.2 心跳范围选择</h4><h5 id="1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。"><a href="#1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。" class="headerlink" title="1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。"></a>1、前后台区分处理：为了保证微信收消息及时性的体验，当微信处于前台活跃状态时，使用固定心跳。</h5><p>微信进入后台（或者前台关屏）时，先用几次最小心跳维持长链接。然后进入后台自适应心跳计算。这样做的目的是尽量选择用户不活跃的时间段，来减少心跳计算可能产生的消息不及时收取影响。</p>
<h5 id="2、后台自适应心跳选择区间："><a href="#2、后台自适应心跳选择区间：" class="headerlink" title="2、后台自适应心跳选择区间："></a>2、后台自适应心跳选择区间：</h5><p>可根据自身产品的特点选择合适的心跳范围。</p>
<h4 id="4-3-3-状态转换图"><a href="#4-3-3-状态转换图" class="headerlink" title="4.3.3 状态转换图"></a>4.3.3 状态转换图</h4><p><img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312164921.png" alt="tips-net-mars-heartbeat-2019312164921"></p>
<h4 id="4-3-4自适应心跳算法描述"><a href="#4-3-4自适应心跳算法描述" class="headerlink" title="4.3.4自适应心跳算法描述"></a>4.3.4自适应心跳算法描述</h4><h5 id="1、按网络类型区分计算："><a href="#1、按网络类型区分计算：" class="headerlink" title="1、按网络类型区分计算："></a>1、按网络类型区分计算：</h5><p>因为每个网络的NAT时间可能不一致。所以需要区分计算，数据网络按subType做关键字，WIFI按WIFI名做关键字。
对稳定的网络，因为NAT老化时间的存在，在自适应计算态的时候，暂设计以下步骤在当前心跳区间逼近出最大可用的心跳。</p>
<h6 id="a）-变量说明："><a href="#a）-变量说明：" class="headerlink" title="a） 变量说明："></a>a） 变量说明：</h6><ul>
<li>[MinHeart，MaxHeart]——心跳可选区间。</li>
<li>successHeart——当前成功心跳，初始为MinHeart</li>
<li>curHeart——当前心跳初始值为successHeart</li>
<li>heartStep——心跳增加步长</li>
<li>successStep——稳定期后的探测步长</li>
</ul>
<h6 id="b）-最大值探测步骤："><a href="#b）-最大值探测步骤：" class="headerlink" title="b） 最大值探测步骤："></a>b） 最大值探测步骤：</h6><p><img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312165138.png" alt="图4-1 自适应心跳计算流程"></p>
<p>自适应心跳计算流程如图4-1所示，经过该流程，会找到必然使心跳失败的curHeart（或者MaxHeart），为了保险起见，我们选择比前一个成功值稍微小一点的值作为后台稳定期的心跳间隔。</p>
<p>影响手机网络测试的因素太多，为了尽量保证测试结果的可靠性，我们使用延迟心跳测试法。在我们重新建立TCP连接后，先使用 短心跳连续成功三次，我们才认为网络相对稳定，可以使用curHeart进行一次心跳测试。图4-2显示了一次有效心跳测试过程。图4-3显示了在没有达到稳定网络环境时，我们会一直使用固定短心跳直到满足三次连续短心跳成功。</p>
<p>使用延迟心跳测试的好处是，可以剔除偶然失败，和网络变化较大的情况（如地铁），使测试结果相对可靠（五次延迟测试确定结论）。同时在网络波动较大的情况，使用短心跳，保证收取消息相对及时。</p>
<h6 id="c）-运行时的动态调整策略-已经按测算心跳稳定值后"><a href="#c）-运行时的动态调整策略-已经按测算心跳稳定值后" class="headerlink" title="c） 运行时的动态调整策略(已经按测算心跳稳定值后)"></a>c） 运行时的动态调整策略(已经按测算心跳稳定值后)</h6><p><strong>NAT超时值算出来后，在维持心跳的过程中的策略</strong></p>
<ol>
<li>无网络、网络时好时坏、偶然失败、NAT超时变小：在后台稳定期发生心跳发生失败后，我们使用延迟心跳测试法测试五次。如果有一次成功，则保持当前心跳值不变；如果五次测试全失败，重新计算合理心跳值。该过程如图4-4所示，有一点需要注意，每个新建的长连接需要先用短心跳成功维持3次后才用successHeart进行心跳。
<img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312165229.png" alt="图4-2 后台稳定态动态调整心跳策略"></li>
<li>NAT超时变大：以周为周期，每周三将后台稳定态调至自适应计算态，使用心跳延迟法往后探测心跳间隔。</li>
<li>successHeart是NAT超时临界值：因为我们现在选择的是一个比successHeart稍小的值作为稳定值，所以在计算过程中可以避开临界值。当运营商在我们后台稳定期将NAT超时调整为我们当前计算值，那么由于我们每周会去向下探索，所以下一周探测时也可以及时调整正确。</li>
</ol>
<h4 id="4-3-5-冗余Sync和心跳"><a href="#4-3-5-冗余Sync和心跳" class="headerlink" title="4.3.5 冗余Sync和心跳"></a>4.3.5 冗余Sync和心跳</h4><p>在用户的一些主动操作以及联网状态改变时，增加冗余Sync和心跳，确保及时收到消息。</p>
<ol>
<li>当用户点亮屏幕的时候，做一次心跳。</li>
<li>当微信切换到前台时，做一次Sync。</li>
<li>联网时重建信令TCP，做一次Sync</li>
</ol>
<h2 id="5-可能存在的风险及预防措施"><a href="#5-可能存在的风险及预防措施" class="headerlink" title="5. 可能存在的风险及预防措施"></a>5. 可能存在的风险及预防措施</h2><h3 id="5-1-DHCP租期因素"><a href="#5-1-DHCP租期因素" class="headerlink" title="5.1 DHCP租期因素"></a>5.1 DHCP租期因素</h3><ol>
<li>问题：根据目前的测试结果显示，安卓不续约到期的IP Bug，会导致TCP连接在不确定的时间点失效，从而会导致一次心跳失败。</li>
<li>预防：统计后台稳定期的心跳成功率，上报给后台。后台可以按地区分网络监控这个指标的波动，并且后台可以根据不同的波动，动态调整某区域特定网络下可选的心跳区间。</li>
</ol>
<h3 id="5-2-其他影响TCP寿命的因素"><a href="#5-2-其他影响TCP寿命的因素" class="headerlink" title="5.2 其他影响TCP寿命的因素"></a>5.2 其他影响TCP寿命的因素</h3><p>是否有遗漏的因素？欢迎各位联系我反馈。</p>
<h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h2><h3 id="6-1-附录A——NAT超时介绍"><a href="#6-1-附录A——NAT超时介绍" class="headerlink" title="6.1 附录A——NAT超时介绍"></a>6.1 附录A——NAT超时介绍</h3><p>因为 IP v4 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换(Network Address Translation，NAT)。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯。
<img src="http://images.wodekouwei.com/tips-net-mars-heartbeat-2019312165718.png" alt="NAT 功能由图中的 GGSN 模块实现"></p>
<p>大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。下表列出一些已测试过的网络的NAT超时时间(更多数据由于测试条件所限没有测到)：</p>
<table>
<thead>
<tr>
<th>地区/网络</th>
<th>NAT超时时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>中国移动3G和2G</td>
<td>5分钟</td>
</tr>
<tr>
<td>中国联通2G</td>
<td>5分钟</td>
</tr>
<tr>
<td>中国电信3G</td>
<td>大于28分钟</td>
</tr>
<tr>
<td>美国3G</td>
<td>大于28分钟</td>
</tr>
<tr>
<td>台湾3G</td>
<td>大于28分钟</td>
</tr>
</tbody>
</table>
<p>长连接心跳间隔必须要小于NAT超时时间(aging-time)，如果超过aging-time不做心跳，TCP长连接链路就会中断，Server就无法发送Push给手机，只能等到客户端下次心跳失败后，重建连接才能取到消息。</p>
<h3 id="6-2-附录B——安卓DHCP的租期（lease-time）问题"><a href="#6-2-附录B——安卓DHCP的租期（lease-time）问题" class="headerlink" title="6.2 附录B——安卓DHCP的租期（lease time）问题"></a>6.2 附录B——安卓DHCP的租期（lease time）问题</h3><p>目前测试发现安卓系统对DHCP的处理有Bug：</p>
<ol>
<li>DHCP租期到了不会主动续约并且会继续使用过期IP，详细描述见<a href="http://www.net.princeton.edu/android/android-stops-renewing-lease-keeps-using-IP-address-11236.html。这个问题导致的问题表象是，在超过租期的某个时间点（没有规律）会导致IP过期，老的TCP连接不能正常收发数据。并且系统没有网络变化事件，只有等应用判断主动建立新的TCP连接才引起安卓设备重新向DHCP" target="_blank" rel="external">http://www.net.princeton.edu/android/android-stops-renewing-lease-keeps-using-IP-address-11236.html。这个问题导致的问题表象是，在超过租期的某个时间点（没有规律）会导致IP过期，老的TCP连接不能正常收发数据。并且系统没有网络变化事件，只有等应用判断主动建立新的TCP连接才引起安卓设备重新向DHCP</a> Server申请IP租用。</li>
<li>未到租期的一半时间，安卓设备重新向DHCP Server申请IP租用。从目前测试结果来看，这种现象恢复的比较快。</li>
<li>移动2G/3G，联通2G没有抓到DHCP。</li>
<li>美国3G下抓取24小时，没有抓到DHCP。</li>
</ol>
<blockquote>
<p>转自<a href="https://mp.weixin.qq.com/s/ghnmC8709DvnhieQhkLJpA" target="_blank" rel="external">Android微信智能心跳方案</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：在13年11月中旬时，因为基础组件组人手紧张，Leo安排我和春哥去广州轮岗支援。刚到广州的时候，Ray让我和春哥对Line和WhatsApp的心跳机制进行分析。我和春哥抓包测试了差不多两个多礼拜，在我们基本上摸清了Line和WhatsApp的心跳机制后，Ray才告诉我
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信终端跨平台组件 Mars 系列（三）连接超时与IP&amp;Port排序</title>
    <link href="http://wodekouwei.com/2019/03/12/tips-net-mars-ip-sort/"/>
    <id>http://wodekouwei.com/2019/03/12/tips-net-mars-ip-sort/</id>
    <published>2019-03-12T07:53:52.000Z</published>
    <updated>2019-03-12T08:36:48.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mars 是微信官方的终端基础组件，是一个使用 C++ 编写的业务无关、跨平台的基础组件。目前在微信 Android、iOS、Windows、Mac、WP 等多个平台中使用。Mars 主要包括以下几个独立的部分：</p>
<ul>
<li>COMM：基础库，包括socket、线程、消息队列、协程等基础工具；</li>
<li>XLOG：通用日志模块，充分考虑移动终端的特点，提供高性能、高可用、安全性、容错性的日志功能；（详情点击：高性能日志模块xlog）</li>
<li>SDT：网络诊断模块；</li>
<li>STN：信令传输网络模块，负责终端与服务器的小数据信令通道。包含了微信终端在移动网络上的大量优化经验与成果，经历了微信海量用户的考验。</li>
</ul>
<p>Mars 系列开始，将为大家介绍 STN（信令传输网络模块）。由于 STN 的复杂性，该模块将被分解为多个篇章进行介绍。本文主要介绍微信中关于 socket 连接及 IP&amp;Port 选择的思考与设计。</p>
<h2 id="你需要知道的TCP连接"><a href="#你需要知道的TCP连接" class="headerlink" title="你需要知道的TCP连接"></a>你需要知道的TCP连接</h2><p>TCP 协议应该是目前使用的最广泛的传输层协议，它提供了可靠的端到端的传输，为应用的设计节省了大量的工作。TCP 建立连接的”三次握手”与连接终止的“四次挥手”也广为人知。在这简单的 connect 调用中，还能做怎样的思考与设计呢？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int connect(int sockfd, const struct *addr, socklen_t addrlen)</div></pre></td></tr></table></figure></p>
<h3 id="连接的超时重传"><a href="#连接的超时重传" class="headerlink" title="连接的超时重传"></a>连接的超时重传</h3><p>超时与重传是 TCP 协议最核心的部分，在不稳定的移动网络中，超时重传的设计尤为重要。在连接建立的过程中，由于网络本身的不可靠特性，不可避免的需要重传的机制来保障可靠服务。在《TCP/IP详解 卷1》的描述中，在大多数 BSD 实现中，若主动 connect 方没有收到 SYN 的回应，会在第6秒发送第2个 SYN 进行重试，第3个 SYN 则是与第2个间隔24秒。在第75秒还没有收到回应，则 connect 调用返回 ETIMEOUT。</p>
<p>这就意味着，在不能立刻确认失败（例如 unreachable 等）的情况下，需要75秒的时间，才能获得结果。如果真相并不是用户的网络不可用，而是某台服务器故障、繁忙、网络不稳定等因素，那75秒的时间只能尝试1个 IP&amp;Port 资源，对于大多数移动应用而言，是不可接受的。我们需要更积极的超时重传机制！！！</p>
<p>然而，我们并不能修改 TCP 的协议栈，我们只能在应用层进行干预，设计应用层的超时机制。说干就干，这个时候你是否已经在构思新的、应用层的连接超时重传机制了呢？应用层的超时重传，典型做法就是提前结束 connect 的阻塞调用，使用新的 IP&amp;Port 资源进行 connect 重试。但是，我们应该选择怎样的连接超时值呢？4秒？10秒？20秒？30秒？不同的应用场景会有不同的选择。我们来看一下常见的几种场景：</p>
<ul>
<li>连不同 or 网络不可用等</li>
<li>服务器繁忙 or 中间路由故障等</li>
<li>基站繁忙 or 连接信号弱 or 丢包率高等</li>
</ul>
<p>在第一种场景中，连接超时设置不会带来什么区别。在第二种场景中，部分服务器资源或路由不可用，我们希望连接超时能稍微短一些，使得我们能尽快的发现故障，并且通过更换 IP&amp;Port 的方式获得可用资源或路由路径。而第三种场景则是在移动网络中经常遇到的弱网络的场景。在这种场景中，我们更换 IP&amp;Port 资源也是无效的，因此希望连接超时能相对长一些，进行更多的TCP层的重传。（当然，也不是超时越长越好，后面的分析可以看到很多等待时长是效果低微的）</p>
<p>不同的场景对连接超时有不同的需求，然而，我们在程序中并没有很好的方法来区分这些场景。在进行连接超时这个阈值的选择前，我们先来看看，当前主流的 android、iOS 操作系统的连接设计。android 的 TCP 层连接超时重传如下图所示（测试机型为 nexus5，android 4.4）。超时间隔依次为（1，2，4，8，16），第5次重试后32秒返回 ETIMEOUT，总用时63秒。超时设置符合 Linux 的常规设置。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162610.png" alt="tips-net-mars-ip-sort-2019312162610"></p>
<p>但在不同的机型中，偶尔会出现差异性。如下图 android 抓包（三星 android 4.4）。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162636.png" alt="tips-net-mars-ip-sort-2019312162636"></p>
<p>iOS 的 connect 超时重传如下图所示。超时间隔依次为（1，1，1，1，1，2，4，8，16，32），总共是67s。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162711.png" alt="tips-net-mars-ip-sort-2019312162711"></p>
<p>经过 tcpdump 的调研分析后，我们发现：</p>
<ol>
<li>在 iOS 系统中对 connect 的超时重传进行了一定的修改，在 connect 初期使用更积极的策略，以适应移动网络的不稳定特征。而在 android 系统中，connect 超时重传则使用了较为“懒惰”、适用于有线网络的超时重传间隔；</li>
<li>不管什么平台，连接总超时时长都需要1分钟左右，这个时长在大多数移动应用中，都是不符合用户体验要求的；</li>
<li>连接的初始阶段，TCP 超时重传会更积极一些，越到后面，重传间隔越大。</li>
</ol>
<p>因此，在实际的连接超时设置上，我们根据不同的系统特征，结合应用能接受的“用户体验”范围，可以设置不同的连接超时间隔。例如在 iOS 系统中，由于采用了较为积极的超时间隔，我们可以将 connect 调用的超时设置为10s。在10s内，iOS 会自动进行6次的重发。在 android 系统中，系统会在第7秒发起第3次重发，之后需要在第15秒才会重发。在不同的用户体验要求下，应用可以将 connect 的调用超时设置为不同的值。例如也可以设置为10s（意味着给第3次重发3s的等待时间），从而避免无效的等待时长。同时通过更换 IP&amp;Port 后，重新调用 connect 操作的方式，来获得更积极的重发策略，更快的查找到可用的 IP&amp;Port 组合。</p>
<h3 id="连接的终止"><a href="#连接的终止" class="headerlink" title="连接的终止"></a>连接的终止</h3><p>“四次挥手”的连接终止协议已经口熟能详。过程如下图所示。需要关注的是，图中主动关闭的一方会进入 TIME_WAIT 状态，在此状态中通常将停留2倍的 MSL 时长。MSL 时长在不同的操作系统中有不同的设置，通常在30秒到60秒。TIME_WAIT 的数量太多会导致耗尽主动关闭方的 socket 端口和句柄，导致无法再发起新的连接，进而严重影响主动关闭方的并发性能。虽然在实际的使用中，可以通过 tcp_tw_recycle，tcp_tw_reuse，tcp_max_tw_buckets 等方式缓解该问题，但也会带来一些副作用。最好的解决方案是在协议的设计上，尽量的由终端来发起关闭的操作，避免服务器的大量 TIME_WAIT 状态。例如，使用长连接避免频繁的关闭；在短连接的协议设计上，务必加上终止标记（例如 http 头部加上 content-length ）使得可以由终端来发起关闭的操作。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312162922.png" alt="tips-net-mars-ip-sort-2019312162922"></p>
<h3 id="串行连接-VS-并发连接-VS-复合连接"><a href="#串行连接-VS-并发连接-VS-复合连接" class="headerlink" title="串行连接 VS 并发连接 VS 复合连接"></a>串行连接 VS 并发连接 VS 复合连接</h3><p>在上述的连接超时策略中，我们选择10秒的连接超时。这就意味着我们需要10秒的时间来确认一个 IP&amp;Port 组合的 connect 超时。当我们有多个 IP&amp;Port 资源时，遍历的效率偏低。那我们是否能设置 connect 的超时为更短呢？例如4秒。我们知道移动互联网具有不稳定的特征，超时时间设置过短，会导致在弱网络的情况下，connect 总是失败，导致不可用。串行连接的策略在超时选择上，由于需要兼顾高性能与高可用的设计目标，使得该策略是一个相对“慢”的连接策略。</p>
<p>与此相应，我们会想到并发连接的策略。并发连接，同时发起对N个 IP&amp;Port 的连接调用，可以让我们第一时间发现可用的连接，并且还顺带发现了 connect 最快的 IP&amp;Port 配置。并发连接可以一举解决了“高性能”、“高可用”的设计目标，看起来很完美。然而，这个时候，服务端的同学“跳”起来了。在并发连接的策略下，服务器需要提供的连接能力是串行连接的N倍，对服务器连接资源是极大的浪费。同时，并发连接是否会引起连接资源的竞争，从而影响网络正常用户的常规体验，也是个未知的因素。</p>
<p>让我们来回顾串行连接与并行连接的优缺点。</p>
<h4 id="串行连接"><a href="#串行连接" class="headerlink" title="串行连接"></a>串行连接</h4><ul>
<li>资源占用少</li>
<li>无服务器负载问题</li>
<li>超时选择困难</li>
<li>最慢可用</li>
</ul>
<h4 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h4><ul>
<li>网络资源竞争</li>
<li>服务器负载高</li>
<li>最快可用</li>
</ul>
<p>那么，有没有一种策略，能同时满足高性能、高可用、低负载的目标呢？在微信的连接设计中，我们使用了”复合连接“的策略。如下图所示。
<img src="http://images.wodekouwei.com/tips-net-mars-ip-sort-2019312163133.png" alt="tips-net-mars-ip-sort-2019312163133"></p>
<p>初始阶段，应用发起对 IP1 &amp;Port1 的 connect 调用。在第4秒的时候，如果第一个 connect 还没有返回，则发起对 IP2 &amp;Port2 的 connect 调用。以此类推，直至发起了5组 IP&amp;Port 的 connect 调用。 </p>
<ul>
<li>对比串行连接与并行连接，复合连接有以下特点：</li>
<li>常规情况下，服务器负载与串行连接策略相同，实现了低负载的目标；</li>
<li>异常情况下，每4s发起新（IP，Port）组合的 connect 调用，使得应用可以快速的查找可用 IP&amp;Port，实现高性能的目标；</li>
<li>在超时时间的选择上，复合方式的“并发”已经实现了高性能、低负载的目标，因此在超时时间的选择上可以相对宽松，以保障高可用为重。</li>
</ul>
<p>综合对比，复合连接能够维持低资源消耗的情况下，能同时实现低负载、高性能、高可用的目标。</p>
<h2 id="微信-IP-amp-Port-排序算法的演进"><a href="#微信-IP-amp-Port-排序算法的演进" class="headerlink" title="微信 IP&amp;Port 排序算法的演进"></a>微信 IP&amp;Port 排序算法的演进</h2><p>在建立连接的调用中，除了超时时间的设置外，IP&amp;Port是连接的最重要参数。IP&amp;Port 的排序、选择对于 connect 的性能也是有着重大的影响。本节主要讨论在已知 IP 列表、Port 列表的情况下，如何排序、组合的问题，而不讨论如何获得就近接入等问题。</p>
<h3 id="IP-amp-Port-的组成"><a href="#IP-amp-Port-的组成" class="headerlink" title="IP&amp;Port 的组成"></a>IP&amp;Port 的组成</h3><p>在微信中，IP有多种来源类型。优先级从上而下分别为：</p>
<ul>
<li>WXDNS IP</li>
<li>DNS IP</li>
<li>Auth IP</li>
<li>Hardcode IP</li>
</ul>
<p>WXDNS IP 是通过微信自建的 DNS 服务获得的IP列表，自建 DNS 对防劫持、有效期控制等有重要作用。DNS IP 则是通过常规的 DNS 解析获得的 IP 列表。Auth IP 是微信动态下发的保底IP列表。而Hardcode IP 则是最终的保底IP列表。总体而言，分为常规IP列表、保底IP列表两个类别。WXDNS IP、DNS IP 为常规列表，Auth IP，Hardcode IP 为保底列表。同时，在组成实际使用的 IP&amp;Port 列表时，由于 WXDNS 与 DNS 的功能近似，因此通常只出现其中一种类型的IP列表。Auth IP 与Hardcode IP 的功能近似，也是同时只能出现两者中的一种类型。 
在 Port 的选择上，微信服务在常规情况下提供2个端口，预防端口被封锁的情况。特别情况下，可以通过配置下发进行端口更新。</p>
<h3 id="IP-amp-Port排序算法（一）：随机组合排序算法"><a href="#IP-amp-Port排序算法（一）：随机组合排序算法" class="headerlink" title="IP&amp;Port排序算法（一）：随机组合排序算法"></a>IP&amp;Port排序算法（一）：随机组合排序算法</h3><p>每个TCP连接都是以 IP&amp;Port 的组合为唯一标识。在 IP&amp;Port 的选择上，我们初步归纳为2个目标：</p>
<ul>
<li>高可用：尽快的找到可用的 IP&amp;Port 资源</li>
<li>高性能：优先使用质量好的 IP&amp;Port</li>
<li>负载均衡：IP的排序算法不带任何偏向因子，避免造成人为的负载不均衡</li>
</ul>
<p>在微信早期的排序选择上，我们使用了一种随机组合的排序算法。即将 WXDNS or DNS IP 列表与 Port 列表进行组合，组合后的结果进行随机排序。在随机排序的结果列表中，使用下述步骤进行排序：</p>
<ol>
<li>选取IP1+Port1；</li>
<li>选取IP2+Port2，尽量使得IP1与IP2不相等，Port1与Port2不相等；</li>
<li>选取IP3+Port3，尽量使得IP3与IP1、IP2都不相等，Port3与Port1、Port2都不相等；</li>
<li>以此类推，形成常规列表。</li>
</ol>
<p>同理，使用 Auth IP or Hardcode IP 列表与 Port 列表的组合，我们按照相同算法生成另外一份保底列表，并将保底列表排序在常规列表的后面，从而组成完整的 IP&amp;Port 列表。随机组合排序的算法有着以下的特点：</p>
<ul>
<li>高性能：每一次尝试都尽量使用完全不同的资源，使得能最快的发现可用资源；</li>
<li>初始随机，从而避免列表顺序的固化；</li>
<li>保底列表在最后，形成最后的保护屏障；</li>
<li>在不同的网络下，维护着不同的资源列表。</li>
</ul>
<p>在使用中，如果发现 IP&amp;Port 访问失败，则在列表中 ban 掉该资源。这里有个小优化，即当 IP1&amp;Port1 的上一次访问成功时，需要连续失败2次才 ban 该资源。目的是为了减小偶然的网络抖动造成的影响。</p>
<p>随机组合排序算法的设计初衷，是为了以最快的速度尝试不同的资源组合，从而快速寻找到可用的资源。然而，在微信的实际使用中，却发现这种算法存在着诸多的问题。例如：</p>
<ul>
<li>网络不可用或网络较大波动情况下，列表被ban的速度较快；</li>
<li>Auth IP or Hardcode IP 列表太容易被访问到：随着常规资源陆续被ban，保底资源总是会被访问到，造成对保底资源的访问量大。保底资源是为了微信服务这不符合保底资源的设计初衷。</li>
<li>当引入复合连接策略后，IP资源不足。这是因为 ban 的策略简单粗暴的丢弃失败的 IP，导致 IP 资源越来越少；</li>
<li>每次缓存超时或列表轮空后，对于新列表没有经验信息可用</li>
</ul>
<p>在随机组合排序算法的基础上，为了解决遇到的新问题，微信使用了新的“以史为鉴”的算法。</p>
<h3 id="IP-amp-Port-排序算法（二）：以史为鉴"><a href="#IP-amp-Port-排序算法（二）：以史为鉴" class="headerlink" title="IP&amp;Port 排序算法（二）：以史为鉴"></a>IP&amp;Port 排序算法（二）：以史为鉴</h3><p>由于复合连接的引入，在每次复合连接的尝试中，微信可以伪“并发”的对N个 IP&amp;Port 进行 connect（微信中目前N=5）。简单的ban丢弃的策略会使得 IP 资源越来越少。 针对这个特点，我们对IP&amp;Port算法进行了以下修改：</p>
<ul>
<li>初始资源列表分为两类列表：常规列表，保底列表，分别使用方案（一）随机组合排序算法生成初始顺序；</li>
<li>对每次复合连接使用的列表，规定5个资源的组成是4个常规资源+1个保底资源，并且保底资源在最后（完全无法获取常规资源的情况除外）。这种资源组成方式一方面解决了“保底资源太容易被访问到”的问题，一方面也保障了保底资源的作用；</li>
<li>在不同网络中，分别记录每个 IP&amp;Port 的使用情况，并根据使用记录进行评分、排序；</li>
<li>区分连续记录：对每个 IP&amp;Port 的更新，10秒内的连续成功或失败，不进行使用情况的记录。这种处理方式一方面是为了避免网络不可用或网络出现较大波动时，IP资源被过快的错误标记；一方面也避免失败历史被快速的覆盖；</li>
<li>最近的8条使用记录中，如果有超过3条失败记录，且最新一次失败记录时间为10分钟内，则本次排序ban该记录。这种处理方式的目的是避免历史分数较高的 IP&amp;Port 在突然出现故障时很难被排序算法排除的问题；</li>
<li>无历史的记录使用随机评分排序。</li>
</ul>
<p>通过上述方法，我们保证了保底资源不会被轻易访问到，解决了列表被快速标记的问题，同时也保证了历史记录好的资源在出现故障时也能被快速替换。</p>
<h3 id="IP-amp-Port-排序算法（三）：遗忘历史"><a href="#IP-amp-Port-排序算法（三）：遗忘历史" class="headerlink" title="IP&amp;Port 排序算法（三）：遗忘历史"></a>IP&amp;Port 排序算法（三）：遗忘历史</h3><p>“以史为鉴”的方案在微信中使用了一段时间，看起来运行良好。直至某一天，微信的部分服务集群出现了故障。虽然微信客户端快速的切换到可用的服务器资源，但当故障服务器恢复后，微信客户端却迟迟没有分流到已恢复服务的集群，导致部分微信服务器负载过高，而部分微信服务器却负载较低的情况。通过分析，发现“以史为鉴”的排序方案存在着一些问题：</p>
<ul>
<li>初始阶段排在前面的资源容易获得较多的成功记录，从而分数始终维持在较高的水平；</li>
<li>出灾情况下，故障机器由于有失败记录，使得很难获得“被原谅”的机会，从而也很难更新使用历史；</li>
<li>采用了无历史记录随机评分，破坏了原有的“相邻记录尽量不相同”的随机性设计；
因此，好的 IP&amp;Port 排序算法，不仅应该快速的发现可用的资源，使得在出灾情况下能快速的响应，同时，也应该具备一定的“遗忘性”、“容灾性”，使得灾情恢复后能较快的发现“灾情恢复”这一事实，并且进行重排序，使得服务器资源得到更合理的使用。在综合考虑“以史为鉴”和“遗忘历史”后，新的 方案具有以下特征：</li>
<li>内存历史、文件历史双层记录历史：反映资源使用的近期情况及历史情况；</li>
<li>初始化状态：每次进程重启或网络切换后，从文件历史中“压缩”出内存历史作为初始状态；</li>
<li>旁路检测：额外更新历史的渠道，更有助于挑选高性能的资源，并且帮助“灾情恢复”的资源获得使用的机会；</li>
<li>文件历史的遗忘性：文件历史每24小时强制刷新，避免高分数的记录长期“占有”队列；</li>
<li>无历史、有历史的混合排序。</li>
</ul>
<p>具体实现查看 Mars 源代码中的 simple_ipport_sort。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连接是信令传输的前提，一个简单的连接操作蕴含着不少的优化空间。在连接超时的选择上，我们要兼顾性能与可用性，过短的连接超时可能导致弱网络下的低可用性，但过长的连接超时又影响用户体验。在 STN 中，我们结合系统本身的 TCP 连接重传特性，进行了相应的设计考量。即使如此，串行的连接方案仍然不能满足高性能的需求。并发连接的方案获得高性能的同时，也带来了服务器负载剧增的损失。综合考虑下，STN 使用了“复合连接”的方案，获得高性能的同时，也保证通常情况下的服务器低负载。</p>
<p>IP&amp;Port 是连接的最重要资源，IP&amp;Port 的排序选择是连接过程的重要部分。在微信的实际使用中，我们依次使用了“随机组合”、“以史为鉴”、“遗忘历史”三种方案，综合的考虑了查找性能、移动互联网的不稳定性、容灾及容灾恢复等。</p>
<p>连接超时、连接策略及 IP&amp;Port 排序是连接的是三个重要组成部分，相关的方案也随着微信实践在不断的发展中。相信在不同的应用场景中，我们可能会遇到更多的不同问题及需求。随着Mars的开源，也能有机会参考、吸收其他应用中的实战经验，使得网络优化持续的深入。</p>
<blockquote>
<p>转自<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286458&amp;idx=1&amp;sn=320f690faa4f97f7a49a291d4de174a9&amp;chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd" target="_blank" rel="external">微信终端跨平台组件 Mars 系列（三）连接超时与IP&amp;Port排序</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Mars 是微信官方的终端基础组件，是一个使用 C++ 编写的业务无关、跨平台的基础组件。目前在微信 Android、iOS、Windows
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信终端跨平台组件 mars 系列(二) - 信令传输超时设计</title>
    <link href="http://wodekouwei.com/2019/03/12/tips-net-mars-timeout/"/>
    <id>http://wodekouwei.com/2019/03/12/tips-net-mars-timeout/</id>
    <published>2019-03-12T07:53:08.000Z</published>
    <updated>2019-03-12T09:36:01.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>mars 是微信官方使用 C++ 编写的业务性无关、平台性无关的终端基础组件，目前在微信 Android、iOS、Windows、Mac、Windows Phone 等多个平台中使用，并正在筹备开源，它主要包含以下几个独立的部分：</p>
<ol>
<li>COMM：基础库，包括 socket、线程、消息队列、协程等基础工具；</li>
<li>XLOG：通用日志模块，充分考虑移动终端的特点，提供高性能、高可用、安全性、容错性的日志功能；（详情点击：高性能日志模块xlog ）</li>
<li>SDT：网络诊断模块；</li>
<li>STN：信令传输网络模块，负责终端与服务器的小数据信令通道。包含了微信终端在移动网络上的大量优化经验与成果，经历了微信海量用户的考验。</li>
</ol>
<p>本篇文章将为大家介绍 STN（信令传输网络模块），由于 STN 的复杂性，该模块将被分解为多个篇章进行介绍，本文主要内容为微信中关于读写超时的思考与设计。</p>
<h2 id="读写超时与设计目标"><a href="#读写超时与设计目标" class="headerlink" title="读写超时与设计目标"></a>读写超时与设计目标</h2><h3 id="TCP-IP中的超时设计"><a href="#TCP-IP中的超时设计" class="headerlink" title="TCP/IP中的超时设计"></a>TCP/IP中的超时设计</h3><p>微信信令通信主要使用 TCP/IP 协议，数据经过应用层、传输层、网络层、链路层（见图1）。其中，链路层与传输层，协议提供了超时重传的机制。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-201931215560.png" alt="图1 使用 TCP/IP 协议"></p>
<h3 id="链路层的超时与重传"><a href="#链路层的超时与重传" class="headerlink" title="链路层的超时与重传"></a>链路层的超时与重传</h3><p>在链路层，一般使用混合自动重传请求（即 HARQ）。HARQ 是一种结合 FEC（前馈式错误修正）与 ARQ（自动重传请求）的技术，原理如图2所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155629.png" alt="图2 HARQ 原理"></p>
<p>通过使用确认和超时这两个机制，链路层在不可靠物理设备的基础上实现可靠的信息传输。这个方案需要手机和 RNC 都支持，目前在 EDGE、HSDPA、HSUPA、UMTS和 LTE 上都已实现支持。</p>
<h3 id="传输层的超时与重传"><a href="#传输层的超时与重传" class="headerlink" title="传输层的超时与重传"></a>传输层的超时与重传</h3><p>传输层（即 TCP 层）提供可靠的传输，然而，TCP 层依赖的链路本身是不可靠的，TCP 是如何在不可靠的环境中提供可靠服务的呢？答案是超时和重传。TCP 在发送数据时设置一个定时器，当定时器溢出还没有收到 ACK，则重传该数据。因此，超时与重传的关键之处在于如何决定定时器间隔与重传频率。</p>
<p>传统 Unix 实现中，定时器的间隔取决于数据的往返时间（即 RTT），根据 RTT 进行一定的计算得到重传超时间隔（即 RTO）。由于网络路由、流量等的变化，RTT 是经常发生变化的，RTT 的测量也极为复杂（平滑算法、Karn 算法、Jacbson 算法等）。在《TCP/IP详解》中，实际测量的重传机制如图3所示，重传的时间间隔，取整后分别为1、3、6、12、24、48和多个64秒。这个倍乘的关系被称为“指数退避”。</p>
<p><img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155711.png" alt="图3 实际测量的重传机制"></p>
<p>在移动终端中，RTO 的设计以及重试频率的设计是否与传统实现一致呢？对此我们进行了实测，实测数据如下：</p>
<p>图4所示为OPPO手机TCP超时重传的间隔，依次为[ 0.25s，0.5s，1s，2s，4s，8s，16s，32s，64s，64s，64s …]：
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155757.png" alt="图4 OPPO 手机 TCP 超时重传间隔"></p>
<p>而 SamSung 中 TCP 超时重传的间隔依次为[0.42s, 0.9s, 1.8s, 3.7s, 7.5s, 15s, 30s, 60s, 120s, 120s …]，见图5。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155816.png" alt="图5 三星手机 TCP 超时重传间隔"></p>
<p>经过多次实际测试我们可以看出虽然由于不同厂商的 Android 系统实现，RTO 的值可能会有不同的设定，但都基本符合“指数退避”原则。</p>
<p>接下来再看 iOS 系统中，TCP RTO 的实验数据，图6所示为实验中第一次的数据[ 1s，1s，1s，2s，4.5s，9s，13.5s，26s，26s … ]。</p>
<p><img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155855.png" alt="图6 iOS 系统 TCP RTO 第一次实验数据"></p>
<p>上面的数据看起来并不完全符合指数退避，开始阶段的重试会较为频繁且 RTO 最终固定在 26s 这一较小的值上。</p>
<p>进行第二次测试后发现数据有了新的变化[1s，1s，1s，2s，3.5s，8.5s，12.5s，24s，24s …]，如图7所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312155936.png" alt="图7 iOS 系统 TCP RTO 第二次实验数据"></p>
<p>RTO 终值由26秒缩减至24秒，最终经过多次测试并未发现 iOS 中 TCP RTO 的规律，但可以看出 iOS 确实采用了较为激进的超时时间设定，对重试更为积极。</p>
<h3 id="读写超时的目标"><a href="#读写超时的目标" class="headerlink" title="读写超时的目标"></a>读写超时的目标</h3><p>通过上述的调研与实验，可以发现在 TCP/IP 中，协议栈已经帮助我们进行了超时与重传的控制。并且在 Android、iOS 的移动操作系统中进行了优化，使用了更为积极的策略，以适应移动网络不稳定的特征。</p>
<p>那是否意味着我们的应用层已经不需要超时与重传的控制了呢？其实不然。在链路层，HARQ 提供的是节点之间每一数据帧的可靠传输；在传输层，TCP 超时重传机制提供的是端与端之间每个 TCP 数据包的可靠传输；同理，在微信所处的应用层中，我们仍然需要提供以“请求”为粒度的可靠传输。</p>
<p>那么，应用层的超时重传机制应该提供怎样的服务呢？</p>
<p>首先，我们来看一下应用层重传的做法。在应用层中，重传的做法是：断掉当前连接，重新建立连接并发送请求。这种重传方式能带来怎样的作用呢？回顾 TCP 层的超时重传机制可以发现，当发生超时重传时，重传的间隔以“指数退避”的规律急剧上升。在 Android 系统中，直到16分钟，TCP 才确认失败；在 iOS 系统中，直到1分半到3分半之间，TCP 才确认失败。这些数值在大部分应用中都是不为“用户体验”所接受的。因此，应用层的超时重传的目标首先应是：
<strong>在用户体验的接受范围内，尽可能地提高成功率</strong>
尽可能地增加成功率，是否意味着在有限的时间内，做尽可能多的重试呢？其实不然。当网络为高延迟/低速率的网络时，较快的应用层重传会导致“请求”在这种网络下很难成功。因此，应用层超时重传的目标二：
<strong>保障弱网络下的可用性</strong>
TCP连接是有固定物理线路的连接，当已 Connect 的线路中，如果中间设备出现较大波动或严重拥塞，即使在限定时间内该请求能成功，但带来的却是性能低下，反应迟钝的用户体验。通过应用层重连，期待的目标三是：
<strong>具有网络敏感性，快速的发现新的链路</strong></p>
<p>我们总结应用层超时重传，可以带来以下作用：</p>
<ol>
<li>减少无效等待时间，增加重试次数：当 TCP 层的重传间隔已经太大的时候，断连重连，使得 TCP 层保持积极的重连间隔，提高成功率；</li>
<li>切换链路：当链路存在较大波动或严重拥塞时，通过更换连接（一般会顺带更换IP&amp;Port）获得更好的性能。</li>
</ol>
<h2 id="微信读写超时"><a href="#微信读写超时" class="headerlink" title="微信读写超时"></a>微信读写超时</h2><h3 id="方案一：总读写超时"><a href="#方案一：总读写超时" class="headerlink" title="方案一：总读写超时"></a>方案一：总读写超时</h3><p>在TCP层的超时重传设计中，超时间隔取决于RTT，RTT即TCP包往返的时间。同理，在微信的早期设计中，我们分析应用层“请求”的往返时间，将其RTT分解为：</p>
<ul>
<li>请求发送耗时 - 类比TCP包传输耗时；</li>
<li>响应信令接收耗时 - 类比ACK传输耗时；</li>
<li>服务器处理请求耗时 - TCP接收端接收和处理数据包的时间相对固定，而微信服务器由于信令所属业务的不同，逻辑处理的耗时会差异明显，所以无法类比；</li>
<li>等待耗时 - 受应用中请求并发数影响。</li>
</ul>
<p>因此，我们提出了应用层的总读写超时如图8所示，最低网速根据不同的网络取不同的值。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-201931216249.png" alt="图8 应用层的总读写超时"></p>
<h3 id="方案二：分步的读写超时"><a href="#方案二：分步的读写超时" class="headerlink" title="方案二：分步的读写超时"></a>方案二：分步的读写超时</h3><p>在实际的使用过程中，我们发现这仅仅是一个可用的方案，并不是一个高性能的解决方案：超时时长的设置使用了差网络下、完整的完成单次信令交互的时间估值。这使得超时时间过长，在网络波动或拥塞时，无法敏感地发现问题并重试。进一步分析可以发现，我们无法预知服务器回包的大小，因此使用了最大的回包进行估算（微信中目前最大回包可到 128KB）。然而，TCP 传输中当发送数据大于 MSS 时，数据将被分段传输，分段到达接收端后重新组合。如果服务器的回包较大，客户端可能会收到多个数据段。因此，我们可以对首个数据分段的到达时间进行预期，从而提出首包超时，如图9所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-201931216413.png" alt="图9 首包超时计算"></p>
<p>首包超时缩短了发现问题的周期，但是我们发现如果首个数据分段按时到达，而后续数据包丢失的情况下，仍然要等待整个读写超时才能发现问题。为此我们引入了包包超时，即两个数据分段之间的超时时间。因为包包超时在首包超时之后，这个阶段已经确认服务器收到了请求，且完成了请求的处理，因此不需要计算等待耗时、请求传输耗时、服务器处理耗时，只需要估算网络的 RTT。</p>
<p>在目前方案中，使用了不同网络下的固定 RTT。由于有了“首包已收到”的上下文，使得包包超时的间隔大大缩短，从而提高了对网络突然波动、拥塞、突发故障的敏感性，使得应用获得较高的性能。</p>
<h3 id="方案三：动态的读写超时"><a href="#方案三：动态的读写超时" class="headerlink" title="方案三：动态的读写超时"></a>方案三：动态的读写超时</h3><p>在上述的方案中，总读写超时、首包超时都使用了一些估值，使得这两个超时是较大的值。假如我们能获得实时的动态网速等，我们能获得更好的超时机制，如图10所示。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312161353.png" alt="图10 实时动态网速下的超时估算"></p>
<p>但是，理想是丰满的，现实是残酷的：</p>
<ul>
<li>动态网速需要通过工具方法测定，实时性要求高，并且要考虑网络波动的影响；</li>
<li>服务器动态耗时需要服务器下发不同业务信令的处理耗时；</li>
<li>真实回包大小则只能靠服务器通知。</li>
</ul>
<p>上述的三种途径对客户端和服务器都是巨大的流量、性能的消耗，所以动态化这些变量看起来并不可行。</p>
<p>因此，这里需要换个角度思考动态优化，手机的网络状况可以大概地归为优质、正常、差三种情况，针对三种网络状况进行不同程度的调整，也是动态优化的一种手段。这里选择优质网络状况进行分析：</p>
<ul>
<li>如何判定网络状况好？网速快、稳定，网络模块中与之等价的是能够短时间完成信令收发，并且能够连续长时间地完成短时间内信令收发。</li>
<li>即使出现网络波动，也可以预期会很快恢复。
<img src="http://images.wodekouwei.com/tips-net-mars-timeout-2019312161536.png" alt="图11 优质网络状况优化"></li>
</ul>
<p>根据对网络状况好的分析，我们可以做出这样的优化（如图11所示）：</p>
<ul>
<li>将客户端网络环境区分为优良（Excellent）、评估（Evaluating）两种状态；</li>
<li>网速快、稳定就是条件1，信令失败或网络类型切换是条件2。</li>
</ul>
<p>进入Exc状态后，就缩短信令收发的预期，即减小首包超时时间，这样做的原因是我们认为用户的网络状况好，可以设置较短的超时时间，当遇到网络波动时预期它能够快速恢复，所以可以尽快超时然后进行重试，从而改善用户体验。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 TCP/IP 协议栈中的链路层、传输层都已经提供了超时重传，保障了传输的可靠性。但应用层有着不同的可靠性需求，从而需要额外的应用层超时重传机制来保障应用的高性能、高可用。应用层超时重传的设计目标，笔者从自身经验出发，总结为：</p>
<ul>
<li>在用户体验的接受范围内，尽可能地提高成功率；</li>
<li>保障弱网络下的可用性；</li>
<li>具有网络敏感性，快速地发现新的链路。</li>
</ul>
<p>依从这些目标，mars STN 的超时重传机制在使用中不断的精细化演进，使用了包含总读写超时、首包超时、包包超时、动态超时等多种方案的综合。即使如此，STN 的超时重传机制也有着不少的缺点与局限性，例如相对适用于小数据传输的信令通道、局限于一来一回的通信模式等。mars STN 也会不断发现新的问题持续演进，并且所有的演进都将在微信的海量用户中进行验证。同时也期待随着 mars STN 的开源，能收获更多、更广的经验交流、问题反馈、新想法的碰撞等。</p>
<blockquote>
<p>转自<a href="https://mp.weixin.qq.com/s/PnICVDyVuMSyvpvTrdEpSQ?" target="_blank" rel="external">微信终端跨平台组件 mars 系列(二) - 信令传输超时设计</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;mars 是微信官方使用 C++ 编写的业务性无关、平台性无关的终端基础组件，目前在微信 Android、iOS、Windows、Mac、W
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-net-applicationlayer-diff</title>
    <link href="http://wodekouwei.com/2019/03/12/tips-net-applicationlayer-diff/"/>
    <id>http://wodekouwei.com/2019/03/12/tips-net-applicationlayer-diff/</id>
    <published>2019-03-12T07:09:49.000Z</published>
    <updated>2019-03-12T07:43:01.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="I-协议优化演进"><a href="#I-协议优化演进" class="headerlink" title="I. 协议优化演进"></a>I. 协议优化演进</h3><h4 id="1-带宽与拥塞"><a href="#1-带宽与拥塞" class="headerlink" title="1. 带宽与拥塞"></a>1. 带宽与拥塞</h4><p><strong>现状</strong></p>
<p>目前的网络基建越来越好，因此带宽的已经不再是瓶颈， 但是由于相关协议(如TCP)的拥塞窗口(CWND, congestion window)控制算法，很多时候并没有将带宽有效的利用，因此更有效的利用带宽是一个优化方向，特别针对视频、游戏等领域。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>QUIC:</strong> 基于UDP，QUIC可以支持无序的递交，因此通常单个丢包最多只会影响1个请求stream，并且QUIC中一定程度上拆分拥塞窗口来更好的适配多个多路复用的连接，来尽可能的利用带宽，目前已经在Youtube以及一些Google通用库(如字体库)上应用</li>
<li><strong>HTTP:</strong> 通过同时建立多个连接通道，由于每个通道有单独的拥塞窗口保证一个丢包最多只拥塞一个连接通道</li>
<li><strong>BBR:</strong> Google推出的全新的阻塞拥塞控制算法，从根本上解决该问题，通过交替测量带宽和激进的估算算法尽可能的占满带宽与降低延迟（此方式极大的提高了带宽利用率），目前已经在Youtube上应用</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>TCP:</strong> 由于采用”加性增，乘性减”的拥塞控制算法，错误的将网络中的错误丢包也认为是拥塞丢包，导致拥塞窗口被收敛的很小，带宽无法有效利用</li>
<li><strong>SPDY:</strong> 由于SPDY基于TCP，因此存在TCP相同的缺陷问题，并且虽然SPDY采用了多路复用，也做个各类优化，但是由于一个TCP连接只有一个拥塞窗口，因此一个请求stream丢包，就会导致整个通道被阻塞</li>
</ul>
<h4 id="2-握手的N-RTT的开销"><a href="#2-握手的N-RTT的开销" class="headerlink" title="2. 握手的N-RTT的开销"></a>2. 握手的N-RTT的开销</h4><p><strong>现状</strong></p>
<p>目前TCP与SSL/TLS(1.0,1.1,1.2)，每次建连需要TCP三次握手+安全握手需要: <code>4~5-RRT</code>，导致建连效率低下，Google、Facebook、Tencent(Wechat)等公司推出了各类优化策略。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>TLS1.3:</strong> 安全握手提出了0-RTT草案</li>
<li><strong>QUIC:</strong> 通过实现自己的安全模块，整个握手过程(TCP + TLS)采用全新的0-RTT方案，并计划当完成时适配到TLS1.3中</li>
<li><strong>Proxygen:</strong> Facebook基于QUIC的0-RTT协议进行优化，保证安全握手最多只有1-RTT，并运用在TCP中 ，并将贡献各类优化成果给TLS1.3</li>
<li><strong>mmtls:</strong> Wechat基于TLS1.3草案中的0-RTT，进行优化推出自己的mmtls，其对于长连接保障安全握手1-RTT，对于短连接安全握手尽可能使用0-RTT</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>SSL、TLS1.3之前版本:</strong>  在TLS1.2中，需要2~1-RTT(全握手需要2-RTT)</li>
</ul>
<h4 id="3-冗余数据"><a href="#3-冗余数据" class="headerlink" title="3. 冗余数据"></a>3. 冗余数据</h4><p><strong>现状</strong></p>
<p>通常的一般的HTTP请求，每次请求header基本上没什么变化；在一些情况下多个页面使用相同静态资源(js、logo等)，却每次都重复下载。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>SPDY:</strong> 采用<a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="external">DEFLATE</a>对请求头/响应头进行压缩</li>
<li><strong>HTTP/2:</strong> 采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="external">HPACK</a>算法对请求头/响应头进行压缩，并且通讯双方各自cache一份header fields表，避免了重复header的传输</li>
<li><strong>QUIC:</strong> 目前版本采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="external">HPACK</a>算法对请求头/响应头进行压缩</li>
<li><strong>HTTP/1.1、HTTP/2:</strong> 支持<code>Cache-Control</code>用于控制资源有效时间,支持<code>Last-Modified</code>来控制资源是否可复用</li>
<li><strong>Facebook geek方案:</strong>  将<code>expiration time</code>全部设置为1年，所有的资源请求链接，都采用概念性的连接(在请求链接后加上资源名的md5，再做mapping)(只要资源不变化链接就不变化)，保证已下载资源能被有效利用的同时，避免重复检测资源有效性</li>
<li><strong>浏览器优化:</strong> Facebook联系Chrome与Firefox，针对复用资源可复用检测频率进行调整(如firefox支持在<code>cache-control</code>中的<code>immutable</code>关键字表示资源不可变不用重复检测)</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>HTTP/1:</strong> 请求头未做压缩，不支持<code>Cache-Control</code>与<code>Last-Modified</code>因此存在冗余资源重复下载问题</li>
<li><strong>HTTP/1.1:</strong> 请求头未做压缩</li>
</ul>
<h4 id="4-预准备"><a href="#4-预准备" class="headerlink" title="4. 预准备"></a>4. 预准备</h4><ul>
<li><strong>Taobao:</strong> DNS-Prefetch、Preconnect、Prefetch、Flush HTML early、PreRender</li>
<li><strong>SPDY、HTTP/2、QUIC:</strong>: 允许服务端主动推服务端认为客户端需要的静态资源</li>
</ul>
<h4 id="5-负载均衡、超时策略优化与其他"><a href="#5-负载均衡、超时策略优化与其他" class="headerlink" title="5. 负载均衡、超时策略优化与其他"></a>5. 负载均衡、超时策略优化与其他</h4><ul>
<li><strong>负载均衡:</strong> 收益较小的长连接，带来服务端没必要的性能开销</li>
<li><strong>超时策略:</strong> 策略性的调整建连与维连时的超时重连的频率、时间、IP/端口，来应对弱网状况，何时快速放弃节约资源(无网状态)，何时找到可用资源快速恢复连接(被劫持、服务器某端口/IP故障、基站繁忙、连接信号弱、丢包率高)</li>
<li><strong>策略性阻塞:</strong> 根据网络情况、请求数目动态调整连接数来保证吞吐量与稳定性（如SPDY、HTTP/2、QUIC中的多路复用）</li>
<li><strong>DNS:</strong> 结合TTL有效管理本地DNS缓存的有效时间、以及缓存大小来减少DNS查询的阻塞，以及可以通过HTTPDNS优化DNS请求的线路以及来避免DNS被篡改等问题(如果使用okhttp3，可以指定DNS，并且可以为请求设定缓存大小与时间，可以很轻易的实现自己的HTTPDNS)</li>
</ul>
<h3 id="II-常见协议区分"><a href="#II-常见协议区分" class="headerlink" title="II. 常见协议区分"></a>II. 常见协议区分</h3><h4 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1. TCP"></a>1. TCP</h4><blockquote>
<p>关于TCP窗口的研究与学习，请移步<a href="/tcp-window/">TCP窗口</a></p>
</blockquote>
<p>目前应用最广泛的可靠的、有序的、自带问题校验修复(<a href="https://en.wikipedia.org/wiki/Error_detection_and_correction" target="_blank" rel="external">error-checked</a>)、传输协议，通常情况下发送端与接收端通过TCP协议来保障数据的可靠到达，中间层通过IP协议来路由数据的传递。</p>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152553.png" alt="tips-net-applicationlayer-diff-2019312152553"></p>
<ul>
<li><strong>建连:</strong> 通过三次握手，保障连接已可靠连接</li>
<li><strong>超时重试:</strong> 通过连接超时重试、读写超时重试机制，来保障连接的稳定性</li>
<li><strong>拥塞控制:</strong> 通过”加性增，乘性减”算法，来保障尽量少的报文传输尽量多的数据的同时，减少丢包重传的概率</li>
<li><strong>校验和:</strong> 通过对TCP/IP头进行”校验和”检查，来保障传输数据与地址信息的可靠</li>
<li><strong>有序性:</strong> 通过”序列号”来鉴别每个字节数据，保证接收端能够有序的重建传输数据，以及校验数据完整性</li>
<li><strong>应答机制:</strong> 每次接收端会发送Acks(Acknowledgements)给发送端告知数据以被接收</li>
<li><strong>断连:</strong> 通过四次挥手，保障连接已可靠断开</li>
</ul>
<h4 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h4><p><strong><code>HTTP1.1</code> vs <code>HTTP1.0</code></strong></p>
<ul>
<li><strong>更灵活缓存处理:</strong> 引入Etag(Entity tag)等目前常用的缓存相关策略</li>
<li><strong>优化带宽使用:</strong> 引入<code>range</code>头域，支持206(Partial Content)，用于数据断点续传。</li>
<li><strong>错误机制更完善:</strong> 引入24个错误状态码，如409(Conflict)请求资源与当前状态冲突； 410(Gone)资源在服务器上被永久删除</li>
<li><strong>Host头处理:</strong> 请求头中必须带上<code>host</code>，否则会报400 Bad Request，为了支持一台服务器上有多台虚拟主机，因此通常一个IP对应了多个域名</li>
<li><strong>长连接:</strong> 默认<code>Connection: keep-alive</code>，以复用已建连通道，不像<code>http1.0</code>每个请求都需要重新创建</li>
</ul>
<h4 id="3-HTTPS"><a href="#3-HTTPS" class="headerlink" title="3. HTTPS"></a>3. HTTPS</h4><p>1994年由 <strong>网景</strong> 提出，并应用在网景导航者浏览器中。最新的HTTPS协议在2000年5月公布的<code>RFC 2818</code>正式确定。</p>
<p>HTTPS协议是基于TLS(Transport Layer Security)/SSL(Secure Sockets Layer)对数据进行加密校验，保障了网络通信中的数据安全。</p>
<p>在当前大陆的网络环境而言，是有效避免运营商劫持的手段。</p>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152610.png" alt="image_1b8ji5se91a1kvn431umcc2vk9.png-44.3kB"></p>
<ul>
<li><strong>SSL与TLS:</strong> 早期HTTPS是通过SSL对数据验证加密，后SSL逐渐演变为现在的TLS，所以大多数为了有效的支持加密，都同时支持了SSL与STL</li>
<li><strong>TLS提高了SSL:</strong> 虽然最早的TLS1.0与SSL3.0非常类似，但是TLS采用HMAC(keyed-Hashing for Message Authentication Code)算法对数据验证相比SSL的MAC(Message Authentication Code)算法会更难破解，并且在其他方面也有一些小的改进</li>
<li><strong>请求端口:</strong> 443</li>
</ul>
<h4 id="4-SPDY"><a href="#4-SPDY" class="headerlink" title="4. SPDY"></a>4. SPDY</h4><blockquote>
<p>读音speedy</p>
</blockquote>
<p>是谷歌开发为了加快网页加载速度的网络协议。</p>
<p>SPDY兼容性: <a href="http://caniuse.com/#feat=spdy" target="_blank" rel="external">http://caniuse.com/#feat=spdy</a></p>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152616.png" alt="image_1b8jj8l511lag13eslpm1al918krm.png-23.8kB"></p>
<ul>
<li><strong>采用多路复用(multiplexing):</strong> 多个请求stream共享一个tcp连接， 降低延时、提高带宽利用率</li>
<li><strong>请求优先级:</strong> 允许给每个请求设置优先级，使得重要的请求得到优先响应</li>
<li><strong>TLS/SSL的加密传输:</strong> 强制要求使用TLS/SSL提高数据安全可靠性</li>
<li><strong>压缩<code>请求头/响应头</code>:</strong> 通过DEFLATE或gzip算法进行对<code>请求头/响应头</code>进行压缩</li>
<li><strong>支持Server Push:</strong> 允许服务端主动的推送资源(js、css)给客户端，当分析获知客户端将会需要时，以此利用起空闲带宽</li>
<li><strong>支持Server Hints:</strong> 允许服务端可以在客户端还没有发现将需要哪些资源的时候，主动通知客户端，以便于客户端实现准备好相关资源的缓存</li>
</ul>
<h4 id="5-HTTP-2"><a href="#5-HTTP-2" class="headerlink" title="5. HTTP/2"></a>5. HTTP/2</h4><blockquote>
<p>HTTP/2基于SPDY设计</p>
</blockquote>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152623.png" alt="image_1b90ik3e01di41tgr16hc12ks19uvp.png-129.5kB">
<img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152632.png" alt="image_1b8jku3ol1rbveu4es1tp8rk61j.png-125kB"></p>
<p><strong>HTTP/2 vs SPDY</strong></p>
<ul>
<li><strong>SSL/TLS:</strong> SPDY强制使用SSL/TLS，HTTP/2非强制(但是部分浏览器(如Chrome)不允许，所以目前如果使用HTTP/2最好都配置SSL/TLS)</li>
<li><strong>消息头压缩算法:</strong> HTTP/2消息头压缩算法采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="external">HPACK</a>，SPDY采用<a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="external">DEFLATE</a>，一般情况下HPACK的压缩率会高于DEFLATE</li>
<li><strong>传输格式:</strong> HTTP/2传输采用二进制而非文本，因此HTTP/2中的基本单位是帧, 文本形式众多很难权衡健壮、性能与复杂度，二进制弥补了这个缺陷，并且是无序的帧，最终根据头帧重新组装</li>
<li><strong>继承与优化:</strong> HTTP/2继承并优化了SPDY的多路复用与Server Push</li>
</ul>
<h4 id="6-QUIC"><a href="#6-QUIC" class="headerlink" title="6. QUIC"></a>6. QUIC</h4><ul>
<li>发音<code>quick</code></li>
<li>QUIC 参考了HTTP/2与SPDY</li>
<li>Google在2013年10月第一次在IETF展示QUIC, 2016年7月启动工作群</li>
<li>可靠的，多路复用的基于UDP的网络协议，内置安全加密模块，低延迟、运行在用户空间、开源的新一代网络协议。Google计划在完成后将其服务于所有的Google服务。</li>
</ul>
<p><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152640.png" alt="">
<img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152646.png" alt=""></p>
<ul>
<li><strong>减少建连延迟:</strong> 从未访问过服务的情况下1-RTT，其他的可以立马开始传输数据(0-RTT)</li>
<li><strong>拥塞控制:</strong> 提升TCP Cubic拥塞控制</li>
<li><strong>HOL阻塞:</strong> 消除多路复用中的HOL阻塞(head-of-line blocking)</li>
<li><strong>更少的帧消耗:</strong> Quic数据包包含更少的帧，因此更多的数据包可以携带数据</li>
<li><strong>提升丢包重试:</strong> 丢包重试时使用新的序列号以及采用重新加密</li>
<li><strong>安全加密:</strong> 内置的加密模块(支持SNI，因此支持一个IP部署多个证书)，并且是默认打开的，相比TLS更高效的向前加密 - 完成以后，将计划适配到TLS 1.3中</li>
<li><strong>端口:</strong> 使用443端口来处理UDP协议数据 - <a href="https://community.spiceworks.com/topic/601177-port-80-443-udp-traffic-to-google" target="_blank" rel="external">Port 80/443 UDP Traffic to Google?</a></li>
<li><strong>其他:</strong> 更好的FEC(Forward error correction)机制、与Connection migration机制</li>
</ul>
<hr>
<ul>
<li><a href="http://lovestblog.cn/blog/2014/05/20/tcp-broken-pipe/" target="_blank" rel="external">从tcp原理角度理解Broken pipe和Connection Reset by Peer的区别</a></li>
<li><a href="http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf" target="_blank" rel="external">淘宝HTTPS探索</a></li>
<li><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="external">HTTP,HTTP/2,SPDY,HTTPS你应该知道的一些事</a></li>
<li><a href="https://docs.google.com/document/d/1lmL9EF6qKrk7gbazY8bIdvq3Pno2Xj_l_YShP40GLQE" target="_blank" rel="external">QUIC Geek FAQ</a></li>
<li><a href="https://github.com/google/bbr" target="_blank" rel="external">google/bbr</a></li>
<li><a href="http://www.cnblogs.com/mydomain/archive/2013/04/18/3027668.html" target="_blank" rel="external">滑动窗口和拥塞窗口简述</a></li>
<li><a href="https://www.zhihu.com/question/53559433" target="_blank" rel="external">BBR算法原理 - 李博杰</a></li>
<li><a href="https://www.nanog.org/sites/default/files/meetings/NANOG64/1051/20150603_Rogan_Quic_Next_Generation_v1.pdf" target="_blank" rel="external">QUIC - Next generation multiplexed transport over UDP</a></li>
<li><a href="https://code.facebook.com/posts/608854979307125/building-zero-protocol-for-fast-secure-mobile-connections/" target="_blank" rel="external">Building Zero protocol for fast, secure mobile connections</a></li>
<li><a href="https://github.com/WeMobileDev/article/blob/master/%E5%9F%BA%E4%BA%8ETLS1.3%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AEmmtls%E4%BB%8B%E7%BB%8D.md" target="_blank" rel="external">基于TLS1.3的微信安全通信协议mmtls介绍</a></li>
<li><a href="https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit" target="_blank" rel="external">QUIC Wire Layout Specification</a></li>
<li><a href="https://en.wikipedia.org/wiki/SPDY" target="_blank" rel="external">SPDY - Wiki</a></li>
<li><a href="https://code.facebook.com/posts/557147474482256/this-browser-tweak-saved-60-of-requests-to-facebook/" target="_blank" rel="external">This browser tweak saved 60% of requests to Facebook</a></li>
<li><a href="http://jiaolonghuang.github.io/2015/08/16/http2/" target="_blank" rel="external">HTTP2学习(四)—HTTP2的新特性</a></li>
<li><a href="https://www.chromium.org/spdy/link-headers-and-server-hint" target="_blank" rel="external">Server Push and Server Hints</a></li>
<li><a href="https://technet.microsoft.com/en-us/library/cc784450(v=ws.10" target="_blank" rel="external">What is TLS/SSL?</a>.aspx)</li>
<li><a href="http://peering.google.com/#/learn-more/quic" target="_blank" rel="external">QUIC - Google-peering</a></li>
<li><a href="https://www.chromium.org/quic" target="_blank" rel="external">QUIC教材</a></li>
<li><a href="https://www.youtube.com/watch?v=hQZ-0mXFmk8" target="_blank" rel="external">QUIC视频介绍</a></li>
<li><a href="https://tools.keycdn.com/http2-test" target="_blank" rel="external">Http2-test</a></li>
<li><a href="https://community.akamai.com/community/web-performance/blog/2015/06/05/useful-tools-for-http2-debugging" target="_blank" rel="external">Http2-debug</a></li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;I-协议优化演进&quot;&gt;&lt;a href=&quot;#I-协议优化演进&quot; class=&quot;headerlink&quot; title=&quot;I. 协议优化演进&quot;&gt;&lt;/a&gt;I. 协议优化演进&lt;/h3&gt;&lt;h4 id=&quot;1-带宽与拥塞&quot;&gt;&lt;a href=&quot;#1-带宽与拥塞&quot; class=&quot;head
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-net-summarize</title>
    <link href="http://wodekouwei.com/2019/03/11/tips-net-summarize/"/>
    <id>http://wodekouwei.com/2019/03/11/tips-net-summarize/</id>
    <published>2019-03-11T10:42:21.000Z</published>
    <updated>2019-03-11T10:42:21.273Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-net-http</title>
    <link href="http://wodekouwei.com/2019/03/11/tips-net-http/"/>
    <id>http://wodekouwei.com/2019/03/11/tips-net-http/</id>
    <published>2019-03-11T10:22:25.000Z</published>
    <updated>2019-03-11T10:22:25.643Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-net-mars</title>
    <link href="http://wodekouwei.com/2019/03/11/tips-net-mars/"/>
    <id>http://wodekouwei.com/2019/03/11/tips-net-mars/</id>
    <published>2019-03-11T10:17:18.000Z</published>
    <updated>2019-03-14T06:18:16.878Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-net-tcp</title>
    <link href="http://wodekouwei.com/2019/03/11/tips-net-tcp/"/>
    <id>http://wodekouwei.com/2019/03/11/tips-net-tcp/</id>
    <published>2019-03-11T08:59:43.000Z</published>
    <updated>2019-03-12T09:04:22.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311171945.png" alt="tips-net-tcp-2019311171945"></p>
<p>各个段位说明:</p>
<ul>
<li>源端口和目的端口:　　各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现</li>
<li>序号:　　占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li>
<li>确认号:　　占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号</li>
<li>数据偏移/首部长度:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)</li>
<li>保留:　　占 6 位,保留为今后使用,但目前应置为 0</li>
<li>紧急URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)</li>
<li>确认ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效</li>
<li>PSH(PuSH):　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付</li>
<li>RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接</li>
<li>同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文</li>
<li>终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接</li>
<li>检验和:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部</li>
<li>紧急指针:　　占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li>
<li>选项:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]</li>
<li>填充:　　这是为了使整个首部长度是 4 字节的整数倍</li>
<li>其他选项:<ul>
<li>窗口扩大:　　占 3 字节,其中有一个字节表示移位值 S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小</li>
<li>时间戳:　　占10 字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)</li>
<li>选择确认:　　接收方收到了和前面的字节流不连续的两2字节.如果这些字节的序号都在接收窗口之内,那么接收方就先收下这些数据,但要把这些信息准确地告诉发送方,使发送方不要再重复发送这些已收到的数据</li>
</ul>
</li>
</ul>
<h2 id="数据单位"><a href="#数据单位" class="headerlink" title="数据单位"></a>数据单位</h2><p>TCP 传送的数据单位协议是 TCP 报文段(segment)</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>TCP 是面向连接的传输层协议 每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的（一对一） TCP 提供可靠交付的服务 TCP 提供全双工通信 面向字节流</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的 TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的) TCP 可把太长的数据块划分短一些再传送.TCP 也可等待积累有足够多的字节后再构成报文段发送出去 每一条 TCP 连接有两个端点 TCP 连接的端点不是主机,不是主机的IP 地址,不是应用进程,也不是传输层的协议端口.TCP 连接的端点叫做套接字(socket)或插口</p>
<h2 id="自动重传请求ARQ"><a href="#自动重传请求ARQ" class="headerlink" title="自动重传请求ARQ"></a>自动重传请求ARQ</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)</p>
<h3 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认:"></a>累积确认:</h3><ul>
<li>定义:　　接收方一般采用累积确认的方式.即不必对收到的分组逐个发送确认,而是对按序到达的最后一个分组发送确认,这样就表示：到这个分组为止的所有分组都已正确收到了</li>
<li>优点:　　容易实现,即使确认丢失也不必重传</li>
<li>缺点:　　不能向发送方反映出接收方已经正确收到的所有分组的信息<h3 id="Go-back-N-回退N"><a href="#Go-back-N-回退N" class="headerlink" title="Go-back-N(回退N):"></a>Go-back-N(回退N):</h3>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了.这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li>TCP 连接的每一端都必须设有两个窗口      一个发送窗口和一个接收窗口</li>
<li>TCP 可靠传输机制用字节的序号进行控制.TCP 所有的确认都是基于序号而不是基于报文段</li>
<li>TCP 两端的四个窗口经常处于动态变化之中</li>
<li>TCP连接的往返时间 RTT 也不是固定不变的.需要使用特定的算法估算较为合理的重传时间</li>
</ul>
<h3 id="图释"><a href="#图释" class="headerlink" title="图释"></a>图释</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117259.png" alt="tips-net-tcp-201931117259"></p>
<h2 id="发送缓存"><a href="#发送缓存" class="headerlink" title="发送缓存"></a>发送缓存</h2><h3 id="发送缓存用来暂时存放："><a href="#发送缓存用来暂时存放：" class="headerlink" title="发送缓存用来暂时存放："></a>发送缓存用来暂时存放：</h3><ul>
<li>发送应用程序传送给发送方 TCP 准备发送的数据</li>
<li>TCP 已发送出但尚未收到确认的数据<h3 id="图释-1"><a href="#图释-1" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172637.png" alt="tips-net-tcp-2019311172637"></li>
</ul>
<h2 id="接收缓存"><a href="#接收缓存" class="headerlink" title="接收缓存"></a>接收缓存</h2><h3 id="接收缓存用来暂时存放："><a href="#接收缓存用来暂时存放：" class="headerlink" title="接收缓存用来暂时存放："></a>接收缓存用来暂时存放：</h3><ul>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据<h3 id="图释-2"><a href="#图释-2" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172725.png" alt="tips-net-tcp-2019311172725"></li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口(rwnd)是用于流控的动态缩放可靠滑动的接收与发送窗口，防止发送端发送过快接收端被淹没
对应的还有拥塞窗口(rwnd),是在一个RTT内可以最多一次可发送的报文段数 — 发送方的流量控制</p>
<p>TCP是以报文段(若干字节)为单位，每一个报文段需要一次ACK确认收到，但是其带来的问题很明显，频繁的发送确认等待导致用于确认与等待的时间太长。引入窗口后，发送端只要在窗口内，便不用每次都等待ACK才发送下一个报文段，可以在发送窗口内一次连续发送几个报文段而无需等待ACK</p>
<h3 id="图释-3"><a href="#图释-3" class="headerlink" title="图释:"></a>图释:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172750.png" alt="tips-net-tcp-2019311172750"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点:"></a>特点:</h3><ul>
<li>以字节为单位的滑动窗口</li>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）<h3 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h3></li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程</li>
<li>TCP 要求接收方必须有累积确认的功能,这样可以减小传输开销</li>
</ul>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现:"></a>具体实现:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117296.png" alt="tips-net-tcp-201931117296">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172934.png" alt="tips-net-tcp-2019311172934">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172949.png" alt="tips-net-tcp-2019311172949">
<img src="http://images.wodekouwei.com/tips-net-tcp-201931117305.png" alt="tips-net-tcp-201931117305"></p>
<h3 id="发送窗口与接收窗口的关系"><a href="#发送窗口与接收窗口的关系" class="headerlink" title="发送窗口与接收窗口的关系"></a>发送窗口与接收窗口的关系</h3><p>TCP是双工协议，会话双方都可以同时接收与发送数据，因此双方都同时维护一个发送窗口与接收窗口。</p>
<ul>
<li>接收窗口大小取决于应用、系统、硬件等限制；</li>
<li>发送窗口大小取决于对方接收窗口的大小</li>
</ul>
<h3 id="窗口滑动协定"><a href="#窗口滑动协定" class="headerlink" title="窗口滑动协定"></a>窗口滑动协定</h3><ul>
<li>发送窗口只有在收到窗口内字节的ACK确认，才会滑动其左边界</li>
<li>接收窗口只有在窗口中所有的段都正确收到的情况下，才会滑动其左边界；当有字节未接收，但收到后面的字节的情况下，也会滑动，也不对后续字节确认，确保对方重传未接收字节<h3 id="哪些允许变化"><a href="#哪些允许变化" class="headerlink" title="哪些允许变化"></a>哪些允许变化</h3></li>
<li>最大报文段大小在握手中，就确定了</li>
<li>窗口缩放因子在握手中，就确定了</li>
<li>接收窗口大小在根据本地的处理能力与缓存剩余空间动态调整，通过ACK带给对方当前剩余的接收窗口大小</li>
</ul>
<h2 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311173223.png" alt="tips-net-tcp-2019311173223">
RTT = 传播时间+接收端处理时间+路由器的排队时间(变化较大反应当前网络拥塞情况)</p>
<h2 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h2><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现:"></a>具体实现:</h3><p>TCP 每发送一个报文段,就对这个报文段设置一次计时器.只要计时器设置的重传时间到但还没有收到确认,就要重传这一报文段</p>
<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间:"></a>加权平均往返时间:</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h4><p>TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）,第一次测量到 RTT 样本时,RTTS 值就取为所测量到的 RTT 样本值.以后每测量到一个新的 RTT 样本,就按下式重新计算一次 RTTS：
R</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h4><p>新的 RTTS = ( 1 - α)×(旧的 RTTS)＋α(新的 RTT 样本)</p>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明:"></a>说明:</h4><p>式中,0 ≤ α＜ 1.若α很接近于零,表示 RTT 值更新较慢若选择 α 接近于1,则表示 RTT 值更新较快 RFC 2988 推荐的 α 值为 1/8,即 0.125</p>
<h3 id="超时重传时间RTO"><a href="#超时重传时间RTO" class="headerlink" title="超时重传时间RTO:"></a>超时重传时间RTO:</h3><p>RTO 应略大于上面得出的加权平均往返时间 RTTS. RFC 2988 建议使用下式计算 RTO：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RTO=RTTS + 4×RTTD</div></pre></td></tr></table></figure></p>
<p>RTTD 是 RTT 的偏差的加权平均值 RFC 2988 建议这样计算 RTTD.第一次测量时,RTTD 值取为测量到的 RTT 样本值的一半.在以后的测量中,则使用下式计算加权平均的 RTTD：</p>
<p><code>新的 RTTD = (1-β)×(旧的RTTD)+β×|RTTS﹣新的 RTT 样本|</code>
β是个小于 1 的系数,其推荐值是 1/4,即 0.25 在计算平均往返时间 RTT 时,只要报文段重传了,就不采用其往返时间样本</p>
<h3 id="修正的Karn算法"><a href="#修正的Karn算法" class="headerlink" title="修正的Karn算法:"></a>修正的Karn算法:</h3><p>报文段每重传一次,就把 RTO 增大一些：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">新的 RTO= γ×(旧的 RTO)</div></pre></td></tr></table></figure></p>
<p>系数γ 的典型值是 2 当不再发生报文段的重传时,才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值</p>
<h3 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h3><ul>
<li>TCP 为每一个连接设有一个持续计时器</li>
<li>只要 TCP 连接的一方收到对方的零窗口通知,就启动持续计时器</li>
<li>若持续计时器设置的时间到期,就发送一个零窗口探测报文段(仅携带 1 字节的数据),而对方就在确认这个探测报文段时给出了现在的窗口值</li>
<li>若窗口仍然是零,则收到这个报文段的一方就重新设置持续计时器</li>
<li>若窗口不是零,则死锁的僵局就可以打破了</li>
</ul>
<h2 id="报文段的发送时机"><a href="#报文段的发送时机" class="headerlink" title="报文段的发送时机"></a>报文段的发送时机</h2><p>TCP 维持一个变量,它等于最大报文段长度 MSS.只要缓存中存放的数据达到 MSS 字节时,就组装成一个 TCP 报文段发送出去 由发送方的应用进程指明要求发送报文段,即 TCP 支持的推送(push)操作 发送方的一个计时器期限到了,这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去</p>
<h2 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h2><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段:"></a>三个阶段:</h3><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立:"></a>连接建立:</h4><h5 id="图释-4"><a href="#图释-4" class="headerlink" title="图释:"></a>图释:</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174443.jpg" alt="tips-net-tcp-2019311174443"></p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>A 的 TCP 向 B 发出连接请求报文段,其首部中的同步位 SYN = 1,并选择序号 seq = x,表明传送数据时的第一个数据字节的序号是 x</li>
<li>B 的 TCP 收到连接请求报文段后,如同意,则发回确认(B 在确认报文段中应使 SYN = 1,使 ACK = 1,其确认号ack = x﹢1,自己选择的序号 seq = y)</li>
<li>A 收到此报文段后向 B 给出确认,其 ACK = 1,确认号 ack = y﹢1(A 的 TCP 通知上层应用进程,连接已经建立,B 的 TCP 收到主机 A 的确认后,也通知其上层应用进程：TCP 连接已经建立)</li>
</ul>
<h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放:"></a>连接释放:</h4><h5 id="图释-5"><a href="#图释-5" class="headerlink" title="图释"></a>图释</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174722.jpg" alt="tips-net-tcp-2019311174722"></p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>数据传输结束后,通信的双方都可释放连接.现在 A 的应用进程先向其 TCP 发出连接释放报文段,并停止再发送数据,主动关闭 TCP 连接(A 把连接释放报文段首部的 FIN = 1,其序号seq = u,等待 B 的确认)</li>
<li>B 发出确认,确认号 ack = u＋1,而这个报文段自己的序号 seq = v(TCP 服务器进程通知高层应用进程.从 A 到 B 这个方向的连接就释放了,TCP 连接处于半关闭状态.B 若发送数据,A 仍要接收)</li>
<li>若 B 已经没有要向 A 发送的数据,其应用进程就通知 TCP 释放连接</li>
<li>A 收到连接释放报文段后,必须发出确认,在确认报文段中 ACK = 1,确认号 ack=w﹢1,自己的序号 seq = u + 1</li>
</ul>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><p>TCP 连接必须经过时间 2MSL 后才真正释放掉(2MSL 的时间的用意 — 为了保证 A 发送的最后一个 ACK 报文段能够到达 B.防止 “已失效的连接请求报文段”出现在本连接中.A 在发送完最后一个 ACK 报文段后,再经过时间 2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失.这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段)</p>
<h5 id="发现丢失确认时候的处理"><a href="#发现丢失确认时候的处理" class="headerlink" title="发现丢失确认时候的处理"></a>发现丢失确认时候的处理</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174940.png" alt="tips-net-tcp-2019311174940"></p>
<h4 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题:"></a>三个问题:</h4><ul>
<li>要使每一方能够确知对方的存在</li>
<li>要允许双方协商一些参数(如最大报文段长度,最大窗口大小,服务质量等)</li>
<li>能够对运输实体资源(如缓存大小,连接表中的项目等)进行分配</li>
</ul>
<h2 id="发送TCP请求客户端"><a href="#发送TCP请求客户端" class="headerlink" title="发送TCP请求客户端"></a>发送TCP请求客户端</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175058.png" alt="tips-net-tcp-2019311175058"></p>
<h2 id="拥塞处理相关概念"><a href="#拥塞处理相关概念" class="headerlink" title="拥塞处理相关概念"></a>拥塞处理相关概念</h2><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口:"></a>拥塞窗口:</h3><ul>
<li>含义:拥塞窗口的大小取决于网络的拥塞程度,并且动态地在变化.发送方让自己的发送窗口等于拥塞窗口.如再考虑到接收方的接收能力,则发送窗口还可能小于拥塞窗口</li>
<li>发送方控制拥塞窗口的原则:只要网络没有出现拥塞,拥塞窗口就再增大一些,以便把更多的分组发送出去.但只要网络出现拥塞,拥塞窗口就减小一些,以减少注入到网络中的分组数</li>
</ul>
<h3 id="乘法减小"><a href="#乘法减小" class="headerlink" title="乘法减小:"></a>乘法减小:</h3><p>是指不论在慢开始阶段还是拥塞避免阶段,只要出现一次超时(即出现一次网络拥塞),就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5</p>
<h3 id="加法增大"><a href="#加法增大" class="headerlink" title="加法增大:"></a>加法增大:</h3><p>是指执行拥塞避免算法后,在收到对所有报文段的确认后(即经过一个往返时间),就把拥塞窗口 cwnd增加一个 MSS 大小,使拥塞窗口缓慢增大,以防止网络过早出现拥塞</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传:"></a>快重传:</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认.这样做可以让发送方及早知道有报文段没有到达接收方,发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311175358.jpg" alt="tips-net-tcp-2019311175358"></p>
<h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复:"></a>快恢复:</h3><p>当发送端收到连续三个重复的确认时,就执行“乘法减小”算法,把慢开始门限 ssthresh 减半.但接下去不执行慢开始算法</p>
<h3 id="发送窗口的上限值"><a href="#发送窗口的上限值" class="headerlink" title="发送窗口的上限值:"></a>发送窗口的上限值:</h3><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个,即应按以下公式确定： 发送窗口的上限值   Min [rwnd, cwnd]</p>
<p>当 rwnd &lt; cwnd 时,是接收方的接收能力限制发送窗口的最大值
当 cwnd &lt; rwnd 时,则是网络的拥塞限制发送窗口的最大值</p>
<h2 id="避免拥塞具体实现"><a href="#避免拥塞具体实现" class="headerlink" title="避免拥塞具体实现"></a>避免拥塞具体实现</h2><h3 id="有滑动窗口了，为什么还要拥塞窗口"><a href="#有滑动窗口了，为什么还要拥塞窗口" class="headerlink" title="有滑动窗口了，为什么还要拥塞窗口"></a>有滑动窗口了，为什么还要拥塞窗口</h3><p>发送方与接收方之间存在多个路由器和速率较慢的链路时，一些中间路由器就必须缓存分组，并可能耗尽缓存，此时便会出现拥塞，这将严重降低了TCP连接的吞吐量，拥塞窗口就是为了防止过多的数据注入到网络中，中间路由无法消化的问题。</p>
<p>TCP的做法是引入拥塞窗口(cwnd)并策略性的调整其大小，如上文提到的发送窗口大小是取滑动窗口大小与拥塞窗口大小的最小值，这个正是用来缓解该问题，下面是拥塞窗口大小变化的策略:</p>
<h4 id="1-慢开始、拥塞控制"><a href="#1-慢开始、拥塞控制" class="headerlink" title="1. 慢开始、拥塞控制"></a>1. 慢开始、拥塞控制</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312133854.png" alt="tips-net-tcp-2019312133854">
其目的是: 拥塞发生时循序减少主机发送到网络的报文数，使得这时路由器有足够的时间消化积压的报文。</p>
<ul>
<li>当主机开发发送数据时，拥塞窗口(cwnd)被初始化为1个报文段，试探性的发送1个字节的报文</li>
<li>每收到一个ACK，拥塞窗口大小就指数的增加报文段数目(1,2,4,16…)</li>
<li>最终到达提前预设的慢开始阀值(ssthresh)，停止使用慢开始算法，改用拥塞避免算法</li>
<li>拥塞避免算法是每经过一个RTT，拥塞窗口就增加一个报文段，即改为线性的增加报文段</li>
<li>最终会出现网络拥塞，比如丢包等情况，停止拥塞避免算法，将慢开始阀值设置为目前拥塞时拥塞窗口大小的一半(但不能小于2)，并重置拥塞窗口大小为1个报文段，开始新的一轮慢开始 </li>
</ul>
<p>慢开始门限 ssthresh 的用法:</p>
<ul>
<li>当 cwnd &lt; ssthresh 时,使用慢开始算法</li>
<li>当 cwnd &gt; ssthresh 时,停止使用慢开始算法而改用拥塞避免算法</li>
<li>当 cwnd = ssthresh 时,既可使用慢开始算法,也可使用拥塞避免算法</li>
</ul>
<h4 id="2-快重传，快恢复"><a href="#2-快重传，快恢复" class="headerlink" title="2. 快重传，快恢复"></a>2. 快重传，快恢复</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134328.png" alt="tips-net-tcp-2019312134328">
其目的是: 减少因为拥塞导致的数据包丢失的重传时间，避免无用的数据到网络</p>
<p>接收方: 如果一个包丢失，后续的包继续发送针对该包的重传请求</p>
<p>发送方: 一旦收到三个一样的确认，判定为拥塞:</p>
<ul>
<li>立即重传该包</li>
<li>开始执行快恢复算法</li>
<li>快恢复是慢开始阀值设置为目前拥塞时拥塞窗口大小的一半；拥塞窗口大小设置为目前设置后的慢开始阀值的大小；执行拥塞避免算法</li>
</ul>
<h2 id="TCP窗口特殊情况"><a href="#TCP窗口特殊情况" class="headerlink" title="TCP窗口特殊情况"></a>TCP窗口特殊情况</h2><h3 id="1-Persistence-timer"><a href="#1-Persistence-timer" class="headerlink" title="1. Persistence timer"></a>1. Persistence timer</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134856.png" alt="tips-net-tcp-2019312134856">
防止丢包导致发送端停留在上次收到的接收窗口大小为0的情况:</p>
<ul>
<li>接收端B: 我的缓存已满，接收窗口为0</li>
<li>发送端A: 停止发送数据, 并启动持续计时器(Persistence timer)</li>
<li>接收端B: 消化完缓存，发送报文给发送端A，我的接收窗口大小为400，但是 这个报文丢了</li>
<li>发送端A: 计时器时间到，发送一个1字节的探测报文</li>
<li>接收端B: 重新发送，接收窗口大小为400</li>
<li>发送端A: 继续发送数据<h3 id="2-应用层每次单字节发送"><a href="#2-应用层每次单字节发送" class="headerlink" title="2. 应用层每次单字节发送"></a>2. 应用层每次单字节发送</h3>单个发送字节，然后等待一个确认，再发送一个字节，这样为一个字节添加40个字节头的做法，无疑增加了网络中许多不必要的报文，该问题TCP层的解决方案:</li>
</ul>
<p>发送方采用Nagle算法:</p>
<ul>
<li>若应用层是逐个字节把数据送到TCP，那么TCP不会逐个的发送，而是先发送第一个数据字节，然后缓存剩余的</li>
<li>在收到第一个字节的ACK获知网络情况与对方的接收窗口大小后，把缓存的剩余字节组成合适的报文发送出去</li>
<li>到达的数据达到发送窗口大小的一半或者报文段的最大长度时，立即发送</li>
</ul>
<p>接收方的做法:</p>
<ul>
<li>等待本地有足够的缓存空间容纳一个报文段，或者等到本地的缓存空间有一半空闲的时候，再通知发送端发送数据。</li>
</ul>
<h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p>说明:</p>
<ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名.状态之间的箭头表示可能发生的状态变迁</li>
<li>箭头旁边的字,表明引起这种变迁的原因,或表明发生状态变迁后又出现什么动作</li>
<li>图中有三种不同的箭头<ul>
<li>粗实线箭头表示对客户进程的正常变迁</li>
<li>粗虚线箭头表示对服务器进程的正常变迁</li>
<li>另一种细线箭头表示异常变迁</li>
</ul>
</li>
</ul>
<p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175949.png" alt="tips-net-tcp-2019311175949"></p>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><h4 id="什么是MTU-Maximum-Transmit-Unit"><a href="#什么是MTU-Maximum-Transmit-Unit" class="headerlink" title="什么是MTU(Maximum Transmit Unit)"></a>什么是MTU(Maximum Transmit Unit)</h4><p>由于以太网传输的限制，每个以太网网数据帧的大小都是落在在区间[64Bytes,1518Bytes]中的，不在区间内的一般会被视为错误的数据帧，以太网转发设备直接丢弃。而根据以太网每帧的数据构成，除去固定的部分，留给上层协议的只有Data域的1500Bytes，我们将它称为MTU。</p>
<p>以太网(Ethernet II)每帧的数据构成: 目的Mac地址(DMAC)+源Mac地址(SMAC)+类型(Type)+数据(Data)+校验(CRC) = 6Bytes(48bit)DMAC + 6Bytes(48bit)SMAC + 2Bytes(16bit)Type + 1500BytesData + 4Bytes(24bit)CRC</p>
<h4 id="MTU造成什么影响"><a href="#MTU造成什么影响" class="headerlink" title="MTU造成什么影响"></a>MTU造成什么影响</h4><p>由于一个帧放不下，如IP协议，就会对数据包进行分片处理，这就导致了原本一次可以搞定的，被分为多次，降低传输性能，不过我们可以通过在数据包包头加上DF(DonotFragment)标签来强制不被分片处理。</p>
<p>UDP协议不用关心数据的到达的有序以及正确，因此对分片无特殊要求
TCP协议相反，因此TCP协议本身的最大报文段大小MSS也受MTU影响，通常MSS是: MTU - 20Bytes(IP Header) - 20Bytes(TCP Header)
不过好在绝大多数的网络链路都是1500Bytes的MTU或者更大</p>
<h3 id="什么是MSS-Maximum-Segment-Size"><a href="#什么是MSS-Maximum-Segment-Size" class="headerlink" title="什么是MSS(Maximum Segment Size)"></a>什么是MSS(Maximum Segment Size)</h3><p>TCP的最大报文段大小，只包含TCP Payload(不包含TCP Header与TCP Option)的TCP每次能够传输的最大数据分段的大小，可以用来限制每次发送的字节数。通常大小为1460Bytes(1500BytesMTU - 20Bytes(IP Header) - 20Bytes(TCP Header))</p>
<p>MSS是在TCP建连时确定的，通讯双方会根据双方提供的MSS值，取最小的MSS作为该次连接数据传输的MSS</p>
<h3 id="什么是WS-Window-Scaling"><a href="#什么是WS-Window-Scaling" class="headerlink" title="什么是WS(Window Scaling)"></a>什么是WS(Window Scaling)</h3><p>TCP首部中表示Window Size的字段只有16位，因此按照协议，能表示的最大窗口大小是2^16-1=65535Bytes(64Kb)，因此TCP的选项字段中包含了窗口扩大因子(WS)分别用option-kind、option-length、option-data来表示，这个参数可带可不带，只有在双方都支持的情况下，才会生效。如双方的WS都是256，而后我们ACK Window size value是5，那么此时就可以表示我们的接收窗口是1280Bytes(5*256=1280)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/zhangdaisylove/article/details/47294315" target="_blank" rel="external">TCP的滑动窗口与拥塞窗口</a>
<a href="http://blog.chinaunix.net/uid-26275986-id-4109679.html" target="_blank" rel="external">计算机网络【七】：可靠传输的实现</a>
<a href="http://blog.csdn.net/cloud323/article/details/77481711" target="_blank" rel="external">TCP窗口控制、流控制、拥塞控制</a>
<a href="http://blog.csdn.net/hldjf/article/details/7450565" target="_blank" rel="external">也谈一下TCP segment of a reassembled PDU</a>
<a href="https://www.zhihu.com/question/48454744" target="_blank" rel="external">TCP流量控制中的滑动窗口大小</a>
<a href="https://my.oschina.net/xinxingegeya/blog/485650" target="_blank" rel="external">TCP 滑动窗口（发送窗口和接收窗口）</a>
<a href="https://www.zhihu.com/question/32255109" target="_blank" rel="external">TCP协议的滑动窗口具体是怎样控制流量的？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;首部格式&quot;&gt;&lt;a href=&quot;#首部格式&quot; class=&quot;headerlink&quot; title=&quot;首部格式&quot;&gt;&lt;/a&gt;首部格式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://images.wodekouwei.com/tips-net-tcp-2019311171
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-net-nat</title>
    <link href="http://wodekouwei.com/2019/03/11/tips-net-nat/"/>
    <id>http://wodekouwei.com/2019/03/11/tips-net-nat/</id>
    <published>2019-03-11T03:05:57.000Z</published>
    <updated>2019-03-11T08:59:07.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-NAT"><a href="#1-NAT" class="headerlink" title="1.NAT"></a>1.NAT</h2><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。
这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>
<p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p>
<h3 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h3><p>是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。</p>
<h3 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h3><p>是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p>
<h3 id="端口多路复用（Port-address-Translation-PAT"><a href="#端口多路复用（Port-address-Translation-PAT" class="headerlink" title="端口多路复用（Port address Translation,PAT)"></a>端口多路复用（Port address Translation,PAT)</h3><p>是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。
ALG（Application Level Gateway），即应用程序级网关技术：传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。例如：对于FTP协议的PORT/PASV命令、DNS协议的 “A” 和 “PTR” queries命令和部分ICMP消息类型等都需要相应的ALG来支持。
如果协议数据报文中不包含地址信息，则很容易利用传统的NAT技术来完成透明的地址转换功能，通常我们使用的如下应用就可以直接利用传统的NAT技术：HTTP、TELNET、FINGER、NTP、NFS、ARCHIE、RLOGIN、RSH、RCP等。</p>
<h2 id="2-TCP长连接"><a href="#2-TCP长连接" class="headerlink" title="2.TCP长连接"></a>2.TCP长连接</h2><p>TCP连接建立后只要不明确关闭，逻辑上连接一直存在。
TCP是有保活定时器的，可以打开保活定时器来维持长连接，设置SO_KEEPALIVE才会开启，时间间隔默认7200s，也就是2h，这个默认是关闭的。</p>
<p>注意：HTTP的keepalive和TCP的用处不大一样tcp。</p>
<h2 id="3-NAT超时"><a href="#3-NAT超时" class="headerlink" title="3.NAT超时"></a>3.NAT超时</h2><p>因为 IP v4 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换(Network Address Translation，NAT)。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯。
大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。
长连接心跳间隔必须要小于NAT超时时间(aging-time)，如果超过aging-time不做心跳，TCP长连接链路就会中断，Server就无法发送Push给手机，只能等到客户端下次心跳失败后，重建连接才能取到消息。</p>
<p>因为IPv4地址不足, 或者我们想通过无线路由器上网, 我们的设备可能会处在一个NAT设备的后面, 生活中最常见的NAT设备是家用路由器.
NAT设备会在IP封包通过设备时修改源/目的IP地址. 对于家用路由器来说, 使用的是网络地址端口转换(NAPT), 它不仅改IP, 还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP. 举个例子, NAPT维护一个类似下表的NAT表
|内网地址|    外网地址|
|—|—|
|192.168.0.2:5566|    120.132.92.21:9200|
|192.168.0.3:7788|    120.132.92.21:9201|
|192.168.0.3:8888|    120.132.92.21:9202|</p>
<p>NAT设备会根据NAT表对出去和进来的数据做修改, 比如将192.168.0.3:8888发出去的封包改成120.132.92.21:9202, 外部就认为他们是在和120.132.92.21:9202通信. 同时NAT设备会将120.132.92.21:9202收到的封包的IP和端口改成192.168.0.3:8888, 再发给内网的主机, 这样内部和外部就能双向通信了, 但如果其中192.168.0.3:8888 == 120.132.92.21:9202这一映射因为某些原因被NAT设备淘汰了, 那么外部设备就无法直接与192.168.0.3:8888通信了.</p>
<p>国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断.</p>
<h2 id="4-心跳包"><a href="#4-心跳包" class="headerlink" title="4.心跳包"></a>4.心跳包</h2><ul>
<li>心跳的原因：虽然理论tcp连接后一直不断，但实际上会断网。见：比如 NAT超时，更多 影响TCP连接寿命的因素</li>
<li>心跳包的主要作用是告知对方连接端，我还活着，心还在跳。</li>
<li>心跳时长多少？
　　
现实是残酷的, 根据网上的一些说法, 中移动2/3G下, NAT超时时间为5分钟, 中国电信3G则大于28分钟, 理想的情况下, 客户端应当以略小于NAT超时时间的间隔来发送心跳包.
|地区/网络|NAT超时时间|
|—|—|
|中国移动3G和2G|5分钟|
|中国联通2G|5分钟|
|中国电信3G|大于28分钟|
|美国3G|大于28分钟|
|台湾3G|大于28分钟|</li>
</ul>
<p>wifi下, NAT超时时间都会比较长, 据说宽带的网关一般没有空闲释放机制, GCM有些时候在wifi下的心跳比在移动网络下的心跳要快, 可能是因为wifi下联网通信耗费的电量比移动网络下小</p>
<h2 id="5-心跳包和轮询的区别"><a href="#5-心跳包和轮询的区别" class="headerlink" title="5.心跳包和轮询的区别"></a>5.心跳包和轮询的区别</h2><p>心跳包和轮询看起来类似, 都是客户端主动联系服务器, 但是区别很大.</p>
<ul>
<li>轮询是为了获取数据, 而心跳是为了保活TCP连接.</li>
<li>轮询得越频繁, 获取数据就越及时, 心跳的频繁与否和数据是否及时没有直接关系</li>
<li>轮询比心跳能耗更高, 因为一次轮询需要经过TCP三次握手, 四次挥手, 单次心跳不需要建立和拆除TCP连接.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-NAT&quot;&gt;&lt;a href=&quot;#1-NAT&quot; class=&quot;headerlink&quot; title=&quot;1.NAT&quot;&gt;&lt;/a&gt;1.NAT&lt;/h2&gt;&lt;p&gt;NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android架构之网络优化</title>
    <link href="http://wodekouwei.com/2019/03/08/tips-android-net/"/>
    <id>http://wodekouwei.com/2019/03/08/tips-android-net/</id>
    <published>2019-03-08T09:13:46.000Z</published>
    <updated>2019-03-27T01:57:19.386Z</updated>
    
    <content type="html"><![CDATA[<p>常规的网络框架设计和常用的网络优化方案。</p>
<ol>
<li>网络框架OkHttp</li>
</ol>
<ul>
<li>简洁易用的接口</li>
<li>拦截器机制，网络重试与跳转</li>
<li>连接池复用</li>
</ul>
<ol>
<li>网络加速</li>
</ol>
<ul>
<li>HttpDNS与IP直连</li>
<li>连接加速：短连接复用、Http2多路复用、长连接</li>
</ul>
<ol>
<li>数据压缩与序列化</li>
</ol>
<ul>
<li>Json vs ProtoBuf</li>
<li>压缩算法</li>
<li>序列化</li>
</ul>
<ol>
<li>长连接技术与Mars架构</li>
</ol>
<ul>
<li>智能心跳机制</li>
<li>自动重连</li>
<li>Android跨进程实现</li>
<li>智能唤醒</li>
</ul>
<ol>
<li>如何应对复杂网络</li>
</ol>
<ul>
<li>弱网</li>
<li>网络超时、振荡</li>
<li>404与DNS劫持</li>
</ul>
<ol>
<li>如何保证网络数据安全</li>
</ol>
<ul>
<li>TLS协议，握手与证书</li>
<li>数据签名及校验</li>
</ul>
<p><a href="https://github.com/dhhAndroid/RxWebSocket" target="_blank" rel="external">https://github.com/dhhAndroid/RxWebSocket</a></p>
<h3 id="网络错误"><a href="#网络错误" class="headerlink" title="网络错误"></a>网络错误</h3><h4 id="ECONNABORTED"><a href="#ECONNABORTED" class="headerlink" title="ECONNABORTED"></a>ECONNABORTED</h4><p>该错误被描述为“software caused connection abort”，即“软件引起的连接中止”。原因在于当服务和客户进程在完成用于 TCP 连接的“三次握手”后，客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用accept。 
SocketException: Software caused connection abort: recv failed
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Linux system */  </div><div class="line">  </div><div class="line">include/asm-alpha/errno.h:#define ECONNABORTED 53 /* Software caused connection </div><div class="line">abort */  </div><div class="line">include/asm-generic/errno.h:#define ECONNABORTED 103 /* Software caused </div><div class="line">connection abort */  </div><div class="line">include/asm-mips/errno.h:#define ECONNABORTED 130 /* Software caused connection </div><div class="line">abort */</div></pre></td></tr></table></figure></p>
<p>导致这个异常出现的根本原因可能有多个，
在服务端/客户端单方面关闭连接的情况下,另一方依然以为 tcp连接仍然建立,试图读取对方的响应数据,导致出现 Software caused connection abort: recv failed的异常. 
可能是是防火墙的原因。</p>
<h4 id="ECONNRESET"><a href="#ECONNRESET" class="headerlink" title="ECONNRESET"></a>ECONNRESET</h4><p>该错误被描述为“connection reset by peer”，即“对方复位连接”，这种情况一般发生在服务进程较客户进程提前终止。当服务进程终止时会向客户 TCP 发送 FIN 分节，客户 TCP 回应 ACK，服务 TCP 将转入 FIN_WAIT2 状态。此时如果客户进程没有处理该 FIN （如阻塞在其它调用上而没有关闭 Socket 时），则客户 TCP 将处于 CLOSE_WAIT 状态。当客户进程再次向 FIN_WAIT2 状态的服务 TCP 发送数据时，则服务 TCP 将立刻响应 RST。一般来说，这种情况还可以会引发另外的应用程序异常，客户进程在发送完数据后，往往会等待从网络IO接收数据，很典型的如 read 或 readline 调用，此时由于执行时序的原因，如果该调用发生在 RST 分节收到前执行的话，那么结果是客户进程会得到一个非预期的 EOF 错误。此时一般会输出“server terminated prematurely”－“服务器过早终止”错误。</p>
<h4 id="EPIPE"><a href="#EPIPE" class="headerlink" title="EPIPE"></a>EPIPE</h4><p>错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。</p>
<h4 id="ETIMEDOUT"><a href="#ETIMEDOUT" class="headerlink" title="ETIMEDOUT"></a>ETIMEDOUT</h4><p>错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。</p>
<h4 id="ENOPROTOOPT"><a href="#ENOPROTOOPT" class="headerlink" title="ENOPROTOOPT"></a>ENOPROTOOPT</h4><p>该错误不是一个 Socket 连接相关的错误。errno 给出该值可能由于，通过 getsockopt 系统调用来获得一个套接字的当前选项状态时，如果发现了系统不支持的选项参数就会引发该错误。
getsockopt/setsockopt(2) man page 写道
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">getsockopt, setsockopt -- get and set options on sockets.</div><div class="line"></div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">int getsockopt(int socket, int level, int option_name,</div><div class="line">void *restrict option_value, socklen_t *restrict option_len);</div><div class="line"></div><div class="line">int setsockopt(int socket, int level, int option_name,</div><div class="line">const void *option_value, socklen_t option_len);</div><div class="line"></div><div class="line">Getsockopt() and setsockopt() manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost &quot;socket&quot; level.</div></pre></td></tr></table></figure></p>
<p> 此外，getsockopt 和 setsockopt 还可能引发以下错误：</p>
<p>getsockopt/setsockopt(2) man page 写道
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ERRORS</div><div class="line"></div><div class="line">The getsockopt() and setsockopt() system calls will succeed unless:</div><div class="line"></div><div class="line">[EBADF] The argument socket is not a valid file descriptor.</div><div class="line">[EFAULT] The address pointed to by option_value is not in a valid part of the process dress space. For getsockopt(), this error may also be returned if option_len is not in a valid part of the process address space.</div><div class="line">[EINVAL] The option is invalid at the level indicated.</div><div class="line">[ENOBUFS]Insufficient memory buffers are available.</div><div class="line">[ENOPROTOOPT] The option is unknown at the level indicated.</div><div class="line">[ENOTSOCK] The argument socket is not a socket (e.g., a plain file).</div><div class="line"></div><div class="line">The setsockopt() system call will succeed unless:</div><div class="line"></div><div class="line">[EDOM] The argument option_value is out of bounds.</div><div class="line">[EISCONN]socket is already connected and a specified option cannot be set while this is the case.</div></pre></td></tr></table></figure></p>
<h4 id="ECONNEREFUSED"><a href="#ECONNEREFUSED" class="headerlink" title="ECONNEREFUSED"></a>ECONNEREFUSED</h4><p>A “connect failed: ECONNREFUSED (Connection refused)” most likely means that there is nothing listening on that port AND that IP address. Possible explanations include:</p>
<ul>
<li>the service has crashed or hasn’t been started,</li>
<li>your client is trying to connect using the wrong IP address or port, or</li>
<li>server access is being blocked by a firewall that is “refusing” on the server/service’s behalf. This is pretty unlikely given that normal practice (these days) is for firewalls to “blackhole” all unwanted connection attempts.</li>
<li>The server couldn’t send a response: Ensure that the backend is working properly at IP and port mentioned.</li>
<li>SSL connections are being blocked: Fix this by importing SSL certificates</li>
<li>Cookies not being sent</li>
<li>Request timeout: Change request timeout</li>
</ul>
<h3 id="The-java-net-SocketException-is-thrown-when-there-is-an-error-creating-or-accessing-a-socket-such-as-TCP-This-usually-can-be-caused-when-the-server-has-terminated-the-connection-without-properly-closing-it-so-before-getting-the-full-response-In-most-cases-this-can-be-caused-either-by-the-timeout-issue-e-g-the-response-takes-too-much-time-or-server-is-overloaded-with-the-requests-or-the-client-sent-the-SYN-but-it-didn’t-receive-ACK-acknowledgment-of-the-connection-termination-For-timeout-issues-you-can-consider-increasing-the-timeout-value"><a href="#The-java-net-SocketException-is-thrown-when-there-is-an-error-creating-or-accessing-a-socket-such-as-TCP-This-usually-can-be-caused-when-the-server-has-terminated-the-connection-without-properly-closing-it-so-before-getting-the-full-response-In-most-cases-this-can-be-caused-either-by-the-timeout-issue-e-g-the-response-takes-too-much-time-or-server-is-overloaded-with-the-requests-or-the-client-sent-the-SYN-but-it-didn’t-receive-ACK-acknowledgment-of-the-connection-termination-For-timeout-issues-you-can-consider-increasing-the-timeout-value" class="headerlink" title="The java.net.SocketException is thrown when there is an error creating or accessing a socket (such as TCP). This usually can be caused when the server has terminated the connection (without properly closing it), so before getting the full response. In most cases this can be caused either by the timeout issue (e.g. the response takes too much time or server is overloaded with the requests), or the client sent the SYN, but it didn’t receive ACK (acknowledgment of the connection termination). For timeout issues, you can consider increasing the timeout value."></a>The java.net.SocketException is thrown when there is an error creating or accessing a socket (such as TCP). This usually can be caused when the server has terminated the connection (without properly closing it), so before getting the full response. In most cases this can be caused either by the timeout issue (e.g. the response takes too much time or server is overloaded with the requests), or the client sent the SYN, but it didn’t receive ACK (acknowledgment of the connection termination). For timeout issues, you can consider increasing the timeout value.</h3><p>The Socket Exception usually comes with the specified detail message about the issue.</p>
<p>Example of detailed messages:</p>
<p>Software caused connection abort: recv failed.</p>
<p>The error indicates an attempt to send the message and the connection has been aborted by your server. If this happened while connecting to the database, this can be related to using not compatible Connector/J JDBC driver.</p>
<p>Possible solution: Make sure you’ve proper libraries/drivers in your CLASSPATH.</p>
<p>Software caused connection abort: connect.</p>
<p>This can happen when there is a problem to connect to the remote. For example due to virus-checker rejecting the remote mail requests.</p>
<p>Possible solution: Check Virus scan service whether it’s blocking the port for the outgoing requests for connections.</p>
<p>Software caused connection abort: socket write error.</p>
<p>Possible solution: Make sure you’re writing the correct length of bytes to the stream. So double check what you’re sending. See this thread.</p>
<p>Connection reset by peer: socket write error / Connection aborted by peer: socket write error</p>
<p>The application did not check whether keep-alive connection had been timed out on the server side.</p>
<p>Possible solution: Ensure that the HttpClient is non-null before reading from the connection.E13222_01</p>
<p>Connection reset by peer.</p>
<p>The connection has been terminated by the peer (server).</p>
<p>Connection reset.</p>
<p>The connection has been either terminated by the client or closed by the server end of the connection due to request with the request.</p>
<p><a href="https://stackoverflow.com/q/585599/55075" target="_blank" rel="external">What’s causing my java.net.SocketException: Connection reset?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常规的网络框架设计和常用的网络优化方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络框架OkHttp&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;简洁易用的接口&lt;/li&gt;
&lt;li&gt;拦截器机制，网络重试与跳转&lt;/li&gt;
&lt;li&gt;连接池复用&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;网络加速&lt;/
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Android SharedPreference详解</title>
    <link href="http://wodekouwei.com/2019/03/07/tips-android-sharedpreferences/"/>
    <id>http://wodekouwei.com/2019/03/07/tips-android-sharedpreferences/</id>
    <published>2019-03-07T04:17:40.000Z</published>
    <updated>2019-03-07T08:33:07.341Z</updated>
    
    <content type="html"><![CDATA[<p>SharedPreferences作为一种数据持久化的方式，是处理简单的key-value类型数据时的首选。</p>
<h3 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法:"></a>一般用法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//demo是该sharedpreference对应文件名,对应的是一个xml文件,里面存放key-value格式的数据.</div><div class="line">SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;demo&quot;, MODE_WORLD_WRITEABLE);</div><div class="line">//提供了getXXX的读取数据方法</div><div class="line">boolean xxx = sharedPreferences.getBoolean(&quot;xxx&quot;, false);</div><div class="line">//通过Editor提供了putXXX系列的存储方法,调用完需要使用apply()或commit()使之生效,不同点后面介绍</div><div class="line">SharedPreferences.Editor edit = sharedPreferences.edit();</div><div class="line">edit.putBoolean(&quot;xxx&quot;, true);</div><div class="line">edit.apply();//使存储生效</div><div class="line">//edit.commit();//使存储生效</div></pre></td></tr></table></figure>
<p>每个SharedPreferences都对应了当前package的<code>data/data/package_name/share_prefs/</code>目录下的一个文件</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>Context.java中getSharedPreferences接口说明:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Retrieve and hold the contents of the preferences file &apos;name&apos;, returning</div><div class="line">     * a SharedPreferences through which you can retrieve and modify its</div><div class="line">     * values.  Only one instance of the SharedPreferences object is returned</div><div class="line">     * to any callers for the same name, meaning they will see each other&apos;s</div><div class="line">     * edits as soon as they are made.</div><div class="line">     *</div><div class="line">     * @param name Desired preferences file. If a preferences file by this name</div><div class="line">     * does not exist, it will be created when you retrieve an</div><div class="line">     * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).</div><div class="line">     * @param mode Operating mode.  Use 0 or &#123;@link #MODE_PRIVATE&#125; for the</div><div class="line">     * default operation, &#123;@link #MODE_WORLD_READABLE&#125;</div><div class="line">     * and &#123;@link #MODE_WORLD_WRITEABLE&#125; to control permissions.</div><div class="line">     *</div><div class="line">     * @return The single &#123;@link SharedPreferences&#125; instance that can be used</div><div class="line">     *         to retrieve and modify the preference values.</div><div class="line">     *</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">    public abstract SharedPreferences getSharedPreferences(String name,</div><div class="line">            int mode);</div></pre></td></tr></table></figure></p>
<p>ContextImpl中getSharedPreferences实现:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public SharedPreferences getSharedPreferences(String name, int mode) &#123;</div><div class="line">        SharedPreferencesImpl sp;</div><div class="line">        synchronized (ContextImpl.class) &#123;</div><div class="line">            if (sSharedPrefs == null) &#123;</div><div class="line">                sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String packageName = getPackageName();</div><div class="line">            ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</div><div class="line">            if (packagePrefs == null) &#123;</div><div class="line">                packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</div><div class="line">                sSharedPrefs.put(packageName, packagePrefs);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // At least one application in the world actually passes in a null</div><div class="line">            // name.  This happened to work because when we generated the file name</div><div class="line">            // we would stringify it to &quot;null.xml&quot;.  Nice.</div><div class="line">            if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">                    Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">                if (name == null) &#123;</div><div class="line">                    name = &quot;null&quot;;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sp = packagePrefs.get(name);</div><div class="line">            if (sp == null) &#123;</div><div class="line">                File prefsFile = getSharedPrefsFile(name);</div><div class="line">                sp = new SharedPreferencesImpl(prefsFile, mode);</div><div class="line">                packagePrefs.put(name, sp);</div><div class="line">                return sp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">            // If somebody else (some other process) changed the prefs</div><div class="line">            // file behind our back, we reload it.  This has been the</div><div class="line">            // historical (if undocumented) behavior.</div><div class="line">            sp.startReloadIfChangedUnexpectedly();</div><div class="line">        &#125;</div><div class="line">        return sp;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码里，我们可以看出，</p>
<ol>
<li>SharedPreferencesImpl是保存在全局个map cache里的，只会创建一次。</li>
<li>MODE_MULTI_PROCESS模式下，每次获取都会尝试去读取文件reload。当然会有一些逻辑尽量减少读取次数，比如当前是否有正在进行的读取操作，文件的修改时间和大小与上次有没有变化等。</li>
</ol>
<p>Context.java中提供了以下四种mode:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">//这是默认模式，仅caller uid的进程可访问</div><div class="line">/**</div><div class="line">     * File creation mode: the default mode, where the created file can only</div><div class="line">     * be accessed by the calling application (or all applications sharing the</div><div class="line">     * same user ID).</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">int MODE_PRIVATE = 0x0000;</div><div class="line"></div><div class="line">//所有人可写，也就是任何应用都可修改它，这是极其危险的，因此改选项已被Deprected</div><div class="line">/**</div><div class="line">     * @deprecated Creating world-readable files is very dangerous, and likely</div><div class="line">     * to cause security holes in applications.  It is strongly discouraged;</div><div class="line">     * instead, applications should use more formal mechanism for interactions</div><div class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</div><div class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</div><div class="line">     * access mode will remain on a file, such as when it goes through a</div><div class="line">     * backup and restore.</div><div class="line">     * File creation mode: allow all other applications to have read access</div><div class="line">     * to the created file.</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">int MODE_WORLD_READABLE = 0x0001; </div><div class="line"></div><div class="line">//所有人可读，这个参数同样非常危险，可能导致隐私数据泄漏</div><div class="line">/**</div><div class="line">     * @deprecated Creating world-writable files is very dangerous, and likely</div><div class="line">     * to cause security holes in applications.  It is strongly discouraged;</div><div class="line">     * instead, applications should use more formal mechanism for interactions</div><div class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</div><div class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</div><div class="line">     * access mode will remain on a file, such as when it goes through a</div><div class="line">     * backup and restore.</div><div class="line">     * File creation mode: allow all other applications to have write access</div><div class="line">     * to the created file.</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     */</div><div class="line">int MODE_WORLD_READABLE = 0x0002</div><div class="line"></div><div class="line">//设置该参数后，每次获取对应的SharedPreferences时都会尝试从磁盘中读取修改过的文件 </div><div class="line">/**</div><div class="line">     * SharedPreference loading flag: when set, the file on disk will</div><div class="line">     * be checked for modification even if the shared preferences</div><div class="line">     * instance is already loaded in this process.  This behavior is</div><div class="line">     * sometimes desired in cases where the application has multiple</div><div class="line">     * processes, all writing to the same SharedPreferences file.</div><div class="line">     * Generally there are better forms of communication between</div><div class="line">     * processes, though.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;This was the legacy (but undocumented) behavior in and</div><div class="line">     * before Gingerbread (Android 2.3) and this flag is implied when</div><div class="line">     * targetting such releases.  For applications targetting SDK</div><div class="line">     * versions &lt;em&gt;greater than&lt;/em&gt; Android 2.3, this flag must be</div><div class="line">     * explicitly set if desired.</div><div class="line">     *</div><div class="line">     * @see #getSharedPreferences</div><div class="line">     *</div><div class="line">     * @deprecated MODE_MULTI_PROCESS does not work reliably in</div><div class="line">     * some versions of Android, and furthermore does not provide any</div><div class="line">     * mechanism for reconciling concurrent modifications across</div><div class="line">     * processes.  Applications should not attempt to use it.  Instead,</div><div class="line">     * they should use an explicit cross-process data management</div><div class="line">     * approach such as &#123;@link android.content.ContentProvider ContentProvider&#125;.</div><div class="line">     */</div><div class="line">int MODE_MULTI_PROCESS = 0x0004;</div></pre></td></tr></table></figure></p>
<h4 id="MODE-MULTI-PROCESS"><a href="#MODE-MULTI-PROCESS" class="headerlink" title="MODE_MULTI_PROCESS"></a>MODE_MULTI_PROCESS</h4><p>当设置MODE_MULTI_PROCESS这个参数的时候，即使当前进程内已经创建了该SharedPreferences，仍然在每次获取的时候都会尝试从本地文件中刷新。在同一个进程中，同一个文件只有一个实例。MODE_MULTI_PROCESS的作用如上getSharedPreferences实现.这个方法先判断是否已创建SharedPreferences实例，若未创建，则先创建。之后判断mode如果为MODE_MULTI_PROCESS, 则调用startReloadIfChangeUnexpectedly()，看下其实现:
SharedPreferencesImpl.java
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void startReloadIfChangedUnexpectedly() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            // TODO: wait for any pending writes to disk?</div><div class="line">            if (!hasFileChangedUnexpectedly()) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            startLoadFromDisk();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mLoaded = false;</div><div class="line">        &#125;</div><div class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    loadFromDiskLocked();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出MODE_MULTI_PROCESS的作用就是在每次获取SharedPreferences实例的时候尝试从磁盘中加载修改过的数据，并且读取是在异步线程中，因此一个线程的修改最终会反映到另一个线程，但不能立即反映到另一个进程，所以通过SharedPreferences无法实现多进程同步。
综合: 如果仅仅让多进程可访问同一个SharedPref文件，不需要设置MODE_MULTI_PROCESS, 如果需要实现多进程同步，必须设置这个参数，但也只能实现最终一致，无法即时同步。</p>
<p><strong>由于SharedPreference内容都会在内存里存一份，所以不要使用SharedPreference保存较大的内容，避免不必要的内存浪费。</strong></p>
<p>注意有一个锁mLoaded ,在对SharedPreference做其他操作时，都必须等待该锁释放:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Nullable</div><div class="line">    public String getString(String key, @Nullable String defValue) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            awaitLoadedLocked();</div><div class="line">            String v = (String)mMap.get(key);</div><div class="line">            return v != null ? v : defValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>写操作有两个commit apply 。 commit 是同步的，写入内存的同时会等待写入文件完成，apply是异步的，先写入内存，在异步线程里再写入文件。apply肯定要快一些,优先推荐使用apply:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">         * Commit your preferences changes back from this Editor to the</div><div class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line">         * performs the requested modifications, replacing whatever is currently</div><div class="line">         * in the SharedPreferences.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line">         * time, the last one to call commit wins.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;If you don&apos;t care about the return value and you&apos;re</div><div class="line">         * using this from your application&apos;s main thread, consider</div><div class="line">         * using &#123;@link #apply&#125; instead.</div><div class="line">         *</div><div class="line">         * @return Returns true if the new values were successfully written</div><div class="line">         * to persistent storage.</div><div class="line">         */</div><div class="line">        boolean commit();</div><div class="line">        /**</div><div class="line">         * Commit your preferences changes back from this Editor to the</div><div class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line">         * performs the requested modifications, replacing whatever is currently</div><div class="line">         * in the SharedPreferences.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line">         * time, the last one to call apply wins.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out</div><div class="line">         * to persistent storage synchronously, &#123;@link #apply&#125;</div><div class="line">         * commits its changes to the in-memory</div><div class="line">         * &#123;@link SharedPreferences&#125; immediately but starts an</div><div class="line">         * asynchronous commit to disk and you won&apos;t be notified of</div><div class="line">         * any failures.  If another editor on this</div><div class="line">         * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125;</div><div class="line">         * while a &#123;@link #apply&#125; is still outstanding, the</div><div class="line">         * &#123;@link #commit&#125; will block until all async commits are</div><div class="line">         * completed as well as the commit itself.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within</div><div class="line">         * a process, it&apos;s safe to replace any instance of &#123;@link #commit&#125; with</div><div class="line">         * &#123;@link #apply&#125; if you were already ignoring the return value.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;You don&apos;t need to worry about Android component</div><div class="line">         * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt;</div><div class="line">         * writing to disk.  The framework makes sure in-flight disk</div><div class="line">         * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching</div><div class="line">         * states.</div><div class="line">         *</div><div class="line">         * &lt;p class=&apos;note&apos;&gt;The SharedPreferences.Editor interface</div><div class="line">         * isn&apos;t expected to be implemented directly.  However, if you</div><div class="line">         * previously did implement it and are now getting errors</div><div class="line">         * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call</div><div class="line">         * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;.</div><div class="line">         */</div><div class="line">        void apply();</div></pre></td></tr></table></figure></p>
<p>注册/解注册sharedpreference变动监听:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Registers a callback to be invoked when a change happens to a preference.</div><div class="line">     *</div><div class="line">     * &lt;p class=&quot;caution&quot;&gt;&lt;strong&gt;Caution:&lt;/strong&gt; The preference manager does</div><div class="line">     * not currently store a strong reference to the listener. You must store a</div><div class="line">     * strong reference to the listener, or it will be susceptible to garbage</div><div class="line">     * collection. We recommend you keep a reference to the listener in the</div><div class="line">     * instance data of an object that will exist as long as you need the</div><div class="line">     * listener.&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param listener The callback that will run.</div><div class="line">     * @see #unregisterOnSharedPreferenceChangeListener</div><div class="line">     */</div><div class="line">    void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Unregisters a previous callback.</div><div class="line">     * </div><div class="line">     * @param listener The callback that should be unregistered.</div><div class="line">     * @see #registerOnSharedPreferenceChangeListener</div><div class="line">     */</div><div class="line">    void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</div></pre></td></tr></table></figure></p>
<h4 id="为什么不推荐使用MODE-MULTI-PROCESS"><a href="#为什么不推荐使用MODE-MULTI-PROCESS" class="headerlink" title="为什么不推荐使用MODE_MULTI_PROCESS?"></a>为什么不推荐使用MODE_MULTI_PROCESS?</h4><p>android文档已经Deprected了这个flag，并且说明不应该通过SharedPreference做进程间数据共享？这是为啥呢？从前面但分析可看到当设置这个flag后，每次获取(获取而不是初次创建)SharedPreferences实例的时候，会判断shared_pref文件是否修改过:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private boolean hasFileChangedUnexpectedly() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mDiskWritesInFlight &gt; 0) &#123;</div><div class="line">                // If we know we caused it, it&apos;s not unexpected.</div><div class="line">                if (DEBUG) Log.d(TAG, &quot;disk write in flight, not unexpected.&quot;);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final StructStat stat;</div><div class="line">        try &#123;</div><div class="line">            /*</div><div class="line">             * Metadata operations don&apos;t usually count as a block guard</div><div class="line">             * violation, but we explicitly want this one.</div><div class="line">             */</div><div class="line">            BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">            stat = Os.stat(mFile.getPath());</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里先判断mDiskWritesInFlight&gt;0，如果成立，说明是当前进程修改了文件，不需要重新读取。然后通过文件最后修改时间，判断文件是否修改过。如果修改了，则重新读取:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mLoaded = false;</div><div class="line">        &#125;</div><div class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    loadFromDiskLocked();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void loadFromDiskLocked() &#123;</div><div class="line">        if (mLoaded) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (mBackupFile.exists()) &#123;</div><div class="line">            mFile.delete();</div><div class="line">            mBackupFile.renameTo(mFile);</div><div class="line">        &#125;</div><div class="line">        Map map = null;</div><div class="line">        StructStat stat = null;</div><div class="line">        try &#123;</div><div class="line">            stat = Os.stat(mFile.getPath());</div><div class="line">            if (mFile.canRead()) &#123;</div><div class="line">                BufferedInputStream str = null;</div><div class="line">                try &#123;</div><div class="line">                    str = new BufferedInputStream(</div><div class="line">                            new FileInputStream(mFile), 16*1024);</div><div class="line">                    map = XmlUtils.readMapXml(str);</div><div class="line">                &#125; finally &#123;</div><div class="line">                    IoUtils.closeQuietly(str);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">        &#125;</div><div class="line">        mLoaded = true;</div><div class="line">        if (map != null) &#123;</div><div class="line">            mMap = map;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125; else &#123;</div><div class="line">            mMap = new HashMap&lt;String, Object&gt;();</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里起码有3个坑！</p>
<ol>
<li>使用MODE_MULTI_PROCESS时，不要保存SharedPreference变量，必须每次都从context.getSharedPreferences 获取。如果你图方便使用变量存了下来，那么无法触发reload，有可能两个进程数据不同步。</li>
<li>前面提到过，load数据是耗时的，并且其他操作会等待该锁。这意味着很多时候获取SharedPreference数据都不得不从文件再读一遍，大大降低了内存缓存的作用。文件读写耗时也影响了性能。</li>
<li>修改数据时得用commit，保证修改时写入了文件，这样其他进程才能通过文件大小或修改时间感知到。</li>
</ol>
<p>重点是这段:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mBackupFile.exists()) &#123;</div><div class="line">      mFile.delete();</div><div class="line">      mBackupFile.renameTo(mFile);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新读取时，如果发现存在mBackupFile,则将原文件mFile删除，并将mBackupFile重命名为mFile。mBackupFile又是如何创建的呢？答案是在修改SharedPreferences时将内存中的数据写会磁盘时创建的:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">        // Rename the current file so it may be used as a backup during the next read</div><div class="line">        if (mFile.exists()) &#123;</div><div class="line">            if (!mBackupFile.exists()) &#123;</div><div class="line">                if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                    mcr.setDiskWriteResult(false);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                mFile.delete();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        final StructStat stat = Os.stat(mFile.getPath());</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        mcr.setDiskWriteResult(true);</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码只保留了核心流程，忽略了错误处理流程。可以看到，写文件的步骤大致是:</p>
<ol>
<li>将原文件重命名为mBackupFile</li>
<li>重新创建原文件mFile, 并将内容写入其中</li>
<li>删除mBackupFile</li>
</ol>
<p>所以，只有当一个进程正处于写文件的过程中的时候，如果另一个进程读文件，才会看到mBackupFile, 这时候读进程会将mBackupFile重命名为mFile, 这样读结果是，读进程只能读到修改前的文件，同时，由于mBackupFile重命名为了mFile,  所以写进程写那个文件就没有文件名引用了，因此其写入的内容无法再被任何进程访问到。所以其内容丢失了，可认为写入失败了，而SharedPreferences对这种失败情况没有任何重试机制，所以就可能出现数据丢失的情况。
回到这段的重点：为什么不推荐用MODE_MULTI_PROCESS？从前面分析可知，这种模式下，每次获取SharedPreferences都会检测文件是否改变，只要读的时候另一进程在写，就会导致写丢失。这样失败概率就会大幅度提高。反之，若不设置这个模式，则只在第一次创建SharedPreferences的时候读取，导致写失败的概率就会大幅度降低，当然，仍然存在失败的可能。</p>
<h4 id="为什么不做写失败重试？"><a href="#为什么不做写失败重试？" class="headerlink" title="为什么不做写失败重试？"></a>为什么不做写失败重试？</h4><p>为什么android不做写失败重试呢？原因是写进程并不能发现写失败的情况。难道写的过程中，目标文件被删不会抛异常吗？答案是不会。删除文件只是从文件系统中删除了一个节点信息而已，重命名也是新建了一个具有相同名称的节点信息，并把文件地址指向另一个磁盘地址而已，原来，之前的写过程仍然会成功写到原来的磁盘地址。所以目前的实现方案并不能检测到失败。</p>
<h4 id="有没有办法解决写失败呢？"><a href="#有没有办法解决写失败呢？" class="headerlink" title="有没有办法解决写失败呢？"></a>有没有办法解决写失败呢？</h4><p>个人觉得是可以做到的，读里面读那段关键操作:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mBackupFile.exists()) &#123;</div><div class="line">      mFile.delete();</div><div class="line">      mBackupFile.renameTo(mFile);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mBackupFile存在，意味着当前正处于写读过程中，这时候是不是可以考虑直接读mBackupFile文件，而不删除mFile呢？这样读话，读取效果一样，都是读的mBackupFile，同时写进程写的mFile也不会被mBacupFile覆盖，写也就能成功了。即使通过这段代码重命名，写进程写完后发现mBackupFile不存在了，其实也能认为发生了读重命名，大可以重试一次。</p>
<h3 id="多进程使用SharedPreference方案"><a href="#多进程使用SharedPreference方案" class="headerlink" title="多进程使用SharedPreference方案"></a>多进程使用SharedPreference方案</h3><p>说简单也简单，就是依据google的建议使用ContentProvider了。我看过网上很多的例子，但总是觉得少了点什么</p>
<p>有的方案里将所有读取操作都写作静态方法，没有继承SharedPreference 。 这样做需要强制改变调用者的使用习惯，不怎么好。
大部分方案做成ContentProvider后，所有的调用都走的ContentProvider。但如果调用进程与SharedPreference 本身就是同一个进程，只用走原生的流程就行了，不用拐个弯去访问ContentProvider，减少不必要的性能损耗。</p>
<p>我这里也写了一个跨进程方案，简单介绍如下
SharedPreferenceProxy 继承SharedPreferences。其所有操作都是通过ContentProvider完成。简要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class SharedPreferenceProxy implements SharedPreferences &#123;</div><div class="line">@Nullable</div><div class="line">    @Override</div><div class="line">    public String getString(String key, @Nullable String defValue) &#123;</div><div class="line">        OpEntry result = getResult(OpEntry.obtainGetOperation(key).setStringValue(defValue));</div><div class="line">        return result == null ? defValue : result.getStringValue(defValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Editor edit() &#123;</div><div class="line">        return new EditorImpl();</div><div class="line">    &#125;</div><div class="line">    private OpEntry getResult(@NonNull OpEntry input) &#123;</div><div class="line">        try &#123;</div><div class="line">            Bundle res = ctx.getContentResolver().call(PreferenceUtil.URI</div><div class="line">                    , PreferenceUtil.METHOD_QUERY_VALUE</div><div class="line">                    , preferName</div><div class="line">                    , input.getBundle());</div><div class="line">            return new OpEntry(res);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">...</div><div class="line"></div><div class="line">    public class EditorImpl implements Editor &#123;</div><div class="line">        private ArrayList&lt;OpEntry&gt; mModified = new ArrayList&lt;&gt;();</div><div class="line">        @Override</div><div class="line">        public Editor putString(String key, @Nullable String value) &#123;</div><div class="line">            OpEntry entry = OpEntry.obtainPutOperation(key).setStringValue(value);</div><div class="line">            return addOps(entry);</div><div class="line">        &#125;</div><div class="line">       @Override</div><div class="line">        public void apply() &#123;</div><div class="line">            Bundle intput = new Bundle();</div><div class="line">            intput.putParcelableArrayList(PreferenceUtil.KEY_VALUES, convertBundleList());</div><div class="line">            intput.putInt(OpEntry.KEY_OP_TYPE, OpEntry.OP_TYPE_APPLY);</div><div class="line">            try &#123;</div><div class="line">                ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_EIDIT_VALUE, preferName, intput);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">...</div><div class="line">        &#125;</div><div class="line">...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>OpEntry只是一个对Bundle操作封装的类。
所有跨进程的操作都是通过SharedPreferenceProvider的call方法完成。SharedPreferenceProvider里会访问真正的SharedPreference
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SharedPreferenceProvider extends ContentProvider&#123;</div><div class="line"></div><div class="line">    private Map&lt;String, MethodProcess&gt; processerMap = new ArrayMap&lt;&gt;();</div><div class="line">    @Override</div><div class="line">    public boolean onCreate() &#123;</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_VALUE, methodQueryValues);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_CONTAIN_KEY, methodContainKey);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_EIDIT_VALUE, methodEditor);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_PID, methodQueryPid);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;</div><div class="line">        MethodProcess processer = processerMap.get(method);</div><div class="line">        return processer == null?null:processer.process(arg, extras);</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重要差别的地方在这里：在调用getSharedPreferences时，会先判断caller的进程pid是否与SharedPreferenceProvider相同。如果不同，则返回SharedPreferenceProxy。如果相同，则返回ctx.getSharedPreferences。只会在第一次调用时进行判断，结果会保存起来。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public static SharedPreferences getSharedPreferences(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        //First check if the same process</div><div class="line">        if (processFlag.get() == 0) &#123;</div><div class="line">            Bundle bundle = ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_QUERY_PID, &quot;&quot;, null);</div><div class="line">            int pid = 0;</div><div class="line">            if (bundle != null) &#123;</div><div class="line">                pid = bundle.getInt(PreferenceUtil.KEY_VALUES);</div><div class="line">            &#125;</div><div class="line">            //Can not get the pid, something wrong!</div><div class="line">            if (pid == 0) &#123;</div><div class="line">                return getFromLocalProcess(ctx, preferName);</div><div class="line">            &#125;</div><div class="line">            processFlag.set(Process.myPid() == pid ? 1 : -1);</div><div class="line">            return getSharedPreferences(ctx, preferName);</div><div class="line">        &#125; else if (processFlag.get() &gt; 0) &#123;</div><div class="line">            return getFromLocalProcess(ctx, preferName);</div><div class="line">        &#125; else &#123;</div><div class="line">            return getFromRemoteProcess(ctx, preferName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private static SharedPreferences getFromRemoteProcess(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        synchronized (SharedPreferenceProxy.class) &#123;</div><div class="line">            if (sharedPreferenceProxyMap == null) &#123;</div><div class="line">                sharedPreferenceProxyMap = new ArrayMap&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            SharedPreferenceProxy preferenceProxy = sharedPreferenceProxyMap.get(preferName);</div><div class="line">            if (preferenceProxy == null) &#123;</div><div class="line">                preferenceProxy = new SharedPreferenceProxy(ctx.getApplicationContext(), preferName);</div><div class="line">                sharedPreferenceProxyMap.put(preferName, preferenceProxy);</div><div class="line">            &#125;</div><div class="line">            return preferenceProxy;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static SharedPreferences getFromLocalProcess(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        return ctx.getSharedPreferences(preferName, Context.MODE_PRIVATE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样，只有当调用者是正真跨进程时才走的contentProvider。对于同进程的情况，就没有必要走contentProvider了。对调用者来说，这都是透明的，只需要获取SharedPreferences就行了，不用关心获得的是SharedPreferenceProxy，还是SharedPreferenceImpl。即使你当前没有涉及到多进程使用，将所有获取SharedPreference的地方封装并替换后，对当前逻辑也没有任何影响。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SharedPreferences作为一种数据持久化的方式，是处理简单的key-value类型数据时的首选。&lt;/p&gt;
&lt;h3 id=&quot;一般用法&quot;&gt;&lt;a href=&quot;#一般用法&quot; class=&quot;headerlink&quot; title=&quot;一般用法:&quot;&gt;&lt;/a&gt;一般用法:&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter介绍</title>
    <link href="http://wodekouwei.com/2019/03/07/flutter-introduce/"/>
    <id>http://wodekouwei.com/2019/03/07/flutter-introduce/</id>
    <published>2019-03-07T02:19:24.000Z</published>
    <updated>2019-03-07T02:29:23.423Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter是一款由Google开发的开源、跨平台的移动端开发框架，使用Flutter开发出的应用符合不同平台的原生体验，可以让应用看起来跟系统更加协调。
Flutter是一个全新的移动UI框架，它允许使用同一个代码库构建高性能的Android和iOS应用，同时它也是Google即将推出的Fuchsia操作系统的开发平台。通过自定义的Flutter引擎可以将其嵌入到其他平台，旨在帮助开发者使用一套代码开发高性能、高保真的Android和iOS应用。</p>
<h3 id="Flutter优点"><a href="#Flutter优点" class="headerlink" title="Flutter优点"></a>Flutter优点</h3><h4 id="原生性能"><a href="#原生性能" class="headerlink" title="原生性能"></a>原生性能</h4><p>Flutter会以原生的性能提供给开发者，它的开发性能非常接近传统的Native，包括渲染方式、AOT的编译方式和其他优化。</p>
<p>Flutter开发的页面跟Native没有差距。在安卓中低端机型里，基于Flutter开发出来的APP在帧率上会有更流畅的体现，内存占用也会有更低的消耗。</p>
<p><strong>渲染方式,AOT,无锁GC</strong></p>
<h4 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h4><p>Flutter因其本身的跨端性，大幅提升了传统的安卓开发速度。一般认为，前端开发的速度较快，基于Flutter，开发速度比前端更快。
<strong>压秒级,有状态的热重载</strong></p>
<h4 id="统一的应用开发体验"><a href="#统一的应用开发体验" class="headerlink" title="统一的应用开发体验"></a>统一的应用开发体验</h4><p>在跨端层面上，由于Flutter把两端的渲染机制下沉到更低的渲染层，基于统一的C++层的渲染引擎来搭建底层的UI框架，因此，Flutter会让跨端体验得到更一致的效果。
<strong>两端一致的开发方式,MD和IOS风格</strong></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>内存的问题。随着Flutter页面的堆栈变得越来越深，内存的释放并没有得到及时的释放。</li>
<li>字体的问题。不同的字体在不同的机器里渲染的效果非常不一致。</li>
<li>截图会出现黑屏的问题。</li>
<li>图片缓存的问题。跟安卓端的图片缓存是完全不同的体系。</li>
<li>它的暗黑区、适配问题，</li>
<li>私有库、中间件的适配，</li>
<li>不支持反射和序列化，</li>
<li>集成问题,怎么把Native的组件集成到Flutter体系</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter是一款由Google开发的开源、跨平台的移动端开发框架，使用Flutter开发出的应用符合不同平台的原生体验，可以让应用看起来跟系统更加协调。
Flutter是一个全新的移动UI框架，它允许使用同一个代码库构建高性能的Android和iOS应用，同时它也是Go
    
    </summary>
    
      <category term="flutter" scheme="http://wodekouwei.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="http://wodekouwei.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>应用targetSdkVersion升级指导</title>
    <link href="http://wodekouwei.com/2019/03/05/tips-android-targetsdkversion/"/>
    <id>http://wodekouwei.com/2019/03/05/tips-android-targetsdkversion/</id>
    <published>2019-03-05T08:00:20.000Z</published>
    <updated>2019-03-05T11:25:01.232Z</updated>
    
    <content type="html"><![CDATA[<p>应电信终端产业协会（TAF）发布的《移动应用软件高 API 等级预置与分发自律公约》（以下简称《公约》）要求：截止到2019年5月1日所有新发布的应用 API 必须为26或更高，2019年8月1日现有应用 API 必须升级为26或更高。《公约》发布至今得到了国内主流互联网及终端制造企业的积极响应。</p>
<ul>
<li>对应用开发者来说，不按时更新Target SDK版本的应用，应用市场将采取强制下架的策略，已上架应用将无法更新。</li>
<li>对用户来说，未适配Android M或更高版本的应用安装在Android M或更高版本时，会默认授予申请的所有权限，且应用运行时无弹框授权提示。其中包括通讯录、电话、短信、通讯记录、位置、麦克风、相机等危险权限，导致用户在不知情的情况下泄露隐私信息，对用户个人信息安全造成危害。</li>
</ul>
<p><strong>应用targetSdkVersion升级流程</strong>
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935161819.jpg" alt="tips-android-targetsdkversion-201935161819"></p>
<h2 id="targetSdkVersion-相关变更介绍"><a href="#targetSdkVersion-相关变更介绍" class="headerlink" title="targetSdkVersion 相关变更介绍"></a>targetSdkVersion 相关变更介绍</h2><h3 id="Android5-x（22-19）及以下版本变更"><a href="#Android5-x（22-19）及以下版本变更" class="headerlink" title="Android5.x（22-19）及以下版本变更"></a>Android5.x（22-19）及以下版本变更</h3><p><img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935184537.jpg" alt="tips-android-targetsdkversion-201935184537"></p>
<h3 id="Android6-0变更"><a href="#Android6-0变更" class="headerlink" title="Android6.0变更"></a>Android6.0变更</h3><h4 id="（一）相关变更"><a href="#（一）相关变更" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><p><strong>运行时权限</strong></p>
<p>此版本引入了一种新的权限模式，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，为安装的应用分别授予或撤销权限，同时为开发者精简了安装和自动更新过程。</p>
<p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。确定应用是否已被授予权限，可调用新增的 checkSelfPermission() 方法。请求权限，可调用新增的 requestPermissions() 方法。具体参考：</p>
<p><a href="https://developer.android.google.cn/training/permissions/requesting" target="_blank" rel="external">https://developer.android.google.cn/training/permissions/requesting</a></p>
<p>####（二）适配指导</p>
<p>• 解释需要权限的原因：系统在开发者调用 requestPermissions() 时显示的权限对话框将说明应用需要的权限，但不会解释为何需要这些权限。某些情况下，用户可能会感到困惑，因此，建议在调用 requestPermissions() 之前向用户解释应用需要相应权限的原因。</p>
<ul>
<li>仅申请应用真正需要的权限</li>
<li>如果应用在启动之后一次要求用户提供多项权限，用户可能会感到无所适从并因此退出应用 。建议开发者应根据需要请求权限，对于某一些权限应用可以在真正需要使用的时候再尝试申请用户动态授权。</li>
</ul>
<h3 id="Android7-0"><a href="#Android7-0" class="headerlink" title="Android7.0"></a>Android7.0</h3><h4 id="（一）相关变更-1"><a href="#（一）相关变更-1" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><h5 id="1-系统禁止链接到非-NDK-库"><a href="#1-系统禁止链接到非-NDK-库" class="headerlink" title="1.系统禁止链接到非 NDK 库"></a>1.系统禁止链接到非 NDK 库</h5><p>从 Android 7.0 开始，系统将阻止应用动态链接非公开 NDK 库，原因为NDK 库可能会导致应用崩溃，此行为变更主要目的在为跨平台更新和不同设备提供统一的应用体验。即使应用中的代码不会链接私有库，但第三方静态库可能会进行链接，因此建议所有开发者都需进行相应检查，确保应用不会在运行 Android 7.0 的设备上崩溃。如果应用使用的是原生代码，则只能使用公开 NDK API。（<a href="https://developer.android.com/ndk/guides/stable_apis）" target="_blank" rel="external">https://developer.android.com/ndk/guides/stable_apis）</a></p>
<h5 id="2-低电耗模式DOZE（系统状态）"><a href="#2-低电耗模式DOZE（系统状态）" class="headerlink" title="2.低电耗模式DOZE（系统状态）"></a>2.低电耗模式DOZE（系统状态）</h5><p>进入条件：灭屏、未充电、静止持续1小时
退出条件：亮屏或移动或充电</p>
<p>限制资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停应用的Sync任务</li>
<li>暂停应用的JobScheduler任务</li>
<li>忽略应用的wakelocks</li>
<li>标准Alarm推迟到维护窗口</li>
<li>不执行wifi扫描</li>
</ul>
<h5 id="3-低电耗模式Lite-Idle（系统状态）"><a href="#3-低电耗模式Lite-Idle（系统状态）" class="headerlink" title="3.低电耗模式Lite Idle（系统状态）"></a>3.低电耗模式Lite Idle（系统状态）</h5><p>进入条件：灭屏、未充电持续5分钟(Android P调整为3分钟）
退出条件：亮屏或充电
限制资源</p>
<ul>
<li>限制应用访问网络。</li>
<li>暂停应用运行Sync任务 。</li>
<li>暂停应用运行JobScheduler任务。</li>
</ul>
<h5 id="4-AppStandby模式（应用状态）"><a href="#4-AppStandby模式（应用状态）" class="headerlink" title="4.AppStandby模式（应用状态）"></a>4.AppStandby模式（应用状态）</h5><p>进入AppIdle条件：应用后台空闲总时间&gt;48小时且亮屏后台空闲时间 &gt; 12小时
排除&amp;退出条件：前台应用、有前台服务的应用、通知栏或锁屏通知消息的应用或进行充电
不限制的应用：系统应用UID&lt;10000的，Persist常驻应用，电池优化白名单，系统关联的其他应用
限制的资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停执行应用的Sync任务</li>
<li>暂停执行应用的JobScheduler任务</li>
</ul>
<h5 id="5-App-Standby-Bucket-应用待机分组模式-Android-P特性）"><a href="#5-App-Standby-Bucket-应用待机分组模式-Android-P特性）" class="headerlink" title="5.App Standby Bucket 应用待机分组模式( Android P特性）"></a>5.App Standby Bucket 应用待机分组模式( Android P特性）</h5><p>应用待机分组模式是在Doze模式未生效时（亮屏或刚刚灭屏时），对运行在后台的用户不可感知应用的耗电管控扩展。</p>
<h4 id="（二）适配指导"><a href="#（二）适配指导" class="headerlink" title="（二）适配指导"></a>（二）适配指导</h4><p>低电耗模式和应用待机模式适配指导如下：</p>
<p>• 前台服务</p>
<p>应用需要在后台访问网络或者使用CPU时可以通过此方式。</p>
<p>• Doze白名单</p>
<p>查询应用是不是再doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PowerManager powerManager = (PowerManager)getSystemService(POWER_SERVICE);</div><div class="line">boolean hasIgnored = powerManager.isIgnoringBatteryOptimizations(activity.getPackageName());</div></pre></td></tr></table></figure></p>
<p>向用户申请授权添加doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);</div><div class="line">intent.setData(Uri.parse(&quot;package:&quot;+activity.getPackageName()));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<h3 id="Android8-0-变更"><a href="#Android8-0-变更" class="headerlink" title="Android8.0 变更"></a>Android8.0 变更</h3><h4 id="1-后台服务限制"><a href="#1-后台服务限制" class="headerlink" title="1.后台服务限制"></a>1.后台服务限制</h4><h5 id="①哪些应用会受到后台服务限制？"><a href="#①哪些应用会受到后台服务限制？" class="headerlink" title="①哪些应用会受到后台服务限制？"></a>①哪些应用会受到后台服务限制？</h5><ul>
<li>TargetSDK&gt;=26的应用</li>
<li>TargetSDK&lt;26且被用户主动设置为限制后台活动的应用（华为EMUI8.x未提供配置）</li>
</ul>
<p>注意：Doze 白名单中的应用不受限制（用户可以设置，手机管家配置有默认值白名单）</p>
<h5 id="②前台如何定义？"><a href="#②前台如何定义？" class="headerlink" title="②前台如何定义？"></a>②前台如何定义？</h5><ul>
<li>前台有可见 Activity</li>
<li>前台服务可以后台播放</li>
<li>绑定服务的情况<h5 id="③后台服务限制，限制了哪些行为？"><a href="#③后台服务限制，限制了哪些行为？" class="headerlink" title="③后台服务限制，限制了哪些行为？"></a>③后台服务限制，限制了哪些行为？</h5></li>
<li>应用进入 uidldle 后，会被调用 Service.stopself()</li>
<li>应用进入 uidldle 后，不允许通过 startService启动服务</li>
<li>应用进程仍然存在，JobScheduler、Alarm、广播等均能触发</li>
<li>广播接收线程处理短暂业务，无法拉起后台服务</li>
<li>非安卓组件线程 CPU 超标时，谷歌原生机制会强制kill进程<h5 id="④临时白名单机制"><a href="#④临时白名单机制" class="headerlink" title="④临时白名单机制"></a>④临时白名单机制</h5>系统调用应用时，少量场景会将应用添加到临时白名单（有效时间30秒~300秒）：</li>
<li>处理高优先级 FCM 消息</li>
<li>接收短信彩信</li>
<li>用户点击通知栏，执行 PendingIntent<h5 id="⑤用户设置限制后台活动之后的影响（Android-P优化）"><a href="#⑤用户设置限制后台活动之后的影响（Android-P优化）" class="headerlink" title="⑤用户设置限制后台活动之后的影响（Android P优化）"></a>⑤用户设置限制后台活动之后的影响（Android P优化）</h5></li>
<li>应用退后台，1分钟就会被停止 Service（包括正在执行的前台任务）</li>
<li>限制访问网络</li>
<li>限制 Alarm 触发</li>
<li>限制 JobScheduler 执行</li>
</ul>
<h4 id="2-广播限制"><a href="#2-广播限制" class="headerlink" title="2.广播限制"></a>2.广播限制</h4><p>Android 8.0 的应用无法继续在其清单中为隐式广播注册广播接收器,但也存在例外情况：</p>
<ul>
<li>应用可以继续在清单中注册显式广播</li>
<li>应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注 册接收器</li>
<li>需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用 ，而不会发送至设备上的所有应用</li>
<li>白名单豁免隐式广播的列表：<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="external">https://developer.android.com/guide/components/broadcast-exceptions</a></li>
</ul>
<p>后台执行限制的适配建议</p>
<ul>
<li>使用 JobScheduler 代替</li>
<li>增加前台服务</li>
<li>加 Doze 白名单（不推荐）</li>
</ul>
<h4 id="3-最大屏幕纵横比"><a href="#3-最大屏幕纵横比" class="headerlink" title="3.最大屏幕纵横比"></a>3.最大屏幕纵横比</h4><p>以 Android 7.1（API 级别 25）或更低版本为目标平台中应用默认的最大屏幕纵横比为1.86。针对 Android 8.0 或更高版本的应用没有默认的最大纵横比，如需设置请在应用 androidmanifest 文件定义 maxAspectRatio 属性（注意：如果应用没有显示申明不支持 resizeableActivity，系统将会忽略应用设置的 maxAspectRatio属性）</p>
<h4 id="4-其他变更"><a href="#4-其他变更" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>提醒窗口</td>
<td>使用SYSTEM_ALERT_WINDOW权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口:TYPE_PHONE,TYPE_PRIORITY_PHONE,TYPE_SYSTEM_ALERT,TYPE_SYSTEM_OVERLAY,TYPE_SYSTEM_ERROR,应用必须使用名为TYPE_APPLICATION_OVERLAY的新窗口类型</td>
</tr>
<tr>
<td>权限</td>
<td>在Android8.0之前,如果应用在运行时请求权限并且被授予该权限,系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用.对于针对8.0的应用,此行为已被纠正.系统只会授予应用明确请求的权限.然而,一旦用户为应用授予某个权限,则所有后续对该权限组中权限的请求都被自动批准.建议应用在使用所有的敏感权限之前,都先判断一下权限是否已经被授予,如果没有授予需要申请动态权限.</td>
</tr>
<tr>
<td>Linker</td>
<td>O版本在linker中新增加检查就是在load之前检测一下需要加载的section的权限,被加载的段不允许同事具有E(可执行)和W(可写)权限.如果有这样的段,则linker报错</td>
</tr>
<tr>
<td>Build.SERIAL弃用</td>
<td>需要知道硬件序列号的应用应改为使用新的Build.getSerial()函数,该函数要求具有READ_PHONE_STATE权限</td>
</tr>
</tbody>
</table>
<h3 id="Android9-0-变更"><a href="#Android9-0-变更" class="headerlink" title="Android9.0 变更"></a>Android9.0 变更</h3><h4 id="1-非SDK管控"><a href="#1-非SDK管控" class="headerlink" title="1.非SDK管控"></a>1.非SDK管控</h4><table>
<thead>
<tr>
<th>名单类型</th>
<th>影响</th>
<th>名单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浅灰名单</td>
<td>targetSDK&gt;=P时,警告</td>
<td>已有应用在使用非SDK接口,仍然可以继续使用</td>
</tr>
<tr>
<td>深灰名单</td>
<td>targetSDK<p时,警告;>=时,不允许调用</p时,警告;></td>
<td>应用可能还在使用</td>
</tr>
<tr>
<td>黑名单</td>
<td>所有三方应用不允许调用</td>
<td>灰名单(深灰+浅灰)之外的其他所有非SDK接口都会被添加到黑名单,应用发现有使用黑名单的接口需要马上整改,或者反馈给谷歌申请加灰名单</td>
</tr>
</tbody>
</table>
<p>使用谷歌提供的非 SDK 扫描工具查看应用使用的深灰名单和黑名单非 SDK 接口： <a href="https://android.googlesource.com/platform/prebuilts/runtime/+/" target="_blank" rel="external">https://android.googlesource.com/platform/prebuilts/runtime/+/</a> master/appcompat/</p>
<h4 id="2-Apache-HTTP-客户端弃用"><a href="#2-Apache-HTTP-客户端弃用" class="headerlink" title="2. Apache HTTP 客户端弃用"></a>2. Apache HTTP 客户端弃用</h4><p>默认情况下该内容库已从 bootclasspath 中移除且不可用于应用，应用不能使用系统的 classloader 加载 org.apache.http.* 库，否则会抛 NoClassDefFoundError。</p>
<p>适配建议</p>
<ul>
<li>方法一：如果要继续使用 Apache HTTP 客户端，以 Android 9.0及更高版本为目标的应用可以向其 AndroidManifest.xml 添加以下内容：<code>&lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot;/&gt;</code></li>
<li>方法二：如果必须要继续使用 Apache HTTP 客户端，开发者可以将 org.apache.http.legacy库打包进自己的apk。</li>
<li>推荐方法：使用 HttpURLConnection 类替代 apache-http</li>
</ul>
<h4 id="3-内联方法不允许跨dex"><a href="#3-内联方法不允许跨dex" class="headerlink" title="3.内联方法不允许跨dex"></a>3.内联方法不允许跨dex</h4><p>Google 在 Android P 新增检测：如果调用某个 inline 方法的类与 inline 方法所在的类由不同的 classloader 加载，就会主动发起 abort（inline不允许跨dex文件）导致应用 crash。
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935181033.jpg" alt="tips-android-targetsdkversion-201935181033"></p>
<h5 id="兼容性影响"><a href="#兼容性影响" class="headerlink" title="兼容性影响"></a>兼容性影响</h5><p>对使用插件和热修复的应用有很大影响，需要重点测试。</p>
<h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><ul>
<li>启动应用，构造热修复场景，在 app 侧触发热修复</li>
<li><code>adb shell cmd package compile -m speed -f my-package 应用包名 (inline编译)</code></li>
<li>重启应用，检查是否会出现闪退问题</li>
</ul>
<h5 id="适配建议"><a href="#适配建议" class="headerlink" title="适配建议"></a>适配建议</h5><ul>
<li>尽量避免使用不同的 classloader 加载相关的类。</li>
<li>如果一定要这样做的话，需要避免内联，比如在函数里面加 try catch， 这样 compiler就不会将这个函数 inline。</li>
</ul>
<h4 id="4-其他变更-1"><a href="#4-其他变更-1" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>前台服务</td>
<td>使用前台服务的应用必须请求FOREGROUND_SERVICE权限.这是普通权限,因此,系统会自动为请求权限的应用授予此权限.如果针对Android9或更高版本的应用尝试创建一个前台服务且未请求FOREGROUND_SERVICE,则系统会引发SecurityException.</td>
</tr>
<tr>
<td>DNS隐私</td>
<td>应用应采用私有DNS API.具体而言,当系统解析程序正在执行DNS-over-TLS时,应用应确保任何内置DNS客户端均使用加密的DNS查找和系统相同的主机名,或停用它而改用系统解析程序</td>
</tr>
<tr>
<td>默认情况下启用网络传输层安全协议(TLS)</td>
<td>默认情况下isCleartextTrafficPermitted()函数返回false.如果您的应用需要为特定域名启动明文,您必须在应用的网络安全性配置中针对这些域名将cleartextTrafficPermitted显式设置为true</td>
</tr>
<tr>
<td>webview数据目录不允许共享</td>
<td>应用无法再让多个进程公用同一个WebView数据目录.如果应用中的多个进程需要访问同一网络数据,您需要自行在这些进程之间复制数据.例如,您可以调用getCookie()和setCooki(),在不同进程之间手动传输Cookie数据</td>
</tr>
<tr>
<td>以应用为单位的SELinux域名</td>
<td>应用的私有数据只能由该应用访问.要与其他应用共享文件,请使用contentprovider</td>
</tr>
</tbody>
</table>
<p>其他的变更和非 TargetSdkVersion 相关的变更以及新特性，可以在谷歌开发者网站查阅：<a href="https://developer.android.google.cn/about/versions/oreo/" target="_blank" rel="external">https://developer.android.google.cn/about/versions/oreo/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应电信终端产业协会（TAF）发布的《移动应用软件高 API 等级预置与分发自律公约》（以下简称《公约》）要求：截止到2019年5月1日所有新发布的应用 API 必须为26或更高，2019年8月1日现有应用 API 必须升级为26或更高。《公约》发布至今得到了国内主流互联网及
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Android启动过程深入解析</title>
    <link href="http://wodekouwei.com/2019/03/05/tips-android-system-load/"/>
    <id>http://wodekouwei.com/2019/03/05/tips-android-system-load/</id>
    <published>2019-03-05T06:11:16.000Z</published>
    <updated>2019-03-05T06:29:37.391Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>A当按下Android设备电源键时究竟发生了什么？</li>
<li>Android的启动过程是怎么样的？</li>
<li>A什么是Linux内核？</li>
<li>A桌面系统linux内核与Android系统linux内核有什么区别？</li>
<li>A什么是引导装载程序？</li>
<li>A什么是Zygote？</li>
<li>A什么是X86以及ARM linux？</li>
<li>A什么是init.rc?</li>
<li>A什么是系统服务？
当我们想到Android启动过程时，脑海中总是冒出很多疑问。本文将介绍Android的启动过程，希望能帮助你找到上面这些问题的答案。</li>
</ul>
<p>Android是一个基于Linux的开源操作系统。x86（x86是一系列的基于intel 8086 CPU的计算机微处理器指令集架构）是linux内核部署最常见的系统。然而，所有的Android设备都是运行在ARM处理器（ARM 源自进阶精简指令集机器，源自ARM架构）上，除了英特尔的Xolo设备(<a href="http://xolo.in/xolo-x900-features)。Xolo来源自凌动1.6GHz" target="_blank" rel="external">http://xolo.in/xolo-x900-features)。Xolo来源自凌动1.6GHz</a> x86处理器。Android设备或者嵌入设备或者基于linux的ARM设备的启动过程与桌面版本相比稍微有些差别。这篇文章中，我将解释Android设备的启动过程。<a href="http://www.ibm.com/developerworks/linux/library/l-linuxboot/" target="_blank" rel="external">深入linux启动</a>过程是一篇讲桌面linux启动过程的好文。</p>
<p>当你按下电源开关后Android设备执行了以下步骤。</p>
<p><img src="http://images.wodekouwei.com/tips-android-system-load-201935141326.png" alt="tips-android-system-load-201935141326"></p>
<h3 id="第一步：启动电源以及系统启动"><a href="#第一步：启动电源以及系统启动" class="headerlink" title="第一步：启动电源以及系统启动"></a>第一步：启动电源以及系统启动</h3><p>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。</p>
<h3 id="第二步：引导程序"><a href="#第二步：引导程序" class="headerlink" title="第二步：引导程序"></a>第二步：引导程序</h3><p>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如<a href="http://ecos.sourceware.org/redboot/" target="_blank" rel="external">redboot</a>、<a href="http://www.denx.de/wiki/U-Boot" target="_blank" rel="external">uboot</a>、<a href="http://wiki.openmoko.org/wiki/Qi" target="_blank" rel="external">qi bootloader</a>或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。</p>
<p>引导程序分两个阶段执行。第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。</p>
<p>Android引导程序可以在<code>\bootable\bootloader\legacy\usbloader</code>找到。
传统的加载器包含的个文件，需要在这里说明：</p>
<ul>
<li>init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；</li>
<li>main.c初始化硬件（闹钟、主板、键盘、控制台），创建linux标签。
更多关于Android引导程序的可以在<a href="https://motorola-global-portal.custhelp.com/app/answers/detail/a_id/86208/~/bootloader-frequently-asked-questions" target="_blank" rel="external">这里</a>了解。</li>
</ul>
<h3 id="第三步：内核"><a href="#第三步：内核" class="headerlink" title="第三步：内核"></a>第三步：内核</h3><p>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p>
<h3 id="第四步：init进程"><a href="#第四步：init进程" class="headerlink" title="第四步：init进程"></a>第四步：init进程</h3><p>init是第一个进程，我们可以说它是root进程或者说有进程的父进程。init进程有两个责任，一是挂载目录，比如/sys、/dev、/proc，二是运行init.rc脚本。</p>
<p>init进程可以在/system/core/init找到。
init.rc文件可以在/system/core/rootdir/init.rc找到。
readme.txt可以在/system/core/init/readme.txt找到。
对于init.rc文件，Android中有特定的格式以及规则。在Android中，我们叫做Android初始化语言。
Android初始化语言由四大类型的声明组成，即Actions（动作）、Commands（命令）、Services（服务）、以及Options（选项）。</p>
<h4 id="Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。"><a href="#Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。" class="headerlink" title="Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。"></a>Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。</h4><p>语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; html-script: false ]</div><div class="line">    on &amp;lt;trigger&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div></pre></td></tr></table></figure></p>
<h4 id="Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。"><a href="#Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。" class="headerlink" title="Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。"></a>Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。</h4><p>语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; html-script: false ]</div><div class="line">service &amp;lt;name&amp;gt; &amp;lt;pathname&amp;gt; [&amp;lt;argument&amp;gt;]*</div><div class="line">    &amp;lt;option&amp;gt;</div><div class="line">    &amp;lt;option&amp;gt;</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h4 id="Options（选项）"><a href="#Options（选项）" class="headerlink" title="Options（选项）"></a>Options（选项）</h4><p>选项是对服务的描述。它们影响init进程如何以及何时启动服务。
咱们来看看默认的init.rc文件。这里我只列出了主要的事件以及服务。
Table
|—|—|
|Action/Service|    描述|
|on early-init    |设置init进程以及它创建的子进程的优先级，设置init进程的安全环境|
|on init    |设置全局环境，为cpu accounting创建cgroup(资源控制)挂载点|
|on fs    |挂载mtd分区|
|on post-fs    |改变系统目录的访问权限|
|on post-fs-data    |改变/data目录以及它的子目录的访问权限|
|on boot    |基本网络的初始化，内存管理等等|
|service servicemanager    |启动系统管理器管理所有的本地服务，比如位置、音频、Shared preference等等…|
|service zygote    |启动zygote作为应用进程|
在这个阶段你可以在设备的屏幕上看到“Android”logo了。</p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>在Java中，我们知道不同的虚拟机实例会为不同的应用分配不同的内存。假如Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。Zygote是一个虚拟器进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是Android SDK或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。</p>
<p>Zygote加载进程</p>
<ol>
<li>加载ZygoteInit类，源代码：<code>/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></li>
<li>registerZygoteSocket()为zygote命令连接注册一个服务器套接字。</li>
<li>preloadClassed “preloaded-classes”是一个简单的包含一系列需要预加载类的文本文件，你可以在<android source="">/frameworks/base找到“preloaded-classes”文件。</android></li>
<li>preloadResources() preloadResources也意味着本地主题、布局以及android.R文件中包含的所有东西都会用这个方法加载。
在这个阶段，你可以看到启动动画。</li>
</ol>
<h3 id="第六步：系统服务或服务"><a href="#第六步：系统服务或服务" class="headerlink" title="第六步：系统服务或服务"></a>第六步：系统服务或服务</h3><p>完成了上面几步之后，运行环境请求Zygote运行系统服务。系统服务同时使用native以及java编写，系统服务可以认为是一个进程。同一个系统服务在Android SDK可以以System Services形式获得。系统服务包含了所有的System Services。</p>
<p>Zygote创建新的进程去启动系统服务。你可以在ZygoteInit类的”startSystemServer”方法中找到源代码。</p>
<p>核心服务：</p>
<ol>
<li>启动电源管理器；</li>
<li>创建Activity管理器；</li>
<li>启动电话注册；</li>
<li>启动包管理器；</li>
<li>设置Activity管理服务为系统进程；</li>
<li>启动上下文管理器；</li>
<li>启动系统Context Providers；</li>
<li>启动电池服务；</li>
<li>启动定时管理器；</li>
<li>启动传感服务；</li>
<li>启动窗口管理器；</li>
<li>启动蓝牙服务；</li>
<li>启动挂载服务</li>
</ol>
<p>其他服务：</p>
<ol>
<li>启动状态栏服务；</li>
<li>启动硬件服务；</li>
<li>启动网络状态服务；</li>
<li>启动网络连接服务；</li>
<li>启动通知管理器；</li>
<li>启动设备存储监视服务；</li>
<li>启动定位管理器；</li>
<li>启动搜索服务；</li>
<li>启动剪切板服务；</li>
<li>启动登记服务；</li>
<li>启动壁纸服务；</li>
<li>启动音频服务；</li>
<li>启动耳机监听；</li>
<li>启动AdbSettingsObserver（处理adb命令）。</li>
</ol>
<h3 id="第七步：引导完成"><a href="#第七步：引导完成" class="headerlink" title="第七步：引导完成"></a>第七步：引导完成</h3><p>一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;A当按下Android设备电源键时究竟发生了什么？&lt;/li&gt;
&lt;li&gt;Android的启动过程是怎么样的？&lt;/li&gt;
&lt;li&gt;A什么是Linux内核？&lt;/li&gt;
&lt;li&gt;A桌面系统linux内核与Android系统linux内核有什么区别？&lt;/li&gt;
&lt;li&gt;A
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>解决方案之美团APP对Crash的治理之路</title>
    <link href="http://wodekouwei.com/2019/03/05/tips-solution-2/"/>
    <id>http://wodekouwei.com/2019/03/05/tips-solution-2/</id>
    <published>2019-03-05T02:06:36.000Z</published>
    <updated>2019-03-05T14:36:16.604Z</updated>
    
    <content type="html"><![CDATA[<p>Crash率是衡量一款APP质量好坏的重要指标之一，不仅会影响用户体验，也可能影响用户存量。一旦出现问题，可能会给企业带来严重损失。</p>
<p>本文由美团技术专家谌天洲分享美团APP Crash率从千分之一到万分之一治理过程中所做的大量实践工作。</p>
<h3 id="美团Crash治理背景"><a href="#美团Crash治理背景" class="headerlink" title="美团Crash治理背景"></a>美团Crash治理背景</h3><p>美团作为一个平台化的APP，背后有20+团队设计和30+业务。</p>
<p>在Crash治理过程中面对的挑战有三项：体量大、迭代快和日活高。这三项挑战带来的直接影响是沟通成本上升和防范难度加大。因此在实际治理过程，主要围绕基础能力、治理效率两个层面进行探索和优化建设。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223013.jpg" alt="tips-solution-2-201935223013"></p>
<h4 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h4><p>Crash治理的基础能力主要体现在三个层面：能发现、能定位和能修复。</p>
<p>在发现能力层面，美团有一套异常监控退出系统，可发现除Java&amp;JNI Crash&amp;ANR以外其他类型的异常退出。在定位能力层面，有可提供内存泄漏路径及OOM时的内存快照的内存监控体系，有可提供线程现场及任务现场的线程管控体系。除此以外，还有动态日志系统提供额外的方法调用链及参数信息。</p>
<h4 id="内存监控体系"><a href="#内存监控体系" class="headerlink" title="内存监控体系"></a>内存监控体系</h4><p>内存问题最典型的呈现形式是OOM，其中80%通过Leak监控系统发现预防，另外20%的内存问题，对于大体量APP需要从全局对内存资源问题进行监控和调查分析。</p>
<p>美团的内存监控体系分为线下和线上两个场景。线下通过Leak监控系统能预防发现80%的OOM问题，线上建立随时获取OOM内存现场的监控能力
<img src="http://images.wodekouwei.com/tips-solution-2-201935223125.jpg" alt="tips-solution-2-201935223125"></p>
<h4 id="动态日志"><a href="#动态日志" class="headerlink" title="动态日志"></a>动态日志</h4><p>美团APP经常会遇到用户个性化的使用场景无法复现和定位的问题。对此，美团提出了一套动态日志系统——</p>
<p>在编译期对应用代码通过插桩实现代理，运行期同步记录，出现异常时可主动触发上报，也可以由服务端主动回捞。基于插桩实现的代理逻辑，可实施获取原方法执行时的方法名、入参和返回值信息，再将这些信息序列化后存储到数据库，由此可在必要的时候获取到较完善的方法调用栈历史，进而定位问题。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223215.jpg" alt="tips-solution-2-201935223215">
<img src="http://images.wodekouwei.com/tips-solution-2-201935223229.jpg" alt="tips-solution-2-201935223229"></p>
<h4 id="修复能力"><a href="#修复能力" class="headerlink" title="修复能力"></a>修复能力</h4><p>在修复能力层面，美团APP一度深受机型多、系统杂带来的framework层的问题困扰。此外，美团APP也经常会遇到常规日志体系无法覆盖的接口问题。</p>
<p>针对这两类问题，参考热修复的方法替换原理，开发并完善了一套小工具——“Graft”。它的基本原理是在native层通过方法替换实现对Java层方法的hook和代理，进而在Java层实现方法代理和方法替换。</p>
<p>这套工具可以动态代理或替换几乎所有Java层的方法（包括framework层），使得美团APP的修复能力从自有代码和第三方代码有效覆盖到framework层。</p>
<p><img src="http://images.wodekouwei.com/tips-solution-2-201935223340.jpg" alt="tips-solution-2-201935223340">
<img src="http://images.wodekouwei.com/tips-solution-2-201935223353.jpg" alt="tips-solution-2-201935223353"></p>
<h4 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h4><p>为了提高治理效率，实际治理过程逐渐形成PR检查流程、自动检查平台和Crash平台三大流程和平台。</p>
<p>PR检查流程主要针对PR阶段进行代码规范性检查、代码准入检查和稳定性案例检查；自动检查平台针对以往案例进行定制化防范检查。Crash平台是整个稳定性治理的核心，在建设的考量中主要遵循规范化、流程化、自动化，它主要涵盖接入管控、聚合策略、频道工单、报警系统、基础工具、模块覆盖，可以通过强大的复用能力快速接入并管理几乎所有稳定性相关的问题。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223433.jpg" alt="tips-solution-2-201935223433"></p>
<h3 id="Crash平台"><a href="#Crash平台" class="headerlink" title="Crash平台"></a>Crash平台</h3><p>Crash平台是整个稳定性治理的核心，在建设的考量中主要遵循规范化、流程化、自动化，它主要涵盖接入管控、聚合策略、频道工单、报警系统、基础工具、模块覆盖，可以通过强大的复用能力快速接入并管理几乎所有稳定性相关的问题。</p>
<p>在PR阶段，PR检查流程可自动识别出增量代码是否被现有体系覆盖，并通过Crash平台的接入管控系统督促增量代码的责任人完善基本信息、频道信息、聚合配合及自动工单配置等等。</p>
<p>在开发或全量过程中一旦发现异常，Crash平台会自动完成堆栈聚合、频道识别、报警评估及工单跟踪等工作。</p>
<p><img src="http://images.wodekouwei.com/tips-solution-2-201935223539.jpg" alt="tips-solution-2-201935223539">
<img src="http://images.wodekouwei.com/tips-solution-2-20193522365.jpg" alt="tips-solution-2-20193522365"></p>
<p>Crash率是APP最重要的指标之一，谌天洲建议开发者建立解决Crash的长效机制，找到最合理的解决方案。随着版本的不断迭代，Crash治理之路才能离目标越来越近。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Crash率是衡量一款APP质量好坏的重要指标之一，不仅会影响用户体验，也可能影响用户存量。一旦出现问题，可能会给企业带来严重损失。&lt;/p&gt;
&lt;p&gt;本文由美团技术专家谌天洲分享美团APP Crash率从千分之一到万分之一治理过程中所做的大量实践工作。&lt;/p&gt;
&lt;h3 id=
    
    </summary>
    
    
  </entry>
  
</feed>
