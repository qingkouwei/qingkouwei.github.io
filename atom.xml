<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老司机种菜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wodekouwei.com/"/>
  <updated>2017-10-10T07:58:21.000Z</updated>
  <id>http://wodekouwei.com/</id>
  
  <author>
    <name>轻口味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Makefile经典教程</title>
    <link href="http://wodekouwei.com/2017/09/30/course-makefile/"/>
    <id>http://wodekouwei.com/2017/09/30/course-makefile/</id>
    <published>2017-09-30T07:18:09.000Z</published>
    <updated>2017-10-10T07:58:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。</p>
<p>在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>
<p>关于程序的编译和链接</p>
<p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。   </p>
<ul>
<li><strong>编译时</strong>，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</li>
<li><strong>链接时</strong>，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</li>
</ul>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.</p>
<h3 id="1-Makefile-介绍"><a href="#1-Makefile-介绍" class="headerlink" title="1 Makefile 介绍"></a>1 Makefile 介绍</h3><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li>
<li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li>
</ol>
<p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h4 id="1-1-Makefile的规则"><a href="#1-1-Makefile的规则" class="headerlink" title="1.1 Makefile的规则"></a>1.1 Makefile的规则</h4><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target... : prerequisites ...</div><div class="line">  command</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  -------------------------------------------------------------------------------</div></pre></td></tr></table></figure></p>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
<ul>
<li>prerequisites就是，要生成那个target所需要的文件或是目标。</li>
<li>command也就是make需要执行的命令。（任意的Shell命令）</li>
</ul>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<p>说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p>
<h4 id="1-2-一个示例"><a href="#1-2-一个示例" class="headerlink" title="1.2 一个示例"></a>1.2 一个示例</h4><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">edit : main.o kbd.o command.o display.o \</div><div class="line">          insert.o search.o files.o utils.o</div><div class="line">          cc -o edit main.o kbd.o command.o display.o \</div><div class="line">                      insert.o search.o files.o utils.o</div><div class="line">main.o : main.c defs.h</div><div class="line">           cc -c main.c</div><div class="line">kbd.o : kbd.c defs.h command.h</div><div class="line">       cc -c kbd.c</div><div class="line">command.o : command.c defs.h command.h</div><div class="line">       cc -c command.c</div><div class="line">display.o : display.c defs.h buffer.h</div><div class="line">       cc -c display.c</div><div class="line">insert.o : insert.c defs.h buffer.h</div><div class="line">       cc -c insert.c</div><div class="line">search.o : search.c defs.h buffer.h</div><div class="line">       cc -c search.c</div><div class="line">files.o : files.c defs.h buffer.h command.h</div><div class="line">       cc -c files.c</div><div class="line">utils.o : utils.c defs.h</div><div class="line">       cc -c utils.c</div><div class="line">clean :</div><div class="line">      rm edit main.o kbd.o command.o display.o \</div><div class="line">            insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>反斜杠<code>（\）</code>是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下<code>make clean</code>就可以了。</p>
<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件<code>（*.o）</code>，依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h4 id="1-3-make是如何工作的"><a href="#1-3-make是如何工作的" class="headerlink" title="1.3 make是如何工作的"></a>1.3 make是如何工作的</h4><p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。</li>
<li>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——<code>make clean</code>，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<h4 id="1-4-makefile中使用变量"><a href="#1-4-makefile中使用变量" class="headerlink" title="1.4 makefile中使用变量"></a>1.4 makefile中使用变量</h4><p>在上面的例子中，先让我们看看edit的规则：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">edit : main.o kbd.o command.o display.o \</div><div class="line">                 insert.o search.o files.o utils.o</div><div class="line">                 cc -o edit main.o kbd.o command.o display.o \</div><div class="line">                      insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。
比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.o search.o files.o utils.o</div></pre></td></tr></table></figure></p>
<p>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.osearch.o files.o utils.o</div><div class="line">edit : $(objects)</div><div class="line">       cc -o edit $(objects)</div><div class="line">main.o : main.c defs.h</div><div class="line">       cc -c main.c</div><div class="line">kbd.o : kbd.c defs.h command.h</div><div class="line">       cc -c kbd.c</div><div class="line">command.o : command.c defs.h command.h</div><div class="line">       cc -c command.c</div><div class="line">display.o : display.c defs.h buffer.h</div><div class="line">       cc -c display.c</div><div class="line">insert.o : insert.c defs.h buffer.h</div><div class="line">       cc -c insert.c</div><div class="line">search.o : search.c defs.h buffer.h</div><div class="line">       cc -c search.c</div><div class="line">files.o : files.c defs.h buffer.h command.h</div><div class="line">       cc -c files.c</div><div class="line">utils.o : utils.c defs.h</div><div class="line">       cc -c utils.c</div><div class="line">clean :</div><div class="line">       rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。
关于变量更多的话题，我会在后续给你一一道来。</p>
<h4 id="1-5-让make自动推导"><a href="#1-5-让make自动推导" class="headerlink" title="1.5 让make自动推导"></a>1.5 让make自动推导</h4><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.o search.o files.o utils.o</div><div class="line"></div><div class="line">edit : $(objects)</div><div class="line">       cc -o edit $(objects)</div><div class="line"></div><div class="line">main.o : defs.h</div><div class="line">kbd.o : defs.h command.h</div><div class="line">command.o : defs.h command.h</div><div class="line">display.o : defs.h buffer.h</div><div class="line">insert.o : defs.h buffer.h</div><div class="line">search.o : defs.h buffer.h</div><div class="line">files.o : defs.h buffer.h command.h</div><div class="line">utils.o : defs.h</div><div class="line"></div><div class="line">.PHONY : clean</div><div class="line">clean :</div><div class="line">       rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。
关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。</p>
<h4 id="1-6-另类风格的makefile"><a href="#1-6-另类风格的makefile" class="headerlink" title="1.6 另类风格的makefile"></a>1.6 另类风格的makefile</h4><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">objects = main.o kbd.o command.o display.o \</div><div class="line">             insert.o search.o files.o utils.o</div><div class="line"></div><div class="line">edit : $(objects)</div><div class="line">       cc -o edit $(objects)</div><div class="line"></div><div class="line">$(objects) : defs.h</div><div class="line">kbd.o command.o files.o : command.h</div><div class="line">display.o insert.o search.o files.o : buffer.h</div><div class="line"></div><div class="line">.PHONY : clean</div><div class="line">clean :</div><div class="line">       rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<h4 id="1-7-清空目标文件的规则"><a href="#1-7-清空目标文件的规则" class="headerlink" title="1.7 清空目标文件的规则"></a>1.7 清空目标文件的规则</h4><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">    rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>更为稳健的做法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.PHONY : clean</div><div class="line">clean :</div><div class="line">       -rm edit $(objects)</div></pre></td></tr></table></figure></p>
<p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。<strong>当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样</strong>。不成文的规矩是——“clean从来都是放在文件的最后”。
上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>
<h3 id="2-Makefile-总述"><a href="#2-Makefile-总述" class="headerlink" title="2 Makefile 总述"></a>2 Makefile 总述</h3><h4 id="2-1-Makefile里有什么？"><a href="#2-1-Makefile里有什么？" class="headerlink" title="2.1 Makefile里有什么？"></a>2.1 Makefile里有什么？</h4><p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ol>
<li>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：<code>\#</code>。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</p>
<h4 id="2-2Makefile的文件名"><a href="#2-2Makefile的文件名" class="headerlink" title="2.2Makefile的文件名"></a>2.2Makefile的文件名</h4><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如：m<code>ake -f Make.Linux</code>或<code>make --file Make.AIX</code>。</p>
<h4 id="2-3-引用其它的Makefile"><a href="#2-3-引用其它的Makefile" class="headerlink" title="2.3 引用其它的Makefile"></a>2.3 引用其它的Makefile</h4><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include&lt;filename&gt;filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</div></pre></td></tr></table></figure></p>
<p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include foo.make *.mk $(bar)</div></pre></td></tr></table></figure></p>
<p>等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include foo.make a.mk b.mk c.mk e.mk f.mk</div></pre></td></tr></table></figure></p>
<p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<ol>
<li>如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。</li>
<li>如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</li>
</ol>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：
-include<filename>
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</filename></p>
<h4 id="2-4-环境变量-MAKEFILES"><a href="#2-4-环境变量-MAKEFILES" class="headerlink" title="2.4 环境变量 MAKEFILES"></a>2.4 环境变量 MAKEFILES</h4><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。
但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h4 id="2-5-make的工作方式"><a href="#2-5-make的工作方式" class="headerlink" title="2.5 make的工作方式"></a>2.5 make的工作方式</h4><p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>
<ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。
当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h3 id="3-Makefile书写规则"><a href="#3-Makefile书写规则" class="headerlink" title="3 Makefile书写规则"></a>3 Makefile书写规则</h3><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。
在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。
好了，还是让我们来看一看如何书写规则。</p>
<h4 id="3-1-规则举例"><a href="#3-1-规则举例" class="headerlink" title="3.1 规则举例"></a>3.1 规则举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo.o: foo.c defs.h       # foo模块</div><div class="line">          cc -c -g foo.c</div></pre></td></tr></table></figure>
<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：</p>
<ol>
<li>文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。</li>
<li>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</li>
</ol>
<h4 id="3-2-规则的语法"><a href="#3-2-规则的语法" class="headerlink" title="3.2 规则的语法"></a>3.2 规则的语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">targets : prerequisites</div><div class="line">       command</div><div class="line">       ...</div></pre></td></tr></table></figure>
<p>或是这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">targets : prerequisites ; command</div><div class="line">          command</div><div class="line">          ...</div></pre></td></tr></table></figure></p>
<p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。
command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）</p>
<p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。
如果命令太长，你可以使用反斜框<code>\</code>作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。
一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>
<h4 id="3-3-在规则中使用通配符"><a href="#3-3-在规则中使用通配符" class="headerlink" title="3.3 在规则中使用通配符"></a>3.3 在规则中使用通配符</h4><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：<code>*</code>，<code>?</code>和<code>[...]</code>。这是和Unix的B-Shell是相同的。</p>
<ol>
<li><code>~</code> :波浪号（<code>~</code>）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。
<code>*</code>:通配符代替了你一系列的文件，如<code>*.c</code>表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：<code>*</code>，那么可以用转义字符<code>\</code>，如<code>\*</code>来表示真实的<code>*</code>字符，而不是任意长度的字符串。
好吧，还是先来看几个例子吧：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">    rm -f *.o</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print: *.c</div><div class="line">    lpr -p $?</div><div class="line">    touch print</div></pre></td></tr></table></figure></p>
<p>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objects = *.o</div></pre></td></tr></table></figure></p>
<p>上面这个例子，表示了，通符同样可以用在变量中。并不是说<code>[*.o]</code>会展开，不！objects的值就是<code>*.o</code>。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objects := $(wildcard *.o)</div></pre></td></tr></table></figure></p>
<p>这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。</p>
<h4 id="3-4-文件搜寻"><a href="#3-4-文件搜寻" class="headerlink" title="3.4 文件搜寻"></a>3.4 文件搜寻</h4><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。
Makefile文件中的特殊变量<code>VPATH</code>就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VPATH = src:../headers</div></pre></td></tr></table></figure></p>
<p>上面的的定义指定两个目录，<code>src</code>和<code>../headers</code>，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）
另一个设置文件搜索路径的方法是使用make的<code>vpath</code>关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<ol>
<li><code>vpath &lt; pattern&gt; &lt; directories&gt;</code>  为符合模式&lt; pattern&gt;的文件指定搜索目录<directories>。</directories></li>
<li><code>vpath &lt; pattern&gt;</code>      清除符合模式&lt; pattern&gt;的文件的搜索目录。</li>
<li><code>vpath</code>    清除所有已被设置好了的文件搜索目录。
vapth使用方法中的&lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt; pattern&gt;指定了要搜索的文件集，而&lt; directories&gt;则指定了的文件集的搜索的目录。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vpath %.h ../headers</div></pre></td></tr></table></figure>
</li>
</ol>
<p>该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）
我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt; pattern&gt;，或是被重复了的&lt; pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vpath %.c foo</div><div class="line">vpath %   blish</div><div class="line">vpath %.c bar</div></pre></td></tr></table></figure></p>
<p>其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vpath %.c foo:bar</div><div class="line">vpath %   blish</div></pre></td></tr></table></figure></p>
<p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h4 id="3-5-伪目标"><a href="#3-5-伪目标" class="headerlink" title="3.5 伪目标"></a>3.5 伪目标</h4><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">       rm *.o temp</div></pre></td></tr></table></figure></p>
<p>正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）
因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。
当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记<code>.PHONY</code>来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.PHONY : clean</div></pre></td></tr></table></figure></p>
<p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.PHONY: clean</div><div class="line">clean:</div><div class="line">       rm *.o temp</div></pre></td></tr></table></figure></p>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">all : prog1 prog2 prog3</div><div class="line">.PHONY : all</div><div class="line"></div><div class="line">prog1 : prog1.o utils.o</div><div class="line">       cc -o prog1 prog1.o utils.o</div><div class="line"></div><div class="line">prog2 : prog2.o</div><div class="line">       cc -o prog2 prog2.o</div><div class="line"></div><div class="line">prog3 : prog3.o sort.o utils.o</div><div class="line">       cc -o prog3 prog3.o sort.o utils.o</div></pre></td></tr></table></figure></p>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。
随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.PHONY: cleanall cleanobj cleandiff</div><div class="line"></div><div class="line">cleanall : cleanobj cleandiff</div><div class="line">       rm program</div><div class="line"></div><div class="line">cleanobj :</div><div class="line">       rm *.o</div><div class="line"></div><div class="line">cleandiff :</div><div class="line">       rm *.diff</div></pre></td></tr></table></figure></p>
<p>“makeclean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的</p>
<h4 id="3-6-多目标"><a href="#3-6-多目标" class="headerlink" title="3.6 多目标"></a>3.6 多目标</h4><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bigoutput littleoutput : text.g</div><div class="line">       generate text.g -$(subst output,,$@) &gt; $@</div></pre></td></tr></table></figure></p>
<p>上述规则等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bigoutput : text.g</div><div class="line">       generate text.g -big &gt; bigoutput</div><div class="line">littleoutput : text.g</div><div class="line">       generate text.g -little &gt; littleoutput</div></pre></td></tr></table></figure></p>
<p>其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。</p>
<h4 id="3-7-静态模式"><a href="#3-7-静态模式" class="headerlink" title="3.7 静态模式"></a>3.7 静态模式</h4><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</div><div class="line">　　　&lt;commands&gt;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<ul>
<li>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</li>
<li>target-parrtern是指明了targets的模式，也就是的目标集模式。</li>
<li>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</li>
</ul>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。
所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠<code>\</code>进行转义，来标明真实的“%”字符。
看一个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">objects = foo.o bar.o</div><div class="line"></div><div class="line">all: $(objects)</div><div class="line"></div><div class="line">$(objects): %.o: %.c</div><div class="line">       $(CC) -c $(CFLAGS) $&lt; -o $@</div></pre></td></tr></table></figure></target-parrtern></target-parrtern></prereq-parrterns></target-parrtern></p>
<p>上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo.o : foo.c</div><div class="line">       $(CC) -c $(CFLAGS) foo.c -o foo.o</div><div class="line">bar.o : bar.c</div><div class="line">       $(CC) -c $(CFLAGS) bar.c -o bar.o</div></pre></td></tr></table></figure></p>
<p>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">files = foo.elc bar.o lose.o</div><div class="line"></div><div class="line">$(filter %.o,$(files)): %.o: %.c</div><div class="line">       $(CC) -c $(CFLAGS) $&lt; -o $@</div><div class="line">$(filter %.elc,$(files)): %.elc: %.el</div><div class="line">       emacs -f batch-byte-compile $&lt;</div></pre></td></tr></table></figure></p>
<p>$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>
<h4 id="3-8-自动生成依赖性"><a href="#3-8-自动生成依赖性" class="headerlink" title="3.8 自动生成依赖性"></a>3.8 自动生成依赖性</h4><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include “defs.h””，那么我们的依赖关系应该是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o : main.c defs.h</div></pre></td></tr></table></figure></p>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc -M main.c</div></pre></td></tr></table></figure></p>
<p>其输出是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o : main.c defs.h</div></pre></td></tr></table></figure></p>
<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用<code>-MM</code>参数，不然，<code>-M</code>参数会把一些标准库的头文件也包含进来。
<code>gcc-M main.c</code>的输出是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \</div><div class="line">    /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \</div><div class="line">    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \</div><div class="line">    /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \</div><div class="line">    /usr/include/bits/sched.h /usr/include/libio.h \</div><div class="line">    /usr/include/_G_config.h /usr/include/wchar.h \</div><div class="line">    /usr/include/bits/wchar.h /usr/include/gconv.h \</div><div class="line">    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \</div><div class="line">    /usr/include/bits/stdio_lim.h</div></pre></td></tr></table></figure></p>
<p><code>gcc-MM main.c</code>的输出则是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o: main.c defs.h</div></pre></td></tr></table></figure></p>
<p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。
于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。
这里，我们给出了一个模式规则来产生[.d]文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">%.d: %.c</div><div class="line">       @set -e; rm -f $@; \</div><div class="line">        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.</div><div class="line">; \</div><div class="line">        sed &apos;s,$∗\.o[ :]*,\1.o $@ : ,g&apos; &lt; $@.</div><div class="line">&gt; $@; \</div><div class="line">        rm -f $@.</div></pre></td></tr></table></figure></p>
<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，<code>rm-f $@</code>的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$<a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#8221;&#xff0c;&#x4e5f;&#x5c31;&#x662f;&#x5b;&#46;&#x63;&#93;&#x6587;&#20214;&#x751f;&#x6210;&#20381;&#x8d56;&#25991;&#x4ef6;&#xff0c;&#x201c;&#36;&#64;&#x201d;&#34920;&#x793a;&#27169;&#x5f0f;&#x201c;&#37;&#x2e;&#100;&#x201d;&#25991;&#20214;&#xff0c;&#x5982;&#26524;&#x6709;&#19968;&#20010;&#67;&#x6587;&#20214;&#26159;&#x6e;&#x61;&#109;&#101;&#x2e;&#x63;&#65292;&#37027;&#x4e48;&#x201c;&#37;&#x201d;&#x5c31;&#26159;&#x201c;&#110;&#x61;&#x6d;&#x65;&#x201d;&#65292;&#x201c;&#xa;&#x201d;&#x610f;&#20026;&#x4e00;&#x4e2a;&#x968f;&#x673a;&#x7f16;&#21495;&#65292;&#31532;&#20108;&#34892;&#x751f;&#x6210;&#30340;&#25991;&#20214;&#x6709;&#x53ef;&#33021;&#x662f;&#8220;&#110;&#x61;&#x6d;&#x65;&#46;&#x64;&#x2e;&#49;&#50;&#x33;&#x34;&#53;&#x201d;&#65292;&#x7b2c;&#19977;&#x884c;&#20351;&#29992;&#115;&#101;&#100;&#x547d;&#x4ee4;&#20570;&#20102;&#x4e00;&#20010;&#x66ff;&#25442;&#xff0c;&#20851;&#x4e8e;&#115;&#x65;&#100;&#21629;&#20196;&#30340;&#29992;&#27861;&#x8bf7;&#x53c2;&#30475;&#x76f8;&#x5173;&#x7684;&#20351;&#29992;&#x6587;&#x6863;&#x3002;&#31532;&#22235;&#x884c;&#23601;&#x662f;&#21024;&#38500;&#x4e34;&#26102;&#x6587;&#x4ef6;&#x3002;&#xa;&#x603b;&#32780;&#x8a00;&#20043;&#65292;&#36825;&#20010;&#x6a21;&#24335;&#35201;&#x505a;&#x7684;&#x4e8b;&#23601;&#x662f;&#22312;&#32534;&#35793;&#22120;&#x751f;&#x6210;&#x7684;&#20381;&#36182;&#x5173;&#x7cfb;&#20013;&#21152;&#x5165;&#91;&#46;&#100;&#x5d;&#25991;&#x4ef6;&#30340;&#x4f9d;&#x8d56;&#xff0c;&#x5373;&#x628a;&#x4f9d;&#x8d56;&#x5173;&#31995;&#xff1a;&#10;&#60;&#x21;&#45;&#45;&#65532;&#x34;&#48;&#45;&#45;">&#8221;&#xff0c;&#x4e5f;&#x5c31;&#x662f;&#x5b;&#46;&#x63;&#93;&#x6587;&#20214;&#x751f;&#x6210;&#20381;&#x8d56;&#25991;&#x4ef6;&#xff0c;&#x201c;&#36;&#64;&#x201d;&#34920;&#x793a;&#27169;&#x5f0f;&#x201c;&#37;&#x2e;&#100;&#x201d;&#25991;&#20214;&#xff0c;&#x5982;&#26524;&#x6709;&#19968;&#20010;&#67;&#x6587;&#20214;&#26159;&#x6e;&#x61;&#109;&#101;&#x2e;&#x63;&#65292;&#37027;&#x4e48;&#x201c;&#37;&#x201d;&#x5c31;&#26159;&#x201c;&#110;&#x61;&#x6d;&#x65;&#x201d;&#65292;&#x201c;&#xa;&#x201d;&#x610f;&#20026;&#x4e00;&#x4e2a;&#x968f;&#x673a;&#x7f16;&#21495;&#65292;&#31532;&#20108;&#34892;&#x751f;&#x6210;&#30340;&#25991;&#20214;&#x6709;&#x53ef;&#33021;&#x662f;&#8220;&#110;&#x61;&#x6d;&#x65;&#46;&#x64;&#x2e;&#49;&#50;&#x33;&#x34;&#53;&#x201d;&#65292;&#x7b2c;&#19977;&#x884c;&#20351;&#29992;&#115;&#101;&#100;&#x547d;&#x4ee4;&#20570;&#20102;&#x4e00;&#20010;&#x66ff;&#25442;&#xff0c;&#20851;&#x4e8e;&#115;&#x65;&#100;&#21629;&#20196;&#30340;&#29992;&#27861;&#x8bf7;&#x53c2;&#30475;&#x76f8;&#x5173;&#x7684;&#20351;&#29992;&#x6587;&#x6863;&#x3002;&#31532;&#22235;&#x884c;&#23601;&#x662f;&#21024;&#38500;&#x4e34;&#26102;&#x6587;&#x4ef6;&#x3002;&#xa;&#x603b;&#32780;&#x8a00;&#20043;&#65292;&#36825;&#20010;&#x6a21;&#24335;&#35201;&#x505a;&#x7684;&#x4e8b;&#23601;&#x662f;&#22312;&#32534;&#35793;&#22120;&#x751f;&#x6210;&#x7684;&#20381;&#36182;&#x5173;&#x7cfb;&#20013;&#21152;&#x5165;&#91;&#46;&#100;&#x5d;&#25991;&#x4ef6;&#30340;&#x4f9d;&#x8d56;&#xff0c;&#x5373;&#x628a;&#x4f9d;&#x8d56;&#x5173;&#31995;&#xff1a;&#10;&#60;&#x21;&#45;&#45;&#65532;&#x34;&#48;&#45;&#45;</a></p>
<p>转成：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">main.o main.d : main.c defs.h</div></pre></td></tr></table></figure></p>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sources = foo.c bar.c</div><div class="line"></div><div class="line">include $(sources:.c=.d)</div></pre></td></tr></table></figure></p>
<p>上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标</p>
<h3 id="4-Makefile-书写命令"><a href="#4-Makefile-书写命令" class="headerlink" title="4 Makefile 书写命令"></a>4 Makefile 书写命令</h3><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。
我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。</p>
<h4 id="4-1-显示命令"><a href="#4-1-显示命令" class="headerlink" title="4.1 显示命令"></a>4.1 显示命令</h4><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@echo 正在编译XXX模块......</div></pre></td></tr></table></figure></p>
<p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo 正在编译XXX模块......</div><div class="line">正在编译XXX模块......</div></pre></td></tr></table></figure></p>
<p>如果make执行时，带入make参数<code>-n</code>或<code>--just-print</code>，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。
而make参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示。</p>
<h4 id="4-2-命令执行"><a href="#4-2-命令执行" class="headerlink" title="4.2 命令执行"></a>4.2 命令执行</h4><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：
 示例一：
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exec:</div><div class="line">       cd /home/hchen</div><div class="line">       pwd</div></pre></td></tr></table></figure></p>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exec:</div><div class="line">       cd /home/hchen; pwd</div></pre></td></tr></table></figure></p>
<p>当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>
<h4 id="4-3-命令出错"><a href="#4-3-命令出错" class="headerlink" title="4.3 命令出错"></a>4.3 命令出错</h4><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。
有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。
为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean:</div><div class="line">         -rm -f *.o</div></pre></td></tr></table></figure></p>
<p>还有一个全局的办法是，给make加上<code>-i</code>或是<code>--ignore-errors</code>参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。
还有一个要提一下的make的参数的是<code>-k</code>或是<code>--keep-going</code>，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h4 id="4-4-嵌套执行make"><a href="#4-4-嵌套执行make" class="headerlink" title="4.4 嵌套执行make"></a>4.4 嵌套执行make</h4><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subsystem:</div><div class="line">         cd subdir &amp;&amp; $(MAKE)</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subsystem:</div><div class="line">       $(MAKE) -C subdir</div></pre></td></tr></table></figure></p>
<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。
我们把这个Makefile叫做 <strong>总控Makefile</strong>，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。
如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export&lt;variable ...&gt;</div></pre></td></tr></table></figure></p>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unexport&lt;variable ...&gt;</div></pre></td></tr></table></figure></p>
<p>如：
示例一：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export variable = value</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable = value</div><div class="line">export variable</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export variable := value</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable := value</div><div class="line">export variable</div></pre></td></tr></table></figure></p>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export variable += value</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable += value</div><div class="line">export variable</div></pre></td></tr></table></figure></p>
<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。
需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。
但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subsystem:</div><div class="line">       cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=</div></pre></td></tr></table></figure></p>
<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。
还有一个在“嵌套执行”中比较有用的参数，“-w”或是“–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make: Entering directory `/home/hchen/gnu/make&apos;.</div></pre></td></tr></table></figure></p>
<p>而在完成下层make后离开目录时，我们会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make: Leaving directory `/home/hchen/gnu/make&apos;</div></pre></td></tr></table></figure></p>
<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“–slient”）或是“–no-print-directory”，那么，“-w”总是失效的。</p>
<h4 id="4-5-定义命令包"><a href="#4-5-定义命令包" class="headerlink" title="4.5 定义命令包"></a>4.5 定义命令包</h4><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define run-yacc</div><div class="line">yacc $(firstword $^)</div><div class="line">mv y.tab.c $@</div><div class="line">endef</div></pre></td></tr></table></figure></p>
<p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo.c : foo.y</div><div class="line">       $(run-yacc)</div></pre></td></tr></table></figure></p>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h3 id="5-使用变量"><a href="#5-使用变量" class="headerlink" title="5.使用变量"></a>5.使用变量</h3><p>在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。</p>
<h4 id="5-1变量的基础"><a href="#5-1变量的基础" class="headerlink" title="5.1变量的基础"></a>5.1变量的基础</h4><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用<code>$$</code>来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。</p>
<p>先看一个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">objects = program.o foo.o utils.o</div><div class="line">program : $(objects)</div><div class="line">cc -o program $(objects)</div><div class="line"></div><div class="line">$(objects) : defs.h</div></pre></td></tr></table></figure></p>
<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo = c</div><div class="line">prog.o : prog.$(foo)</div><div class="line">$(foo)$(foo) -$(foo) prog.$(foo)</div></pre></td></tr></table></figure></p>
<p>展开后得到：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">prog.o : prog.c</div><div class="line">cc -c prog.c</div></pre></td></tr></table></figure></p>
<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h4 id="5-2变量中的变量"><a href="#5-2变量中的变量" class="headerlink" title="5.2变量中的变量"></a>5.2变量中的变量</h4><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好
的值，其也可以使用后面定义的值。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo = $(bar)</div><div class="line">bar = $(ugh)</div><div class="line">ugh = Huh?</div><div class="line"></div><div class="line"></div><div class="line">all:</div><div class="line">echo $(foo)</div></pre></td></tr></table></figure></p>
<p>我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。
这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFLAGS = $(include_dirs) -O</div><div class="line">include_dirs = -Ifoo -Ibar</div></pre></td></tr></table></figure></p>
<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方
，那就是递归定义，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFLAGS = $(CFLAGS) -O</div></pre></td></tr></table></figure></p>
<p>或：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A = $(B)</div><div class="line">B = $(A)</div></pre></td></tr></table></figure></p>
<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x := foo</div><div class="line">y := $(x) bar</div><div class="line">x := later</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y := foo bar</div><div class="line">x := later</div></pre></td></tr></table></figure></p>
<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y := $(x) bar</div><div class="line">x := foo</div></pre></td></tr></table></figure></p>
<p>那么，y的值是“bar”，而不是“foo bar”。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ifeq (0,$&#123;MAKELEVEL&#125;)</div><div class="line">cur-dir := $(shell pwd)</div><div class="line">whoami := $(shell whoami)</div><div class="line">host-type := $(shell arch)</div><div class="line">MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nullstring :=</div><div class="line">space := $(nullstring) # end of the line</div></pre></td></tr></table></figure></p>
<p>nullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir := /foo/bar # directory to put the frobs in</div></pre></td></tr></table></figure></p>
<p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是“?=”，先看示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FOO ?= bar</div></pre></td></tr></table></figure></p>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifeq ($(origin FOO), undefined)</div><div class="line">FOO = bar</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<h4 id="5-3变量高级用法"><a href="#5-3变量高级用法" class="headerlink" title="5.3变量高级用法"></a>5.3变量高级用法</h4><p>这里介绍两种变量的高级使用方法</p>
<p>第一种是变量值的替换。</p>
<p>我们可以替换变量中的共有的部分，其格式是<code>$(var:a=b)</code>或是<code>${var:a=b}</code>，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p>
<p>还是看一个示例吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo := a.o b.o c.o</div><div class="line">bar := $(foo:.o=.c)</div></pre></td></tr></table></figure>
<p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。</p>
<p>另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo := a.o b.o c.o</div><div class="line">bar := $(foo:%.o=%.c)</div></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = y</div><div class="line">y = z</div><div class="line">a := $($(x))</div></pre></td></tr></table></figure>
<p>在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）</p>
<p>我们还可以使用更多的层次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = y</div><div class="line">y = z</div><div class="line">z = u</div><div class="line">a := $($($(x)))</div></pre></td></tr></table></figure>
<p>这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。</p>
<p>让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = $(y)</div><div class="line">y = z</div><div class="line">z = Hello</div><div class="line">a := $($(x))</div></pre></td></tr></table></figure>
<p>这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。</p>
<p>再复杂一点，我们再加上函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = variable1</div><div class="line">variable2 := Hello</div><div class="line">y = $(subst 1,2,$(x))</div><div class="line">z = y</div><div class="line">a := $($($(z)))</div></pre></td></tr></table></figure>
<p>这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">first_second = Hello</div><div class="line">a = first</div><div class="line">b = second</div><div class="line">all = $($a_$b)</div></pre></td></tr></table></figure></p>
<p>这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。</p>
<p>再来看看结合第一种技术的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a_objects := a.o b.o c.o</div><div class="line">1_objects := 1.o 2.o 3.o</div><div class="line"></div><div class="line">sources := $($(a1)_objects:.o=.c)</div></pre></td></tr></table></figure>
<p>这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。</p>
<p>再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ifdef do_sort</div><div class="line">func := sort</div><div class="line">else</div><div class="line">func := strip</div><div class="line">endif</div><div class="line"></div><div class="line">bar := a d b g q c</div><div class="line"></div><div class="line">foo := $($(func) $(bar))</div></pre></td></tr></table></figure>
<p>这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d bg q c)，调用的就是strip函数。</p>
<p>当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dir = foo</div><div class="line">$(dir)_sources := $(wildcard $(dir)/*.c)</div><div class="line">define $(dir)_print</div><div class="line">lpr $($(dir)_sources)</div><div class="line">endef</div></pre></td></tr></table></figure></p>
<p>这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</p>
<h4 id="5-4追加变量值"><a href="#5-4追加变量值" class="headerlink" title="5.4追加变量值"></a>5.4追加变量值</h4><p>我们可以使用“+=”操作符给变量追加值，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects = main.o foo.o bar.o utils.o</div><div class="line">objects += another.o</div></pre></td></tr></table></figure></p>
<p>于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p>
<p>使用“+=”操作符，可以模拟为下面的这种例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects = main.o foo.o bar.o utils.o</div><div class="line">objects := $(objects) another.o</div></pre></td></tr></table></figure>
<p>所不同的是，用“+=”更为简洁。</p>
<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable := value</div><div class="line">variable += more</div></pre></td></tr></table></figure></p>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable := value</div><div class="line">variable := $(variable) more</div></pre></td></tr></table></figure>
<p>但如果是这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable = value</div><div class="line">variable += more</div></pre></td></tr></table></figure>
<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h4 id="5-5override-指示符"><a href="#5-5override-指示符" class="headerlink" title="5.5override 指示符"></a>5.5override 指示符</h4><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">override &lt;variable&gt; = &lt;value&gt;</div><div class="line">override &lt;variable&gt; := &lt;value&gt;</div></pre></td></tr></table></figure></p>
<p>当然，你还可以追加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">override &lt;variable&gt; += &lt;more text&gt;</div></pre></td></tr></table></figure>
<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override define foo</div><div class="line">bar</div><div class="line">endef</div></pre></td></tr></table></figure>
<h4 id="5-6多行变量"><a href="#5-6多行变量" class="headerlink" title="5.6多行变量"></a>5.6多行变量</h4><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>
<p>define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define two-lines</div><div class="line">echo foo</div><div class="line">echo $(bar)</div><div class="line">endef</div></pre></td></tr></table></figure>
<h4 id="5-7环境变量"><a href="#5-7环境变量" class="headerlink" title="5.7环境变量"></a>5.7环境变量</h4><p>make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。     当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h4 id="5-8目标变量"><a href="#5-8目标变量" class="headerlink" title="5.8目标变量"></a>5.8目标变量</h4><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;</div><div class="line"></div><div class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure></p>
<p><variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</variable-assignment></p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">prog : CFLAGS = -g</div><div class="line">prog : prog.o foo.o bar.o</div><div class="line">$(CC) $(CFLAGS) prog.o foo.o bar.o</div><div class="line"></div><div class="line"></div><div class="line">prog.o : prog.c</div><div class="line">$(CC) $(CFLAGS) prog.c</div><div class="line"></div><div class="line"></div><div class="line">foo.o : foo.c</div><div class="line">$(CC) $(CFLAGS) foo.c</div><div class="line"></div><div class="line"></div><div class="line">bar.o : bar.c</div><div class="line">$(CC) $(CFLAGS) bar.c</div></pre></td></tr></table></figure></p>
<p>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”</p>
<h4 id="5-9模式变量"><a href="#5-9模式变量" class="headerlink" title="5.9模式变量"></a>5.9模式变量</h4><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.o : CFLAGS = -O</div></pre></td></tr></table></figure>
<p>同样，模式变量的语法和“目标变量”一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;pattern ...&gt; : &lt;variable-assignment&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;pattern ...&gt; : override &lt;variable-assignment&gt;</div></pre></td></tr></table></figure>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h3 id="6-使用条件判断"><a href="#6-使用条件判断" class="headerlink" title="6. 使用条件判断"></a>6. 使用条件判断</h3><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h4 id="6-1-示例"><a href="#6-1-示例" class="headerlink" title="6.1 示例"></a>6.1 示例</h4><p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">libs_for_gcc = -lgnu</div><div class="line">normal_libs =</div><div class="line"></div><div class="line"></div><div class="line">foo: $(objects)</div><div class="line">ifeq ($(CC),gcc)</div><div class="line">$(CC) -o foo $(objects) $(libs_for_gcc)</div><div class="line">else</div><div class="line">$(CC) -o foo $(objects) $(normal_libs)</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>
<p>当我们的变量$(CC)值是“gcc”时，目标foo的规则是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo: $(objects)</div><div class="line">$(CC) -o foo $(objects) $(libs_for_gcc)</div></pre></td></tr></table></figure>
<p>而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo: $(objects)</div><div class="line">$(CC) -o foo $(objects) $(normal_libs)</div></pre></td></tr></table></figure></p>
<p>当然，我们还可以把上面的那个例子写得更简洁一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">libs_for_gcc = -lgnu</div><div class="line">normal_libs =</div><div class="line"></div><div class="line"></div><div class="line">ifeq ($(CC),gcc)</div><div class="line">libs=$(libs_for_gcc)</div><div class="line">else</div><div class="line">libs=$(normal_libs)</div><div class="line">endif</div><div class="line"></div><div class="line"></div><div class="line">foo: $(objects)</div><div class="line">$(CC) -o foo $(objects) $(libs)</div></pre></td></tr></table></figure>
<h4 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h4><p>条件表达式的语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;conditional-directive&gt;</div><div class="line">&lt;text-if-true&gt;</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;conditional-directive&gt;</div><div class="line">&lt;text-if-true&gt;</div><div class="line">else</div><div class="line">&lt;text-if-false&gt;</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。</conditional-directive></p>
<p>第一个是我们前面所见过的“ifeq”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifeq (&lt;arg1&gt;, &lt;arg2&gt; )</div><div class="line">ifeq &apos;&lt;arg1&gt;&apos; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;</div><div class="line">ifeq &quot;&lt;arg1&gt;&quot; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifeq &apos;&lt;arg1&gt;&apos; &quot;&lt;arg2&gt;&quot;</div></pre></td></tr></table></figure>
<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifeq ($(strip $(foo)),)</div><div class="line">&lt;text-if-empty&gt;</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。</text-if-empty></p>
<p>第二个条件关键字是“ifneq”。语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifneq (&lt;arg1&gt;, &lt;arg2&gt; )</div><div class="line">ifneq &apos;&lt;arg1&gt;&apos; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;</div><div class="line">ifneq &quot;&lt;arg1&gt;&quot; &apos;&lt;arg2&gt;&apos;</div><div class="line">ifneq &apos;&lt;arg1&gt;&apos; &quot;&lt;arg2&gt;&quot;</div></pre></td></tr></table></figure>
<p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p>
<p>第三个条件关键字是“ifdef”。语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifdef &lt;variable-name&gt;</div></pre></td></tr></table></figure>
<p>如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</variable-name></variable-name></p>
<p>示例一：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bar =</div><div class="line">foo = $(bar)</div><div class="line">ifdef foo</div><div class="line">frobozz = yes</div><div class="line">else</div><div class="line">frobozz = no</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo =</div><div class="line">ifdef foo</div><div class="line">frobozz = yes</div><div class="line">else</div><div class="line">frobozz = no</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。</p>
<p>第四个条件关键字是“ifndef”。其语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifndef &lt;variable-name&gt;</div></pre></td></tr></table></figure>
<p>这个我就不多说了，和“ifdef”是相反的意思。</p>
<p>在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也
一样，只要不是以[Tab]键开始就行了。</conditional-directive></p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h3 id="7-使用函数"><a href="#7-使用函数" class="headerlink" title="7. 使用函数"></a>7. 使用函数</h3><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h4 id="7-1函数的调用语法"><a href="#7-1函数的调用语法" class="headerlink" title="7.1函数的调用语法"></a>7.1函数的调用语法</h4><p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&lt;function&gt; &lt;arguments&gt; )</div></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</div></pre></td></tr></table></figure>
<p>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</arguments></function></p>
<p>还是来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">comma:= ,</div><div class="line">empty:=</div><div class="line">space:= $(empty) $(empty)</div><div class="line">foo:= a b c</div><div class="line">bar:= $(subst $(space),$(comma),$(foo))</div></pre></td></tr></table></figure>
<p>在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“
a,b,c”。</p>
<h4 id="7-2-字符串处理函数"><a href="#7-2-字符串处理函数" class="headerlink" title="7.2 字符串处理函数"></a>7.2 字符串处理函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：字符串替换函数——subst。
功能：把字串<text>中的<from>字符串替换成<to>。
返回：函数返回被替换过后的字符串。</to></from></text></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(subst ee,EE,feet on the street)，</div></pre></td></tr></table></figure>
<p>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt
”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：模式字符串替换函数——patsubst。
功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。</pattern></replacement></replacement></pattern></replacement></pattern></text></p>
<p>示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(patsubst %.c,%.o,x.c.c bar.c)</div></pre></td></tr></table></figure></p>
<p>把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</p>
<p>备注：</p>
<p>这和我们前面“变量章节”说过的相关知识有点相似。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">“$(var:&lt;pattern&gt;=&lt;replacement&gt; )”</div></pre></td></tr></table></figure>
<p>相当于
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">“$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))”，</div></pre></td></tr></table></figure></p>
<p>而“$(var: <suffix>=<replacement> )”
则相当于
“$(patsubst %<suffix>,%<replacement>,$(var))”。</replacement></suffix></replacement></suffix></p>
<p>例如有：objects = foo.o bar.o baz.o，
那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(strip &lt;string&gt; )</div></pre></td></tr></table></figure>
<p>名称：去空格函数——strip。
功能：去掉<string>字串中开头和结尾的空字符。
返回：返回被去掉空格的字符串值。
示例：</string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(strip a b c )</div></pre></td></tr></table></figure>
<p>把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(findstring &lt;find&gt;,&lt;in&gt; )</div></pre></td></tr></table></figure>
<p>名称：查找字符串函数——findstring。
功能：在字串<in>中查找<find>字串。
返回：如果找到，那么返回<find>，否则返回空字符串。
示例：</find></find></in></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(findstring a,a b c)</div><div class="line">$(findstring a,b c)</div></pre></td></tr></table></figure>
<p>第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(filter &lt;pattern...&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：过滤函数——filter。
功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可
以有多个模式。
返回：返回符合模式<pattern>的字串。
示例：</pattern></pattern></text></pattern></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sources := foo.c bar.c baz.s ugh.h</div><div class="line">foo: $(sources)</div><div class="line">cc $(filter %.c %.s,$(sources)) -o foo</div></pre></td></tr></table></figure>
<p>$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(filter-out &lt;pattern...&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：反过滤函数——filter-out。
功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可
以有多个模式。
返回：返回不符合模式<pattern>的字串。
示例：</pattern></pattern></text></pattern></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objects=main1.o foo.o main2.o bar.o</div><div class="line">mains=main1.o main2.o</div></pre></td></tr></table></figure>
<p>$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(sort &lt;list&gt; )</div></pre></td></tr></table></figure>
<p>名称：排序函数——sort。
功能：给字符串<list>中的单词排序（升序）。
返回：返回排序后的字符串。
示例：$(sort foo bar lose)返回“bar foo lose” 。
备注：sort函数会去掉<list>中相同的单词。</list></list></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(word &lt;n&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：取单词函数——word。
功能：取字符串<text>中第<n>个单词。（从一开始）
返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空
字符串。
示例：$(word 2, foo bar baz)返回值是“bar”。</text></n></n></text></n></text></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：取单词串函数——wordlist。
功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。
返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那
么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单
词串。
示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</text></s></text></e></text></s></e></s></text></e></s></e></s></text></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(words &lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：单词个数统计函数——words。
功能：统计<text>中字符串中的单词个数。
返回：返回<text>中的单词数。
示例：$(words, foo bar baz)返回值是“3”。
备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text>
),<text> )。</text></text></text></text></text></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(firstword &lt;text&gt; )</div></pre></td></tr></table></figure>
<p>名称：首单词函数——firstword。
功能：取字符串<text>中的第一个单词。
返回：返回字符串<text>的第一个单词。
示例：$(firstword foo bar)返回值是“foo”。
备注：这个函数可以用word函数来实现：$(word 1,<text> )。</text></text></text></p>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，
举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索
路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，
如：</p>
<p>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))</p>
<p>如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :
, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数</p>
<h4 id="7-3文件名操作函数"><a href="#7-3文件名操作函数" class="headerlink" title="7.3文件名操作函数"></a>7.3文件名操作函数</h4><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是
一系列的文件名来对待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(dir &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取目录函数——dir。
功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之
前的部分。如果没有反斜杠，那么返回“./”。
返回：返回文件名序列<names>的目录部分。
示例： $(dir src/foo.c hacks)返回值是“src/ ./”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(notdir &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取文件函数——notdir。
功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”
）之后的部分。
返回：返回文件名序列<names>的非目录部分。
示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(suffix &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取后缀函数——suffix。
功能：从文件名序列<names>中取出各个文件名的后缀。
返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。
示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(basename &lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：取前缀函数——basename。
功能：从文件名序列<names>中取出各个文件名的前缀部分。
返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。
示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar h
acks”。</names></names></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )</div></pre></td></tr></table></figure>
<p>名称：加后缀函数——addsuffix。
功能：把后缀<suffix>加到<names>中的每个单词后面。
返回：返回加过后缀的文件名序列。
示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(addprefix &lt;prefix&gt;,&lt;names...&gt; )</div></pre></td></tr></table></figure></names></suffix></p>
<p>名称：加前缀函数——addprefix。
功能：把前缀<prefix>加到<names>中的每个单词后面。
返回：返回加过前缀的文件名序列。
示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。</names></prefix></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(join &lt;list1&gt;,&lt;list2&gt; )</div></pre></td></tr></table></figure>
<p>名称：连接函数——join。
功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比&lt;
list2&gt;的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比</list2></list1></list1></list1></list2></p>
<p><list1>多，那么，<list2>多出来的单词将被复制到<list2>中。
返回：返回连接过后的字符串。
示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</list2></list2></list1></p>
<h4 id="7-4-foreach-函数"><a href="#7-4-foreach-函数" class="headerlink" title="7.4 foreach 函数"></a>7.4 foreach 函数</h4><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的
foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin
/csh）中的foreach语句而构建的。它的语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt; )</div></pre></td></tr></table></figure></p>
<p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</text></text></text></text></var></list></p>
<p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>
这个参数来依次枚举<list>中的单词。举个例子：</list></var></text></list></var></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">names := a b c d</div><div class="line"></div><div class="line"></div><div class="line">files := $(foreach n,$(names),$(n).o)</div></pre></td></tr></table></figure>
<p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(f
iles)的值是“a.o b.o c.o d.o”。</p>
<p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</var></var></p>
<h4 id="7-5-if-函数"><a href="#7-5-if-函数" class="headerlink" title="7.5 if 函数"></a>7.5 if 函数</h4><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(if &lt;condition&gt;,&lt;then-part&gt; )</div></pre></td></tr></table></figure>
<p>或是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; )</div></pre></td></tr></table></figure></p>
<p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。</else-part></then-part></condition></p>
<p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part="">会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</else-part></else-part></condition></then-></condition></p>
<p>所以，<then-part>和<else-part>只会有一个被计算。</else-part></then-part></p>
<h4 id="7-6-call函数"><a href="#7-6-call函数" class="headerlink" title="7.6 call函数"></a>7.6 call函数</h4><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</div></pre></td></tr></table></figure>
<p>当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reverse = $(1) $(2)</div><div class="line"></div><div class="line">foo = $(call reverse,a,b)</div></pre></td></tr></table></figure></expression></parm3></parm2></parm1></expression></p>
<p>那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">reverse = $(2) $(1)</div><div class="line">foo = $(call reverse,a,b)</div></pre></td></tr></table></figure></p>
<p>此时的foo的值就是“b a”。</p>
<h4 id="7-7origin函数"><a href="#7-7origin函数" class="headerlink" title="7.7origin函数"></a>7.7origin函数</h4><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(origin &lt;variable&gt; )</div></pre></td></tr></table></figure></p>
<p>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函
数的返回值:</variable></variable></p>
<p>“undefined”</p>
<p>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</variable></p>
<p>“default”</p>
<p>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</variable></p>
<p>“environment”</p>
<p>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</variable></p>
<p>“file”</p>
<p>如果<variable>这个变量被定义在Makefile中。</variable></p>
<p>“command line”</p>
<p>如果<variable>这个变量是被命令行定义的。</variable></p>
<p>“override”</p>
<p>如果<variable>是被override指示符重新定义的。</variable></p>
<p>“automatic”</p>
<p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</variable></p>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一
个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是
，在我们的Makefile中，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ifdef bletch</div><div class="line"></div><div class="line"></div><div class="line">ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;</div><div class="line"></div><div class="line"></div><div class="line">bletch = barf, gag, etc.</div><div class="line"></div><div class="line">endif</div><div class="line"></div><div class="line">endif</div></pre></td></tr></table></figure>
<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗
暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h4 id="7-8-shell函数"><a href="#7-8-shell函数" class="headerlink" title="7.8 shell函数"></a>7.8 shell函数</h4><p>shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号 是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数
返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">contents := $(shell cat foo)</div><div class="line">files := $(shell echo *.c)</div></pre></td></tr></table></figure>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h4 id="7-9-控制make的函数"><a href="#7-9-控制make的函数" class="headerlink" title="7.9 控制make的函数"></a>7.9 控制make的函数</h4><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(error &lt;text ...&gt; )</div></pre></td></tr></table></figure>
<p>产生一个致命的错误，<text ...="">是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也
是可以的。例如：</text></p>
<p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifdef ERROR_001</div><div class="line">$(error error is $(ERROR_001))</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>示例二：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERR = $(error found an error!)</div><div class="line">.PHONY: err</div><div class="line">err: ; $(ERR)</div></pre></td></tr></table></figure></p>
<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(warning &lt;text ...&gt; )</div></pre></td></tr></table></figure></p>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h3 id="8-make-的运行"><a href="#8-make-的运行" class="headerlink" title="8. make 的运行"></a>8. make 的运行</h3><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h4 id="8-1-make的退出码"><a href="#8-1-make的退出码" class="headerlink" title="8.1 make的退出码"></a>8.1 make的退出码</h4><p>make命令执行后有三个退出码：</p>
<ul>
<li>0 —— 表示成功执行。</li>
<li>1 —— 如果make运行时出现任何错误，其返回1。</li>
<li>2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li>
</ul>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h4 id="8-2-指定Makefile"><a href="#8-2-指定Makefile" class="headerlink" title="8.2 指定Makefile"></a>8.2 指定Makefile</h4><p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就
开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“– makefile”参数也行）。例如，我们有个mak
efile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make –f hchen.mk</div></pre></td></tr></table></figure></p>
<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h3 id="8-3-指定目标"><a href="#8-3-指定目标" class="headerlink" title="8.3 指定目标"></a>8.3 指定目标</h3><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sources = foo.c bar.c</div><div class="line">ifneq ( $(MAKECMDGOALS),clean)</div><div class="line">include $(sources:.c=.d)</div><div class="line">endif</div></pre></td></tr></table></figure>
<p>基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.PHONY: all</div><div class="line">all: prog1 prog2 prog3 prog4</div></pre></td></tr></table></figure>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标
（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。</p>
<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件
发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<ul>
<li>“all”              这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li>“clean”       这个伪目标功能是删除所有被make创建的文件。</li>
<li>“install”       这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li>“print”         这个伪目标的功能是例出改变过的源文件。</li>
<li>“tar”             这个伪目标功能是把源程序打包备份。也就是一个tar文件。</li>
<li>“dist”           这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</li>
<li>“TAGS”        这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li>“check”和“test”    这两个伪目标一般用来测试makefile的流程。</li>
</ul>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h4 id="8-4-检查规则"><a href="#8-4-检查规则" class="headerlink" title="8.4 检查规则"></a>8.4 检查规则</h4><p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<ul>
<li>“-n”</li>
<li>“–just-print”</li>
<li>“–dry-run”</li>
<li><p>“–recon”
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
</li>
<li><p>“-t”</p>
</li>
<li><p>“–touch”
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
</li>
<li><p>“-q”</p>
</li>
<li>“–question”
这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</li>
</ul>
<ul>
<li>“-W <file>”</file></li>
<li>“–what-if=<file>”</file></li>
<li>“–assume-new=<file>”</file></li>
<li>“–new-file=<file>”
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件
所发生的规则命令。</file></li>
</ul>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h4 id="8-5-make的参数"><a href="#8-5-make的参数" class="headerlink" title="8.5 make的参数"></a>8.5 make的参数</h4><p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<ul>
<li>“-b”</li>
<li>“-m”
这两个参数的作用是忽略和其它版本make的兼容性。</li>
</ul>
<ul>
<li>“-B”</li>
<li>“–always-make”
认为所有的目标都需要更新（重编译）。</li>
</ul>
<ul>
<li>“-C <dir>”</dir></li>
<li>“–directory=<dir>”
指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”
等价于“make –C ~hchen/test/prog”。</dir></li>
</ul>
<ul>
<li>“—debug[=<options>]”
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：
a —— 也就是all，输出所有的调试信息。（会非常的多）
b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。
v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。
i —— 也就是implicit，输出所以的隐含规则。
j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。
m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</options></options></li>
</ul>
<ul>
<li>“-d”
相当于“–debug=a”。</li>
</ul>
<ul>
<li>“-e”</li>
<li>“–environment-overrides”
指明环境变量的值覆盖makefile中定义的变量的值。</li>
</ul>
<ul>
<li>“-f=<file>”</file></li>
<li>“–file=<file>”</file></li>
<li>“–makefile=<file>”
指定需要执行的makefile。</file></li>
</ul>
<ul>
<li>“-h”</li>
<li>“–help”
显示帮助信息。</li>
</ul>
<ul>
<li>“-i”</li>
<li>“–ignore-errors”
在执行时忽略所有的错误。</li>
</ul>
<ul>
<li>“-I <dir>”</dir></li>
<li>“–include-dir=<dir>”
指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</dir></li>
</ul>
<ul>
<li>“-j [<jobsnum>]”</jobsnum></li>
<li>“–jobs[=<jobsnum>]”
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-D
OS中是无用的）</jobsnum></li>
</ul>
<ul>
<li>“-k”</li>
<li>“–keep-going”
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</li>
</ul>
<ul>
<li>“-l <load>”</load></li>
<li>“–load-average[=&lt;load]”</li>
<li>“—max-load[=<load>]”
指定make运行命令的负载。</load></li>
</ul>
<ul>
<li>“-n”</li>
<li>“–just-print”</li>
<li>“–dry-run”</li>
<li>“–recon”
仅输出执行过程中的命令序列，但并不执行。</li>
</ul>
<ul>
<li>“-o <file>”</file></li>
<li>“–old-file=<file>”</file></li>
<li>“–assume-old=<file>”
不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</file></file></li>
</ul>
<ul>
<li>“-p”</li>
<li><p>“–print-data-base”
输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -q
p”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用
这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
</li>
<li><p>“-q”</p>
</li>
<li>“–question”
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</li>
</ul>
<ul>
<li>“-r”</li>
<li>“–no-builtin-rules”
禁止make使用任何隐含规则。</li>
</ul>
<ul>
<li>“-R”</li>
<li>“–no-builtin-variabes”
禁止make使用任何作用于变量上的隐含规则。</li>
</ul>
<ul>
<li>“-s”</li>
<li>“–silent”</li>
<li>“–quiet”
在命令运行时不输出命令的输出。</li>
</ul>
<ul>
<li>“-S”</li>
<li>“–no-keep-going”</li>
<li>“–stop”
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</li>
</ul>
<ul>
<li>“-t”</li>
<li>“–touch”
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</li>
</ul>
<ul>
<li>“-v”</li>
<li>“–version”
输出make程序的版本、版权等关于make的信息。</li>
</ul>
<ul>
<li>“-w”</li>
<li>“–print-directory”
输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</li>
</ul>
<ul>
<li>“–no-print-directory”
禁止“-w”选项。</li>
</ul>
<ul>
<li>“-W <file>”</file></li>
<li>“–what-if=<file>”</file></li>
<li>“–new-file=<file>”</file></li>
<li>“–assume-file=<file>”
假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时
间为当前时间。</file></file></file></li>
</ul>
<ul>
<li>“–warn-undefined-variables”
只要make发现有未定义的变量，那么就输出警告信息。</li>
</ul>
<h3 id="9-隐含规则"><a href="#9-隐含规则" class="headerlink" title="9. 隐含规则"></a>9. 隐含规则</h3><p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就
不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>
<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保
证我们Makefile的兼容性。
我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当
然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h4 id="9-1-使用隐含规则"><a href="#9-1-使用隐含规则" class="headerlink" title="9.1 使用隐含规则"></a>9.1 使用隐含规则</h4><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo : foo.o bar.o</div><div class="line">cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</div></pre></td></tr></table></figure></p>
<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成
命令。</p>
<p>make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo.o : foo.c</div><div class="line">cc –c foo.c $(CFLAGS)</div><div class="line">bar.o : bar.c</div><div class="line">cc –c bar.c $(CFLAGS)</div></pre></td></tr></table></figure></p>
<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.o : foo.p</div></pre></td></tr></table></figure></p>
<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成f
oo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
<h4 id="9-2隐含规则一览"><a href="#9-2隐含规则一览" class="headerlink" title="9.2隐含规则一览"></a>9.2隐含规则一览</h4><p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统
定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：<code>.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .
h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el</code>。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<ol>
<li>编译C程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“<code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code>”</n></n></li>
</ol>
<ol>
<li>编译C++程序的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“<code>$(CXX) –c $(CPPFLAGS) $(CFLAGS)</code>”。（建议使用“.cc”作为C++源文件的后缀，而
不是“.C”）</n></n></n></li>
</ol>
<ol>
<li>编译Pascal程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“<code>$(PC) –c $(PFLAGS)</code>”。</n></n></li>
</ol>
<ol>
<li><p>编译Fortran/Ratfor程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:</n></n></n></n></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">“.f” “$(FC) –c $(FFLAGS)”</div><div class="line">“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”</div><div class="line">“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”</div></pre></td></tr></table></figure>
</li>
<li><p>预处理Fortran/Ratfor程序的隐含规则。
“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</n></n></n></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”</div><div class="line">“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”</div></pre></td></tr></table></figure>
</li>
<li><p>编译Modula-2程序的隐含规则。
“<n>.sym” 的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：<code>“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;”</code>的目标的依赖目标会自动推导为“<n>.mod”，
并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。</n></n></n></p>
</li>
</ol>
<ol>
<li>汇编和汇编预处理的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”
，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。</n></n></n></n></li>
</ol>
<ol>
<li>链接Object文件的隐含规则。
“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对
于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x : y.o z.o</div></pre></td></tr></table></figure>
</n></n></n></li>
</ol>
<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cc -c x.c -o x.o</div><div class="line">cc -c y.c -o y.o</div><div class="line">cc -c z.c -o z.o</div><div class="line">cc x.o y.o z.o -o x</div><div class="line">rm -f x.o</div><div class="line">rm -f y.o</div><div class="line">rm -f z.o</div></pre></td></tr></table></figure></p>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<ol>
<li>Yacc C程序时的隐含规则。</li>
</ol>
<p>“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</n></p>
<ol>
<li>Lex C程序时的隐含规则。
“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）</n></li>
</ol>
<ol>
<li>Lex Ratfor程序时的隐含规则。
“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX
) $(LFALGS)”。</n></li>
</ol>
<ol>
<li>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。
“<n>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。</n></n></n></li>
</ol>
<h4 id="9-3隐含规则使用的变量"><a href="#9-3隐含规则使用的变量" class="headerlink" title="9.3隐含规则使用的变量"></a>9.3隐含规则使用的变量</h4><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量
对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把
变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数
相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<ol>
<li>关于命令的变量。</li>
</ol>
<ul>
<li>AR 函数库打包程序。默认命令是“ar”。</li>
<li>AS 汇编语言编译程序。默认命令是“as”。</li>
<li>CC C语言编译程序。默认命令是“cc”。</li>
<li>CXX C++语言编译程序。默认命令是“g++”。</li>
<li>CO 从 RCS文件中扩展文件程序。默认命令是“co”。</li>
<li>CPP C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。</li>
<li>FC Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。</li>
<li>GET 从SCCS文件中扩展文件的程序。默认命令是“get”。</li>
<li>LEX Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。</li>
<li>PC Pascal语言编译程序。默认命令是“pc”。</li>
<li>YACC Yacc文法分析器（针对于C程序）。默认命令是“yacc”。</li>
<li>YACCR Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。</li>
<li>MAKEINFO 转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。</li>
<li>TEX 从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。</li>
<li>TEXI2DVI 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。</li>
<li>WEAVE 转换Web到TeX的程序。默认命令是“weave”。</li>
<li>CWEAVE 转换C Web 到 TeX的程序。默认命令是“cweave”。</li>
<li>TANGLE 转换Web到Pascal语言的程序。默认命令是“tangle”。</li>
<li>CTANGLE 转换C Web 到 C。默认命令是“ctangle”。</li>
<li>RM 删除文件命令。默认命令是“rm –f”。</li>
</ul>
<ol>
<li>关于命令参数的变量
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是
空。</li>
</ol>
<ul>
<li>ARFLAGS 函数库打包程序AR命令的参数。默认值是“rv”。</li>
<li>ASFLAGS 汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。</li>
<li>CFLAGS C语言编译器参数。</li>
<li>CXXFLAGS C++语言编译器参数。</li>
<li>COFLAGS RCS命令参数。</li>
<li>CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。</li>
<li>FFLAGS Fortran语言编译器参数。</li>
<li>GFLAGS</li>
<li>SCCS “get”程序参数。</li>
<li>LDFLAGS 链接器参数。（如：“ld”）</li>
<li>LFLAGS Lex文法分析器参数。</li>
<li>PFLAGS Pascal语言编译器参数。</li>
<li>RFLAGS Ratfor 程序的Fortran 编译器参数。</li>
<li>YFLAGS Yacc文法分析器参数。</li>
</ul>
<h4 id="9-4-隐含规则链"><a href="#9-4-隐含规则链" class="headerlink" title="9.4 隐含规则链"></a>9.4 隐含规则链</h4><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则
叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调
用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规
则就不会生成中间文件。</p>
<h4 id="9-5定义模式规则"><a href="#9-5定义模式规则" class="headerlink" title="9.5定义模式规则"></a>9.5定义模式规则</h4><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p>
<p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p>
<h5 id="9-5-1-模式规则介绍"><a href="#9-5-1-模式规则介绍" class="headerlink" title="9.5.1 模式规则介绍"></a>9.5.1 模式规则介绍</h5><p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为 5）。</p>
<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.o : %.c ; &lt;command ......&gt;</div></pre></td></tr></table></figure></p>
<p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是”a.o b.o”，那么”%c”就是”a.c b.c”。</p>
<p>一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h5 id="9-5-2-模式规则示例"><a href="#9-5-2-模式规则示例" class="headerlink" title="9.5.2 模式规则示例"></a>9.5.2 模式规则示例</h5><p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.o : %.c</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</div></pre></td></tr></table></figure></p>
<p>其中，<code>&quot;$@&quot;</code>表示所有的目标的挨个值，<code>&quot;$&lt;&quot;</code>表示了所有依赖目标的挨个值。这些奇怪的变
量我们叫”自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.tab.c %.tab.h: %.y</div><div class="line">bison -d $&lt;</div></pre></td></tr></table></figure></p>
<p>这条规则告诉make把所有的[.y]文件都以”bison -d <n>.y”执行，然后生成”<n>.tab.c”和”<n>.tab.h”文件。（其中，”<n>“ 表示一个任意字符串）。如果我们的执行程序”foo”依
赖于文件”parse.tab.o”和”scan.o”，并且文件”scan.o”依赖于文件”parse.tab.h”，如果”parse.y”文件被更新了，那么根据上述的规则，”bison -d parse.y”就会被执行一次，于
是，”parse.tab.o”和”scan.o”的依赖文件就齐了。（假设，”parse.tab.o” 由”parse.tab.c”生成，和”scan.o”由”scan.c”生成，而”foo”由”parse.tab.o”和”scan.o”链接生成，
而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</n></n></n></n></p>
<h5 id="9-5-3-自动化变量"><a href="#9-5-3-自动化变量" class="headerlink" title="9.5.3 自动化变量"></a>9.5.3 自动化变量</h5><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<ul>
<li><code>$@</code>:表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</li>
<li><code>$%</code>:仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，<code>&quot;$%&quot;</code>就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是<code>[.a]</code>，Windows下是<code>[.lib]</code>），那么，其值为空。</li>
<li><code>$&lt;</code>:依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li>
<li><code>$?</code>: 所有比目标新的依赖目标的集合。以空格分隔。</li>
<li><code>$^</code>: 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</li>
<li><code>$+</code>:这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li>
<li><code>$*</code>:这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，<code>&quot;$*&quot;</code>的值就是<code>&quot;dir /a.foo</code>“。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么<code>&quot;$*</code>“也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么<code>&quot;$*&quot;</code>就是除了后缀的那一部分。例如：如果目标是”foo.c”，因为”.c”是make所能识别的后缀名，所以，<code>&quot;$*&quot;</code>的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用<code>&quot;$*&quot;</code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么<code>&quot;$*&quot;</code>就是空值。当你希望只对更新过的依赖文件进行操作时，<code>&quot;$?&quot;</code>在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：<code>lib : foo.o bar.o lose.o win.o
ar r lib $?</code></li>
</ul>
<p>在上述所列出来的自动量变量中。四个变量（<code>$@、$&lt;、$%、$*）</code>在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNU make中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上”D”或是”F”的含义：</p>
<ul>
<li><code>$(@D)</code>:表示”$@”的目录部分（不以斜杠作为结尾），如果”$@”值是”dir/foo.o”，那么<code>&quot;$(@D)&quot;</code>就是”dir”，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。</li>
<li><code>$(@F)</code>:表示”$@”的文件部分，如果”$@”值是”dir/foo.o”，那么<code>&quot;$(@F)&quot;</code>就是”foo.o”，<code>&quot;$(@F)&quot;</code>相当于函数”$(notdir $@)”。</li>
<li><code>&quot;$(*D)&quot;</code></li>
<li><code>&quot;$(*F)&quot;</code>:和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>&quot;$(*D)&quot;</code>返回”dir”，而<code>&quot;$(*F)&quot;</code>返回”foo”</li>
<li><code>&quot;$(%D)&quot;</code></li>
<li><code>&quot;$(%F)&quot;</code>:分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。</li>
<li><code>&quot;$(&lt;D)&quot;</code></li>
<li><code>&quot;$(&lt;F)&quot;</code>:分别表示依赖文件的目录部分和文件部分。</li>
<li><code>&quot;$(^D)&quot;</code></li>
<li><code>&quot;$(^F)&quot;</code>:分别表示所有依赖文件的目录部分和文件部分。（无相同的）</li>
<li><code>&quot;$(+D)&quot;</code></li>
<li><code>&quot;$(+F)&quot;</code>:分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</li>
<li><code>&quot;$(?D)&quot;</code></li>
<li><code>&quot;$(?F)&quot;</code>:分别表示被更新的依赖文件的目录部分和文件部分。</li>
</ul>
<p>最后想提醒一下的是，对于<code>&quot;$&lt;&quot;</code>，为了避免产生不必要的麻烦，我们最好给<code>$</code>后面的那个特定字符都加上圆括号，比如，<code>&quot;$(&lt; )&quot;</code>就要比<code>&quot;$&lt;&quot;</code>要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。</p>
<h5 id="9-5-4-模式的匹配"><a href="#9-5-4-模式的匹配" class="headerlink" title="9.5.4 模式的匹配"></a>9.5.4 模式的匹配</h5><p>一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat” 匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）</p>
<h5 id="9-5-5-重载内建隐含规则"><a href="#9-5-5-重载内建隐含规则" class="headerlink" title="9.5.5 重载内建隐含规则"></a>9.5.5 重载内建隐含规则</h5><p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.o : %.c</div><div class="line">$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)</div></pre></td></tr></table></figure></p>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.o : %.s</div></pre></td></tr></table></figure></p>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h4 id="9-6-老式风格的”后缀规则”"><a href="#9-6-老式风格的”后缀规则”" class="headerlink" title="9.6 老式风格的”后缀规则”"></a>9.6 老式风格的”后缀规则”</h4><p>后缀规则是一个比较老式的定义隐含规则的方法。<strong>后缀规则</strong> 会被 <strong>模式规则</strong> 逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o : %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”% : %.c”。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c” 是源文件的后缀，”.o”是目标文件的后缀。如下示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.c.o:</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</div></pre></td></tr></table></figure></p>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.c.o: foo.h</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</div></pre></td></tr></table></figure>
<p>这个例子，就是说，文件”.c.o”依赖于文件”foo.h”，而不是我们想要的这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%.o: %.c foo.h</div><div class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</div></pre></td></tr></table></figure></p>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标<code>&quot;.SUFFIXES&quot;</code>来定义或是删除，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.SUFFIXES: .hack .win</div></pre></td></tr></table></figure></p>
<p>把后缀.hack和.win加入后缀列表中的末尾。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.SUFFIXES: # 删除默认的后缀</div><div class="line">.SUFFIXES: .c .o .h # 定义自己的后缀</div></pre></td></tr></table></figure></p>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p>make的参数”-r”或”-no-builtin-rules”也会使用得默认的后缀列表为空。而变量”SUFFIXE”被用来定义默认的后缀列表，你可以用”.SUFFIXES”来改变后缀列表，但请不要改变变量”SUFFIXE”的值。</p>
<h4 id="9-7-隐含规则搜索算法"><a href="#9-7-隐含规则搜索算法" class="headerlink" title="9.7 隐含规则搜索算法"></a>9.7 隐含规则搜索算法</h4><p>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是”archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把”member”当作T来搜索。</p>
<ol>
<li>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）</li>
<li>创建所有匹配于T或是N的模式规则列表。</li>
<li>如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。</li>
<li>移除列表中没有命令的规则。</li>
<li>对于第一个在列表中的模式规则：<ul>
<li>推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。</li>
<li>计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li>
<li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）</li>
<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>
<li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<ul>
<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li>
<li>计算依赖文件。（同第5步）</li>
<li>测试所有的依赖文件是否存在或是理当存在。</li>
<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li>
<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li>
<li>如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h3 id="10-使用make更新函数库文件"><a href="#10-使用make更新函数库文件" class="headerlink" title="10. 使用make更新函数库文件"></a>10. 使用make更新函数库文件</h3><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p>
<h4 id="10-1-函数库文件的成员"><a href="#10-1-函数库文件的成员" class="headerlink" title="10.1 函数库文件的成员"></a>10.1 函数库文件的成员</h4><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">archive(member)</div></pre></td></tr></table></figure></p>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foolib(hack.o) : hack.o</div><div class="line">ar cr foolib hack.o</div></pre></td></tr></table></figure></p>
<p>如果要指定多个member，那就以空格分开，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foolib(hack.o kludge.o)</div></pre></td></tr></table></figure></p>
<p>其等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foolib(hack.o) foolib(kludge.o)</div></pre></td></tr></table></figure></p>
<p>你还可以使用Shell的文件通配符来定义，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foolib(*.o)</div></pre></td></tr></table></figure></p>
<h4 id="10-2-函数库成员的隐含规则"><a href="#10-2-函数库成员的隐含规则" class="headerlink" title="10.2 函数库成员的隐含规则"></a>10.2 函数库成员的隐含规则</h4><p>当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o” 的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cc -c bar.c -o bar.o</div><div class="line">ar r foo.a bar.o</div><div class="line">rm -f bar.o</div></pre></td></tr></table></figure>
<p>还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。</p>
<h4 id="10-3-函数库文件的后缀规则"><a href="#10-3-函数库文件的后缀规则" class="headerlink" title="10.3 函数库文件的后缀规则"></a>10.3 函数库文件的后缀规则</h4><p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.c.a:</div><div class="line">$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</div><div class="line">$(AR) r $@ $*.o</div><div class="line">$(RM) $*.o</div></pre></td></tr></table></figure></p>
<p>其等效于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(%.o) : %.c</div><div class="line">$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</div><div class="line">$(AR) r $@ $*.o</div><div class="line">$(RM) $*.o</div></pre></td></tr></table></figure></p>
<h4 id="10-4-注意事项"><a href="#10-4-注意事项" class="headerlink" title="10.4 注意事项"></a>10.4 注意事项</h4><p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。
但就目前而言，你还是应该不要尽量不要使用”-j”参数。</p>
<p>该篇文章为转载，是对原作者系列文章的总汇加上标注。
支持原创，请移步陈浩大神博客：
<a href="http://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="external">http://blog.csdn.net/haoel/article/details/2886</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>makefile语法</title>
    <link href="http://wodekouwei.com/2017/09/30/tips-makefile/"/>
    <id>http://wodekouwei.com/2017/09/30/tips-makefile/</id>
    <published>2017-09-30T04:22:14.000Z</published>
    <updated>2017-09-30T04:22:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell开发使用小技巧</title>
    <link href="http://wodekouwei.com/2017/09/30/tips-shell-language/"/>
    <id>http://wodekouwei.com/2017/09/30/tips-shell-language/</id>
    <published>2017-09-30T03:54:47.000Z</published>
    <updated>2017-09-30T04:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写脚本修改数据库中表的某一字段值"><a href="#写脚本修改数据库中表的某一字段值" class="headerlink" title="写脚本修改数据库中表的某一字段值"></a>写脚本修改数据库中表的某一字段值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">##########################################################</div><div class="line">#修改表TBL_BAT_TASK_CTL的USE_FLAG字段，启动或停止贷记卡销卡的批处理</div><div class="line">#useage：执行脚本时加-n参数就是关闭批处理</div><div class="line">#    执行脚本时加-y参数就是打开批处理</div><div class="line">##########################################################</div><div class="line"></div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">if test &quot;$1&quot; = &quot;-n&quot;</div><div class="line">then</div><div class="line">    db2 connect to $DBLINK</div><div class="line">    db2 &quot;update TBL_BAT_TASK_CTL set USE_FLAG=&apos;N&apos; where BAT_ID=&apos;0024&apos; or BAT_ID=&apos;0025&apos;&quot;</div><div class="line">    db2 terminate</div><div class="line">#   exit 0</div><div class="line">fi</div><div class="line"></div><div class="line">if test &quot;$1&quot; = &quot;-y&quot;</div><div class="line">then</div><div class="line">    db2 connect to $DBLINK</div><div class="line">    db2 &quot;update TBL_BAT_TASK_CTL set USE_FLAG=&apos;Y&apos; where BAT_ID=&apos;0024&apos; or BAT_ID=&apos;0025&apos;&quot;</div><div class="line">    db2 terminate</div><div class="line">fi</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写脚本修改数据库中表的某一字段值&quot;&gt;&lt;a href=&quot;#写脚本修改数据库中表的某一字段值&quot; class=&quot;headerlink&quot; title=&quot;写脚本修改数据库中表的某一字段值&quot;&gt;&lt;/a&gt;写脚本修改数据库中表的某一字段值&lt;/h4&gt;&lt;figure class=&quot;hi
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="shell" scheme="http://wodekouwei.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>opencv核心类型</title>
    <link href="http://wodekouwei.com/2017/09/29/opencv-core/"/>
    <id>http://wodekouwei.com/2017/09/29/opencv-core/</id>
    <published>2017-09-29T10:09:42.000Z</published>
    <updated>2017-09-30T02:53:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mat"><a href="#mat" class="headerlink" title="mat"></a>mat</h3><h4 id="创建和清理mat空间"><a href="#创建和清理mat空间" class="headerlink" title="创建和清理mat空间"></a>创建和清理mat空间</h4><ul>
<li>Mat mat(3000, 4000, CV_8UC3);//3000行,4000列数组,数组里存放3个unsigned char类型的数据</li>
<li>mat.create(rows, cols, CV_8UC1);//行数,列数</li>
<li>release或者析构:引用计数为1时释放</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;mat&quot;&gt;&lt;a href=&quot;#mat&quot; class=&quot;headerlink&quot; title=&quot;mat&quot;&gt;&lt;/a&gt;mat&lt;/h3&gt;&lt;h4 id=&quot;创建和清理mat空间&quot;&gt;&lt;a href=&quot;#创建和清理mat空间&quot; class=&quot;headerlink&quot; title=&quot;创
    
    </summary>
    
      <category term="opencv" scheme="http://wodekouwei.com/categories/opencv/"/>
    
    
      <category term="opencv" scheme="http://wodekouwei.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv开发环境搭建</title>
    <link href="http://wodekouwei.com/2017/09/29/opencv-env/"/>
    <id>http://wodekouwei.com/2017/09/29/opencv-env/</id>
    <published>2017-09-29T09:50:52.000Z</published>
    <updated>2017-09-29T10:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>从github下载opencv最新源码<a href="https://github.com/opencv/opencv,目前最新是`5e93c8202363a13fc72df30f8c14069c5ab66e42`" target="_blank" rel="external">https://github.com/opencv/opencv,目前最新是`5e93c8202363a13fc72df30f8c14069c5ab66e42`</a>.</p>
<h3 id="Ubuntu环境下编译"><a href="#Ubuntu环境下编译" class="headerlink" title="Ubuntu环境下编译"></a>Ubuntu环境下编译</h3><p>安装依赖库:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential</div><div class="line"></div><div class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</div><div class="line"></div><div class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</div><div class="line"></div><div class="line">git clone https://github.com/opencv/opencv.git</div><div class="line"></div><div class="line">sudo apt-get install cmake-gui</div></pre></td></tr></table></figure></p>
<h3 id="Mac环境下编译"><a href="#Mac环境下编译" class="headerlink" title="Mac环境下编译"></a>Mac环境下编译</h3><p>进入源码路径,新建一个release的文件夹,并进入,执行:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cmake -G &quot;Unix Makefiles&quot; ..</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p>
<p>编译完成后会在release生成lib目录,lib下存放所有编译成的动态库,可能与ubuntu下编译结果不同,ubuntu下编译只生成<code>libopencv_world.so</code>一个动态库,而mac下会生成<code>opencv_core opencv_highgui opencv_imgproc opencv_ml opencv_objdetect opencv_photo opencv_video opencv_dnn opencv_imgcodecs opencv_shape</code>等多个动态库.执行<code>make install</code>后会将头文件拷贝到<code>/usr/local/include/</code>下,将动态库拷贝到<code>/usr/local/lib/</code>下,将jar包等其他文件拷贝到<code>/usr/local/share/OpenCV/</code>下,makefile脚本加入动态链接库:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testopencv:main.cpp</div><div class="line">	g++ $+ -o $@ -lopencv_core -lopencv_highgui -lopencv_imgproc -lopencv_ml -lopencv_objdetect -lopencv_photo -lopencv_video -lopencv_dnn -lopencv_imgcodecs -lopencv_shape</div></pre></td></tr></table></figure></p>
<p><code>main.cpp</code>下输入下面测试代码:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;opencv2/core.hpp&gt;</div><div class="line">#include &lt;opencv2/imgcodecs.hpp&gt;</div><div class="line">#include &lt;opencv2/highgui.hpp&gt;</div><div class="line">using namespace cv;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">	Mat image = imread(&quot;1.png&quot;);</div><div class="line">	namedWindow(&quot;img&quot;);</div><div class="line">	imshow(&quot;img&quot;, image);</div><div class="line">	waitKey(0);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在生成的执行文件同目录下放入名字为<code>1.png</code>的图片.</p>
<h4 id="配置QT环境"><a href="#配置QT环境" class="headerlink" title="配置QT环境"></a>配置QT环境</h4><p>在新建的QT工程中的.pro文件中添加如下配置代码:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">INCLUDEPATH += /usr/local/include</div><div class="line">INCLUDEPATH += /usr/local/include/opencv</div><div class="line">INCLUDEPATH += /usr/local/include/opencv2</div><div class="line">LIBS += -L/usr/local/lib \</div><div class="line"> -lopencv_core \</div><div class="line"> -lopencv_highgui \</div><div class="line"> -lopencv_imgproc \</div></pre></td></tr></table></figure></p>
<p>完成以上步骤后按理应该是能成功的，但是运行时发现会出现如下的错误。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dyld: Symbol not found: __cg_jpeg_resync_to_restart</div><div class="line">Referenced from: /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO</div><div class="line">Expected in: /usr/local/lib/libjpeg.8.dylib</div><div class="line">in /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO</div></pre></td></tr></table></figure></p>
<p>针对以上问题,在项目-运行配置中,增加变量<code>DYLD_LIBRARY_PATH</code>值为<code>/Application/QT5.7.0/5.7/clang_64/lib:/usr/local/lib</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从github下载opencv最新源码&lt;a href=&quot;https://github.com/opencv/opencv,目前最新是`5e93c8202363a13fc72df30f8c14069c5ab66e42`&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
      <category term="opencv" scheme="http://wodekouwei.com/categories/opencv/"/>
    
    
      <category term="opencv" scheme="http://wodekouwei.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>tips-android</title>
    <link href="http://wodekouwei.com/2017/09/27/tips-android/"/>
    <id>http://wodekouwei.com/2017/09/27/tips-android/</id>
    <published>2017-09-27T02:41:33.000Z</published>
    <updated>2017-09-27T02:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="1-使用Glide库提取视频帧"><a href="#1-使用Glide库提取视频帧" class="headerlink" title="1.使用Glide库提取视频帧"></a>1.使用Glide库提取视频帧</h6><p>图片加载框架Glide就可以做到获取本地视频的缩略图(不能获取网络视频文件):
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String filePath = &quot;/storage/emulated/0/Pictures/example_video.mp4&quot;;</div><div class="line">Glide  </div><div class="line">    .with( context )</div><div class="line">    .load( Uri.fromFile( new File( filePath ) ) )</div><div class="line">    .into( imageViewGifAsBitmap );</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;1-使用Glide库提取视频帧&quot;&gt;&lt;a href=&quot;#1-使用Glide库提取视频帧&quot; class=&quot;headerlink&quot; title=&quot;1.使用Glide库提取视频帧&quot;&gt;&lt;/a&gt;1.使用Glide库提取视频帧&lt;/h6&gt;&lt;p&gt;图片加载框架Glide就可以做到获取
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>关于QT QAudioOutput push模式问题</title>
    <link href="http://wodekouwei.com/2017/09/13/tips-qt-audiooutput/"/>
    <id>http://wodekouwei.com/2017/09/13/tips-qt-audiooutput/</id>
    <published>2017-09-13T03:52:14.000Z</published>
    <updated>2017-09-13T04:08:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在MAC上基于QT和ffmpeg实现最简单播放器,在完成声音播放模块后导致无法正常播放,QAudioOutput start后state仍是idel,将QAudioOutput buffer写满后就不能继续写数据了,导致播放被卡死.</p>
<p>QAudioOutput创建代码:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">QAudioFormat fmt;</div><div class="line">fmt.setSampleRate(this-&gt;sampleRate);</div><div class="line">fmt.setSampleSize(this-&gt;sampleSize);</div><div class="line">fmt.setChannelCount(this-&gt;channel);</div><div class="line">fmt.setCodec(&quot;audio/pcm&quot;);</div><div class="line">fmt.setByteOrder(QAudioFormat::LittleEndian);</div><div class="line">fmt.setSampleType(QAudioFormat::UnSignedInt);</div><div class="line">QAudioDeviceInfo info = QAudioDeviceInfo::defaultOutputDevice();</div><div class="line">printf(&quot;deviceName:%s\n&quot;,qPrintable(info.deviceName()));</div><div class="line">if (!info.isFormatSupported(fmt)) &#123;</div><div class="line">    printf(&quot;default format not supported try to use nearest\n&quot;);</div><div class="line">    fmt = info.nearestFormat(fmt);</div><div class="line">&#125;</div><div class="line">output = new QAudioOutput(fmt);</div><div class="line">//connect(output, SIGNAL(stateChanged(QAudio::State)), this, SLOT(handleStateChanged(QAudio::State)));</div><div class="line">io = output-&gt;start();</div><div class="line">printf(&quot;io:%p\n&quot;, io);</div><div class="line">//printf(&quot;state:%s&quot;,output-&gt;state());</div><div class="line">QAudio::State stat = output-&gt;state();</div></pre></td></tr></table></figure></p>
<p>在stackoverflow <a href="https://stackoverflow.com/questions/15651407/qt-qaudiooutput-push-mode" target="_blank" rel="external">Qt QAudioOutput push mode</a>看到别人的问题和解释,发现是setSampleType引起的,代码在window上可以正常跑,只是在mac上失败.</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>I’ve got a question about using QAudioOutput to directly write samples at a specific sample rate to the sound output device. I’m writing an emulator that emualates sound chips on a per-frame basis, and then gets a buffer containing a frame’s worth of audio samples, which I would like to write to the audio output. Currently, to test my audio output routine, I allocate a huge (5 minute) buffer to put random numbers into, like so:</p>
<p>Header:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uint16_t *audio_outputBuffer;</div><div class="line">uint32_t audio_bytesRemainingToRead;</div><div class="line">QAudioOutput *audio_outputStream;</div><div class="line">QIODevice *audio_outputDevice;</div></pre></td></tr></table></figure></p>
<p>Implementation:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">audio_outputBuffer = (uint16_t *) malloc((96000 * 4) * 300);</div><div class="line">int i = 0;</div><div class="line"></div><div class="line">uint16_t *tempAudioBuffer = audio_outputBuffer;</div><div class="line">for(i = 0; i &lt; ((96000 * 4) * 150); i++) &#123;</div><div class="line">    *tempAudioBuffer = (uint16_t) rand() &amp; 0xFFFF;</div><div class="line">    tempAudioBuffer++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">audio_bytesRemainingToRead = (96000 * 4) * 300;</div></pre></td></tr></table></figure></p>
<p>Next, I set up my audio device with some basic parameters:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Set up the format</div><div class="line">QAudioFormat format;</div><div class="line">format.setFrequency(96000); // Usually this is specified through an UI option</div><div class="line">format.setChannels(2);</div><div class="line">format.setSampleSize(16);</div><div class="line">format.setCodec(&quot;audio/pcm&quot;);</div><div class="line">format.setByteOrder(QAudioFormat::LittleEndian);</div><div class="line">format.setSampleType(QAudioFormat::UnSignedInt);</div><div class="line"></div><div class="line">// There&apos;s code here to notify the user of inability to match the format and choose an action, which is omitted for clarity</div><div class="line"></div><div class="line">// Create audio output stream, set up signals</div><div class="line">audio_outputStream = new QAudioOutput(format, this);</div><div class="line"></div><div class="line">connect(audio_outputStream, SIGNAL(stateChanged(QAudio::State)), this, SLOT(audio_stateChanged(QAudio::State)));</div><div class="line"></div><div class="line">audio_outputDevice = audio_outputStream-&gt;start();</div></pre></td></tr></table></figure></p>
<p>Then, in my timer tick routine, which is called by a QTimer at 60 FPS, I do the following code to write a ‘chunk’ of audio data to the QAudioOutput’s buffer:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(audio_outputDevice-&gt;isOpen() &amp;&amp; audio_outputStream-&gt;state() != QAudio::StoppedState) &#123;</div><div class="line">    qint64 bytesOfAudioWrittenToDevice = audio_outputDevice-&gt;write((char *) audio_outputBuffer, audio_outputStream-&gt;periodSize());</div><div class="line">    audio_bytesRemainingToRead -= bytesOfAudioWrittenToDevice;</div><div class="line">    qDebug() &lt;&lt; &quot;Wrote&quot; &lt;&lt; bytesOfAudioWrittenToDevice &lt;&lt; &quot;bytes of audio to output device. Remaining bytes to read:&quot; &lt;&lt; audio_bytesRemainingToRead;</div><div class="line">    qDebug() &lt;&lt; &quot;Free bytes in audio output:&quot; &lt;&lt; audio_outputStream-&gt;bytesFree();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Once I start the audio output process, I get the following output on the console:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Current audio state: 3 Error: 0</div><div class="line">Wrote 2048 bytes of audio to output device. Remaining bytes to read: 115197952</div><div class="line">Free bytes in audio output: 6144</div><div class="line">Current audio state: 0 Error: 0</div><div class="line">Wrote 2048 bytes of audio to output device. Remaining bytes to read: 115195904</div><div class="line">Free bytes in audio output: 4096</div><div class="line">Wrote 2048 bytes of audio to output device. Remaining bytes to read: 115193856</div><div class="line">Free bytes in audio output: 2048</div><div class="line">Wrote 2048 bytes of audio to output device. Remaining bytes to read: 115191808</div><div class="line">Free bytes in audio output: 0 (This and the above line is repeated forever)</div></pre></td></tr></table></figure></p>
<p>To me, it looks like QAudioOutput isn’t flushing it’s internal buffer to the sound card, which goes along with the entire “no sound coming out of my computer” thing.</p>
<p>What would cause this issue, and how could I fix it?</p>
<p>(By the way, I’m compiling my code against Qt 4.8.1, on Mac OS X 10.7.4.)</p>
<p>Thanks for any answers.</p>
<h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>Upfront just wanna point out: This is not a Qt bug. Why? The answer is that in the WAV spec’, 8-bit samples are always unsigned, whereas 16-bit samples are always signed. Any other combination does not work. This is device related, the framework can not do anything about it.</p>
<p>So this will not work because you have set 16 bit sample size and unsigned integer format. And yes, the solution is: you have to set the sample type to signed for 16-bit resolution:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">format.setSampleType(QAudioFormat::SignedInt);</div></pre></td></tr></table></figure></p>
<p>Inversely for 8-bit samples you would have to put:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">format.setSampleType(QAudioFormat:UnsignedInt);</div></pre></td></tr></table></figure></p>
<p>Also this very similar question (same problem but with 8-bit) shows you that it is not a particular problem of using signed or unsigned samples in Qt, but that it is the combination of samples size and type that matters (for the audio device, not for Qt ;) QAudioOutput in Qt5 is not producing any sound</p>
<p>IMHO the fact that Qt does not take care of handling these cases by forcing the correct format is a flaw but not a lack in functionnality.</p>
<p>You can learn more about this in the notes section of this page: <a href="https://ccrma.stanford.edu/courses/422/projects/WaveFormat/" target="_blank" rel="external">https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a></p>
<p>I’ve figured this out — apparently Qt has issues with UNSIGNED samples. If you set the sample type to signed, everything works fine, regardless of platform.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在MAC上基于QT和ffmpeg实现最简单播放器,在完成声音播放模块后导致无法正常播放,QAudioOutput start后state仍是idel,将QAudioOutput buffer写满后就不能继续写数据了,导致播放被卡死.&lt;/p&gt;
&lt;p&gt;QAudioOutp
    
    </summary>
    
      <category term="QT" scheme="http://wodekouwei.com/categories/QT/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="QT" scheme="http://wodekouwei.com/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG api使用流程</title>
    <link href="http://wodekouwei.com/2017/09/13/ffmpeg-arch/"/>
    <id>http://wodekouwei.com/2017/09/13/ffmpeg-arch/</id>
    <published>2017-09-13T02:04:15.000Z</published>
    <updated>2017-09-13T04:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>ffmpeg接口使用流程比较固定:</p>
<ol>
<li><code>av_register_all()</code>:注册所有模块</li>
<li><code>int ret = avformat_open_input(&amp;ic, ofn, 0, 0);</code>:获取AVFormatContext ic(ofn为输入文件地址)</li>
<li><code>for(i = 0; i &lt; ic-&gt;nb_streams; i++)</code>:遍历AVFormatContext中所有stream,分别找到Audio与Video对应的AVCodecContext;</li>
<li><code>AVCodec *codec = avcodec_find_decoder(enc-&gt;codec_id);</code>:根据AVCodecContext中codec_id获取到AVCodec;</li>
<li><code>avcodec_open2(enc, codec,NULL)</code>:打开AVCodec;</li>
<li>接下来分配AVPacket与AVFrame</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ffmpeg接口使用流程比较固定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;av_register_all()&lt;/code&gt;:注册所有模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int ret = avformat_open_input(&amp;amp;ic, ofn, 0, 0);&lt;/
    
    </summary>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/categories/FFMPEG/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG编解码</title>
    <link href="http://wodekouwei.com/2017/09/13/ffmpeg-codec/"/>
    <id>http://wodekouwei.com/2017/09/13/ffmpeg-codec/</id>
    <published>2017-09-13T02:03:37.000Z</published>
    <updated>2017-09-13T03:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>ffmpeg3版本的解码接口做了调整,之前的视频解码接口<code>avcodec_decode_video2</code>和音频解码接口<code>avcodec_decode_audio4</code>被设置为deprecated,对这两个接口做了合并,使用同一的接口.并且将音视频解码步骤分成了两步,第一步<code>avcodec_send_packet</code>,第二步<code>avcodec_receive_frame</code>,</p>
<h4 id="旧版本avcodec-decode-video2"><a href="#旧版本avcodec-decode-video2" class="headerlink" title="旧版本avcodec_decode_video2"></a>旧版本<code>avcodec_decode_video2</code></h4><h4 id="旧版本avcodec-decode-audio4"><a href="#旧版本avcodec-decode-audio4" class="headerlink" title="旧版本avcodec_decode_audio4"></a>旧版本<code>avcodec_decode_audio4</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int got_picture;</div><div class="line">            ret = avcodec_decode_audio4(enc, pcm,&amp;got_picture, pkt);</div><div class="line">            if ( ret &lt; 0 ) &#123;</div><div class="line">                char buf[1024] = &#123;0&#125;;</div><div class="line">                av_strerror(err, buf, sizeof(buf));</div><div class="line">                printf(buf);</div><div class="line">                printf(&quot;avcodec_decode_audio4 failed:%d&quot; ,got_picture);</div><div class="line">                av_packet_unref(pkt);</div><div class="line">                av_frame_free(&amp;pcm);</div><div class="line">                if(ic) avformat_close_input(&amp;ic);</div><div class="line">                return -1;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>将AVPacket的pkt解码成AVFrame的pcm</p>
<h4 id="新版本avcodec-send-packet"><a href="#新版本avcodec-send-packet" class="headerlink" title="新版本avcodec_send_packet"></a>新版本<code>avcodec_send_packet</code></h4><h5 id="接口源码"><a href="#接口源码" class="headerlink" title="接口源码:"></a>接口源码:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Supply raw packet data as input to a decoder.</div><div class="line"> *</div><div class="line"> * Internally, this call will copy relevant AVCodecContext fields, which can</div><div class="line"> * influence decoding per-packet, and apply them when the packet is actually</div><div class="line"> * decoded. (For example AVCodecContext.skip_frame, which might direct the</div><div class="line"> * decoder to drop the frame contained by the packet sent with this function.)</div><div class="line"> *</div><div class="line"> * @warning The input buffer, avpkt-&gt;data must be AV_INPUT_BUFFER_PADDING_SIZE</div><div class="line"> *          larger than the actual read bytes because some optimized bitstream</div><div class="line"> *          readers read 32 or 64 bits at once and could read over the end.</div><div class="line"> *</div><div class="line"> * @warning Do not mix this API with the legacy API (like avcodec_decode_video2())</div><div class="line"> *          on the same AVCodecContext. It will return unexpected results now</div><div class="line"> *          or in future libavcodec versions.</div><div class="line"> *</div><div class="line"> * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()</div><div class="line"> *       before packets may be fed to the decoder.</div><div class="line"> *</div><div class="line"> * @param avctx codec context</div><div class="line"> * @param[in] avpkt The input AVPacket. Usually, this will be a single video</div><div class="line"> *                  frame, or several complete audio frames.</div><div class="line"> *                  Ownership of the packet remains with the caller, and the</div><div class="line"> *                  decoder will not write to the packet. The decoder may create</div><div class="line"> *                  a reference to the packet data (or copy it if the packet is</div><div class="line"> *                  not reference-counted).</div><div class="line"> *                  Unlike with older APIs, the packet is always fully consumed,</div><div class="line"> *                  and if it contains multiple frames (e.g. some audio codecs),</div><div class="line"> *                  will require you to call avcodec_receive_frame() multiple</div><div class="line"> *                  times afterwards before you can send a new packet.</div><div class="line"> *                  It can be NULL (or an AVPacket with data set to NULL and</div><div class="line"> *                  size set to 0); in this case, it is considered a flush</div><div class="line"> *                  packet, which signals the end of the stream. Sending the</div><div class="line"> *                  first flush packet will return success. Subsequent ones are</div><div class="line"> *                  unnecessary and will return AVERROR_EOF. If the decoder</div><div class="line"> *                  still has frames buffered, it will return them after sending</div><div class="line"> *                  a flush packet.</div><div class="line"> *</div><div class="line"> * @return 0 on success, otherwise negative error code:</div><div class="line"> *      AVERROR(EAGAIN):   input is not accepted right now - the packet must be</div><div class="line"> *                         resent after trying to read output</div><div class="line"> *      AVERROR_EOF:       the decoder has been flushed, and no new packets can</div><div class="line"> *                         be sent to it (also returned if more than 1 flush</div><div class="line"> *                         packet is sent)</div><div class="line"> *      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush</div><div class="line"> *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar</div><div class="line"> *      other errors: legitimate decoding errors</div><div class="line"> */</div><div class="line">int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt);</div></pre></td></tr></table></figure>
<h5 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h5><ul>
<li><code>AVCodecContext *avctx</code>：第一个参数与旧的接口一致，是视频解码的上下文，包含解码器。</li>
<li><code>const AVPacket *avpkt</code>： 编码的音视频帧数据</li>
</ul>
<p>为什么要传递空的avpkt
这里有一个说明是可以传递NULL，什么情况下需要传递NULL，你平时看一些视频播放器，播放经常会少最后几帧，很多情况就是因为没有处理好缓冲帧的问题，ffmpeg内部会缓冲几帧，要想取出来就需要传递空的AVPacket进去。</p>
<h4 id="新版本avcodec-receive-frame"><a href="#新版本avcodec-receive-frame" class="headerlink" title="新版本avcodec_receive_frame"></a>新版本<code>avcodec_receive_frame</code></h4><h5 id="接口源码-1"><a href="#接口源码-1" class="headerlink" title="接口源码"></a>接口源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return decoded output data from a decoder.</div><div class="line"> *</div><div class="line"> * @param avctx codec context</div><div class="line"> * @param frame This will be set to a reference-counted video or audio</div><div class="line"> *              frame (depending on the decoder type) allocated by the</div><div class="line"> *              decoder. Note that the function will always call</div><div class="line"> *              av_frame_unref(frame) before doing anything else.</div><div class="line"> *</div><div class="line"> * @return</div><div class="line"> *      0:                 success, a frame was returned</div><div class="line"> *      AVERROR(EAGAIN):   output is not available right now - user must try</div><div class="line"> *                         to send new input</div><div class="line"> *      AVERROR_EOF:       the decoder has been fully flushed, and there will be</div><div class="line"> *                         no more output frames</div><div class="line"> *      AVERROR(EINVAL):   codec not opened, or it is an encoder</div><div class="line"> *      other negative values: legitimate decoding errors</div><div class="line"> */</div><div class="line">int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame);</div></pre></td></tr></table></figure>
<h5 id="参数分析-1"><a href="#参数分析-1" class="headerlink" title="参数分析"></a>参数分析</h5><ul>
<li><code>AVCodecContext *avctx</code>：第一个参数视频解码的上下文，与上面接口一致。</li>
<li><code>AVFrame *frame</code>：解码后的视频帧数据。</li>
</ul>
<h5 id="空间申请和释放问题"><a href="#空间申请和释放问题" class="headerlink" title="空间申请和释放问题"></a>空间申请和释放问题</h5><p>解码后图像空间由函数内部申请，你所做的只需要分配 AVFrame 对象空间，如果你每次调用avcodec_receive_frame传递同一个对象，接口内部会判断空间是否已经分配，如果没有分配会在函数内部分配。
avcodec_send_packet和avcodec_receive_frame调用关系并不一定是一对一的，比如一些音频数据一个AVPacket中包含了1秒钟的音频，调用一次avcodec_send_packet之后，可能需要调用25次 avcodec_receive_frame才能获取全部的解码音频数据，所以要做如下处理：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int re = avcodec_send_packet(codec, pkt);</div><div class="line">if (re != 0)</div><div class="line">&#123;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">while( avcodec_receive_frame(codec, frame) == 0)</div><div class="line">&#123;</div><div class="line">    //读取到一帧音频或者视频</div><div class="line">    //处理解码后音视频 frame</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考
<a href="http://ffmpeg.org/doxygen/trunk/group__lavc__encdec.html" target="_blank" rel="external">send/receive encoding and decoding API overview</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;解码&quot;&gt;&lt;a href=&quot;#解码&quot; class=&quot;headerlink&quot; title=&quot;解码&quot;&gt;&lt;/a&gt;解码&lt;/h3&gt;&lt;p&gt;ffmpeg3版本的解码接口做了调整,之前的视频解码接口&lt;code&gt;avcodec_decode_video2&lt;/code&gt;和音频解码接口&lt;
    
    </summary>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/categories/FFMPEG/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG工具方法</title>
    <link href="http://wodekouwei.com/2017/09/13/ffmpeg-util/"/>
    <id>http://wodekouwei.com/2017/09/13/ffmpeg-util/</id>
    <published>2017-09-13T02:03:27.000Z</published>
    <updated>2017-09-13T04:20:49.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="av-strerror"><a href="#av-strerror" class="headerlink" title="av_strerror"></a>av_strerror</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int av_strerror	(	int 	errnum,</div><div class="line">char * 	errbuf,</div><div class="line">size_t 	errbuf_size</div><div class="line">)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;av-strerror&quot;&gt;&lt;a href=&quot;#av-strerror&quot; class=&quot;headerlink&quot; title=&quot;av_strerror&quot;&gt;&lt;/a&gt;av_strerror&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
    
    </summary>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/categories/FFMPEG/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>音视频参数之Profile</title>
    <link href="http://wodekouwei.com/2017/09/12/tips-media-profile/"/>
    <id>http://wodekouwei.com/2017/09/12/tips-media-profile/</id>
    <published>2017-09-12T04:12:19.000Z</published>
    <updated>2017-09-12T08:40:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天发现公司产品 <strong>触发</strong> 有导入从微信等下载的外部小视频时失败的情况, <strong>触发</strong> 导入视频时使用开源库<a href="https://github.com/INDExOS/media-for-mobile" target="_blank" rel="external">media-for-mobile</a>对视频进行重新编码.media-for-mobile使用android系统接口<code>android.media.MediaExtractor</code>对mp4文件解复用,使用android硬件编解码接口<code>android.media.MediaCodec</code>对视频解码-处理-编码操作,最后通过Android系统API<code>android.media.MediaMuxer</code>将视频写成文件.</p>
<p>反馈的两个有问题视频,一个视频导入时报<code>BufferOverFlowException</code>错误,另一个视频不报错但是导入时进度一直为0%.</p>
<p>经分析出问题的两个视频的Video profile为High,普通视频为<code>Baseline</code>,报<code>BufferOverFlowException</code>错误的视频的Audio profile为<code>HE-AAC</code>,普通视频的Audio profile为<code>LC</code>.
详细了解了一下H264 与AAC profile:</p>
<h4 id="H264各种profile"><a href="#H264各种profile" class="headerlink" title="H264各种profile"></a>H264各种profile</h4><p>作为行业标准，H.264编码体系定义了4种不同的Profile(类)：Baseline(基线类),Main(主要类), Extended(扩展类)和High Profile(高端类)（它们各自下分成许多个层）：</p>
<ol>
<li><code>Baseline Profile</code>: 提供I/P帧，仅支持progressive(逐行扫描)和CAVLC；</li>
<li><code>Extended Profile</code>: 提供I/P/B/SP/SI帧，仅支持progressive(逐行扫描)和CAVLC；</li>
<li><code>Main Profile:</code> 提供I/P/B帧，支持progressive(逐行扫描)和interlaced(隔行扫描)，提供CAVLC或CABAC；</li>
<li><code>High Profile</code>: （也就是FRExt）在Main Profile基础上新增：8x8 intra prediction(8x8 帧内预测), custom quant(自定义量化), lossless video coding(无损视频编码), 更多的yuv格式（4:4:4…）；</li>
</ol>
<p>H.264在高清中具有最小体积。在同等图像质量下，采用H.264技术压缩后的数据量只有MPEG2的1/8，MPEG4的1/3，相对Xvid、Divx等属于MPEG4编码而言，其体积优势明显，在互联网上，H.264资源处在爆发趋势。而High Profile是H.264解码中的高端类型，拥有最完善的支持程度、最优秀的特性，可以说是高清视频编码中的劳斯莱斯，只有征服了这个优秀的编码，MP4才能将H.264完全掌控，也才能充分享受到高清视频带来的视觉震撼，意义非凡。</p>
<p>针对当前高清是视频会议行业的主流发展趋势，而目前高清普及的主要阻力之一就是带宽的限制。而High Profile H.264技术在同等视频质量的情况下可节省50%的带宽，为客户节省大量的网络带宽成本。据业内专家介绍，此次H.264 High Profile的推出是视频技术的一个巨大进步，其意义不亚于2003年从H.263向H.264过渡的价值。它将为目前正在推广的高清视频通信应用扫清了令人头疼的网络带宽障碍，不仅如此，这些变化对于包括CIF、标清等品质的视频通信应用也同样适用。</p>
<p>鉴于High Profile H.264对于视频会议行业的非凡影响，目前已有国内外厂商尝鲜，宣布其旗下产品全面支持该项技术，包括宝利通、华平、华腾网讯。从这一趋势来看，未来视频会议产品全面支持High Profile H.264也经成为不可逆转的潮流，而高清普及也在技术层面更近了一步。</p>
<blockquote>
<p>参考:
<a href="http://blog.csdn.net/qiaoliang328/article/details/10153313" target="_blank" rel="external">H264 各种profile</a></p>
</blockquote>
<h4 id="AAC各种profile"><a href="#AAC各种profile" class="headerlink" title="AAC各种profile"></a>AAC各种profile</h4><h5 id="AAC共有9种规格，以适应不同的场合的需要："><a href="#AAC共有9种规格，以适应不同的场合的需要：" class="headerlink" title="AAC共有9种规格，以适应不同的场合的需要："></a>AAC共有9种规格，以适应不同的场合的需要：</h5><ol>
<li><code>MPEG-2 AAC LC</code>: 低复杂度规格（Low Complexity）–比较简单，没有增益控制，但提高了编码效率，在中等码率的编码效率以及音质方面，都能找到平衡点</li>
<li><code>MPEG-2 AAC Main</code>: 主规格    </li>
<li><code>MPEG-2 AAC SSR</code>: 可变采样率规格（Scaleable Sample Rate）</li>
<li><code>MPEG-4 AAC LC</code>: 低复杂度规格（Low Complexity）——现在的手机比较常见的MP4文件中的音频部份就包括了该规格音频文件</li>
<li><code>MPEG-4 AAC Main</code>: 主规格   ——包含了除增益控制之外的全部功能，其音质最好</li>
<li><code>MPEG-4 AAC SSR</code>: 可变采样率规格（Scaleable Sample Rate）</li>
<li><code>MPEG-4 AAC LTP</code>: 长时期预测规格（Long Term Predicition）</li>
<li><code>MPEG-4 AAC LD</code>: 低延迟规格（Low Delay）</li>
<li><code>MPEG-4 AAC HE</code>: 高效率规格（High Efficiency）—–这种规格适合用于低码率编码，有Nero ACC 编码器支持</li>
</ol>
<p>14496-3标准，里面定义的profile除了上述的一些规格，还有如Scalable 、 TwinVQ、  CELP、  HVXC等更多其他的profile。</p>
<p>目前听到用的比较多的应该是LC和HE(适合低码率)。流行的Nero AAC的命令行编码程序就支持LC，HE，HEv2这三种，试用后，用MediaInfo分析了编码后的AAC音频，发现规格显示都是LC，当时就感到奇怪，不是说支持三种规格吗？然后才又查资料发现，原来HE其实就是AAC（LC）+SBR技术，HEv2就是AAC（LC）+SBR+PS技术，难怪用MediaInfo分析后，HE规格的文件即显示:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">格式简介:LC</div><div class="line">格式设置,SBR:是</div><div class="line">格式设置,PS:否</div></pre></td></tr></table></figure></p>
<h5 id="HE与HEv2"><a href="#HE与HEv2" class="headerlink" title="HE与HEv2"></a>HE与HEv2</h5><ul>
<li><p>HE：“high efficiency”（高效性）。HE-AAC v1（又称AACPlusV1，SBR)用容器的方法加了原AAC（LC）+SBR技术。SBR其实代表的是Spectral Band Replication(频段复制)。简单概括一下，音乐的主要频谱集中在低频段，高频段幅度很小（但很重要，决定了音质），如果对整个频段编码，要么为了保护高频造成低频段编码过细以致文件巨大，要么为了保存了低频的主要成分而失去高频成分以致丧失音质。SBR把频谱切割开来，低频单独编码保存主要成分，高频单独放大编码保存音质，“统筹兼顾”了，在减少文件大小的情况下还保存了音质，完美的化解了一对矛盾</p>
</li>
<li><p>HEv2 它用容器的方法包含了HE-AAC v1和PS技术。PS指“parametric stereo”（参数立体声）。这个其实好理解，原来的立体声文件，文件大小是一个声道的两倍。但是两个声道的声音存在某种相似性，根据香农信息熵编码定理，相关性应该被去掉才能减小文件大小。所以PS技术存储了一个声道的全部信息，然后，花很少的字节用参数描述另一个声道和它不同的地方
这样，HEv1和HEv2用个图简单表示下就是：(图中的AAC即指的是原来的AAC-LC)
<img src="http://images.wodekouwei.com/media/aac-he.jpg" alt="image">
由于NERO AAC编码后产生的是经过MP4容器封装后的，而我们的decoder需要处理的是未经封装的AAC流，因此还需要处理从MP4封装格式中extract出AAC流的步骤；哦，这里提到了MP4容器封装，就再把我看到的一些关于MP4容器的心得插入在此也说下：</p>
</li>
</ul>
<p>其实.mp4格式规范是MPEG4 Part 1标准定义的。但是这个格式本身相当通用，并不是只能用来存贮MPEG4视频格式。举个例子，一个.mp4文件中包含的可能是H.263的视频轨及AMR的音频轨。这样它和MPEG4视频压缩算法就半点边都沾不上。但它绝对是一个合法的.mp4文件。从这个意义上讲，.mp4是一个独立的封包格式。也许它的原始设计意图是仅用于MPEG4，但事实上大家觉得它很好用，已经把它扩展成可以包容其它格式了。现在市场上比如某产品号称“支持MP4播放”，到底是什么意思呢？如果它是指可以播放<em>.mp4这种文件，那里面的音频和视频格式它能支持多少种组合呢？没说清楚吧。举个极端的例子，假设一台设备仅支持“视频为未压缩YUV以及不带音频轨的.mp4文件，但它的文件名确实可以是</em>.mp4，是不是也可以在盒子上印上“支持MP4”呢？那么，买回去，复制一个网上下载的.mp4文件（MPEG4视频和AAC音频应该是个比较流行的组合），结果却发现根本不能播放。就算不举这么极端的例子，一般.mp4文件中常见的视频音频格式也有多种，一个产品要做到支持所有的格式是很难的。所以，如果要准确的描述，应该写清楚类似“支持视频格式为MPEG4或H.264/AVC，音频为AMR或AAC的*.mp4文件”。其实更严格一些，还应该写清楚MPEG4支持到哪种profile, AMR是NB还是WB，AAC是LC还是HE等更多细节。当然，这种误导型的说明应该在减少，不过如果有比较确切的格式需求，最好还是先搞清楚这些细节。看到网上还有人说到N73，其实只支持视频为MPEG4 Simple Profile / Advanced Simple Profile及H.263 Profile 0 &amp; 3，音频为AMR-NB/WB或者AAC-LC, HE-AAC的mp4文件。如果你放一个视频格式为H.264/AVC的mp4上去，是无法播放出画面来的。</p>
<p>在网上找了一些工具，如MP4UI,MP4BOX,Yamb(mp4box的GUI程序),采用它们进行extract操作后发现，原来的SBR和PS等信息咋没有了，都变成LC规格的AAC文件啦。好容易准备的测试流，难道还是不能用？于是一番苦寻发现，可能是SBR和PS等信息在ADTS头中是无法体现的，所以分析ADTS格式头的AAC，就无法判别是否是HE和HEv2啦。但是我总觉得SBR和PS等技术信息在AAC流中应该还是存在的。因为我还在一个国外的论坛上看到这么几句话：There’s no requirement for MP4 with AAC to have SBR indicated in the headers. It’s still correct not to have it marked and have SBR or PS data in the stream anyway. Likewise, decoding a frame and not seeing any SBR or PS info doesn’t mean you can’t find it further up in the stream anyway（我理解就是说SBR OR PS信息不一定在Header中有，但是并不意味着你不能进一步在stream中发现它）。</p>
<p><strong>HE-AAC的.mp4码流，经过extract出AAC(ADTS)后，44.1KHZ的变成了22.05KHZ。HEv2-AAC的.mp4码流，经过extract出AAC(ADTS)后，不但44.1KHZ的变成了22.05KHZ(一半)，连2channels也变成了1channels</strong>，这个问题更奇怪了，在论坛上找，发现也有人有此问题：“I get 22050Hz, 1 channel for audio that is in fact 44100Hz, 2channels and having both SBR and PS”。</p>
<p>后来看到MSDN中的AAC Decoder的描述中有这么一小段话：
The media type gives the sample rate and number of channels prior to the application of spectral band replication (SBR) and parametric stereo (PS) tools, if present. The effect of the SBR tool is to double the decoded sample rate relative to the core AAC-LC sample rate. The effect of the PS tool is to decode stereo from a mono-channel core AAC-LC stream.
我的理解是AAC的decoder如果支持SBR和PS，会将AAC-HEV1(SBR)中的sample rate提高一倍，而会将AAC-HEV2(SBR+PS)中不仅sample rate提高一倍，单声道也提高至双声道了。结合前面提到的SBR(频段复制)和PS(参数立体声）技术的简单介绍，好像觉得这样是有点儿道理的哦~~
用IPP example提供的解码工具simple_player简单试了下，对于44.1khz，stereo的HEv2-AAC的.mp4码流，经过extract出22.05KHZ，mono 的AAC(ADTS)后，再使用simple_player进行音频解码测试，解完后，果然发现又恢复了44.1khz和stereo。（但目前也测试了好几种extract出的HE和HEv2的aac码流，有的能将sample rate和channel 又double回来，有的又不能，这个具体原因是不是由于Ipp example提供的解码器的问题还不确定）。</p>
<p>另外，用simple_player如果直接decoder编码出的经过封装的.mp4格式的AAC音频的话，发现：其它都正常，只AAC-HEv2格式的.mp4音频解码后变成了单声道。难道是解码器中的PS tools没能发挥作用？初步估计应该是IPP 的那个小解码器的问题吧。</p>
<h5 id="关于ADTS-amp-ADIF"><a href="#关于ADTS-amp-ADIF" class="headerlink" title="关于ADTS&amp;ADIF"></a>关于ADTS&amp;ADIF</h5><p>上面说到了ADTS头格式的AAC。其实，AAC的音频文件格式有以下两种：</p>
<ul>
<li><strong>ADIF</strong>：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。</li>
<li><strong>ADTS</strong>：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。
简单说，ADTS可以在任意帧解码，也就是说它每一帧都有头信息。ADIF只有一个统一的头，所以必须得到所有的数据后解码。且这两种的header的格式也是不同的，具体的组织结构在这里就不详说了。</li>
</ul>
<blockquote>
<p>参考:
<a href="http://blog.csdn.net/axdc_qa_team/article/details/4271043" target="_blank" rel="external">AAC的各种规格</a></p>
</blockquote>
<h4 id="问题原因分析"><a href="#问题原因分析" class="headerlink" title="问题原因分析"></a>问题原因分析</h4><p>首先<code>BufferOverFlowException</code>问题,由于音频采用AAC-HE导致MediaExtractor解析出的音频采样率为本身采样率的一半,同时创建出的解码OutputBuffer的大小是编码InputBuffer的2倍,而media-for-mobile开源项目直接将从解码器OutputBuffer取出的数据塞入编码器InputBuffer中,2倍的数据放入一倍的Buffer导致溢出,暂时的解决办法手动指定编码器InputBuffer max-size为一个较大值(10*1024).同时,由于MediaExtractor不能获取正确的audio profile,也无法确认获取到的采样率是否不正确采样率的一半,所以采用ffmpeg接口获取profile,但是ffmpeg调用<code>avcodec_open2</code>获取到的profile为-99,而且采样率依然为正常采样率一半,只有在解码一帧音频后才能得到正确的profile与采样率.</p>
<p>其次,转码进度不增加的问题,主要是High的H264视频,media-for-mobile使用一个MediaExtractor一次抽取音视频帧,如果是音频则交音频解码器,如果为视频则交视频解码器,解码后将解码帧转交编码器,编码后将数据写入MediaMuxer,将数据写入MediaMuxer的前提是吊用过addTrack,将音视频track加入到Muxer中,而addTrack需要在音视频解码若干帧后产生<code>INFO_OUTPUT_FORMAT_CHANGED</code>,若没有addTrack会导致编码后数据如法写入Muxer,卡死编码器,Baseline视频只需要少量帧就可以产生<code>INFO_OUTPUT_FORMAT_CHANGED</code>,但High视频产生<code>INFO_OUTPUT_FORMAT_CHANGED</code>需要更多的帧,而media-for-mobile中,MediaExtractor首先一直获取到的是音频数据,音频一直解码编码,但是输出的muxer时,videotrack未被添加,所以无法将音频编码器的数据写入muxer,音频解码器被卡死,而mediasource一直被产生的audio数据无法被消费,无法获取到视频数据导致视频<code>INFO_OUTPUT_FORMAT_CHANGED</code>一直无法产生,最终产生死锁,导致audio等待video的<code>INFO_OUTPUT_FORMAT_CHANGED</code>,video等待audio被读完后读到video解码产生<code>INFO_OUTPUT_FORMAT_CHANGED</code>.</p>
<p>最后将audio和video使用两个<code>MediaExtractor</code>各读取各自内容.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天发现公司产品 &lt;strong&gt;触发&lt;/strong&gt; 有导入从微信等下载的外部小视频时失败的情况, &lt;strong&gt;触发&lt;/strong&gt; 导入视频时使用开源库&lt;a href=&quot;https://github.com/INDExOS/media-for-mobile&quot; 
    
    </summary>
    
      <category term="media" scheme="http://wodekouwei.com/categories/media/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://wodekouwei.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>android自动化测试(一):UiAutomator官方介绍</title>
    <link href="http://wodekouwei.com/2017/08/30/at-android-start/"/>
    <id>http://wodekouwei.com/2017/08/30/at-android-start/</id>
    <published>2017-08-30T13:43:15.000Z</published>
    <updated>2017-09-29T04:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>了解android测试需要查询android官方文档,android官方培训教程<a href="https://developer.android.com/training/testing/start/index.html" target="_blank" rel="external">Getting Started with Testing</a>介绍了android提供的测试类型,测试接口等,相较与网上总结的android自动化测试框架,官方文档显然分类更合理,定位更准确.</p>
<h3 id="两种测试类型"><a href="#两种测试类型" class="headerlink" title="两种测试类型"></a>两种测试类型</h3><p>在使用Android Studio创建模块时会在<code>src</code>下生成<code>androidTest</code>和<code>test</code>两个用于测试的的目录,对应下面两种测试类型.
<img src="http://images.wodekouwei.com/technology/at_sum.png" alt="image"></p>
<h4 id="本地单元测试-Local-unit-tests"><a href="#本地单元测试-Local-unit-tests" class="headerlink" title="本地单元测试(Local unit tests)"></a>本地单元测试(Local unit tests)</h4><p>位于<code>module-name/src/test/java/.</code>下,运行在PC端本地的JVM虚拟机上,并且不能访问Android框架的接口.
参考<a href="https://developer.android.com/training/testing/unit-testing/local-unit-tests.html" target="_blank" rel="external">Building Local Tests</a></p>
<h4 id="设备化测试"><a href="#设备化测试" class="headerlink" title="设备化测试"></a>设备化测试</h4><p>位于<code>module-name/src/androidTest/java/.</code>下,必须运行在Android物理设备和虚拟机上.
参考<a href="https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html" target="_blank" rel="external">Building Instrumented Unit Tests</a></p>
<p>Instrumented unit tests are tests that run on physical devices and emulators, and they can take advantage of the Android framework APIs and supporting APIs, such as the Android Testing Support Library. You should create instrumented unit tests if your tests need access to instrumentation information (such as the target app’s Context) or if they require the real implementation of an Android framework component (such as a Parcelable or SharedPreferences object).</p>
<p>Using instrumented unit tests also helps to reduce the effort required to write and maintain mock code. You are still free to use a mocking framework, if you choose, to simulate any dependency relationships.</p>
<p>设备化单元测试分为:</p>
<ul>
<li>设备化单元测试(Instrumented Unit Test):<a href="https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html" target="_blank" rel="external">Building Instrumented Unit Tests</a>: Build complex unit tests with Android dependencies that cannot be satisfied with mock objects.</li>
<li>组件集成测试:<a href="https://developer.android.com/training/testing/ui-testing/index.html" target="_blank" rel="external">Automating User Interface Tests</a>: Create tests to verify that the user interface behaves correctly for user interactions within a single app or for interactions across multiple apps.</li>
<li>app集成测试:<a href="https://developer.android.com/training/testing/integration-testing/index.html" target="_blank" rel="external">Testing App Component Integrations</a>: Verify the behavior of components that users do not directly interact with, such as a Service or aContent Provider.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解android测试需要查询android官方文档,android官方培训教程&lt;a href=&quot;https://developer.android.com/training/testing/start/index.html&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>android自动化测试(N):UiAutomator官方介绍</title>
    <link href="http://wodekouwei.com/2017/08/30/at-android-uiautomator-official/"/>
    <id>http://wodekouwei.com/2017/08/30/at-android-uiautomator-official/</id>
    <published>2017-08-30T07:58:35.000Z</published>
    <updated>2017-08-30T13:43:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Automating-User-Interface-Tests"><a href="#Automating-User-Interface-Tests" class="headerlink" title="Automating User Interface Tests"></a><a href="https://developer.android.com/training/testing/ui-testing/index.html" target="_blank" rel="external">Automating User Interface Tests</a></h3><p>User interface (UI) testing lets you ensure that your app meets its functional requirements and achieves a high standard of quality such that it is more likely to be successfully adopted by users.</p>
<p>One approach to UI testing is to simply have a human tester perform a set of user operations on the target app and verify that it is behaving correctly. However, this manual approach can be time-consuming, tedious, and error-prone. A more efficient approach is to write your UI tests such that user actions are performed in an automated way. The automated approach allows you to run your tests quickly and reliably in a repeatable manner.</p>
<blockquote>
<p>Note: It is strongly encouraged that you use Android Studio for building your test apps, because it provides project setup, library inclusion, and packaging conveniences. This class assumes you are using Android Studio.</p>
</blockquote>
<p>To automate UI tests with Android Studio, you implement your test code in a separate Android test folder (src/androidTest/java). The Android Plug-in for Gradle builds a test app based on your test code, then loads the test app on the same device as the target app. In your test code, you can use UI testing frameworks to simulate user interactions on the target app, in order to perform testing tasks that cover specific usage scenarios.</p>
<p>For testing Android apps, you typically create these types of automated UI tests:</p>
<ul>
<li>UI tests that span a single app: This type of test verifies that the target app behaves as expected when a user performs a specific action or enters a specific input in its activities. It allows you to check that the target app returns the correct UI output in response to user interactions in the app’s activities. UI testing frameworks like Espresso allow you to programmatically simulate user actions and test complex intra-app user interactions.</li>
<li>UI tests that span multiple apps: This type of test verifies the correct behavior of interactions between different user apps or between user apps and system apps. For example, you might want to test that your camera app shares images correctly with a 3rd-party social media app, or with the default Android Photos app. UI testing frameworks that support cross-app interactions, such as UI Automator, allow you to create tests for such scenarios.
The lessons in this class teach you how to use the tools and APIs in the Android Testing Support Library to build these types of automated tests. Before you begin building tests using these APIs, you must install the Android Testing Support Library, as described in Downloading the Android Testing Support Library.</li>
</ul>
<h3 id="UI-Testing"><a href="#UI-Testing" class="headerlink" title="UI Testing"></a><a href="https://stuff.mit.edu/afs/sipb/project/android/docs/tools/testing/testing_ui.html" target="_blank" rel="external">UI Testing</a></h3><p>In addition to unit testing the individual components that make up your Android application (such as activities, services, and content providers), it is also important that you test the behavior of your application’s user interface (UI) when it is running on a device. UI testing ensures that your application returns the correct UI output in response to a sequence of user actions on a device, such as entering keyboard input or pressing toolbars, menus, dialogs, images, and other UI controls.</p>
<p>Functional or black-box UI testing does not require testers to know the internal implementation details of the app, only its expected output when a user performs a specific action or enters a specific input. This approach allows for better separation of development and testing roles in your organization.</p>
<p>One common approach to UI testing is to run tests manually and verify that the app is behaving as expected. However, this approach can be time-consuming, tedious, and error-prone. A more efficient and reliable approach is to automate the UI testing with a software testing framework. Automated testing involves creating programs to perform testing tasks (test cases) to cover specific usage scenarios, and then using the testing framework to run the test cases automatically and in a repeatable manner.</p>
<h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>he Android SDK provides the following tools to support automated, functional UI testing on your application:</p>
<ul>
<li>uiautomatorviewer - A GUI tool to scan and analyze the UI components of an Android application.</li>
<li><p>uiautomator - A Java library containing APIs to create customized functional UI tests, and an execution engine to automate and run the tests.
To use these tools, you must have the following versions of the Android development tools installed:</p>
</li>
<li><p>Android SDK Tools, Revision 21 or higher</p>
</li>
<li>Android SDK Platform, API 16 or higher</li>
</ul>
<p><strong>Workflow for the the uiautomator testing framework</strong>
Here’s a short overview of the steps required to automate UI testing:</p>
<ol>
<li>Prepare to test by installing the app on a test device, analyzing the app’s UI components, and ensuring that your application is accessible by the test automation framework.</li>
<li>Create automated tests to simulate specific user interactions on your application.</li>
<li>Compile your test cases into a JAR file and install it on your test device along with your app.</li>
<li>Run the tests and view the test results.</li>
<li>Correct any bugs or defects discovered in testing.</li>
</ol>
<h4 id="Analyzing-Your-Application’s-UI"><a href="#Analyzing-Your-Application’s-UI" class="headerlink" title="Analyzing Your Application’s UI"></a>Analyzing Your Application’s UI</h4><p>Before you start writing your test cases, it’s helpful to familiarize yourself with the UI components (including the views and controls) of the targeted application. You can use the uiautomatorviewer tool to take a snapshot of the foreground UI screen on any Android device that is connected to your development machine. The uiautomatorviewer tool provides a convenient visual interface to inspect the layout hierarchy and view the properties of the individual UI components that are displayed on the test device. Using this information, you can later create uiautomator tests with selector objects that target specific UI components to test.</p>
<p>To analyze the UI components of the application that you want to test:</p>
<ol>
<li>Connect your Android device to your development machine.</li>
<li>Open a terminal window and navigate to <android-sdk>/tools/.</android-sdk></li>
<li><p>Run the tool with this command:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ uiautomatorviewer</div></pre></td></tr></table></figure>
</li>
<li><p>To capture a screen for analysis, click the Device Screenshot button in the GUI of the uiautomatorviewer tool.</p>
<blockquote>
<p>Note: If you have more than one device connected, specify the device for screen capture by setting the ANDROID_SERIAL environment variable:</p>
</blockquote>
</li>
</ol>
<p>a. Find the serial numbers for your connected devices by running this command:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ adb devices</div><div class="line">```  </div><div class="line">b. Set the ANDROID_SERIAL environment variable to select the device to test:</div></pre></td></tr></table></figure></p>
<p>#In Windows:
set ANDROID_SERIAL=<device serial="" number=""></device></p>
<p>#In UNIX:
export ANDROID_SERIAL=<device serial="" number="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">If you are connected to only a single device, you do not need to set the ANDROID_SERIAL environment variable.</div><div class="line"></div><div class="line">5. View the UI properties for your application:</div><div class="line">- Hover over the snapshot in the left-hand panel to see the UI components identified by the uiautomatorviewer tool. You can view the component’s properties listed in the lower right-hand panel, and the layout hierarchy in the upper right-hand panel.</div><div class="line">- Optionally, click on the Toggle NAF Nodes button to see UI components that are not accessible to the uiautomator testing framework. Only limited information may be available for these components.</div><div class="line"></div><div class="line">#### Preparing to Test</div><div class="line">Before using the uiautomator testing framework, complete these pre-flight tasks:</div><div class="line"></div><div class="line">##### Load the application to a device</div><div class="line"></div><div class="line">If you are reading this document, chances are that the Android application that you want to test has not been published yet. If you have a copy of the APK file, you can install the APK onto a test device by using the adb tool. To learn how to install an APK file using the adb tool, see the [adb](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/adb.html#move) documentation.</div><div class="line"></div><div class="line">##### Identify the application’s UI components</div><div class="line"></div><div class="line">Before writing your `uiautomator` tests, first identify the UI components in the application that you want to test. Typically, good candidates for testing are UI components that are visible and that users can interact with. The UI components should also have visible text labels, `android:contentDescription` values, or both.</div><div class="line"></div><div class="line">You can inspect the visible screen objects in an application conveniently by using the `uiautomatorviewer` tool. For more information about how to analyze an application screen with this tool, see the section [Analyzing Your Application’s UI](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/testing/testing_ui.html#uianalaysis). For more information about the common types of UI components provided by Android, see [User Interface](https://stuff.mit.edu/afs/sipb/project/android/docs/guide/topics/ui/index.html).</div><div class="line"></div><div class="line">##### Ensure that the application is accessible</div><div class="line"></div><div class="line">This step is required because the `uiautomator` tool depends on the accessibility features of the Android framework to execute your functional UI tests. You should include these minimum optimizations to support the `uiautomator` tool:</div><div class="line">- Use the `android:contentDescription` attribute to label the `ImageButton`, `ImageView`, `CheckBox` and other user interface controls.</div><div class="line">- Provide an `android:hint` attribute instead of a content description for `EditText` fields</div><div class="line">- Associate an `android:hint` attribute with any graphical icons used by controls that provide feedback to the user (for example, status or state information).</div><div class="line">- Make sure that all the user interface elements are accessible with a directional controller, such as a trackball or D-pad.</div><div class="line">- Use the `uiautomatorviewer` tool to ensure that the UI component is accessible to the testing framework. You can also test the application by turning on accessibility services like TalkBack and Explore by Touch, and try using your application using only directional controls.</div><div class="line"></div><div class="line">For more information about implementing and testing accessibility, see [Making Applications Accessible](https://stuff.mit.edu/afs/sipb/project/android/docs/guide/topics/ui/accessibility/apps.html).</div><div class="line"></div><div class="line">&gt; Note: To identify the non-accessible components in the UI, click on the Toggle NAF Nodes option in the `uiautomatorviewer` tool.</div><div class="line"></div><div class="line">Generally, Android application developers get accessibility support for free, courtesy of the `View` and `ViewGroup` classes. However, some applications use custom view components to provide a richer user experience. Such custom components won&apos;t get the accessibility support that is provided by the standard Android UI components. If this applies to your application, ensure that the application developer exposes the custom drawn UI components to Android accessibility services, by implementing the `AccessibilityNodeProvider` class. For more information about making custom view components accessible, see [Making Applications Accessible](https://stuff.mit.edu/afs/sipb/project/android/docs/guide/topics/ui/accessibility/apps.html#custom-views).</div><div class="line"></div><div class="line">##### Configure your development environment</div><div class="line">If you&apos;re developing in Eclipse, the Android SDK provides additional tools that help you write test cases using `uiautomator` and buiild your JAR file. In order to set up Eclipse to assist you, you need to create a project that includes the `uiautomator` client library, along with the Android SDK library. To configure Eclipse:</div><div class="line"></div><div class="line">1. Create a new Java project in Eclipse, and give your project a name that is relevant to the tests you’re about to create (for example, &quot;MyAppNameTests&quot;). In the project, you will create the test cases that are specific to the application that you want to test.</div><div class="line">2. From the Project Explorer, right-click on the new project that you created, then select Properties &gt; Java Build Path, and do the following:</div><div class="line">    - Click Add Library &gt; JUnit then select JUnit3 to add JUnit support.</div><div class="line">    - Click Add External JARs... and navigate to the SDK directory. Under the platforms directory, select the latest SDK version and add both the uiautomator.jar and android.jar files.</div><div class="line">If you did not configure Eclipse as your development environment, make sure that the `uiautomator.jar` and `android.jar` files from the `&lt;android-sdk&gt;/platforms/&lt;sdk&gt;` directory are in your Java class path.</div><div class="line"></div><div class="line">Once you have completed these prerequisite tasks, you&apos;re almost ready to start creating your `uiautomator` tests.</div><div class="line"></div><div class="line">#### Creating uiautomator Tests</div><div class="line">To build a test that runs in the `uiautomator` framework, create a test case that extends the `UiAutomatorTestCase` class. In Eclipse, the test case file goes under the `src` directory in your project. Later, you will build the test case as a JAR file, then copy this file to the test device. The test JAR file is not an APK file and resides separately from the application that you want to test on the device.</div><div class="line"></div><div class="line">Because the `UiAutomatorTestCase` class extends `junit.framework.TestCase`, you can use the `JUnit` Assert class to test that UI components in the app return the expected results. To learn more about JUnit, you can read the documentation on the `junit.org` home page.</div><div class="line"></div><div class="line">The first thing your test case should do is access the device that contains the target app. It’s also good practice to start the test from the Home screen of the device. From the Home screen (or some other starting location you’ve chosen in the target app), you can use the classes provided by the `uiautomator` API to simulate user actions and to test specific UI components. For an example of how to put together a `uiautomator` test case, see the sample test case.</div><div class="line"></div><div class="line">##### uiautomator API</div><div class="line">The `uiautomator` API is bundled in the `uiautomator.jar` file under the `&lt;android-sdk&gt;/platforms/` directory. The API includes these key classes that allow you to capture and manipulate UI components on the target app:</div><div class="line">- [UiDevice](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/UiDevice.html)</div><div class="line">Represents the device state. In your tests, you can call methods on the UiDevice instance to check for the state of various properties, such as current orientation or display size. Your tests also can use the UiDevice instance to perform device level actions, such as forcing the device into a specific rotation, pressing the d-pad hardware button, or pressing the Home and Menu buttons.</div><div class="line">To get an instance of UiDevice and simulate a Home button press:</div></pre></td></tr></table></figure></device></p>
<p>getUiDevice().pressHome();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- [UiSelector](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/UiSelector.html)</div><div class="line">Represents a search criteria to query and get a handle on specific elements in the currently displayed UI. If more than one matching element is found, the first matching element in the layout hierarchy is returned as the target UiObject. When constructing a UiSelector, you can chain together multiple properties to refine your search. If no matching UI element is found, a `UiAutomatorObjectNotFoundException` is thrown. You can use the childSelector() method to nest multiple UiSelector instances. For example, the following code example shows how to specify a search to find the first ListView in the currently displayed UI, then search within that ListView to find a UI element with the text property Apps.</div></pre></td></tr></table></figure></p>
<p>UiObject appItem = new UiObject(new UiSelector()
   .className(“android.widget.ListView”).instance(1)
   .childSelector(new UiSelector().text(“Apps”)));
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- [UiObject](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/UiObject.html)</div><div class="line">Represents a UI element. To create a UiObject instance, use a UiSelector that describes how to search for, or select, the UI element.</div><div class="line">The following code example shows how to construct UiObject instances that represent a Cancel button and a OK button in your application.</div></pre></td></tr></table></figure></p>
<p>UiObject cancelButton = new UiObject(new UiSelector().text(“Cancel”));
UiObject okButton = new UiObject(new UiSelector().text(“OK”));
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You can reuse the UiObject instances that you have created in other parts of your app testing, as needed. Note that the `uiautomator` test framework searches the current display for a match every time your test uses a UiObject instance to click on a UI element or query a property.</div><div class="line">In the following code example, the `uiautomator` test framework searches for a UI element with the text property OK. If a match is found and if the element is enabled, the framework simulates a user click action on the element.</div></pre></td></tr></table></figure></p>
<p>if(okButton.exists() &amp;&amp; okButton.isEnabled())
{
  okButton.click();
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">You can also restrict the search to find only elements of a specific class. For example, to find matches of the Button class:</div></pre></td></tr></table></figure></p>
<p>UiObject cancelButton = new UiObject(new UiSelector().text(“Cancel”)
   .className(“android.widget.Button”));
UiObject okButton = new UiObject(new UiSelector().text(“OK”)
   .className(“android.widget.Button”));
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- [UiCollection](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/UiCollection.html)</div><div class="line">Represents a collection of items, for example songs in a music album or a list of emails in an inbox. Similar to a UiObject, you construct a UiCollection instance by specifying a UiSelector. The UiSelector for a UiCollection should search for a UI element that is a container or wrapper of other child UI elements (such as a layout view that contains child UI elements). For example, the following code snippet shows how to construct a UiCollection to represent a video album that is displayed within a FrameLayout:</div></pre></td></tr></table></figure></p>
<p>UiCollection videos = new UiCollection(new UiSelector()
   .className(“android.widget.FrameLayout”));
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If the videos are listed within a LinearLayout view, and you want to to retrieve the number of videos in this collection:</div></pre></td></tr></table></figure></p>
<p>int count = videos.getChildCount(new UiSelector()
   .className(“android.widget.LinearLayout”));
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If you want to find a specific video that is labeled with the text element Cute Baby Laughing from the collection and simulate a user-click on the video:</div></pre></td></tr></table></figure></p>
<p>UiObject video = videos.getChildByText(new UiSelector()
   .className(“android.widget.LinearLayout”), “Cute Baby Laughing”);
video.click();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Similarly, you can simulate other user actions on the UI object. For example, if you want to simulate selecting a checkbox that is associated with the video:</div></pre></td></tr></table></figure></p>
<p>UiObject checkBox = video.getChild(new UiSelector()
   .className(“android.widget.Checkbox”));
if(!checkBox.isSelected()) checkbox.click();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- [UiScrollable](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/UiScrollable.html)</div><div class="line">Represents a scrollable collection of UI elements. You can use the UiScrollable class to simulate vertical or horizontal scrolling across a display. This technique is helpful when a UI element is positioned off-screen and you need to scroll to bring it into view.</div><div class="line">For example, the following code shows how to simulate scrolling down the Settings menu and clicking on an About tablet option:</div></pre></td></tr></table></figure></p>
<p>UiScrollable settingsItem = new UiScrollable(new UiSelector()
   .className(“android.widget.ListView”));
UiObject about = settingsItem.getChildByText(new UiSelector()
   .className(“android.widget.LinearLayout”), “About  tablet”);
about.click()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For more information about these APIs, see the uiautomator reference.</div><div class="line"></div><div class="line">##### A sample uiautomator test case</div><div class="line">The following code example shows a simple test case which simulates a user bringing up the Settings app in a stock Android device. The test case mimics all the steps that a user would typically take to perform this task, including opening the Home screen, launching the All Apps screen, scrolling to the Settings app icon, and clicking on the icon to enter the Settings app.</div></pre></td></tr></table></figure></p>
<p>package com.uia.example.my;</p>
<p>// Import the uiautomator libraries
import com.android.uiautomator.core.UiObject;
import com.android.uiautomator.core.UiObjectNotFoundException;
import com.android.uiautomator.core.UiScrollable;
import com.android.uiautomator.core.UiSelector;
import com.android.uiautomator.testrunner.UiAutomatorTestCase;</p>
<p>public class LaunchSettings extends UiAutomatorTestCase {   </p>
<p>   public void testDemo() throws UiObjectNotFoundException {   </p>
<pre><code>// Simulate a short press on the HOME button.
getUiDevice().pressHome();

// We’re now in the home screen. Next, we want to simulate
// a user bringing up the All Apps screen.
// If you use the uiautomatorviewer tool to capture a snapshot
// of the Home screen, notice that the All Apps button’s
// content-description property has the value “Apps”.  We can
// use this property to create a UiSelector to find the button.
UiObject allAppsButton = new UiObject(new UiSelector()
   .description(&quot;Apps&quot;));

// Simulate a click to bring up the All Apps screen.
allAppsButton.clickAndWaitForNewWindow();

// In the All Apps screen, the Settings app is located in
// the Apps tab. To simulate the user bringing up the Apps tab,
// we create a UiSelector to find a tab with the text
// label “Apps”.
UiObject appsTab = new UiObject(new UiSelector()
   .text(&quot;Apps&quot;));

// Simulate a click to enter the Apps tab.
appsTab.click();

// Next, in the apps tabs, we can simulate a user swiping until
// they come to the Settings app icon.  Since the container view
// is scrollable, we can use a UiScrollable object.
UiScrollable appViews = new UiScrollable(new UiSelector()
   .scrollable(true));

// Set the swiping mode to horizontal (the default is vertical)
appViews.setAsHorizontalList();

// Create a UiSelector to find the Settings app and simulate      
// a user click to launch the app.
UiObject settingsApp = appViews.getChildByText(new UiSelector()
   .className(android.widget.TextView.class.getName()),
   &quot;Settings&quot;);
settingsApp.clickAndWaitForNewWindow();

// Validate that the package name is the expected one
UiObject settingsValidation = new UiObject(new UiSelector()
   .packageName(&quot;com.android.settings&quot;));
assertTrue(&quot;Unable to detect Settings&quot;,
   settingsValidation.exists());   
</code></pre><p>  }<br>}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Building and Deploying Your uiautomator Tests</div><div class="line">1. Once you have coded your test, follow these steps to build and deploy your test JAR to your target Android test device:</div><div class="line">Create the required build configuration files to build the output JAR. To generate the build configuration files, open a terminal and run the following command:</div></pre></td></tr></table></figure></p>
<p><android-sdk>/tools/android create uitest-project -n <name> -t 1 -p <path></path>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The &lt;name&gt; is the name of the project that contains your uiautomator test source files, and the &lt;path&gt; is the path to the corresponding project directory.</div><div class="line">2. From the command line, set the ANDROID_HOME variable:</div><div class="line">- In Windows:`set ANDROID_HOME=&lt;path_to_your_sdk&gt;`</div><div class="line">- In UNIX:`export ANDROID_HOME=&lt;path_to_your_sdk&gt;`</div><div class="line">3. Go to the project directory where your build.xml file is located and build your test JAR.</div></pre></td></tr></table></figure></name></android-sdk></p>
<p>ant build
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4. Deploy your generated test JAR file to the test device by using the adb push command:</div></pre></td></tr></table></figure></p>
<p>adb push <path_to_output_jar> /data/local/tmp/
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Here’s an example:</div></pre></td></tr></table></figure></path_to_output_jar></p>
<p>adb push ~/dev/workspace/LaunchSettings/bin/LaunchSettings.jar /data/local/tmp/
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Running uiautomator Tests</div><div class="line">Here’s an example of how to run a test that is implemented in the `LaunchSettings.jar` file. The tests are bundled in the `com.uia.example.my` package:</div></pre></td></tr></table></figure></p>
<p>adb shell uiautomator runtest LaunchSettings.jar -c com.uia.example.my.LaunchSettings
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">To learn more about the syntax, subcommands, and options for uiautomator, see the [uiautomator](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/index.html) reference.</div><div class="line"></div><div class="line">#### Best Practices</div><div class="line">Here are some best practices for functional UI testing with the uiautomator framework:</div><div class="line"></div><div class="line">- Ensure that you validate the same UI functions on your application across the various types of devices that your application might run on (for example, devices with different screen densities).</div><div class="line">- You should also test your UI against common scenarios such as in-coming phone calls, network interruptions, and user-initiated switching to other applications on the device.</div><div class="line"></div><div class="line">### [uiautomator tools](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/index.html)</div><div class="line">The uiautomator testing framework lets you test your user interface (UI) efficiently by creating automated functional UI testcases that can be run against your app on one or more devices.</div><div class="line"></div><div class="line">For more information on testing with the uiautomator framework, see [UI Testing](https://stuff.mit.edu/afs/sipb/project/android/docs/tools/testing/testing_ui.html).</div><div class="line"></div><div class="line">#### Syntax</div><div class="line">To run your testcases on the target device, you can use the `adb shell` command to invoke the `uiautomator` tool. The syntax is:</div></pre></td></tr></table></figure></p>
<p>adb shell uiautomator runtest <jar> -c <test_class_or_method> [options]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Here’s an example:</div></pre></td></tr></table></figure></test_class_or_method></jar></p>
<p>adb shell uiautomator runtest LaunchSettings.jar -c com.uia.example.my.LaunchSettings
```</p>
<h4 id="Command-line-Options"><a href="#Command-line-Options" class="headerlink" title="Command-line Options"></a>Command-line Options</h4><p>The following table describes the subcommands and options for uiautomator.
Table 1. Command-line options for uiautomator</p>
<table>
<thead>
<tr>
<th>Subcommand</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>runtest</td>
<td><code>&lt;jar&gt;</code></td>
<td>Required. The <jar> argument is the name of one or more JAR files that you deployed to the target device which contain your uiautomator testcases. You can list more than one JAR file by using a space as a separator.</jar></td>
</tr>
<tr>
<td></td>
<td><code>-c &lt;test_class_or_method&gt;</code></td>
<td>Required. The <test_class_or_method> argument is a list of one or more specific test classes or test methods from the JARs that you want uiautomator to run.Each class or method must be fully qualified with the package name, in one of these formats: package_name.class_name package_name.class_name#method_name You can list multiple classes or methods by using a space as a separator.</test_class_or_method></td>
</tr>
<tr>
<td></td>
<td>–nohup</td>
<td>Runs the test to completion on the device even if its parent process is terminated (for example, if the device is disconnected).</td>
</tr>
<tr>
<td></td>
<td>-e</td>
<td><name> <value></value></name></td>
<td>Specify other name-value pairs to be passed to test classes. May be repeated.Note: The -e options cannot be combined; you must prefix each option with a separate -e flag.</td>
</tr>
<tr>
<td></td>
<td>-e debug [true</td>
<td>false]</td>
<td>Wait for debugger to connect before starting.</td>
</tr>
<tr>
<td></td>
<td>dump    [file]</td>
<td>Generate an XML file with a dump of the current UI hierarchy. If a filepath is not specified, by default, the generated dump file is stored on the device in this location <code>/storage/sdcard0/window_dump.xml</code>.</td>
</tr>
<tr>
<td>events</td>
<td></td>
<td>Prints out accessibility events to the console until the connection to the device is terminated</td>
</tr>
</tbody>
</table>
<h3 id="UiAutomation-api"><a href="#UiAutomation-api" class="headerlink" title="UiAutomation api"></a><a href="https://developer.android.com/reference/android/app/UiAutomation.html" target="_blank" rel="external">UiAutomation api</a></h3><p>Class for interacting with the device’s UI by simulation user actions and introspection of the screen content. It relies on the platform accessibility APIs to introspect the screen and to perform some actions on the remote view tree. It also allows injecting of arbitrary raw input events simulating user interaction with keyboards and touch devices. One can think of a UiAutomation as a special type of AccessibilityService which does not provide hooks for the service life cycle and exposes other APIs that are useful for UI test automation.
这是一个通过模拟用户操作来与设备用户界面交互以及获取屏幕内容的类。它依赖于平台的辅助功能APIs来在远程的控件树上获取屏幕内容以及执行一些操作。同时它也允许通过注入原生事件(译者注:指的就是InputEvent. KeyEvent也是继承于InputEvent的，所以说它是原生事件)来模拟用户的按键和触屏操作。我们可以认为UiAutomation就是一个特殊类型的AccessibilityService,其既不会为控制服务的生命周期而提供钩子函数，也不会暴露任何其他可以直接用于用户界面测试自动化的APIs.</p>
<p>The APIs exposed by this class are low-level to maximize flexibility when developing UI test automation tools and libraries. Generally, a UiAutomation client should be using a higher-level library or implement high-level functions. For example, performing a tap on the screen requires construction and injecting of a touch down and up events which have to be delivered to the system by a call to injectInputEvent(InputEvent, boolean).
这个类暴露出来的APIs是很低层的，目的就是为了在开发用户界面测试自动化框架和库时提供最大的弹性。总的来说，一个UiAutomation客户端应该使用一些（基于UiAutomation的)更高层次的库或者实现更高层次的方法。比如，模拟一个用户在屏幕上的点击事件需要构造并注入一个按下和一个弹起事件，然后必须调用UiAutomation的一个injectInputEvent(InputEvent, boolean)的调用来发送给操作系统。</p>
<p>The APIs exposed by this class operate across applications enabling a client to write tests that cover use cases spanning over multiple applications. For example, going to the settings application to change a setting and then interacting with another application whose behavior depends on that setting.
这个类暴露出来的APIs可以跨应用，这样用户就可以编写可以跨越多个应用的测试用例脚本了。比如，打开系统的设置应用去修改一些设置然后再与另外一个依赖于该设置的应用进行交互（译者注：这个在instrumentation这个框架可以做不到的）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Automating-User-Interface-Tests&quot;&gt;&lt;a href=&quot;#Automating-User-Interface-Tests&quot; class=&quot;headerlink&quot; title=&quot;Automating User Interface Test
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>android自动化测试之(N):测试支持库</title>
    <link href="http://wodekouwei.com/2017/08/30/at-android-support-library/"/>
    <id>http://wodekouwei.com/2017/08/30/at-android-support-library/</id>
    <published>2017-08-30T02:14:05.000Z</published>
    <updated>2017-08-30T02:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://developer.android.com/topic/libraries/testing-support-library/index.html#setup" target="_blank" rel="external">Android官方文档-测试支持库</a></p>
</blockquote>
<p>Android 测试支持库提供了大量用于测试 Android 应用的框架。此库提供了一组 API，让您可以为应用快速构建何运行测试代码，包括 JUnit 4 和功能性用户界面 (UI) 测试。您可以从 <a href="https://developer.android.com/tools/studio/index.html" target="_blank" rel="external">Android Studio IDE</a> 或命令行运行使用这些 API 创建的测试。</p>
<p>Android 测试支持库通过 Android SDK 管理器提供。如需了解详细信息，请参阅<a href="https://developer.android.com/topic/libraries/testing-support-library/index.html#setup" target="_blank" rel="external">测试支持库设置</a></p>
<p>本页介绍了 Android 测试支持库提供了哪些工具、如何在测试环境中使用这些工具，以及库版本的相关信息。</p>
<h3 id="测试支持库功能"><a href="#测试支持库功能" class="headerlink" title="测试支持库功能"></a>测试支持库功能</h3><p>Android 测试支持库包括以下自动化测试工具：</p>
<ul>
<li>AndroidJUnitRunner：适用于 Android 且与 JUnit 4 兼容的测试运行器</li>
<li>Espresso：UI 测试框架；适合应用中的功能性 UI 测试</li>
<li>UI Automator：UI 测试框架；适合跨系统和已安装应用的跨应用功能性 UI 测试</li>
</ul>
<h4 id="AndroidJUnitRunner"><a href="#AndroidJUnitRunner" class="headerlink" title="AndroidJUnitRunner"></a>AndroidJUnitRunner</h4><p>AndroidJUnitRunner 类是一个 <a href="http://junit.org/" target="_blank" rel="external">JUnit</a> 测试运行器，可让您在 Android 设备上运行 JUnit 3 或 JUnit 4 样式测试类，包括使用 Espresso 和 UI Automator 测试框架的设备。测试运行器可以将测试软件包和要测试的应用加载到设备、运行测试并报告测试结果。此类将替换 <a href="https://developer.android.com/reference/android/test/InstrumentationTestRunner.html" target="_blank" rel="external">InstrumentationTestRunner</a> 类，后者仅支持 JUnit 3 测试。</p>
<p>此测试运行器的主要功能包括：</p>
<ul>
<li>JUnit 支持</li>
<li>访问仪器信息</li>
<li>测试筛选</li>
<li>测试分片
要求 Android 2.2（API 级别 8）或更高版本。</li>
</ul>
<h5 id="JUnit-支持"><a href="#JUnit-支持" class="headerlink" title="JUnit 支持"></a>JUnit 支持</h5><p>测试运行器与 JUnit 3 和 JUnit 4（最高版本为 JUnit 4.10）测试兼容。不过，请勿在同一软件包中混用 JUnit 3 和 JUnit 4 测试代码，因为这可能会导致意外结果。如果要创建一个 JUnit 4 仪器测试类以在设备或模拟器上运行，则测试类必须以 <code>@RunWith(AndroidJUnit4.class)</code> 注解作为前缀。</p>
<p>以下代码段显示了如何编写 JUnit 4 仪器测试来验证 CalculatorActivity 类中的 add 操作是否正常工作。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import android.support.test.runner.AndroidJUnit4;</div><div class="line">import android.support.test.runner.AndroidJUnitRunner;</div><div class="line">import android.test.ActivityInstrumentationTestCase2;</div><div class="line"></div><div class="line">@RunWith(AndroidJUnit4.class)</div><div class="line">public class CalculatorInstrumentationTest</div><div class="line">        extends ActivityInstrumentationTestCase2&lt;CalculatorActivity&gt; &#123;</div><div class="line"></div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line">        super.setUp();</div><div class="line"></div><div class="line">        // Injecting the Instrumentation instance is required</div><div class="line">        // for your test to run with AndroidJUnitRunner.</div><div class="line">        injectInstrumentation(InstrumentationRegistry.getInstrumentation());</div><div class="line">        mActivity = getActivity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void typeOperandsAndPerformAddOperation() &#123;</div><div class="line">        // Call the CalculatorActivity add() method and pass in some operand values, then</div><div class="line">        // check that the expected value is returned.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        super.tearDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="访问仪器信息"><a href="#访问仪器信息" class="headerlink" title="访问仪器信息"></a>访问仪器信息</h5><p>您可以使用 <a href="https://developer.android.com/reference/android/support/test/InstrumentationRegistry.html" target="_blank" rel="external">InstrumentationRegistry</a> 类访问与测试运行相关的信息。此类包括 <a href="https://developer.android.com/reference/android/app/Instrumentation.html" target="_blank" rel="external">Instrumentation</a> 对象、目标应用 Context 对象、测试应用 Context 对象，以及传递到测试中的命令行参数。使用 UI Automator 框架编写测试或编写依赖于 Instrumentation 或 Context 对象的测试时，此数据非常有用。</p>
<h5 id="测试筛选"><a href="#测试筛选" class="headerlink" title="测试筛选"></a>测试筛选</h5><p>在 JUnit 4.x 测试中，您可以使用注解对测试运行进行配置。此功能可将向测试中添加样板文件和条件代码的需求降至最低。除了 JUnit 4 支持的标准注解外，测试运行器还支持 Android 特定的注解，包括：</p>
<ul>
<li><code>@RequiresDevice</code>：指定测试仅在物理设备而不在模拟器上运行。</li>
<li><code>@SdkSupress</code>：禁止在低于给定级别的 Android API 级别上运行测试。例如，要禁止在低于 18 的所有 API 级别上运行测试，请使用注解 - - @SDKSupress(minSdkVersion=18)。</li>
<li><code>@SmallTest</code>、<code>@MediumTest</code> 和 <code>@LargeTest</code>：指定测试的运行时长以及运行频率。<h5 id="测试分片"><a href="#测试分片" class="headerlink" title="测试分片"></a>测试分片</h5>测试运行器支持将单一测试套件拆分成多个碎片，因此您可以将属于同一碎片的测试作为一个组在同一 Instrumentation 实例下运行。每个分片由一个索引号进行标识。运行测试时，使用 -e numShards 选项指定要创建的独立分片数量，并使用 -e shardIndex 选项指定要运行哪个分片。</li>
</ul>
<p>例如，要将测试套件拆分成 10 个分片，且仅运行第二个碎片中的测试，请使用以下命令：</p>
<p><code>adb shell am instrument -w -e numShards 10 -e shardIndex 2</code>
要详细了解如何使用此测试运行器，请参阅 <a href="https://developer.android.com/reference/android/support/test/package-summary.html" target="_blank" rel="external">API 参考</a>。</p>
<h4 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h4><p>Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。</p>
<p>Espresso 测试框架的主要功能包括：</p>
<ul>
<li>灵活的 API，用于目标应用中的视图和适配器匹配。如需了解详细信息，请参阅视图匹配。</li>
<li>一组丰富的操作 API，用于自动化 UI 交互。如需了解详细信息，请参阅操作 API。</li>
<li>UI 线程同步，用于提升测试可靠性。如需了解详细信息，请参阅 UI 线程同步。
要求 Android 2.2（API 级别 8）或更高版本。</li>
</ul>
<h5 id="视图匹配"><a href="#视图匹配" class="headerlink" title="视图匹配"></a>视图匹配</h5><p>利用 Espresso.onView() 方法，您可以访问目标应用中的 UI 组件并与之交互。此方法接受 Matcher 参数并搜索视图层次结构，以找到符合给定条件的相应 View 实例。您可以通过指定以下条件来优化搜索：</p>
<ul>
<li>视图的类名称</li>
<li>视图的内容描述</li>
<li>视图的 R.id</li>
<li>在视图中显示的文本
例如，要找到 ID 值为 my_button 的按钮，可以指定如下匹配器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onView(withId(R.id.my_button));</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果搜索成功，onView() 方法将返回一个引用，让您可以执行用户操作并基于目标视图对断言进行测试。</p>
<h5 id="适配器匹配"><a href="#适配器匹配" class="headerlink" title="适配器匹配"></a>适配器匹配</h5><p>在 AdapterView 布局中，布局在运行时由子视图动态填充。如果目标视图位于某个布局内部，而该布局是从 AdapterView（例如 ListView 或 GridView）派生出的子类，则 onView() 方法可能无法工作，因为只有布局视图的子集会加载到当前视图层次结构中。</p>
<p>因此，请使用 Espresso.onData() 方法访问目标视图元素。Espresso.onData() 方法将返回一个引用，让您可以执行用户操作并根据 AdapterView 中的元素对断言进行测试。</p>
<h5 id="操作-API"><a href="#操作-API" class="headerlink" title="操作 API"></a>操作 API</h5><p>通常情况下，您可以通过根据应用的用户界面执行某些用户交互来测试应用。借助 ViewActions API，您可以轻松地实现这些操作的自动化。您可以执行多种 UI 交互，例如：</p>
<ul>
<li>视图点击</li>
<li>滑动</li>
<li>按下按键和按钮</li>
<li>键入文本</li>
<li>打开链接
例如，要模拟输入字符串值并按下按钮以提交该值，您可以像下面一样编写自动化测试脚本。ViewInteraction.perform() 和 DataInteraction.perform() 方法采用一个或多个 ViewAction 参数，并以提供的顺序运行操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Type text into an EditText view, then close the soft keyboard</div><div class="line">onView(withId(R.id.editTextUserInput))</div><div class="line">    .perform(typeText(STRING_TO_BE_TYPED), closeSoftKeyboard());</div><div class="line"></div><div class="line">// Press the button to submit the text change</div><div class="line">onView(withId(R.id.changeTextBt)).perform(click());</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="UI-线程同步"><a href="#UI-线程同步" class="headerlink" title="UI 线程同步"></a>UI 线程同步</h5><p>由于计时问题，Android 设备上的测试可能随机失败。此测试问题称为测试不稳定。在 Espresso 之前，解决方法是在测试中插入足够长的休眠或超时期或添加代码，以便重试失败的操作。Espresso 测试框架可以处理 Instrumentation 与 UI 线程之间的同步；这就消除了对之前的计时解决方法的需求，并确保测试操作与断言更可靠地运行。</p>
<p>要详细了解如何使用 Espresso，请参阅 <a href="https://developer.android.com/reference/android/support/test/package-summary.html" target="_blank" rel="external">API 参考</a>和<a href="https://developer.android.com/training/testing/ui-testing/espresso-testing.html" target="_blank" rel="external">测试单个应用的 UI </a>培训。</p>
<h4 id="UI-Automator"><a href="#UI-Automator" class="headerlink" title="UI Automator"></a>UI Automator</h4><p>UI Automator 测试框架提供了一组 API 来构建 UI 测试，用于在用户应用和系统应用中执行交互。利用 UI Automator API，您可以执行在测试设备中打开“设置”菜单或应用启动器等操作。UI Automator 测试框架非常适合编写黑盒自动化测试，其中的测试代码不依赖于目标应用的内部实现详情。</p>
<p>UI Automator 测试框架的主要功能包括：</p>
<ul>
<li>用于检查布局层次结构的查看器。如需了解详细信息，请参阅 UI Automator 查看器。</li>
<li>在目标设备上检索状态信息并执行操作的 API。如需了解详细信息，请参阅访问设备状态。</li>
<li>支持跨应用 UI 测试的 API。如需了解详细信息，请参阅 UI Automator API。
要求 Android 4.3（API 级别 18）或更高版本。</li>
</ul>
<h5 id="UI-Automator-查看器"><a href="#UI-Automator-查看器" class="headerlink" title="UI Automator 查看器"></a>UI Automator 查看器</h5><p>uiautomatorviewer 工具提供了一个方便的 GUI，可以扫描和分析 Android 设备上当前显示的 UI 组件。您可以使用此工具检查布局层次结构，并查看在设备前台显示的 UI 组件属性。利用此信息，您可以使用 UI Automator（例如，通过创建与特定可见属性匹配的 UI 选择器）创建控制更加精确的测试。</p>
<p>uiautomatorviewer 工具位于 <code>&lt;android-sdk&gt;/tools/</code>目录中。</p>
<h5 id="访问设备状态"><a href="#访问设备状态" class="headerlink" title="访问设备状态"></a>访问设备状态</h5><p>UI Automator 测试框架提供了一个 UiDevice 类，用于在目标应用运行的设备上访问和执行操作。您可以调用其方法来访问设备属性，如当前屏幕方向或显示尺寸。UiDevice 类还可用于执行以下操作：</p>
<ul>
<li>更改设备旋转</li>
<li>按 D-pad 按钮</li>
<li>按“返回”、“主屏幕”或“菜单”按钮</li>
<li>打开通知栏</li>
<li>对当前窗口进行屏幕截图
例如，要模拟按下“主屏幕”按钮，请调用 <code>UiDevice.pressHome()</code> 方法。</li>
</ul>
<h5 id="UI-Automator-API"><a href="#UI-Automator-API" class="headerlink" title="UI Automator API"></a>UI Automator API</h5><p>利用 UI Automator API，您可以编写稳健可靠的测试，而无需了解目标应用的实现详情。您可以使用这些 API 在多个应用中捕获和操作 UI 组件：</p>
<ul>
<li><a href="https://developer.android.com/reference/android/support/test/uiautomator/UiCollection.html" target="_blank" rel="external">UiCollection</a>：枚举容器的 UI 元素以便计算子元素个数，或者通过可见的文本或内容描述属性来指代子元素。</li>
<li><a href="https://developer.android.com/reference/android/support/test/uiautomator/UiObject.html" target="_blank" rel="external">UiObject</a>：表示设备上可见的 UI 元素。</li>
<li><a href="https://developer.android.com/reference/android/support/test/uiautomator/UiScrollable.html" target="_blank" rel="external">UiScrollable</a>：为在可滚动 UI 容器中搜索项目提供支持。</li>
<li><a href="https://developer.android.com/reference/android/support/test/uiautomator/UiSelector.html" target="_blank" rel="external">UiSelector</a>：表示在设备上查询一个或多个目标 UI 元素。</li>
<li><a href="https://developer.android.com/reference/android/support/test/uiautomator/Configurator.html" target="_blank" rel="external">Configurator</a>：允许您设置运行 UI Automator 测试所需的关键参数。
例如，以下代码显示了如何编写可在设备中调用默认应用启动器的测试脚本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Initialize UiDevice instance</div><div class="line">mDevice = UiDevice.getInstance(getInstrumentation());</div><div class="line"></div><div class="line">// Perform a short press on the HOME button</div><div class="line">mDevice.pressHome();</div><div class="line"></div><div class="line">// Bring up the default launcher by searching for</div><div class="line">// a UI component that matches the content-description for the launcher button</div><div class="line">UiObject allAppsButton = mDevice</div><div class="line">        .findObject(new UiSelector().description(&quot;Apps&quot;));</div><div class="line"></div><div class="line">// Perform a click on the button to bring up the launcher</div><div class="line">allAppsButton.clickAndWaitForNewWindow();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>要详细了解如何使用 UI Automator，请参阅 <a href="https://developer.android.com/reference/android/support/test/package-summary.html" target="_blank" rel="external">API 参考</a>和<a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html" target="_blank" rel="external">测试多个应用的 UI </a>培训。</p>
<h3 id="测试支持库设置"><a href="#测试支持库设置" class="headerlink" title="测试支持库设置"></a>测试支持库设置</h3><p>Android 测试支持库软件包在最新版本的 Android 支持存储库中提供，后者可作为辅助组件通过 Android SDK 管理器下载。</p>
<p>要通过 SDK 管理器下载 Android 支持存储库，请执行以下操作：</p>
<ul>
<li>启动 Android SDK 管理器。</li>
<li>在 SDK 管理器窗口中，滚动到 Packages 列表末尾，找到 Extras 文件夹并展开（如有必要）以显示其内容。</li>
<li>选择 Android Support Repository 项。</li>
<li>点击 Install packages… 按钮。</li>
</ul>
<p>下载后，此工具会将支持存储库文件安装到您现有的 Android SDK 目录中。库文件位于 SDK 的以下子目录中：<code>&lt;sdk&gt;/extras/android/m2repository</code> 目录。</p>
<p>Android 测试支持库的类位于 <code>android.support.test</code> 软件包中。</p>
<p>要在 Gradle 项目中使用 Android 测试支持库，请在 build.gradle 文件中添加这些依赖关系：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  androidTestCompile &apos;com.android.support.test:runner:0.4&apos;</div><div class="line">  // Set this dependency to use JUnit 4 rules</div><div class="line">  androidTestCompile &apos;com.android.support.test:rules:0.4&apos;</div><div class="line">  // Set this dependency to build and run Espresso tests</div><div class="line">  androidTestCompile &apos;com.android.support.test.espresso:espresso-core:2.2.1&apos;</div><div class="line">  // Set this dependency to build and run UI Automator tests</div><div class="line">  androidTestCompile &apos;com.android.support.test.uiautomator:uiautomator-v18:2.1.2&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要将 AndroidJUnitRunner 设置为 Gradle 项目中的默认测试仪器运行器，请在 build.gradle 文件中指定此依赖关系：</p>
<p>``
android {
    defaultConfig {
        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”
    }
}
```</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/topic/libraries/testing-support-library/index.html#setup&quot; target=&quot;_blank&quot; rel=&quot;extern
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>android自动化测试之(N):adb工具</title>
    <link href="http://wodekouwei.com/2017/08/29/at-android-adb/"/>
    <id>http://wodekouwei.com/2017/08/29/at-android-adb/</id>
    <published>2017-08-29T06:43:09.000Z</published>
    <updated>2017-08-29T08:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android手机自动化测试过程离不开adb工具,介绍几个常用的adb命令.</p>
<h3 id="1-adb-forward"><a href="#1-adb-forward" class="headerlink" title="1. adb forward"></a>1. <code>adb forward</code></h3><p>命令示例:
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb forward tcp:8000 tcp:9000</div></pre></td></tr></table></figure></p>
<p>作用:
把PC端8000端口的数据, 转发到Android端的9000端口上,PC端的8000端口会被 adb
监听, 这个时候我们只需要往8000端口写数据, 这个数据就会发送到手机端的9000端口上.</p>
<h3 id="2-adb-connect"><a href="#2-adb-connect" class="headerlink" title="2. adb connect"></a>2. <code>adb connect</code></h3><p>命令示例:
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb connect + IP</div></pre></td></tr></table></figure></p>
<p>作用:
通过无线网络在PC端adb连接手机端</p>
<p>注意:</p>
<ol>
<li>要链接的IP ，必须和自己的PC的网络在同一个局域网内，adb 不能跨局域网链接设备</li>
<li>如果通过usb链接Android设备，通过adb devices 可以看见设备列表，但是使用不了，可以参考下面的命令说明手机端的服务未开启,需要连接usb开启手机服务,默认端口5555:<code>adb tcpip 5555</code>,开启后拔掉usb通过<code>adb connect 192.168.0.101:5555</code>即可连接</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android手机自动化测试过程离不开adb工具,介绍几个常用的adb命令.&lt;/p&gt;
&lt;h3 id=&quot;1-adb-forward&quot;&gt;&lt;a href=&quot;#1-adb-forward&quot; class=&quot;headerlink&quot; title=&quot;1. adb forward&quot;&gt;&lt;/
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView实现单选列表</title>
    <link href="http://wodekouwei.com/2017/08/24/tips-recyclerview-selectable/"/>
    <id>http://wodekouwei.com/2017/08/24/tips-recyclerview-selectable/</id>
    <published>2017-08-23T16:49:31.000Z</published>
    <updated>2017-08-23T16:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>常规方法：
在Javabean里增加一个boolean isSelected字段，
并在Adapter里根据这个字段的值设置“CheckBox”的选中状态。
在每次选中一个新优惠券时，改变数据源里的isSelected字段，
并notifyDataSetChanged()刷新整个列表。
这样实现起来很简单，代码量也很少，唯一不足的地方就是性能有损耗，不是最优雅。
So作为一个有追求 今天比较闲 的程序员，我决心分享一波优雅方案。</p>
<p>本文会列举分析一下在ListView和RecyclerView中, 列表实现单选的几种方案，并推荐采用定向刷新 部分绑定的方案，因为更高效and优雅</p>
<h3 id="1常规方案"><a href="#1常规方案" class="headerlink" title="1常规方案:"></a>1常规方案:</h3><p>常规方案 请光速阅读，直接上码：
Bean结构：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class TestBean extends SelectedBean &#123;</div><div class="line">    private String name;</div><div class="line">    public TestBean(String name,boolean isSelected) &#123;</div><div class="line">        this.name = name;</div><div class="line">        setSelected(isSelected);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我项目里有好多单选需求，懒得写isSelected字段，所以弄了个父类供子类继承。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class SelectedBean &#123;</div><div class="line">    private boolean isSelected;</div><div class="line">    public boolean isSelected() &#123;</div><div class="line">        return isSelected;</div><div class="line">    &#125;</div><div class="line">    public void setSelected(boolean selected) &#123;</div><div class="line">        isSelected = selected;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Acitivity 和Adapter其他方法都是最普通的不再赘述。
Adapter的onBindViewHolder()如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Log.d(&quot;TAG&quot;, &quot;onBindViewHolder() called with: holder = [&quot; + holder + &quot;], position = [&quot; + position + &quot;]&quot;);</div><div class="line">        holder.ivSelect.setSelected(mDatas.get(position).isSelected());//“CheckBox”</div><div class="line">        holder.tvCoupon.setText(mDatas.get(position).getName());//TextView</div><div class="line">        holder.ivSelect.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view) &#123;</div><div class="line">                //实现单选，第一种方法，十分简单， Lv Rv通用,因为它们都有notifyDataSetChanged()方法</div><div class="line">                // 每次点击时，先将所有的selected设为false，并且将当前点击的item 设为true， 刷新整个视图</div><div class="line">                for (TestBean data : mDatas) &#123;</div><div class="line">                    data.setSelected(false);</div><div class="line">                &#125;</div><div class="line">                mDatas.get(position).setSelected(true);</div><div class="line">                notifyDataSetChanged();</div><div class="line"></div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">ViewHolder：</div><div class="line"></div><div class="line">    public static class CouponVH extends RecyclerView.ViewHolder &#123;</div><div class="line">        private ImageView ivSelect;</div><div class="line">        private TextView tvCoupon;</div><div class="line"></div><div class="line">        public CouponVH(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            ivSelect = (ImageView) itemView.findViewById(R.id.ivSelect);</div><div class="line">            tvCoupon = (TextView) itemView.findViewById(R.id.tvCoupon);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>方案优点：简单粗暴</li>
<li>方案缺点：
其实需要修改的Item只有两项：
一个当前处于选中状态的Item-&gt;普通状态
再将当前手指点击的这个Item-&gt;选中状态
但采用普通方案，则会刷新整个一屏可见的Item，重走他们的getView()/onBindViewHolder()方法。
其实一个屏幕一般最多可见10+个Item，遍历一遍也无伤大雅。
但咱们还是要有追求优雅的心，所以我们继续往下看。</li>
</ul>
<h3 id="2-利用Rv的notifyItemChanged-定向刷新"><a href="#2-利用Rv的notifyItemChanged-定向刷新" class="headerlink" title="2 利用Rv的notifyItemChanged()定向刷新:"></a>2 利用Rv的notifyItemChanged()定向刷新:</h3><p>本方案可以中速阅读</p>
<ol>
<li><p>本方案需要在Adapter里新增一个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private int mSelectedPos = -1;//实现单选  方法二，变量保存当前选中的position</div></pre></td></tr></table></figure>
</li>
<li><p>在设置数据集时(构造函数，setData()方法等：)，初始化 mSelectedPos 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//实现单选方法二： 设置数据集时，找到默认选中的pos</div><div class="line">for (int i = 0; i &lt; mDatas.size(); i++) &#123;</div><div class="line">    if (mDatas.get(i).isSelected()) &#123;</div><div class="line">        mSelectedPos = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>onClick里代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//实现单选方法二： notifyItemChanged() 定向刷新两个视图</div><div class="line">//如果勾选的不是已经勾选状态的Item</div><div class="line">if (mSelectedPos!=position)&#123;</div><div class="line">    //先取消上个item的勾选状态</div><div class="line">    mDatas.get(mSelectedPos).setSelected(false);</div><div class="line">    notifyItemChanged(mSelectedPos);</div><div class="line">    //设置新Item的勾选状态</div><div class="line">    mSelectedPos = position;</div><div class="line">    mDatas.get(mSelectedPos).setSelected(true);</div><div class="line">    notifyItemChanged(mSelectedPos);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>本方案由于调用了notifyItemChanged()，所以还会伴有“白光一闪”的动画。</p>
<ul>
<li><p>方案优点：
本方案，较优雅了，不会重走一屏可见的Item的getView()/onBindViewHolder()方法，
但仍然会重走需要修改的两个Item的getView()/onBindViewHolder()方法，</p>
</li>
<li><p>方案缺点：
我们实际上需要修改的，只是里面“CheckBox”的值，
按照在DiffUtil一文学习到的姿势，术语应该是“Partial bind “，
（安利时间,没听过DiffUtil和Partial bind的 戳-&gt;：【Android】详解7.0带来的新工具类：DiffUtil）
我们需要的只是部分绑定。</p>
</li>
</ul>
<p>一个疑点：
使用方法2 在第一次选中其他Item时，切换selected状态时，
查看log，并不是只重走了新旧Item的onBindViewHolder()方法，还走了两个根本不在屏幕范围里的Item的onBindViewHolder()方法，
如，本例中 在还有item 0-3 在屏幕里，默认勾选item1，我选中item0后，log显示postion 4,5,0,1 依次执行了onBindViewHolder()方法。
但是再次切换其他Item时， 会符合预期：只走需要修改的两个Item的getView()/onBindViewHolder()方法。
原因未知，有朋友知道烦请告知，多谢。</p>
<h3 id="3-Rv-实现部分绑定（推荐）"><a href="#3-Rv-实现部分绑定（推荐）" class="headerlink" title="3 Rv 实现部分绑定（推荐）:"></a>3 Rv 实现部分绑定（推荐）:</h3><p>利用RecyclerView的 findViewHolderForLayoutPosition()方法，获取某个postion的ViewHolder，按照源码里这个方法的注释，它可能返回null。所以我们需要注意判空，（空即在屏幕不可见）。
与方法2只有onClick里的代码不一样，核心还是利用mSelectedPos 字段搞事情。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//实现单选方法三： RecyclerView另一种定向刷新方法：不会有白光一闪动画 也不会重复onBindVIewHolder</div><div class="line">CouponVH couponVH = (CouponVH) mRv.findViewHolderForLayoutPosition(mSelectedPos);</div><div class="line">if (couponVH != null) &#123;//还在屏幕里</div><div class="line">    couponVH.ivSelect.setSelected(false);</div><div class="line">&#125;else &#123;</div><div class="line">    //add by 2016 11 22 for 一些极端情况，holder被缓存在Recycler的cacheView里，</div><div class="line">    //此时拿不到ViewHolder，但是也不会回调onBindViewHolder方法。所以add一个异常处理</div><div class="line">    notifyItemChanged(mSelectedPos);</div><div class="line">&#125;</div><div class="line">mDatas.get(mSelectedPos).setSelected(false);//不管在不在屏幕里 都需要改变数据</div><div class="line">//设置新Item的勾选状态</div><div class="line">mSelectedPos = position;</div><div class="line">mDatas.get(mSelectedPos).setSelected(true);</div><div class="line">holder.ivSelect.setSelected(true);</div></pre></td></tr></table></figure></p>
<ul>
<li>方案优点：
定向刷新两个Item，只修改必要的部分，不会重走onBindViewHolder()，属于手动部分绑定。代码量也适中，不多。</li>
<li>方案缺点：
没有白光一闪动画？？？（如果这算缺点）</li>
</ul>
<h3 id="4-Rv-利用payloads实现部分绑定-不推荐"><a href="#4-Rv-利用payloads实现部分绑定-不推荐" class="headerlink" title="4 Rv 利用payloads实现部分绑定(不推荐):"></a>4 Rv 利用payloads实现部分绑定(不推荐):</h3><p>本方案属于开拓思维，是在方案2的基础上，利用payloads和notifyItemChanged(int position, Object payload)搞事情。
不知道payloads是什么的，看不懂此方案的，我又要安利：（戳-&gt;：【Android】详解7.0带来的新工具类：DiffUtil）
onClick代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//实现单选方法四：</div><div class="line">if (mSelectedPos != position) &#123;</div><div class="line">    //先取消上个item的勾选状态</div><div class="line">    mDatas.get(mSelectedPos).setSelected(false);</div><div class="line">    //传递一个payload</div><div class="line">    Bundle payloadOld = new Bundle();</div><div class="line">    payloadOld.putBoolean(&quot;KEY_BOOLEAN&quot;, false);</div><div class="line">    notifyItemChanged(mSelectedPos, payloadOld);</div><div class="line">    //设置新Item的勾选状态</div><div class="line">    mSelectedPos = position;</div><div class="line">    mDatas.get(mSelectedPos).setSelected(true);</div><div class="line">    Bundle payloadNew = new Bundle();</div><div class="line">    payloadNew.putBoolean(&quot;KEY_BOOLEAN&quot;, true);</div><div class="line">    notifyItemChanged(mSelectedPos, payloadNew);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要重写三参数的onBindViewHolder() 方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onBindViewHolder(CouponVH holder, int position, List&lt;Object&gt; payloads) &#123;</div><div class="line">    if (payloads.isEmpty()) &#123;</div><div class="line">        onBindViewHolder(holder, position);</div><div class="line">    &#125; else &#123;</div><div class="line">        Bundle payload = (Bundle) payloads.get(0);</div><div class="line">        if (payload.containsKey(&quot;KEY_BOOLEAN&quot;)) &#123;</div><div class="line">            boolean aBoolean = payload.getBoolean(&quot;KEY_BOOLEAN&quot;);</div><div class="line">            holder.ivSelect.setSelected(aBoolean);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>方案优点：
同方法3</p>
</li>
<li><p>方案缺点：
代码量多，实现效果和方法三一样，仅做开拓思维用，所以选择方法三。</p>
</li>
</ul>
<p>作者：张旭童
链接：<a href="http://www.jianshu.com/p/1ac13f74da63" target="_blank" rel="external">http://www.jianshu.com/p/1ac13f74da63</a>
來源：简书</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常规方法：
在Javabean里增加一个boolean isSelected字段，
并在Adapter里根据这个字段的值设置“CheckBox”的选中状态。
在每次选中一个新优惠券时，改变数据源里的isSelected字段，
并notifyDataSetChanged()刷
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Android Activity任务和返回栈</title>
    <link href="http://wodekouwei.com/2017/08/24/tips-activity-stack/"/>
    <id>http://wodekouwei.com/2017/08/24/tips-activity-stack/</id>
    <published>2017-08-23T16:31:17.000Z</published>
    <updated>2017-08-23T16:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>问题:<a href="http://blog.csdn.net/love100628/article/details/43238135" target="_blank" rel="external">实例化launcher activity</a>
这个问题表现:</p>
<ol>
<li><p>在package installers 安装界面安装完一个应用后，直接打开app，然后进入了 Activity_1, 此时再通过此activity用startActivity(intent)的方法打开 Activity_2.</p>
</li>
<li><p>然后按home键返回桌面，在桌面点击app图标进入，你觉得应该进入的是 Activity_2 ，实际上却是launcher Activity_1 .</p>
</li>
<li><p>然而还没完，这时候你按 back 返回键，会发现返回到了之前打开的 Activity_2，再按返回，又出现 launcherActivity_1. 也就是说系统重复实例化了Activity_1.</p>
</li>
<li><p>退出app后再次点击桌面图标进入，反复试验，没有再出现这个问题。也就是说，这个问题（bug ？）只出现在操作步骤（1）后才会产生.</p>
</li>
</ol>
<p>以上问题我在一些知名厂商的app 上发现也存在这个BUG ：</p>
<p>百度云</p>
<p>陌陌</p>
<p>去哪儿旅行</p>
<p>…QQ没有出现这个问题</p>
<p>另外，如果以root方式静默安装的话不会出现这个问题，在eclipse里直接发布到模拟器上运行也没有出现这个问题</p>
<p>解决方案:
在super.onCreate(…)方法之后插入代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if(!this.isTaskRoot()) &#123; //判断该Activity是不是任务空间的源Activity，“非”也就是说是被系统重新实例化出来  </div><div class="line">//如果你就放在launcher Activity中话，这里可以直接return了  </div><div class="line">        Intent mainIntent=getIntent();   </div><div class="line">String action=mainIntent.getAction();  </div><div class="line">if(mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;&amp; action.equals(Intent.ACTION_MAIN)) &#123;  </div><div class="line">finish();  </div><div class="line">return;//finish()之后该活动会继续执行后面的代码，你可以logCat验证，加return避免可能的exception  </div><div class="line">&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来源google ：
<a href="https://code.google.com/p/android/issues/detail?id=14262" target="_blank" rel="external">https://code.google.com/p/android/issues/detail?id=14262</a></p>
<p><a href="https://code.google.com/p/android/issues/detail?id=2373#c40" target="_blank" rel="external">https://code.google.com/p/android/issues/detail?id=2373#c40</a></p>
<p>还有另一种方案：</p>
<p><a href="http://stackoverflow.com/questions/3042420/home-key-press-behaviour/4782423#4782423" target="_blank" rel="external">http://stackoverflow.com/questions/3042420/home-key-press-behaviour/4782423#4782423</a></p>
<p><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="external">以下引用自google官方文档</a></p>
<p>应用通常包含多个 Activity。每个 Activity 均应围绕用户可以执行的特定操作设计，并且能够启动其他 Activity。 例如，电子邮件应用可能有一个 Activity 显示新邮件的列表。用户选择某邮件时，会打开一个新 Activity 以查看该邮件。</p>
<p>一个 Activity 甚至可以启动设备上其他应用中存在的 Activity。例如，如果应用想要发送电子邮件，则可将 Intent 定义为执行“发送”操作并加入一些数据，如电子邮件地址和电子邮件。 然后，系统将打开其他应用中声明自己处理此类 Intent 的 Activity。在这种情况下，Intent 是要发送电子邮件，因此将启动电子邮件应用的“撰写”Activity（如果多个 Activity 支持相同 Intent，则系统会让用户选择要使用的 Activity）。发送电子邮件时，Activity 将恢复，看起来好像电子邮件 Activity 是您的应用的一部分。 即使这两个 Activity 可能来自不同的应用，但是 Android 仍会将 Activity 保留在相同的任务中，以维护这种无缝的用户体验。</p>
<p>任务是指在执行特定作业时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈（即返回栈）中。</p>
<p>设备主屏幕是大多数任务的起点。当用户触摸应用启动器中的图标（或主屏幕上的快捷方式）时，该应用的任务将出现在前台。 如果应用不存在任务（应用最近未曾使用），则会创建一个新任务，并且该应用的“主”Activity 将作为堆栈中的根 Activity 打开。</p>
<p>当前 Activity 启动另一个 Activity 时，该新 Activity 会被推送到堆栈顶部，成为焦点所在。 前一个 Activity 仍保留在堆栈中，但是处于停止状态。Activity 停止时，系统会保持其用户界面的当前状态。 用户按“返回”按钮时，当前 Activity 会从堆栈顶部弹出（Activity 被销毁），而前一个 Activity 恢复执行（恢复其 UI 的前一状态）。 堆栈中的 Activity 永远不会重新排列，仅推入和弹出堆栈：由当前 Activity 启动时推入堆栈；用户使用“返回”按钮退出时弹出堆栈。 因此，返回栈以“后进先出”对象结构运行。 图 1 通过时间线显示 Activity 之间的进度以及每个时间点的当前返回栈，直观呈现了这种行为。
<img src="https://developer.android.com/images/fundamentals/diagram_backstack.png" alt="image">
图 1. 显示任务中的每个新 Activity 如何向返回栈添加项目。 用户按“返回”按钮时，当前 Activity 随即被销毁，而前一个 Activity 恢复执行。</p>
<p>如果用户继续按“返回”，堆栈中的相应 Activity 就会弹出，以显示前一个 Activity，直到用户返回主屏幕为止（或者，返回任务开始时正在运行的任意 Activity）。 当所有 Activity 均从堆栈中移除后，任务即不复存在。</p>
<p>任务是一个有机整体，当用户开始新任务或通过“主页”按钮转到主屏幕时，可以移动到“后台”。 尽管在后台时，该任务中的所有 Activity 全部停止，但是任务的返回栈仍旧不变，也就是说，当另一个任务发生时，该任务仅仅失去焦点而已，如图 2 中所示。然后，任务可以返回到“前台”，用户就能够回到离开时的状态。 例如，假设当前任务（任务 A）的堆栈中有三个 Activity，即当前 Activity 下方还有两个 Activity。 用户先按“主页”按钮，然后从应用启动器启动新应用。 显示主屏幕时，任务 A 进入后台。新应用启动时，系统会使用自己的 Activity 堆栈为该应用启动一个任务（任务 B）。与该应用交互之后，用户再次返回主屏幕并选择最初启动任务 A 的应用。现在，任务 A 出现在前台，其堆栈中的所有三个 Activity 保持不变，而位于堆栈顶部的 Activity 则会恢复执行。 此时，用户还可以通过转到主屏幕并选择启动该任务的应用图标（或者，通过从概览屏幕选择该应用的任务）切换回任务 B。这是 Android 系统中的一个多任务示例。
<img src="https://developer.android.com/images/fundamentals/diagram_multitasking.png" alt="image">
图 2. 两个任务：任务 B 在前台接收用户交互，而任务 A 则在后台等待恢复。</p>
<blockquote>
<p>注：后台可以同时运行多个任务。但是，如果用户同时运行多个后台任务，则系统可能会开始销毁后台 Activity，以回收内存资源，从而导致 Activity 状态丢失。请参阅下面有关 Activity 状态的部分。</p>
</blockquote>
<p>由于返回栈中的 Activity 永远不会重新排列，因此如果应用允许用户从多个 Activity 中启动特定 Activity，则会创建该 Activity 的新实例并推入堆栈中（而不是将 Activity 的任一先前实例置于顶部）。 因此，应用中的一个 Activity 可能会多次实例化（即使 Activity 来自不同的任务），如图 3 所示。因此，如果用户使用“返回”按钮向后导航，则会按 Activity 每个实例的打开顺序显示这些实例（每个实例的 UI 状态各不相同）。 但是，如果您不希望 Activity 多次实例化，则可修改此行为。 具体操作方法将在后面的管理任务部分中讨论。
<img src="https://developer.android.com/images/fundamentals/diagram_multiple_instances.png" alt="image">
图 3. 一个 Activity 将多次实例化。</p>
<p>Activity 和任务的默认行为总结如下：</p>
<ul>
<li>当 Activity A 启动 Activity B 时，Activity A 将会停止，但系统会保留其状态（例如，滚动位置和已输入表单中的文本）。如果用户在处于 Activity B 时按“返回”按钮，则 Activity A 将恢复其状态，继续执行。</li>
<li>用户通过按“主页”按钮离开任务时，当前 Activity 将停止且其任务会进入后台。 系统将保留任务中每个 Activity 的状态。如果用户稍后通过选择开始任务的启动器图标来恢复任务，则任务将出现在前台并恢复执行堆栈顶部的 Activity。</li>
<li>如果用户按“返回”按钮，则当前 Activity 会从堆栈弹出并被销毁。 堆栈中的前一个 Activity 恢复执行。销毁 Activity 时，系统不会保留该 Activity 的状态。</li>
<li>即使来自其他任务，Activity 也可以多次实例化。</li>
</ul>
<h3 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h3><p>正如上文所述，当 Activity 停止时，系统的默认行为会保留其状态。 这样一来，当用户导航回到上一个 Activity 时，其用户界面与用户离开时一样。 但是，在 Activity 被销毁且必须重建时，您可以而且应当主动使用回调方法保留 Activity 的状态。</p>
<p>系统停止您的一个 Activity 时（例如，新 Activity 启动或任务转到前台），如果系统需要回收系统内存资源，则可能会完全销毁该 Activity。 发生这种情况时，有关该 Activity 状态的信息将会丢失。如果发生这种情况，系统仍会知道该 Activity 存在于返回栈中，但是当该 Activity 被置于堆栈顶部时，系统一定会重建 Activity（而不是恢复 Activity）。 为了避免用户的工作丢失，您应主动通过在 Activity 中实现 onSaveInstanceState() 回调方法来保留工作。</p>
<p>如需了解有关如何保存 Activity 状态的详细信息，请参阅 Activity 文档。</p>
<h3 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h3><p>Android 管理任务和返回栈的方式（如上所述，即：将所有连续启动的 Activity 放入同一任务和“后进先出”堆栈中）非常适用于大多数应用，而您不必担心 Activity 如何与任务关联或者如何存在于返回栈中。 但是，您可能会决定要中断正常行为。 也许您希望应用中的 Activity 在启动时开始新任务（而不是放置在当前任务中）；或者，当启动 Activity 时，您希望将其现有实例上移一层（而不是在返回栈的顶部创建新实例）；或者，您希望在用户离开任务时，清除返回栈中除根 Activity 以外的所有其他 Activity。</p>
<p>通过使用 <activity> 清单文件元素中的属性和传递给 startActivity() 的 Intent 中的标志，您可以执行所有这些操作以及其他操作。</activity></p>
<p>在这一方面，您可以使用的主要 <activity> 属性包括：</activity></p>
<ul>
<li>taskAffinity</li>
<li>launchMode</li>
<li>allowTaskReparenting</li>
<li>clearTaskOnLaunch</li>
<li>alwaysRetainTaskState</li>
<li>finishOnTaskLaunch</li>
</ul>
<p>您可以使用的主要 Intent 标志包括：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>在下文中，您将了解如何使用这些清单文件属性和 Intent 标志定义 Activity 与任务的关联方式，以及 Activity 在返回栈中的行为方式。</p>
<p>此外，我们还单独介绍了有关如何在概览屏幕中显示和管理任务与 Activity 的注意事项。 如需了解详细信息，请参阅概览屏幕。 通常，您应该允许系统定义任务和 Activity 在概览屏幕中的显示方法，并且无需修改此行为。</p>
<blockquote>
<p>注意：大多数应用都不得中断 Activity 和任务的默认行为： 如果确定您的 Activity 必须修改默认行为，当使用“返回”按钮从其他 Activity 和任务导航回到该 Activity 时，请务必要谨慎并确保在启动期间测试该 Activity 的可用性。请确保测试导航行为是否有可能与用户的预期行为冲突。</p>
</blockquote>
<h3 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h3><p>启动模式允许您定义 Activity 的新实例如何与当前任务关联。 您可以通过两种方法定义不同的启动模式：</p>
<ol>
<li>使用清单文件
在清单文件中声明 Activity 时，您可以指定 Activity 在启动时应该如何与任务关联。</li>
<li>使用 Intent 标志
调用 startActivity() 时，可以在 Intent 中加入一个标志，用于声明新 Activity 如何（或是否）与当前任务关联。</li>
</ol>
<p>因此，如果 Activity A 启动 Activity B，则 Activity B 可以在其清单文件中定义它应该如何与当前任务关联（如果可能），并且 Activity A 还可以请求 Activity B 应该如何与当前任务关联。如果这两个 Activity 均定义 Activity B 应该如何与任务关联，则 Activity A 的请求（如 Intent 中所定义）优先级要高于 Activity B 的请求（如其清单文件中所定义）。</p>
<blockquote>
<p>注：某些适用于清单文件的启动模式不可用作 Intent 标志，同样，某些可用作 Intent 标志的启动模式无法在清单文件中定义。</p>
<h4 id="使用清单文件"><a href="#使用清单文件" class="headerlink" title="使用清单文件"></a>使用清单文件</h4><p>在清单文件中声明 Activity 时，您可以使用 <activity> 元素的 launchMode 属性指定 Activity 应该如何与任务关联。</activity></p>
</blockquote>
<p>launchMode 属性指定有关应如何将 Activity 启动到任务中的指令。您可以分配给 launchMode 属性的启动模式共有四种：</p>
<ul>
<li>“standard”（默认模式）
默认。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</li>
<li>“singleTop”
如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的 Activity 并不是 Activity 的现有实例）。
例如，假设任务的返回栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈是 A-B-C-D；D 位于顶部）。收到针对 D 类 Activity 的 Intent。如果 D 具有默认的 “standard” 启动模式，则会启动该类的新实例，且堆栈会变成 A-B-C-D-D。但是，如果 D 的启动模式是 “singleTop”，则 D 的现有实例会通过 onNewIntent() 接收 Intent，因为它位于堆栈的顶部；而堆栈仍为 A-B-C-D。但是，如果收到针对 B 类 Activity 的 Intent，则会向堆栈添加 B 的新实例，即便其启动模式为 “singleTop” 也是如此。</li>
</ul>
<blockquote>
<p>注：为某个 Activity 创建新实例时，用户可以按“返回”按钮返回到前一个 Activity。 但是，当 Activity 的现有实例处理新 Intent 时，则在新 Intent 到达 onNewIntent() 之前，用户无法按“返回”按钮返回到 Activity 的状态。</p>
</blockquote>
<ul>
<li><p>“singleTask”
系统创建新任务并实例化位于新任务底部的 Activity。但是，如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。一次只能存在 Activity 的一个实例。</p>
<blockquote>
<p>注：尽管 Activity 在新任务中启动，但是用户按“返回”按钮仍会返回到前一个 Activity。</p>
</blockquote>
</li>
<li><p>“singleInstance”.
与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。</p>
</li>
</ul>
<p>我们再来看另一示例，Android 浏览器应用声明网络浏览器 Activity 应始终在其自己的任务中打开（通过在 <activity> 元素中指定 singleTask 启动模式）。这意味着，如果您的应用发出打开 Android 浏览器的 Intent，则其 Activity 与您的应用位于不同的任务中。相反，系统会为浏览器启动新任务，或者如果浏览器已有任务正在后台运行，则会将该任务上移一层以处理新 Intent。</activity></p>
<p>无论 Activity 是在新任务中启动，还是在与启动 Activity 相同的任务中启动，用户按“返回”按钮始终会转到前一个 Activity。 但是，如果启动指定 singleTask 启动模式的 Activity，则当某后台任务中存在该 Activity 的实例时，整个任务都会转移到前台。此时，返回栈包括上移到堆栈顶部的任务中的所有 Activity。 图 4 显示了这种情况。
<img src="https://developer.android.com/images/fundamentals/diagram_backstack_singletask_multiactivity.png" alt="image">
图 4. 显示如何将启动模式为“singleTask”的 Activity 添加到返回栈。 如果 Activity 已经是某个拥有自己的返回栈的后台任务的一部分，则整个返回栈也会上移到当前任务的顶部。</p>
<p>如需了解有关在清单文件中使用启动模式的详细信息，请参阅 <activity> 元素文档，其中更详细地讨论了 launchMode 属性和可接受的值。</activity></p>
<blockquote>
<p>注：使用 launchMode 属性为 Activity 指定的行为可由 Intent 附带的 Activity 启动标志替代，下文将对此进行讨论。</p>
</blockquote>
<h4 id="使用-Intent-标志"><a href="#使用-Intent-标志" class="headerlink" title="使用 Intent 标志"></a>使用 Intent 标志</h4><p>启动 Activity 时，您可以通过在传递给 startActivity() 的 Intent 中加入相应的标志，修改 Activity 与其任务的默认关联方式。可用于修改默认行为的标志包括：</p>
<ul>
<li><p>FLAG_ACTIVITY_NEW_TASK
在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 onNewIntent() 中收到新 Intent。
正如前文所述，这会产生与 “singleTask”launchMode 值相同的行为。</p>
</li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP
如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 onNewIntent() 的调用，而不是创建 Activity 的新实例。
正如前文所述，这会产生与 “singleTop”launchMode 值相同的行为。</p>
</li>
<li><p>FLAG_ACTIVITY_CLEAR_TOP
如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。
产生这种行为的 launchMode 属性没有值。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP 通常与 FLAG_ACTIVITY_NEW_TASK 结合使用。一起使用时，通过这些标志，可以找到其他任务中的现有 Activity，并将其放入可从中响应 Intent 的位置。</p>
<blockquote>
<p>注：如果指定 Activity 的启动模式为 “standard”，则该 Activity 也会从堆栈中移除，并在其位置启动一个新实例，以便处理传入的 Intent。 这是因为当启动模式为 “standard” 时，将始终为新 Intent 创建新实例。</p>
</blockquote>
</li>
</ul>
<h3 id="处理关联"><a href="#处理关联" class="headerlink" title="处理关联"></a>处理关联</h3><p>“关联”指示 Activity 优先属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此关联。 因此，默认情况下，同一应用中的所有 Activity 优先位于相同任务中。 不过，您可以修改 Activity 的默认关联。 在不同应用中定义的 Activity 可以共享关联，或者可为在同一应用中定义的 Activity 分配不同的任务关联。</p>
<p>可以使用 <activity> 元素的 taskAffinity 属性修改任何给定 Activity 的关联。</activity></p>
<p>taskAffinity 属性取字符串值，该值必须不同于在 <manifest> 元素中声明的默认软件包名称，因为系统使用该名称标识应用的默认任务关联。</manifest></p>
<p>在两种情况下，关联会起作用：</p>
<ul>
<li>启动 Activity 的 Intent 包含 FLAG_ACTIVITY_NEW_TASK 标志。
默认情况下，新 Activity 会启动到调用 startActivity() 的 Activity 任务中。它将推入与调用方相同的返回栈。 但是，如果传递给 startActivity() 的 Intent 包含 FLAG_ACTIVITY_NEW_TASK 标志，则系统会寻找其他任务来储存新 Activity。这通常是新任务，但未做强制要求。 如果现有任务与新 Activity 具有相同关联，则会将 Activity 启动到该任务中。 否则，将开始新任务。
如果此标志导致 Activity 开始新任务，且用户按“主页”按钮离开，则必须为用户提供导航回任务的方式。 有些实体（如通知管理器）始终在外部任务中启动 Activity，而从不作为其自身的一部分启动 Activity，因此它们始终将 FLAG_ACTIVITY_NEW_TASK 放入传递给 startActivity() 的 Intent 中。请注意，如果 Activity 能够由可以使用此标志的外部实体调用，则用户可以通过独立方式返回到启动的任务，例如，使用启动器图标（任务的根 Activity 具有 CATEGORY_LAUNCHER Intent 过滤器；请参阅下面的启动任务部分）。</li>
<li><p>Activity 将其 allowTaskReparenting 属性设置为 “true”。
在这种情况下，Activity 可以从其启动的任务移动到与其具有关联的任务（如果该任务出现在前台）。</p>
<blockquote>
<p>提示：如果从用户的角度来看，一个 .apk 文件包含多个“应用”，则您可能需要使用 taskAffinity 属性将不同关联分配给与每个“应用”相关的 Activity。</p>
</blockquote>
</li>
</ul>
<h3 id="清理返回栈"><a href="#清理返回栈" class="headerlink" title="清理返回栈"></a>清理返回栈</h3><p>如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。 当用户再次返回到任务时，仅恢复根 Activity。系统这样做的原因是，经过很长一段时间后，用户可能已经放弃之前执行的操作，返回到任务是要开始执行新的操作。</p>
<p>您可以使用下列几个 Activity 属性修改此行为：</p>
<ul>
<li>alwaysRetainTaskState
如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。</li>
<li>clearTaskOnLaunch
如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。</li>
<li>finishOnTaskLaunch
此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。<h3 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h3>通过为 Activity 提供一个以 “android.intent.action.MAIN” 为指定操作、以 “android.intent.category.LAUNCHER” 为指定类别的 Intent 过滤器，您可以将 Activity 设置为任务的入口点。 例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity ... &gt;</div><div class="line">    &lt;intent-filter ... &gt;</div><div class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</div><div class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">    ...</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此类 Intent 过滤器会使 Activity 的图标和标签显示在应用启动器中，让用户能够启动 Activity 并在启动之后随时返回到创建的任务中。</p>
<p>第二个功能非常重要：用户必须能够在离开任务后，再使用此 Activity 启动器返回该任务。 因此，只有在 Activity 具有 ACTION_MAIN 和 CATEGORY_LAUNCHER 过滤器时，才应该使用将 Activity 标记为“始终启动任务”的两种启动模式，即 “singleTask” 和 “singleInstance”。例如，我们可以想像一下如果缺少过滤器会发生什么情况： Intent 启动一个 “singleTask” Activity，从而启动一个新任务，并且用户花了些时间处理该任务。然后，用户按“主页”按钮。 任务现已发送到后台，而且不可见。现在，用户无法返回到任务，因为该任务未显示在应用启动器中。</p>
<p>如果您并不想用户能够返回到 Activity，对于这些情况，请将 <activity> 元素的 finishOnTaskLaunch 设置为 “true”（请参阅清理堆栈）。</activity></p>
<p>有关如何在概览屏幕中显示和管理任务与 Activity 的更多信息，请参阅概览屏幕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题:&lt;a href=&quot;http://blog.csdn.net/love100628/article/details/43238135&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实例化launcher activity&lt;/a&gt;
这个问题表现:&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>home后从service重新启动activity延迟问题</title>
    <link href="http://wodekouwei.com/2017/08/24/tips-starting-an-activity-from-a-service-after-home-button/"/>
    <id>http://wodekouwei.com/2017/08/24/tips-starting-an-activity-from-a-service-after-home-button/</id>
    <published>2017-08-23T16:23:17.000Z</published>
    <updated>2017-08-23T16:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>问题:
在Activity界面，按下HOME键后，点击悬浮层按钮，再启动Activity， Activity要延时5S后才出来。
经验证，这个问题不是应用自身的BUG。那怕该Activity是空的，也会有这个问题</p>
<p>Android为了避免应用在按下HOME键退出后还可以强制把自己启动，特意加的限制。
在现有的API情况下，不能解决这个问题，除非你的应用是一个启动器（Launcher）， 添加了home/ launcher intent filter。如果你不是启动器，又要从悬浮层启动一个Activity，就把该Activity也改成悬浮层吧</p>
<h3 id="1-不从后台启动-Activity-准则："><a href="#1-不从后台启动-Activity-准则：" class="headerlink" title="1. 不从后台启动 Activity 准则："></a>1. 不从后台启动 Activity 准则：</h3><p>在谷歌的 Android API Guides 中，特意提醒开发者不要在后台启动 activity，包括在 Service 和 BroadcastReceiver 中，这样的设计是为了避免在用户毫不知情的情况下突然中断用户正在进行的工作，在  <a href="http://developer.android.com/guide/practices/seamlessness.html#interrupt" target="_blank" rel="external">http://developer.android.com/guide/practices/seamlessness.html#interrupt</a> 中有如下解释：</p>
<p>That is, don’t call startActivity() from BroadcastReceivers or Services running in the background. Doing so will interrupt whatever application is currently running, and result in an annoyed user. Perhaps even worse, your Activity may become a “keystroke bandit” and receive some of the input the user was in the middle of providing to the previous Activity. Depending on what your application does, this could be bad news.</p>
<h3 id="2-需要违反“不从后台启动-Activity”准则的特例："><a href="#2-需要违反“不从后台启动-Activity”准则的特例：" class="headerlink" title="2. 需要违反“不从后台启动 Activity”准则的特例："></a>2. 需要违反“不从后台启动 Activity”准则的特例：</h3><p>特例：即便如此，手机厂商的开发者们在开发基于系统级的应用的时候，可能仍然需要有从 Service 或 BroadcastReceiver 中 startActivity 的需求，往往这样的前提是连这样的 Service 或 BroadcastReceiver 也是由用户的某些操作而触发的，Service 或 BroadcastReceiver 只是充当了即将启动 activity 之前的一些代理参数检查工作以便决定是否需要 start 该 activity。</p>
<p>除非是上述笔者所述的特殊情况，应用开发者都应该遵循 “不要从后台启动 Activity”准则。</p>
<p>一个需要特别注意的问题是，特例中所述的情况还会遇到一个问题，就是当通过 home 键将当前 activity 置于后台时，任何在后台startActivity 的操作都将会延迟 5 秒，除非该应用获取了 “android.permission.STOP_APP_SWITCHES” 权限。</p>
<p>关于延迟 5 秒的操作在 com.android.server.am.ActivityManagerService 中的 stopAppSwitches() 方法中，系统级的应用当获取了 “android.permission.STOP_APP_SWITCHES” 后将不会调用到这个方法来延迟通过后台启动 activity 的操作，事实上 android 原生的 Phone 应用就是这样的情况，它是一个获取了”android.permission.STOP_APP_SWITCHES” 权限的系统级应用，当有来电时，一个从后台启动的 activity 将突然出现在用户的面前，警醒用户有新的来电，这样的设计是合理的。</p>
<p>所以，当你需要开发类似 Phone 这样的应用时，需要做如下工作：</p>
<ol>
<li>root 你的手机；</li>
<li>在 AndroidManifest.xml 中添加 “android.permission.STOP_APP_SWITCHES”  用户权限；</li>
<li>将你开发的应用程序 push 到手机的 /system/app 目录中。</li>
</ol>
<h3 id="3-参考资料："><a href="#3-参考资料：" class="headerlink" title="3. 参考资料："></a>3. 参考资料：</h3><p><a href="http://developer.android.com/guide/practices/seamlessness.html#interrupt" target="_blank" rel="external">无缝的设计之——不要中断你的用户</a>
<a href="http://stackoverflow.com/questions/5600084/starting-an-activity-from-a-service-after-home-button-pressed-without-the-5-seco" target="_blank" rel="external">stackoverflow 中关于后台 startActivity 被延迟 5 秒的探讨</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题:
在Activity界面，按下HOME键后，点击悬浮层按钮，再启动Activity， Activity要延时5S后才出来。
经验证，这个问题不是应用自身的BUG。那怕该Activity是空的，也会有这个问题&lt;/p&gt;
&lt;p&gt;Android为了避免应用在按下HOME键退出
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Linux下C开发使用小技巧</title>
    <link href="http://wodekouwei.com/2017/08/06/tips-c-language/"/>
    <id>http://wodekouwei.com/2017/08/06/tips-c-language/</id>
    <published>2017-08-06T02:45:03.000Z</published>
    <updated>2017-09-30T04:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="架构类"><a href="#架构类" class="headerlink" title="架构类"></a>架构类</h3><h4 id="Linux-C代码实现主函数参数选项解析"><a href="#Linux-C代码实现主函数参数选项解析" class="headerlink" title="Linux C代码实现主函数参数选项解析"></a>Linux C代码实现主函数参数选项解析</h4><h5 id="1-手动解析版本"><a href="#1-手动解析版本" class="headerlink" title="1. 手动解析版本"></a>1. 手动解析版本</h5><p>使用argc、argv，逐个字符比较，得到要想的参数名字即进行判断、解析。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;ctype.h&gt;</div><div class="line"></div><div class="line">int debug;</div><div class="line"></div><div class="line">void show_version(char* name)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%s by Late Lee, version: 1.0\n&quot;, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void usage(char* name)</div><div class="line">&#123;</div><div class="line">    show_version(name);</div><div class="line"></div><div class="line">    printf(&quot;         -h,  --help           short help\n&quot;);</div><div class="line">    printf(&quot;         -v,  --version        show version\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int i = 0;</div><div class="line"></div><div class="line">    /* early check for debug and config parameter */</div><div class="line">    if (argc &gt; 1) &#123;</div><div class="line">        for (i = 1; i &lt; argc; i++)</div><div class="line">        &#123;</div><div class="line">            if ((strcmp(argv[i], &quot;-D&quot;)==0) || (strcmp(argv[i], &quot;--debug&quot;)==0))</div><div class="line">            &#123;</div><div class="line">                debug = 1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //</div><div class="line">    /* parse parameters, maybe not the best way but... */</div><div class="line">    for (i = 1; i &lt; argc; i++)</div><div class="line">    &#123;</div><div class="line">        if (debug)</div><div class="line">            printf(&quot;arg %d: \&quot;%s\&quot;\n&quot;,i,argv[i]);</div><div class="line">        // help</div><div class="line">        if ((strcmp(argv[i],&quot;-h&quot;)==0) || (strcmp(argv[i],&quot;--help&quot;)==0))</div><div class="line">        &#123;</div><div class="line">            usage(argv[0]);</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        // version</div><div class="line">        else if ((strcmp(argv[i],&quot;-v&quot;)==0) || (strcmp(argv[i],&quot;--version&quot;)==0))</div><div class="line">        &#123;</div><div class="line">            show_version(argv[0]);</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        // debug</div><div class="line">        else if ((strcmp(argv[i],&quot;-D&quot;)==0) || (strcmp(argv[i],&quot;--debug&quot;)==0))</div><div class="line">        &#123;</div><div class="line">            debug=1;</div><div class="line">        &#125;</div><div class="line">        else if ((strcmp(argv[i],&quot;fpga&quot;)==0))</div><div class="line">        &#123;</div><div class="line">            printf(&quot;test of fpga...\n&quot;);</div><div class="line">        &#125;</div><div class="line">        // string</div><div class="line">        else if ((strcmp(argv[i],&quot;-i&quot;)==0) || (strcmp(argv[i],&quot;--iface&quot;)==0))</div><div class="line">        &#123;</div><div class="line">            if (i+1&lt;argc)</div><div class="line">            &#123;</div><div class="line">                char interface[32] = &#123;0&#125;;</div><div class="line">                strncpy(interface, argv[i+1], 32);</div><div class="line">                if (debug)</div><div class="line">                    printf(&quot;Used interface: %s\n&quot;, interface);</div><div class="line">                i++;</div><div class="line">                continue;</div><div class="line">            &#125; else &#123;</div><div class="line">                printf(&quot;Error: Interface for -i missing.\n&quot;);</div><div class="line">                return 1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // number</div><div class="line">        else if ((strcmp(argv[i],&quot;-ru&quot;)==0) || (strcmp(argv[i],&quot;--rateunit&quot;))==0)</div><div class="line">        &#123;</div><div class="line">            if (i+1&lt;argc &amp;&amp; isdigit(argv[i+1][0])) &#123;</div><div class="line">                int rateunit = 0;</div><div class="line">                rateunit = atoi(argv[i+1]);</div><div class="line">                if (rateunit &lt; 0 || rateunit &gt; 1)</div><div class="line">                &#123;</div><div class="line">                    printf(&quot;Error: Invalid parameter \&quot;%d\&quot; for --rateunit.\n&quot;, rateunit);</div><div class="line">                    printf(&quot; Valid parameters:\n&quot;);</div><div class="line">                    printf(&quot;    0 - bytes\n&quot;);</div><div class="line">                    printf(&quot;    1 - bits\n&quot;);</div><div class="line">                    return 1;</div><div class="line">                &#125;</div><div class="line">                if (debug)</div><div class="line">                    printf(&quot;Rateunit changed: %d\n&quot;, rateunit);</div><div class="line">                i++;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // only one</div><div class="line">        else if (strcmp(argv[i],&quot;--enable&quot;)==0)</div><div class="line">        &#123;</div><div class="line">            int enable = 0;</div><div class="line">            enable = 1;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            printf(&quot;Unknown parameter \&quot;%s\&quot;. Use --help for help.\n&quot;,argv[i]);</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="2-利用getopt函数完成"><a href="#2-利用getopt函数完成" class="headerlink" title="2. 利用getopt函数完成"></a>2. 利用getopt函数完成</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">解析命令选项示例</div><div class="line"></div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">extern char *optarg;   //选项的参数指针</div><div class="line">extern int optind,    //下一次调用getopt的时，从optind存储的位置处重新开始检查选项。</div><div class="line">extern int opterr,   //当opterr=0时，getopt不向stderr输出错误信息。</div><div class="line">extern int optopt;   //当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回&apos;？’、</div><div class="line">int getopt(int argc, char * const argv[], const char *optstring);</div><div class="line"></div><div class="line">使用：</div><div class="line">$ ./a.out -Wall -o hello.c</div><div class="line"></div><div class="line">*/</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line"></div><div class="line">int debug_level = 0;</div><div class="line"></div><div class="line">#define _AUTHOR &quot;Late Lee&quot;</div><div class="line">#define _VERSION_STR &quot;1.0&quot;</div><div class="line">#define _DATE &quot;&quot;</div><div class="line"></div><div class="line">// 默认打印error等级</div><div class="line">enum</div><div class="line">&#123;</div><div class="line">    MSG_ERROR = 0,</div><div class="line">    MSG_WARNING,</div><div class="line">    MSG_INFO,</div><div class="line">    MSG_DEBUG,</div><div class="line">    MSG_MSGDUMP,</div><div class="line">    MSG_EXCESSIVE,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void ll_printf(int level, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));</div><div class="line"></div><div class="line">void ll_printf(int level, const char *fmt, ...)</div><div class="line">&#123;</div><div class="line">    va_list ap;</div><div class="line"></div><div class="line">    va_start(ap, fmt);</div><div class="line">    if (debug_level &gt;= level)</div><div class="line">    &#123;</div><div class="line">#ifdef CONFIG_DEBUG_SYSLOG</div><div class="line">        if (wpa_debug_syslog) &#123;</div><div class="line">            vsyslog(syslog_priority(level), fmt, ap);</div><div class="line">        &#125; else &#123;</div><div class="line">#endif /* CONFIG_DEBUG_SYSLOG */</div><div class="line">        //debug_print_timestamp();</div><div class="line">#ifdef CONFIG_DEBUG_FILE</div><div class="line">        if (out_file) &#123;</div><div class="line">            vfprintf(out_file, fmt, ap);</div><div class="line">            fprintf(out_file, &quot;\n&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">#endif /* CONFIG_DEBUG_FILE */</div><div class="line">        vprintf(fmt, ap);</div><div class="line">        printf(&quot;\n&quot;);</div><div class="line">#ifdef CONFIG_DEBUG_FILE</div><div class="line">        &#125;</div><div class="line">#endif /* CONFIG_DEBUG_FILE */</div><div class="line">#ifdef CONFIG_DEBUG_SYSLOG</div><div class="line">        &#125;</div><div class="line">#endif /* CONFIG_DEBUG_SYSLOG */</div><div class="line">    &#125;</div><div class="line">    va_end(ap);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void show_version(char* name)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%s by %s, version: %s\n&quot;, name, _AUTHOR, _VERSION_STR);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void usage(char* name)</div><div class="line">&#123;</div><div class="line">    show_version(name);</div><div class="line"></div><div class="line">    printf(&quot;    -h,    short help\n&quot;);</div><div class="line">    printf(&quot;    -v,    show version\n&quot;);</div><div class="line">    printf(&quot;    -d,    debug level\n&quot;);</div><div class="line"></div><div class="line">    exit(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">const char* my_opt = &quot;hOo:W:d:&quot;;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int c;</div><div class="line">    const char* p1 = NULL;</div><div class="line">    const char* p2 = NULL;</div><div class="line">    const char* p3 = NULL;</div><div class="line">    while(1)</div><div class="line">    &#123;</div><div class="line">        c = getopt(argc, argv, my_opt);</div><div class="line">        printf(&quot;optind: %d\n&quot;, optind);</div><div class="line">        if (c &lt; 0)</div><div class="line">        &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;option char: %x %c\n&quot;, c, c);</div><div class="line">        switch(c)</div><div class="line">        &#123;</div><div class="line">        case &apos;d&apos;:</div><div class="line">                debug_level = atoi(optarg);</div><div class="line">                printf(&quot;debug level: %d\n&quot;, debug_level);</div><div class="line">                break;</div><div class="line">        case &apos;O&apos;:</div><div class="line">                printf(&quot;optimization flag is open.\n\n&quot;);</div><div class="line">                break;</div><div class="line">        case &apos;o&apos;:</div><div class="line">                printf(&quot;the obj is: %s\n\n&quot;, optarg);</div><div class="line">                p1 = optarg;</div><div class="line">                break;</div><div class="line">        case &apos;W&apos;:</div><div class="line">                printf(&quot;optarg: %s\n\n&quot;, optarg);</div><div class="line">                p2 = optarg;</div><div class="line">                break;</div><div class="line">        case &apos;:&apos;:</div><div class="line">                fprintf(stderr, &quot;miss option char in optstring.\n&quot;);</div><div class="line">                break;</div><div class="line">        case &apos;?&apos;:</div><div class="line">        case &apos;h&apos;:</div><div class="line">        default:</div><div class="line">                usage(argv[0]);</div><div class="line">                break;</div><div class="line">                //return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (optind == 1)</div><div class="line">    &#123;</div><div class="line">        usage(argv[0]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ll_printf(MSG_ERROR, &quot;p1: %s p2: %s\n&quot;, p1, p2);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h4><h4 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h4><h4 id="读取配置文件模块"><a href="#读取配置文件模块" class="headerlink" title="读取配置文件模块"></a>读取配置文件模块</h4><h4 id="内存池模块"><a href="#内存池模块" class="headerlink" title="内存池模块"></a>内存池模块</h4><h4 id="缓存库模块"><a href="#缓存库模块" class="headerlink" title="缓存库模块"></a>缓存库模块</h4><h4 id="文件系统模块"><a href="#文件系统模块" class="headerlink" title="文件系统模块"></a>文件系统模块</h4><h4 id="管理后台模块"><a href="#管理后台模块" class="headerlink" title="管理后台模块"></a>管理后台模块</h4><h4 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h4><h3 id="技巧类"><a href="#技巧类" class="headerlink" title="技巧类"></a>技巧类</h3><h4 id="Linux程序中预定义的几个调试宏"><a href="#Linux程序中预定义的几个调试宏" class="headerlink" title="Linux程序中预定义的几个调试宏"></a>Linux程序中预定义的几个调试宏</h4><p>Linux下C语言编程中有几个很实用的调试宏
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__LINE__ __FILE__  __FUNCTION__ __TIME__ __DATA__</div></pre></td></tr></table></figure></p>
<p>这几个预定义宏是属于ANSI标准的，内置于编译器，全局性的变量，可以方便地实现代码跟踪调试，不是在哪个头文件中包含的，见下例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    printf(&quot;The file is %s.\n&quot;,__FILE__);</div><div class="line">    printf( &quot;The date is %s.\n&quot;, __DATE__ );</div><div class="line">    printf( &quot;The time is %s.\n&quot;, __TIME__ );</div><div class="line">    printf( &quot;This is line %d.\n&quot;, __LINE__ );</div><div class="line">    printf( &quot;This function is %s.\n&quot;, __FUNCTION__ );   </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The file is macro.c.</div><div class="line">The date is Aug 24 2012.</div><div class="line">The time is 23:13:26.</div><div class="line">This is line 8.</div><div class="line">This function is main.</div></pre></td></tr></table></figure></p>
<p><code>line 行数 文件名</code>指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。</p>
<p>DATE 宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。
TIME 宏指令包含程序编译的时间。时间用字符串表示，其形式为时：分：秒</p>
<p><code>__func__</code>代表这条语句所在的函数的函数名</p>
<h4 id="联合体用途"><a href="#联合体用途" class="headerlink" title="联合体用途"></a>联合体用途</h4><p>字节序有两种表示方法：大端法（big ending），小端法（little  ending）。网络字节序采用的是大端法。主机字节序不同的CPU采用的方法不一样，可以通过代码来查看自己主机的字节序。</p>
<ul>
<li>大端法：高位字节排放在内存低地址端，低位字节排放在内存的高地址端。</li>
<li>小端法：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
看一个unsigned short 数据，它占2个字节，给它赋值0x1234。</li>
<li>若采用的大端法，则其低地址端应该存放的是0x12；</li>
<li>若采用的小端法，则其低地址端应该存放的是0x34；
可以通过联合体来获得其高低地址的数据。测试主机字节序的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef union&#123;</div><div class="line">    unsigned short value;</div><div class="line">    unsigned char bytes[2];</div><div class="line">&#125;Test;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    Test test_value;</div><div class="line">    test_value.value = 0x1234;</div><div class="line">    if(test_value.bytes[0] == 0x12 &amp;&amp; test_value.bytes[1] == 0x34)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;big ending&quot;);</div><div class="line">    &#125;</div><div class="line">    else if(test_value.bytes[0] == 0x34 &amp;&amp; test_value.bytes[1] == 0x12)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;little ending&quot;);</div><div class="line">    &#125;else&#123;</div><div class="line">        printf(&quot;use test_value error&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="自定义日志的调试打印信息"><a href="#自定义日志的调试打印信息" class="headerlink" title="自定义日志的调试打印信息"></a>自定义日志的调试打印信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#define TRACE_NONE      0</div><div class="line">#define TRACE_FATAL     1</div><div class="line">#define TRACE_ERROR     2</div><div class="line">#define TRACE_WARNING   3</div><div class="line">#define TRACE_INFO      4</div><div class="line">#define TRACE_DEBUG     5</div><div class="line"></div><div class="line">#define TRACE_LEN_MAX    64</div><div class="line"></div><div class="line">extern int  *TraceLevel;</div><div class="line">extern char TraceName[TRACE_LEN_MAX + 1];</div><div class="line"></div><div class="line">#define Log(A, format,args...) \</div><div class="line">    ((TraceLevel == NULL || TraceName == NULL || *TraceLevel &lt; (A)) ? 0 : LogMsg(A, __FILE__, __LINE__, format, ##args))</div><div class="line"></div><div class="line">#define LogFatal(format,args...) \</div><div class="line">    Log(TRACE_FATAL, format, ##args)</div><div class="line">#define LogError(format,args...) \</div><div class="line">    Log(TRACE_ERROR, format, ##args)</div><div class="line">#define LogWarning(format,args...) \</div><div class="line">    Log(TRACE_WARNING, format, ##args)</div><div class="line">#define LogInfo(format,args...) \</div><div class="line">    Log(TRACE_INFO, format, ##args)</div><div class="line">#define LogDebug(format,args...) \</div><div class="line">    Log(TRACE_DEBUG, format, ##args)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">int LogMsg(int level, const char *filename,</div><div class="line">           int line, const char *fmt, ...)</div><div class="line">&#123;</div><div class="line">    va_list      ap;</div><div class="line">    FILE         *fp;</div><div class="line">    char         sLogFile[128 + 1];</div><div class="line">    char         sCurrTime[6 + 1];</div><div class="line">    struct timeb tTimeB;</div><div class="line">    char         sMilliTM[4];</div><div class="line"></div><div class="line">    memset(sLogFile, 0, sizeof(sLogFile));</div><div class="line">    LogFile(sLogFile);</div><div class="line">    GetTime_HHMMSS(sCurrTime);</div><div class="line">    memset(&amp;tTimeB, 0, sizeof(tTimeB));    </div><div class="line">    ftime(&amp;tTimeB);</div><div class="line">    snprintf(sMilliTM, sizeof(sMilliTM), &quot;%03d&quot;, tTimeB.millitm);</div><div class="line"></div><div class="line">    fp = fopen(sLogFile, &quot;a+&quot;);</div><div class="line">    if (fp != (FILE*)NULL) &#123;</div><div class="line">        fprintf(fp, &quot;[%08d][%.6s:%.3s][%16s][%04d][%7s]&quot;,</div><div class="line">                getpid(), sCurrTime, sMilliTM, filename, line, g_LevelDsp[level]);</div><div class="line">        va_start(ap, fmt);</div><div class="line">        vfprintf(fp, fmt, ap);</div><div class="line">        va_end(ap);</div><div class="line">        fprintf(fp, &quot;\n&quot;);</div><div class="line">        fflush(fp);</div><div class="line">        fclose(fp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再在后台进程中设置TraceLevel和TraceName即可。</p>
<h4 id="获取当前系统日期、时间"><a href="#获取当前系统日期、时间" class="headerlink" title="获取当前系统日期、时间"></a>获取当前系统日期、时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/*****************************************************************************</div><div class="line">  **  函数名称: GetDate</div><div class="line">  **  功能描述: 取当前系统日期                           </div><div class="line">  **  当前版本: 1.0.0.0                                                    </div><div class="line">  **  作    者:                                             </div><div class="line">  **  修    改：                                                        </div><div class="line">  **  输入参数:</div><div class="line">  **  输出参数: char * psDate  -- 系统日期, 格式为yyyymmdd</div><div class="line">  **  返回结果：int</div><div class="line">                   0    ---&gt;  成功</div><div class="line">  ****************************************************************************/</div><div class="line">int GetDate(char * psDate)</div><div class="line">&#123;</div><div class="line">    time_t nSeconds;</div><div class="line">    struct tm * pTM;</div><div class="line"></div><div class="line">    time(&amp;nSeconds);</div><div class="line">    pTM = localtime(&amp;nSeconds);</div><div class="line"></div><div class="line">    /* 系统日期, 格式：YYYYMMDD */</div><div class="line">    sprintf( psDate,&quot;%04d%02d%02d&quot;,</div><div class="line">            pTM-&gt;tm_year + 1900, pTM-&gt;tm_mon + 1,pTM-&gt;tm_mday );</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/*****************************************************************************</div><div class="line">  **  函数名称: GetTime</div><div class="line">  **  功能描述: 取当前系统时间                           </div><div class="line">  **  当前版本: 1.0.0.0                                                    </div><div class="line">  **  作    者:                                            </div><div class="line">  **  修    改：                                                        </div><div class="line">  **  输入参数:</div><div class="line">  **  输出参数: char * psTime  -- 系统时间, 格式为HHMMSS</div><div class="line">  **  返回结果：int</div><div class="line">                   0    ---&gt;  成功</div><div class="line">  ****************************************************************************/</div><div class="line">int GetTime(char * psTime)</div><div class="line">&#123;</div><div class="line">    time_t nSeconds;</div><div class="line">    struct tm * pTM;</div><div class="line"></div><div class="line">    time(&amp;nSeconds);</div><div class="line">    pTM = localtime(&amp;nSeconds);</div><div class="line"></div><div class="line">    /* 系统时间, 格式：HHMMSS */</div><div class="line">    sprintf( psTime,&quot;%02d%02d%02d&quot;,</div><div class="line">            pTM-&gt;tm_hour,pTM-&gt;tm_min, pTM-&gt;tm_sec);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/*****************************************************************************</div><div class="line">  **  函数名称: GetDateTime</div><div class="line">  **  功能描述: 取当前系统日期和时间                           </div><div class="line">  **  当前版本: 1.0.0.0                                                    </div><div class="line">  **  作    者:                                            </div><div class="line">  **  修    改：                                                        </div><div class="line">  **  输入参数:</div><div class="line">  **  输出参数: char * psDateTime  -- 系统日期时间, 格式为yyyymmddHHMMSS</div><div class="line">  **  返回结果：int</div><div class="line">                   0    ---&gt;  成功</div><div class="line">  ****************************************************************************/</div><div class="line">int GetDateTime(char * psDateTime)</div><div class="line">&#123;</div><div class="line">    time_t nSeconds;</div><div class="line">    struct tm * pTM;</div><div class="line"></div><div class="line">    time(&amp;nSeconds);</div><div class="line">    pTM = localtime(&amp;nSeconds);</div><div class="line"></div><div class="line">    /* 系统日期和时间, 格式：yyyymmddHHMMSS */</div><div class="line">    sprintf( psDateTime,&quot;%04d%02d%02d%02d%02d%02d&quot;,</div><div class="line">            pTM-&gt;tm_year + 1900, pTM-&gt;tm_mon + 1,pTM-&gt;tm_mday,</div><div class="line">            pTM-&gt;tm_hour,pTM-&gt;tm_min, pTM-&gt;tm_sec );</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用的时候定义一个char数组，大小为日期的长度大小加1，然后直接调用上面的函数，参数为数组名即可。
　　当然，还有其他许多关于日期、时间操作的函数，比如不同日期、时间格式间的转换等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;架构类&quot;&gt;&lt;a href=&quot;#架构类&quot; class=&quot;headerlink&quot; title=&quot;架构类&quot;&gt;&lt;/a&gt;架构类&lt;/h3&gt;&lt;h4 id=&quot;Linux-C代码实现主函数参数选项解析&quot;&gt;&lt;a href=&quot;#Linux-C代码实现主函数参数选项解析&quot; class=&quot;
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="C" scheme="http://wodekouwei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>FQA</title>
    <link href="http://wodekouwei.com/2017/07/25/FQA/"/>
    <id>http://wodekouwei.com/2017/07/25/FQA/</id>
    <published>2017-07-25T12:42:03.000Z</published>
    <updated>2017-07-25T12:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="ssh连接服务器出错"><a href="#ssh连接服务器出错" class="headerlink" title="ssh连接服务器出错"></a>ssh连接服务器出错</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</div><div class="line">@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @</div><div class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</div><div class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</div><div class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</div><div class="line">It is also possible that a host key has just been changed.</div><div class="line">The fingerprint for the RSA key sent by the remote host is</div><div class="line">da:f7:3e:ba:f7:00:e6:44:76:f2:58:6e:48:**.</div><div class="line">Please contact your system administrator.</div><div class="line">Add correct host key in /用户home目录/.ssh/known_hosts to get rid of this message.</div><div class="line">Offending RSA key in /用户home目录/.ssh/known_hosts:1</div><div class="line">RSA host key for ip地址 has changed and you have requested strict checking.</div><div class="line">Host key verification failed.</div></pre></td></tr></table></figure>
<p>出现这个问题的原因是,第一次使用SSH连接时，会生成一个认证，储存在客户端的known_hosts中.</p>
<p>可使用以下指令查看:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -l -f ~/.ssh/known_hosts</div></pre></td></tr></table></figure></p>
<p>由于服务器重新安装系统了，所以会出现以上错误。
解决办法:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -R 服务器端的ip地址</div></pre></td></tr></table></figure></p>
<p>或者直接在known_hosts中删除对应ip的行</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;ssh连接服务器出错&quot;&gt;&lt;a href=&quot;#ssh连接服务器出错&quot; class=&quot;headerlink&quot; title=&quot;ssh连接服务器出错&quot;&gt;&lt;/a&gt;ssh连接服务器出错&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
    
    </summary>
    
    
  </entry>
  
</feed>
