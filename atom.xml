<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老司机种菜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wodekouwei.com/"/>
  <updated>2018-01-12T12:23:00.691Z</updated>
  <id>http://wodekouwei.com/</id>
  
  <author>
    <name>轻口味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tips-android-pluggable-6</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-6/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-6/</id>
    <published>2018-01-12T12:23:00.000Z</published>
    <updated>2018-01-12T12:23:00.691Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-android-pluggable-5</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-5/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-5/</id>
    <published>2018-01-12T12:22:57.000Z</published>
    <updated>2018-01-12T12:22:57.937Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tips-android-pluggable-4</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-4/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-4/</id>
    <published>2018-01-12T12:22:24.000Z</published>
    <updated>2018-01-12T12:22:24.042Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化(三)基础之Android应用程序资源的编译和打包过程分析</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-3/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-3/</id>
    <published>2018-01-12T12:19:09.000Z</published>
    <updated>2018-01-13T06:29:35.012Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(三)基础之反射与代理</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-2/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-2/</id>
    <published>2018-01-12T08:38:36.000Z</published>
    <updated>2018-01-12T12:25:27.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h3><p>反射机制中的类：</p>
<ul>
<li>java.lang.Class;                </li>
<li>java.lang.reflect.Constructor;</li>
<li>java.lang.reflect.Field;</li>
<li>java.lang.reflect.Method;</li>
<li>java.lang.reflect.Modifier;</li>
</ul>
<ol>
<li><p>获取Class的三种方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/第一种方式：  </div><div class="line">Classc1 = Class.forName(&quot;Employee&quot;);  </div><div class="line">//第二种方式：  </div><div class="line">//java中每个类型都有class 属性.  </div><div class="line">Classc2 = Employee.class;  </div><div class="line"></div><div class="line">//第三种方式：  </div><div class="line">//java语言中任何一个java对象都有getClass 方法  </div><div class="line">Employeee = new Employee();  </div><div class="line">Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)</div></pre></td></tr></table></figure>
</li>
<li><p>创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class c =Class.forName(&quot;Employee&quot;);  </div><div class="line"></div><div class="line">//创建此Class 对象所表示的类的一个新实例  </div><div class="line">Objecto = c.newInstance(); //调用了Employee的无参数构造方法.</div></pre></td></tr></table></figure>
</li>
<li><p>获取属性：分为所有的属性和指定的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//获取整个类  </div><div class="line">Class c = Class.forName(&quot;java.lang.Integer&quot;);  </div><div class="line">  //获取所有的属性?  </div><div class="line">Field[] fs = c.getDeclaredFields();  </div><div class="line"></div><div class="line">//定义可变长的字符串，用来存储属性  </div><div class="line">StringBuffer sb = new StringBuffer();  </div><div class="line">//通过追加的方法，将每个属性拼接到此字符串中  </div><div class="line">//最外边的public定义  </div><div class="line">sb.append(Modifier.toString(c.getModifiers()) + &quot; class &quot; + c.getSimpleName() +&quot;&#123;\n&quot;);  </div><div class="line">//里边的每一个属性  </div><div class="line">for(Field field:fs)&#123;  </div><div class="line">    sb.append(&quot;\t&quot;);//空格  </div><div class="line">    sb.append(Modifier.toString(field.getModifiers())+&quot; &quot;);//获得属性的修饰符，例如public，static等等  </div><div class="line">    sb.append(field.getType().getSimpleName() + &quot; &quot;);//属性的类型的名字  </div><div class="line">    sb.append(field.getName()+&quot;;\n&quot;);//属性的名字+回车  </div><div class="line">&#125;  </div><div class="line">sb.append(&quot;&#125;&quot;);  </div><div class="line">System.out.println(sb);  </div><div class="line"></div><div class="line"></div><div class="line">//获取特定属性</div><div class="line">//获取类  </div><div class="line">Class c = Class.forName(&quot;User&quot;);  </div><div class="line">//获取id属性  </div><div class="line">Field idF = c.getDeclaredField(&quot;id&quot;);  </div><div class="line">//实例化这个类赋给o  </div><div class="line">Object o = c.newInstance();  </div><div class="line">//打破封装  </div><div class="line">idF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。  </div><div class="line">//给o对象的id属性赋值&quot;110&quot;  </div><div class="line">idF.set(o, &quot;110&quot;); //set  </div><div class="line">//get  </div><div class="line">System.out.println(idF.get(o));</div></pre></td></tr></table></figure>
</li>
<li><p>关键字</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredMethods()</td>
<td>获取所有的方法</td>
</tr>
<tr>
<td>getReturnType()</td>
<td>获得方法的放回类型</td>
</tr>
<tr>
<td>getParameterTypes()</td>
<td>获得方法的传入参数类型</td>
</tr>
<tr>
<td>getDeclaredMethod(“方法名”,参数类型.class,……)</td>
<td>获得特定的方法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>构造方法关键字</td>
<td>含义</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>获取所有的构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructor(参数类型.class,……)</td>
<td>获取特定的构造方法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>父类和父接口</td>
<td>含义</td>
</tr>
<tr>
<td>getSuperclass()</td>
<td>获取某类的父类</td>
</tr>
<tr>
<td>getInterfaces()</td>
<td>获取某类实现的接口</td>
</tr>
</tbody>
</table>
<h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a>2.代理模式</h3><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。
<img src="http://images.wodekouwei.com/technology/oh3VMNs.gif" alt="image"></p>
<ul>
<li>RealSubject 是原对象（本文把原对象称为”委托对象”），Proxy 是代理对象。</li>
<li>Subject 是委托对象和代理对象都共同实现的接口。</li>
<li>Request() 是委托对象和代理对象共同拥有的方法。</li>
</ul>
<p>Java 实现上面的UML图的代码（即实现静态代理）为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class ProxyDemo &#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        RealSubject subject = new RealSubject();</div><div class="line">        Proxy p = new Proxy(subject);</div><div class="line">        p.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Subject&#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RealSubject implements Subject&#123;</div><div class="line">    public void request()&#123;</div><div class="line">        System.out.println(&quot;request&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Proxy implements Subject&#123;</div><div class="line">    private Subject subject;</div><div class="line">    public Proxy(Subject subject)&#123;</div><div class="line">        this.subject = subject;</div><div class="line">    &#125;</div><div class="line">    public void request()&#123;</div><div class="line">        System.out.println(&quot;PreProcess&quot;);</div><div class="line">        subject.request();</div><div class="line">        System.out.println(&quot;PostProcess&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代理的实现分为：</p>
<ul>
<li>静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。</li>
<li>动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</li>
</ul>
<h4 id="2-1Java-实现动态代理"><a href="#2-1Java-实现动态代理" class="headerlink" title="2.1Java 实现动态代理"></a>2.1Java 实现动态代理</h4><p>首先先说明几个词：</p>
<ul>
<li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例。</li>
<li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li>
</ul>
<p>Java实现动态代理的大致步骤如下：</p>
<ol>
<li>定义一个委托类和公共接口。</li>
<li>自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li>
<li>生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li>
</ol>
<p>Java 实现动态代理主要涉及以下几个类：
<code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 DynamicProxyClass extends Proxy。
<code>java.lang.reflect.InvocationHandler</code>: 这里称他为”调用处理器”，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。</p>
<p>Proxy 类主要方法为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建代理对象  </div><div class="line">static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</div></pre></td></tr></table></figure></p>
<p>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么）。这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用newProxyInstance()时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)</div><div class="line">&#123;</div><div class="line">    //1. 根据类加载器和接口创建代理类</div><div class="line">    Class clazz = Proxy.getProxyClass(loader, interfaces);</div><div class="line">    //2. 获得代理类的带参数的构造函数</div><div class="line">    Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;);</div><div class="line">    //3. 创建代理对象，并制定调用处理器实例为参数传入</div><div class="line">    Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123;handler&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Proxy 类还有一些静态方法，比如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InvocationHandler getInvocationHandler(Object proxy): 获得代理对象对应的调用处理器对象。</div><div class="line">Class getProxyClass(ClassLoader loader, Class[] interfaces): 根据类加载器和实现的接口获得代理类。</div></pre></td></tr></table></figure></p>
<p>Proxy 类中有一个映射表，映射关系为：(<classloader>,(<interfaces>,<proxyclass>) )，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</proxyclass></interfaces></classloader></p>
<p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class DynamicProxyDemo01 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        RealSubject realSubject = new RealSubject();    //1.创建委托对象</div><div class="line">        ProxyHandler handler = new ProxyHandler(realSubject);   //2.创建调用处理器对象</div><div class="line">        Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject.class.getClassLoader(),</div><div class="line">        RealSubject.class.getInterfaces(), handler);    //3.动态生成代理对象</div><div class="line">        proxySubject.request(); //4.通过代理对象调用方法</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 接口</div><div class="line"> */</div><div class="line">interface Subject&#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 委托类</div><div class="line"> */</div><div class="line">class RealSubject implements Subject&#123;</div><div class="line">    public void request()&#123;</div><div class="line">        System.out.println(&quot;====RealSubject Request====&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 代理类的调用处理器</div><div class="line"> */</div><div class="line">class ProxyHandler implements InvocationHandler&#123;</div><div class="line">    private Subject subject;</div><div class="line">    public ProxyHandler(Subject subject)&#123;</div><div class="line">        this.subject = subject;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">            throws Throwable &#123;</div><div class="line">        System.out.println(&quot;====before====&quot;);//定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作</div><div class="line">        Object result = method.invoke(subject, args);</div><div class="line">        System.out.println(&quot;====after====&quot;);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>InvocationHandler 接口中有方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">invoke(Object proxy, Method method, Object[] args)</div></pre></td></tr></table></figure></p>
<p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</p>
<p>动态生成的代理类具有几个特点：</p>
<ul>
<li>继承 Proxy 类，并实现了在Proxy.newProxyInstance()中提供的接口数组。</li>
<li>public final。</li>
<li>命名方式为 $ProxyN，其中N会慢慢增加，一开始是 $Proxy1，接下来是$Proxy2…</li>
<li>有一个参数为 InvocationHandler 的构造函数。这个从 Proxy.newProxyInstance() 函数内部的clazz.getConstructor(new Class[] { InvocationHandler.class }) 可以看出。</li>
</ul>
<p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p>
<blockquote>
<p>不难发现，代理类的实现是有很多共性的（重复代码），动态代理的好处在于避免了这些重复代码，只需要关注操作。</p>
</blockquote>
<h4 id="2-2Java-动态代理的内部实现"><a href="#2-2Java-动态代理的内部实现" class="headerlink" title="2.2Java 动态代理的内部实现"></a>2.2Java 动态代理的内部实现</h4><p>现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 InvocationHandler 的 invoke() 方法的？</p>
<p>这就涉及到动态代理的内部实现。假设有一个接口 Subject，且里面有 int request(int i) 方法，则生成的代理类大致如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final class $Proxy1 extends Proxy implements Subject&#123;</div><div class="line">    private InvocationHandler h;</div><div class="line">    private $Proxy1()&#123;&#125;</div><div class="line">    public $Proxy1(InvocationHandler h)&#123;</div><div class="line">        this.h = h;</div><div class="line">    &#125;</div><div class="line">    public int request(int i)&#123;</div><div class="line">        Method method = Subject.class.getMethod(&quot;request&quot;, new Class[]&#123;int.class&#125;); //创建method对象</div><div class="line">        return (Integer)h.invoke(this, method, new Object[]&#123;new Integer(i)&#125;); //调用了invoke方法</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面的方法就成功调用了 invoke() 方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-反射&quot;&gt;&lt;a href=&quot;#1-反射&quot; class=&quot;headerlink&quot; title=&quot;1.反射&quot;&gt;&lt;/a&gt;1.反射&lt;/h3&gt;&lt;p&gt;反射机制中的类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.lang.Class;                &lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(二)基础之类加载器</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-1/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-1/</id>
    <published>2018-01-12T08:35:40.000Z</published>
    <updated>2018-01-12T12:25:31.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是ClassLoader"><a href="#1-什么是ClassLoader" class="headerlink" title="1.什么是ClassLoader"></a>1.什么是ClassLoader</h3><p>当我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。</p>
<h3 id="2-Java-ClassLoader"><a href="#2-Java-ClassLoader" class="headerlink" title="2.Java ClassLoader"></a>2.Java ClassLoader</h3><h4 id="2-1-Java默认提供的三个ClassLoader"><a href="#2-1-Java默认提供的三个ClassLoader" class="headerlink" title="2.1.Java默认提供的三个ClassLoader"></a>2.1.Java默认提供的三个ClassLoader</h4><ol>
<li>BootStrap ClassLoader：
称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();  </div><div class="line">for (int i = 0; i &lt; urls.length; i++) &#123;  </div><div class="line">    System.out.println(urls[i].toExternalForm());  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以下内容是上述程序从本机JDK环境所获得的结果：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/resources.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/rt.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/sunrsasign.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jsse.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jce.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/charsets.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jfr.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/classes</div></pre></td></tr></table></figure></p>
<p>其实上述结果也是通过查找sun.boot.class.path这个系统属性所得知的。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</div></pre></td></tr></table></figure></p>
<p>打印结果:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/resources.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/rt.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/sunrsasign.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jsse.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jce.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/charsets.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jfr.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/classes</div></pre></td></tr></table></figure></p>
<ol>
<li>Extension ClassLoader：
称为扩展类加载器，负责加载Java的扩展类库，默认加载<code>JAVA_HOME/jre/lib/ext/</code>目下的所有jar。</li>
<li>App ClassLoader：
称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</li>
</ol>
<p>除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</p>
<h4 id="2-2ClassLoader加载类的原理"><a href="#2-2ClassLoader加载类的原理" class="headerlink" title="2.2ClassLoader加载类的原理"></a>2.2ClassLoader加载类的原理</h4><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p>
<p>这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p>
<p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。现在通过实例来验证上述所描述的是否正确:</p>
<ol>
<li>在web服务器上建一个org.classloader.simple.NetClassLoaderSimple.java类<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package org.classloader.simple;  </div><div class="line"></div><div class="line">public class NetClassLoaderSimple &#123;  </div><div class="line"></div><div class="line">    private NetClassLoaderSimple instance;  </div><div class="line"></div><div class="line">    public void setNetClassLoaderSimple(Object obj) &#123;  </div><div class="line">        this.instance = (NetClassLoaderSimple)obj;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>org.classloader.simple.NetClassLoaderSimple类的setNetClassLoaderSimple方法接收一个Object类型参数，并将它强制转换成org.classloader.simple.NetClassLoaderSimple类型。</p>
<ol>
<li>测试两个class是否相同
<code>NetWorkClassLoader.java</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">package classloader;</div><div class="line"></div><div class="line">import java.io.ByteArrayOutputStream;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 加载网络class的ClassLoader</div><div class="line"> */</div><div class="line">public class NetworkClassLoader extends ClassLoader &#123;</div><div class="line"></div><div class="line">	private String rootUrl;</div><div class="line"></div><div class="line">	public NetworkClassLoader(String rootUrl) &#123;</div><div class="line">		this.rootUrl = rootUrl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class="line">		Class clazz = null;//this.findLoadedClass(name); // 父类已加载</div><div class="line">		//if (clazz == null) &#123;	//检查该类是否已被加载过</div><div class="line">			byte[] classData = getClassData(name);	//根据类的二进制名称,获得该class文件的字节码数组</div><div class="line">			if (classData == null) &#123;</div><div class="line">				throw new ClassNotFoundException();</div><div class="line">			&#125;</div><div class="line">			clazz = defineClass(name, classData, 0, classData.length);	//将class的字节码数组转换成Class类的实例</div><div class="line">		//&#125;</div><div class="line">		return clazz;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private byte[] getClassData(String name) &#123;</div><div class="line">		InputStream is = null;</div><div class="line">		try &#123;</div><div class="line">			String path = classNameToPath(name);</div><div class="line">			URL url = new URL(path);</div><div class="line">			byte[] buff = new byte[1024*4];</div><div class="line">			int len = -1;</div><div class="line">			is = url.openStream();</div><div class="line">			ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class="line">			while((len = is.read(buff)) != -1) &#123;</div><div class="line">				baos.write(buff,0,len);</div><div class="line">			&#125;</div><div class="line">			return baos.toByteArray();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; finally &#123;</div><div class="line">			if (is != null) &#123;</div><div class="line">			   try &#123;</div><div class="line">			      is.close();</div><div class="line">			   &#125; catch(IOException e) &#123;</div><div class="line">			      e.printStackTrace();</div><div class="line">			   &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private String classNameToPath(String name) &#123;</div><div class="line">		return rootUrl + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package classloader;  </div><div class="line"></div><div class="line">public class NewworkClassLoaderTest &#123;  </div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        try &#123;  </div><div class="line">            //测试加载网络中的class文件  </div><div class="line">            String rootUrl = &quot;http://localhost:8080/httpweb/classes&quot;;  </div><div class="line">            String className = &quot;org.classloader.simple.NetClassLoaderSimple&quot;;  </div><div class="line">            NetworkClassLoader ncl1 = new NetworkClassLoader(rootUrl);  </div><div class="line">            NetworkClassLoader ncl2 = new NetworkClassLoader(rootUrl);  </div><div class="line">            Class&lt;?&gt; clazz1 = ncl1.loadClass(className);  </div><div class="line">            Class&lt;?&gt; clazz2 = ncl2.loadClass(className);  </div><div class="line">            Object obj1 = clazz1.newInstance();  </div><div class="line">            Object obj2 = clazz2.newInstance();  </div><div class="line">            clazz1.getMethod(&quot;setNetClassLoaderSimple&quot;, Object.class).invoke(obj1, obj2);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得网络上一个class文件的二进制名称，然后通过自定义的类加载器NetworkClassLoader创建两个实例，并根据网络地址分别加载这份class，并得到这两个ClassLoader实例加载后生成的Class实例clazz1和clazz2，最后将这两个Class实例分别生成具体的实例对象obj1和obj2，再通过反射调用clazz1中的setNetClassLoaderSimple方法。</p>
<p>结果抛出<code>java.lang.ClassCastgException</code>,虽然是同一份class字节码文件，但是由于被两个不同的ClassLoader实例所加载，所以JVM认为它们就是两个不同的类。</p>
<h4 id="2-3ClassLoader的体系架构："><a href="#2-3ClassLoader的体系架构：" class="headerlink" title="2.3ClassLoader的体系架构："></a>2.3ClassLoader的体系架构：</h4><p><img src="http://images.wodekouwei.com/technology/classloader.gif" alt="iamge"></p>
<p>打印ClassLoader类的层次结构:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ClassLoader loader = ClassLoaderTest.class.getClassLoader();    //获得加载ClassLoaderTest.class这个类的类加载器  </div><div class="line">while(loader != null) &#123;  </div><div class="line">    System.out.println(loader);  </div><div class="line">    loader = loader.getParent();    //获得父类加载器的引用  </div><div class="line">&#125;  </div><div class="line">System.out.println(loader);</div></pre></td></tr></table></figure></p>
<p>输出:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</div><div class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</div><div class="line">null</div></pre></td></tr></table></figure></p>
<p>第一行结果说明：ClassLoaderTest的类加载器是AppClassLoader。</p>
<p>第二行结果说明：AppClassLoader的类加器是ExtClassLoader，即parent=ExtClassLoader。</p>
<p>第三行结果说明：ExtClassLoader的类加器是Bootstrap ClassLoader，因为Bootstrap ClassLoader不是一个普通的Java类，所以ExtClassLoader的parent=null，所以第三行的打印结果为null就是这个原因。</p>
<ul>
<li>将ClassLoaderTest.class打包成ClassLoaderTest.jar，放到Extension ClassLoader的加载目录下（JAVA_HOME/jre/lib/ext）可以测试Extension ClassLoader</li>
<li>在jvm中添加-Xbootclasspath参数，指定Bootstrcp ClassLoader加载类的路径，并追加我们自已的jar（ClassTestLoader.jar）或 将class文件放到JAVA_HOME/jre/classes/目录下测试用Bootstrcp ClassLoader加载ClassLoaderTest.class.</li>
</ul>
<h4 id="2-4定义自己的ClassLoader"><a href="#2-4定义自己的ClassLoader" class="headerlink" title="2.4定义自己的ClassLoader:"></a>2.4定义自己的ClassLoader:</h4><p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</p>
<p><strong>定义自已的类加载器分为两步：</strong></p>
<ol>
<li>继承java.lang.ClassLoader</li>
<li>重写父类的findClass方法</li>
</ol>
<blockquote>
<p>参考:<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="external">深入探讨 Java 类加载器</a></p>
<h3 id="3-Android-ClassLoader"><a href="#3-Android-ClassLoader" class="headerlink" title="3.Android ClassLoader"></a>3.Android ClassLoader</h3><p>Android ClassLoader种类：</p>
<ul>
<li>DexClassLoader：可以加载文件系统上的jar、dex、apk</li>
<li>PathClassLoader：可以加载/data/app目录下的apk，这也意味着，它只能加载已经安装的apk</li>
<li>URLClassLoader：可以加载java中的jar，但是由于dalvik不能直接识别jar，所以此方法在android中无法使用</li>
</ul>
</blockquote>
<p>Android开发和普通的java开发不同的地方是把class文件再重新打包成dex类型的文件，这种重新打包会对Class文件内部的各种函数表、变量表等进行优化。dex文件是一种经过android打包工具优化后的Class文件，因此加载这样特殊的Class文件就需要特殊的类装载器，所以android中提供了DexClassLoader类。加载流程如下：</p>
<ol>
<li>通过PacageMangager获得指定的apk的安装的目录，dex的解压缩目录，c/c++库的目录</li>
<li>创建一个 DexClassLoader实例</li>
<li>加载指定的类返回一个Class</li>
<li>然后使用反射调用这个Class</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-什么是ClassLoader&quot;&gt;&lt;a href=&quot;#1-什么是ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;1.什么是ClassLoader&quot;&gt;&lt;/a&gt;1.什么是ClassLoader&lt;/h3&gt;&lt;p&gt;当我们写好一个Java程序之
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>(转)聊一聊机器学习的MLE和MAP:最大似然估计和最大后验估计</title>
    <link href="http://wodekouwei.com/2018/01/08/tips-ml-mle-map/"/>
    <id>http://wodekouwei.com/2018/01/08/tips-ml-mle-map/</id>
    <published>2018-01-08T09:36:01.000Z</published>
    <updated>2018-01-08T10:15:40.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TLDR-or-the-take-away"><a href="#TLDR-or-the-take-away" class="headerlink" title="TLDR (or the take away)"></a>TLDR (or the take away)</h3><ul>
<li>概率学派 - Frequentist - Maximum Likelihood Estimation(MLE,最大似然估计)</li>
<li>贝叶斯学派 - Baysesian - Maximum A Posteriori(MAP, 最大后验估计)</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>有时候和别人聊天，对方会说自己有很多机器学习经验，深入一聊发现，对方竟然对MLE和MAP一知半解，至少在我看来，这位同学的机器学习基础并不扎实。难道在这个深度学习盛行的年代，不少同学都只注重调参数？</p>
<p>现代机器学习的终极问题都会转化为解目标函数的优化问题，MLE和MAP是生成这个函数的很基本的思想，因此我们对二者的认知是非常重要的。这次就和大家认真聊一聊MLE和MAP这两种estimator。</p>
<h3 id="两大学派的争论"><a href="#两大学派的争论" class="headerlink" title="两大学派的争论"></a>两大学派的争论</h3><p>抽象一点来讲，频率学派和贝叶斯学派对世界的认知有本质不同：频率学派认为世界是确定的，有一个本体，这个本体的真值是不变的，我们的目标就是要找到这个真值或真值所在的范围；而贝叶斯学派认为世界是不确定的，人们对世界先有一个预判，而后通过观测数据对这个预判做调整，我们的目标是要找到最优的描述这个世界的概率分布。</p>
<p>在对事物建模时，用 θ  表示模型的参数，请注意，解决问题的本质就是求θ 。那么：
<strong>(1) 频率学派：</strong> 存在唯一真值 θ  。举一个简单直观的例子–抛硬币，我们用 P(head) 来表示硬币的bias。抛一枚硬币100次，有20次正面朝上，要估计抛硬币正面朝上的bias P(head)=θ。在频率学派来看，θ = 20 / 100 = 0.2，很直观。当数据量趋于无穷时，这种方法能给出精准的估计；然而缺乏数据时则可能产生严重的偏差。例如，对于一枚均匀硬币，即 θ = 0.5，抛掷5次，出现5次正面 (这种情况出现的概率是1/2^5=3.125%)，频率学派会直接估计这枚硬币 θ = 1，出现严重错误。</p>
<p><strong>(2) 贝叶斯学派：</strong> θ 是一个随机变量，符合一定的概率分布。在贝叶斯学派里有两大输入和一大输出，输入是先验 (prior)和似然 (likelihood)，输出是后验 (posterior)。先验，即 P(θ) ，指的是在没有观测到任何数据时对 θ 的预先判断，例如给我一个硬币，一种可行的先验是认为这个硬币有很大的概率是均匀的，有较小的概率是是不均匀的；似然，即 P(X|θ) ，是假设 θ 已知后我们观察到的数据应该是什么样子的；后验，即 P(θ|X) ，是最终的参数分布。贝叶斯估计的基础是贝叶斯公式，如下：</p>
<p>$P(\theta|X)=\frac{P(X|\theta) \times P(\theta)}{P(X)}$</p>
<p>同样是抛硬币的例子，对一枚均匀硬币抛5次得到5次正面，那么 P(head) ，即 P(θ|X) ，是一个distribution，最大值会介于0.5~1之间，而不是武断的 θ = 1。</p>
<p>这里有两点值得注意的地方：</p>
<p>随着数据量的增加，参数分布会越来越向数据靠拢，先验的影响力会越来越小
如果先验是uniform distribution，则贝叶斯方法等价于频率方法。因为直观上来讲，先验是uniform distribution本质上表示对事物没有任何预判</p>
<h3 id="MLE-最大似然估计"><a href="#MLE-最大似然估计" class="headerlink" title="MLE - 最大似然估计"></a>MLE - 最大似然估计</h3><p>Maximum Likelihood Estimation, MLE是频率学派常用的估计方法！</p>
<p>假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。其中i.i.d.表示Independent and identical distribution，独立同分布。那么MLE对 $\theta$ 的估计方法可以如下推导：</p>
<p>Maximum Likelihood Estimation, MLE是频率学派常用的估计方法！</p>
<p>假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。其中i.i.d.表示Independent and identical distribution，独立同分布。那么MLE对 $\theta$ 的估计方法可以如下推导：</p>
<p>最后这一行所优化的函数被称为Negative Log Likelihood (NLL)，这个概念和上面的推导是非常重要的！</p>
<p>我们经常在不经意间使用MLE，例如</p>
<ul>
<li>上文中关于频率学派求硬币概率的例子，其方法其实本质是由优化NLL得出。本文末尾附录中给出了具体的原因 :-)</li>
<li>给定一些数据，求对应的高斯分布时，我们经常会算这些数据点的均值和方差然后带入到高斯分布的公式，其理论依据是优化NLL</li>
<li>深度学习做分类任务时所用的cross entropy loss，其本质也是MLE</li>
</ul>
<h3 id="MAP-最大后验估计"><a href="#MAP-最大后验估计" class="headerlink" title="MAP - 最大后验估计"></a>MAP - 最大后验估计</h3><p>Maximum A Posteriori, MAP是贝叶斯学派常用的估计方法！</p>
<p>同样的，假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。那么MLE对 $\theta$ 的估计方法可以如下推导：
其中，第二行到第三行使用了贝叶斯定理，第三行到第四行P(X) 可以丢掉因为与 $\theta$ 无关。注意 $-\log P(X|\theta )$ 其实就是NLL，所以MLE和MAP在优化时的不同就是在于先验项 - $\log P(\theta) $。好的，那现在我们来研究一下这个先验项，假定先验是一个高斯分布，即</p>
<p>$P(\theta) = \text{constant} \times e^{-\frac{\theta^2}{2\sigma^2}}$</p>
<p>那么， $-\log P(\theta) = \text{constant} + \frac{\theta^2}{2\sigma^2} $。至此，一件神奇的事情发生了 – 在MAP中使用一个高斯分布的先验等价于在MLE中采用L2的regularizaton！</p>
<p>再稍微补充几点：</p>
<ul>
<li>我们不少同学大学里学习概率论时，最主要的还是频率学派的思想，其实贝叶斯学派思想也非常流行，而且实战性很强</li>
<li>CMU的很多老师都喜欢用贝叶斯思想解决问题；我本科时的导师朱军老师也在做<a href="https://arxiv.org/abs/1709.05870" target="_blank" rel="external">贝叶斯深度学习</a>的工作，有兴趣可以关注一下。</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>有的同学说：“了解这些没用，现在大家都不用了。”这种想法是不对的，因为这是大家常年在用的知识，是推导优化函数的核心，而优化函数又是机器学习 (包含深度学习) 的核心之一。这位同学有这样的看法，说明对机器学习的本质并没有足够的认识，而让我吃惊的是，竟然有不少其他同学为这种看法点赞。内心感到有点儿悲凉，也引发了我写这篇文章的动力，希望能帮到一些朋友 :-)</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>[1] <a href="http://link.zhihu.com/?target=http%3A//www.utdallas.edu/%7Enrr150130/cs7301/2016fa/lects/Lecture_14_Bayes.pdf" target="_blank" rel="external">Bayesian Method Lecture</a>, UT Dallas.</p>
</li>
<li><p>[2] <a href="http://link.zhihu.com/?target=http%3A//www.utdallas.edu/%7Enrr150130/cs7301/2016fa/lects/Lecture_14_Bayes.pdf" target="_blank" rel="external">MLE, MAP, Bayes classification Lecture</a>, CMU.</p>
</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>为什么说频率学派求硬币概率的算法本质是在优化NLL？</p>
<p>因为抛硬币可以表示为参数为 $\theta$  的Bernoulli分布，即</p>
<p>$P(x_i; \theta) =\left{ \begin{array}{ll} \theta &amp; x_i = 1 \ 1 - \theta &amp; x_i = 0 \ \end{array} \right. \ = \theta^{x_i} (1- \theta)^{1-x_i}$</p>
<p>其中 x_i = 1 表示第 i 次抛出正面。那么，</p>
<p>$\text{NLL} = -\sum_{i=1}^n \log P(x<em>i; \theta) = -\sum</em>{i=1}^n \log \theta^{x_i} (1- \theta)^{1-x_i}$</p>
<p>求导数并使其等于零，得到</p>
<p>$\text{NLL}’ = -\sum_{i=1}^n\Big(\frac{x_i}{\theta} + (1-x_i)\frac{-1}{1-\theta}\Big) = 0$</p>
<p>即 $\hat{\theta} = \frac{\sum_{i=1}^n x_i}{n}$ ，也就是出现正面的次数除以总共的抛掷次数。</p>
<blockquote>
<p>转自<a href="https://zhuanlan.zhihu.com/p/32480810" target="_blank" rel="external">聊一聊机器学习的MLE和MAP：最大似然估计和最大后验估计</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TLDR-or-the-take-away&quot;&gt;&lt;a href=&quot;#TLDR-or-the-take-away&quot; class=&quot;headerlink&quot; title=&quot;TLDR (or the take away)&quot;&gt;&lt;/a&gt;TLDR (or the take awa
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
      <category term="reprint" scheme="http://wodekouwei.com/tags/reprint/"/>
    
  </entry>
  
  <entry>
    <title>机器学习资源</title>
    <link href="http://wodekouwei.com/2017/12/29/tips-ml-res/"/>
    <id>http://wodekouwei.com/2017/12/29/tips-ml-res/</id>
    <published>2017-12-29T01:59:09.000Z</published>
    <updated>2018-01-08T09:50:27.006Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/andabi/deep-voice-conversion" target="_blank" rel="external">deep-voice-conversion</a>:Deep neural networks for voice conversion (voice style transfer) in Tensorflow</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/andabi/deep-voice-conversion&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;deep-voice-conversion&lt;/a&gt;:Deep neural networks f
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
      <category term="res" scheme="http://wodekouwei.com/tags/res/"/>
    
  </entry>
  
  <entry>
    <title>FLV格式解析</title>
    <link href="http://wodekouwei.com/2017/12/20/m-f-flv/"/>
    <id>http://wodekouwei.com/2017/12/20/m-f-flv/</id>
    <published>2017-12-20T06:49:06.000Z</published>
    <updated>2018-01-08T11:37:26.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流的视频网站无一例外地使用了FLV格式。另外由于当前浏览器与Flash Player紧密的结合，使得网页播放FLV视频轻而易举，也是FLV流行的原因之一。</p>
<p>FLV是流媒体封装格式，我们可以将其数据看为二进制字节流。总体上看，FLV包括文件头（File Header）和文件体（File Body）两部分，其中文件体由一系列的Tag及Tag Size对组成。
<img src="http://images.wodekouwei.com/M/F/flv-struct.jpg" alt="flv-struct"></p>
<h3 id="FLV格式解析"><a href="#FLV格式解析" class="headerlink" title="FLV格式解析"></a>FLV格式解析</h3><p>先来一张图，这是《科比退役演讲》下载）的一个FLV视频。我使用的是UltraEdit的二进制查看工具。
<img src="http://images.wodekouwei.com/M/F/flv1.png" alt="flv-head"></p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>头部分由一下几部分组成
Signature(3 Byte)+Version(1 Byte)+Flags(1 Bypte)+DataOffset(4 Byte)</p>
<ul>
<li>signature 占3个字节 固定FLV三个字符作为标示。一般发现前三个字符为FLV时就认为他是flv文件。图中0x46 0x4C 0x56,代表FLV</li>
<li>Version 占1个字节 标示FLV的版本号。这里我们看到是1</li>
<li>Flags 占1个字节 内容标示。第0位和第2位,分别表示 video 与 audio 存在的情况.(1表示存在,0表示不存在)。截图看到是0x05，也就是00000101，代表既有视频，也有音频。</li>
<li>DataOffset 4个字节 表示FLV的header长度。这里可以看到固定是9</li>
</ul>
<h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>FLV的body部分是一系列的back-pointers+tag构成的</p>
<ul>
<li>back-pointers固定4个字节,表示前一个tag的size</li>
<li><p>tag分三种类型:video,audio,scripts.</p>
<h5 id="tag组成"><a href="#tag组成" class="headerlink" title="tag组成"></a>tag组成</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tag type+tag data size+Timestamp+TimestampExtended+stream id+ tag data</div></pre></td></tr></table></figure>
</li>
<li><p>type 1个字节。8为Audio,9为Video,18为scripts</p>
</li>
<li>tag data size 3个字节。表示tag data的长度。从streamd id 后算起。</li>
<li>Timestreamp 3个字节。时间戳</li>
<li>TimestampExtended 1个字节。时间戳扩展字段</li>
<li>stream id 3个字节。总是0</li>
<li>tag data 数据部分</li>
</ul>
<p>图上第一个tag:</p>
<ul>
<li>type=0x12=18,表示是一个scripts,FLV中,header后的第一个tag是script tag,script tag内容是amf格式数据,包含两个amf.</li>
<li>size=0x00 0x01 0x74 = 372</li>
<li>timpestreamp = 0x00 0x00 0x00</li>
<li>TimestampExtended=0x00</li>
<li>streamid=0x00 0x00 0x00</li>
<li>tag data部分:
<img src="http://images.wodekouwei.com/M/F/flv2.png" alt="FLV-TAG"></li>
</ul>
<h5 id="tag的划分"><a href="#tag的划分" class="headerlink" title="tag的划分"></a>tag的划分</h5><p>图中红色部分是我标出”(“与”)”前后的的两个back-pointers，都是4个字节。而括号中间就是第一个TAG。那是怎么计算的呢？我们就以这个做个示例。</p>
<ul>
<li>首先第一个back-pointers是0x00000000，那是因为后面是第一个TAG。所以他为0。</li>
<li>然后根据我们我们前面格式获取到size是0x00 0x01 0x74 = 372。也就是说从stream id后面再加上372个字节就到了第一个TAG的末尾，我们数一下。tag header有11个字节。那么到第一个TAG，总共有372+11=383=0x17f。</li>
<li>接下来我们找到0x17f的地址，从工具上很容易找到，正好就是后括号”)”的前面。红0x00 0x00 0x01 0x7F=372，这代表的是上一个TAG的大小。</li>
<li>最后我们计算一下，上一个TAG数据部分是372个字节，前面type、stream id等字段占了11个字节。正好是匹配的。
上面我们已经知道了怎么取划分每个TAG。接下来我们就看TAG的具体内容:</li>
</ul>
<h5 id="tag的内容"><a href="#tag的内容" class="headerlink" title="tag的内容"></a>tag的内容</h5><p>前面已经提到tag分3种。我们一个个看</p>
<h6 id="script"><a href="#script" class="headerlink" title="script"></a>script</h6><p>脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。
首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。</p>
<p>一般来说，该Tag Data结构包含两个AMF包。AMF（Action Message Format）是Adobe设计的一种通用数据封装格式，在Adobe的很多产品中应用，简单来说，AMF将不同类型的数据用统一的格式来描述。第一个AMF包封装字符串类型数据，用来装入一个“onMetaData”标志，这个标志与Adobe的一些API调用有，在此不细述。第二个AMF包封装一个数组类型(srs返回为object类型)，这个数组中包含了音视频信息项的名称和值。具体说明如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Number type</td>
<td>8 Bypte Double</td>
</tr>
<tr>
<td>1</td>
<td>Boolean type</td>
<td>1 Bypte bool</td>
</tr>
<tr>
<td>2</td>
<td>String type</td>
<td>后面2个字节为长度</td>
</tr>
<tr>
<td>3</td>
<td>Object type</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>MovieClip type</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Null type</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>Undefined type</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Reference type</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ECMA array type</td>
<td>数组,类似Map</td>
</tr>
<tr>
<td>10</td>
<td>Strict array type</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>Date type</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>Long string type</td>
<td>后面4个字节为长度</td>
</tr>
</tbody>
</table>
<p><img src="http://images.wodekouwei.com/M/F/flv3.png" alt="FLV-script-1.png">
上图为第一个AMF包</p>
<ul>
<li>type=0x02对应String</li>
<li>size=0A=10</li>
<li>value=onMetaData 正好是10个字节。</li>
</ul>
<p><img src="http://images.wodekouwei.com/M/F/flv4.png" alt="FLV_script-2.png">
上图为第二个AMF</p>
<ul>
<li>type=0x08 对应ECMA array type。</li>
</ul>
<blockquote>
<p>表示数组，类似Map。后面4个字节为数组的个数。然后是键值对，第一个为键，2个字节为长度。后面跟具体的内容。接着3个字节表示值的类型，然后根据类型判断长度。
上图我们可以判断，总共有13个键值对。
第一个长度为8个字节是duration。值类型是0x004073，第一个字节是00，所以是double，8个字节。
第二个长度5个字节是width。值也是double类型，8个字节。
依次解析下去…</p>
</blockquote>
<h6 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h6><p><img src="http://images.wodekouwei.com/M/F/flv5.png" alt="flv-audio1">
<img src="http://images.wodekouwei.com/M/F/flv6.png" alt="flv-audio2">
<img src="http://images.wodekouwei.com/M/F/flv7.png" alt="flv-audio3">
<img src="http://images.wodekouwei.com/M/F/flv8.png" alt="flv-audio4">
视频中第二个tag为音频tag</p>
<p>stream-id之后:</p>
<ul>
<li>前4位为音频格式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Linear PCM, platform endian</td>
</tr>
<tr>
<td>1</td>
<td>ADPCM</td>
</tr>
<tr>
<td>2</td>
<td>MP3</td>
</tr>
<tr>
<td>3</td>
<td>Linear PCM, little endian</td>
</tr>
<tr>
<td>4</td>
<td>Nellymoser 16-kHz mono</td>
</tr>
<tr>
<td>5</td>
<td>Nellymoser 8-kHz mono</td>
</tr>
<tr>
<td>6</td>
<td>Nellymoser</td>
</tr>
<tr>
<td>7</td>
<td>G.711 A-law logarithmic PCM</td>
</tr>
<tr>
<td>8</td>
<td>G.711 mu-law logarithmic PCM</td>
</tr>
<tr>
<td>9</td>
<td>reserved</td>
</tr>
<tr>
<td>10</td>
<td>AAC</td>
</tr>
<tr>
<td>11</td>
<td>Speex</td>
</tr>
<tr>
<td>14</td>
<td>MP3 8-Khz</td>
</tr>
<tr>
<td>15</td>
<td>Device-specific sound</td>
</tr>
</tbody>
</table>
<ul>
<li>接着2位为采样率(对于AAC总是3)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>5.5-kHz</td>
</tr>
<tr>
<td>1</td>
<td>11-kHz</td>
</tr>
<tr>
<td>2</td>
<td>22-kHz</td>
</tr>
<tr>
<td>3</td>
<td>44-kHz</td>
</tr>
</tbody>
</table>
<ul>
<li>接着1位为采样的长度(压缩过的音视频都是16bit)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>snd8Bit</td>
</tr>
<tr>
<td>1</td>
<td>snd16Bit</td>
</tr>
</tbody>
</table>
<ul>
<li>接着1位为音频类型(对于AAC总是1)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>sndMono</td>
</tr>
<tr>
<td>1</td>
<td>sndStereo</td>
</tr>
</tbody>
</table>
<h6 id="video"><a href="#video" class="headerlink" title="video"></a>video</h6><p>由于kobe视频音频编码是pcm,查找视频tag太难,使用&lt;&lt;东风破&gt;&gt; mv视频
<img src="http://images.wodekouwei.com/M/F/flv9.png" alt="flv-video1"></p>
<ul>
<li>type=0x09=9。这里应该是一个video。</li>
<li>size=0x000030=48。长度为48。</li>
<li>timestreamp=0x000000。</li>
<li>TimestampExtended =0x00。</li>
<li>stream id =0x000000</li>
</ul>
<p>我们看到数据部分：
视频信息+数据
视频信息，1个字节。</p>
<blockquote>
<p>StreamId之后的数据就表示是VideoTagHeader,如果是avc,VideoTagHeader会多出4个字节的信息就是AVCPacketType和CompositionTime</p>
</blockquote>
<ul>
<li>前4位为帧类型Frame Type</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>keyframe (for AVC, a seekable frame) 关键帧</td>
</tr>
<tr>
<td>2</td>
<td>inter frame (for AVC, a non-seekable frame)</td>
</tr>
<tr>
<td>3</td>
<td>disposable inter frame (H.263 only)</td>
</tr>
<tr>
<td>4</td>
<td>generated keyframe (reserved for server use only)</td>
</tr>
<tr>
<td>5</td>
<td>video info/command frame</td>
</tr>
</tbody>
</table>
<ul>
<li>后4位为编码ID (CodecID)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>JPEG (currently unused)</td>
</tr>
<tr>
<td>2</td>
<td>Sorenson H.263</td>
</tr>
<tr>
<td>3</td>
<td>Screen video</td>
</tr>
<tr>
<td>4</td>
<td>On2 VP6</td>
</tr>
<tr>
<td>5</td>
<td>On2 VP6 with alpha channel</td>
</tr>
<tr>
<td>6</td>
<td>Screen video version 2</td>
</tr>
<tr>
<td>7</td>
<td>AVC</td>
</tr>
</tbody>
</table>
<p>特殊情况
视频的格式(CodecID)是AVC（H.264）的话，VideoTagHeader会多出4个字节的信息，AVCPacketType 和CompositionTime。</p>
<ul>
<li>AVCPacketType 占1个字节</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>AVCDecoderConfigurationRecord(AVC sequence header)</td>
</tr>
<tr>
<td>1</td>
<td>AVC NALU</td>
</tr>
<tr>
<td>2</td>
<td>AVC end of sequence (lower level NALU sequence ender is not required or supported)</td>
</tr>
</tbody>
</table>
<p>AVCDecoderConfigurationRecord.包含着是H.264解码相关比较重要的sps和pps信息，再给AVC解码器送数据流之前一定要把sps和pps信息送出，否则的话解码器不能正常解码。而且在解码器stop之后再次start之前，如seek、快进快退状态切换等，都需要重新送一遍sps和pps的信息.AVCDecoderConfigurationRecord在FLV文件中一般情况也是出现1次，也就是第一个video tag.</p>
<ul>
<li>CompositionTime 占3个字节</li>
</ul>
<table>
<thead>
<tr>
<th>条件</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVCPacketType ==1</td>
<td>Composition time offset</td>
</tr>
<tr>
<td>AVCPacketType !=1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>再看到第二个video tag
<img src="http://images.wodekouwei.com/M/F/flv10.png" alt="flv-video"></p>
<p>我们看到 AVCPacketType =1，而后面三个字节为000043。这是一个视频帧数据。
解析到的数据完全符合上面的理论。</p>
<p>sps pps
前面我们提到第一个video 一般存放的是sps和pps。这里我们具体解析下sps和pps内容。先看下存储的格）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x01+sps[1]+sps[2]+sps[3]+0xFF+0xE1+sps size+sps+01+pps size+pps</div></pre></td></tr></table></figure></p>
<p>sps[1]=0x64
sps[2]=00
sps[3]=0D
sps size=0x001B=27(占两个字节)
跳过27个字节后，是0x01
pps size=0x0005=118(占两个字节)
跳过5个字节，就到了back-pointers。</p>
<p>视频帧数据
解析出sps和pps tag后，后面的video tag就是真正的视频数据内容了
<img src="http://images.wodekouwei.com/M/F/flv11.png" alt="flv-video3">
这是第二个video tag其实和之前图一样，只是我圈出来关键信息。先看下格式
frametype=0x17=00010111
AVCPacketType =1
Composition Time=0x000043
后面就是NALU DATA</p>
<blockquote>
<p>引用:</p>
<p><a href="http://www.jianshu.com/p/7ffaec7b3be6" target="_blank" rel="external">flv格式详解+实例剖析</a></p>
<p><a href="http://blog.csdn.net/bsplover/article/details/7426511" target="_blank" rel="external">FLV视频封装格式详解</a></p>
<p><a href="https://blog.evanxia.com/2017/07/1378" target="_blank" rel="external">【总结】FLV（AAC/AVC）学习笔记</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932368" target="_blank" rel="external">将h.264视频流封装成flv格式文件（一.flv格式）</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932431" target="_blank" rel="external">将h.264视频流封装成flv格式文件（二.开始动手）</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932585" target="_blank" rel="external">RTMP协议中的AMF数据</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/8011362" target="_blank" rel="external">rtmp协议简单解析以及用其发送h264的flv文件</a></p>
<p><a href="https://chensi.moe/blog/2015/11/20/flv-format/" target="_blank" rel="external">FLV 文件格式解析</a></p>
<p><a href="http://www.cnblogs.com/lihaiping/p/5285166.html" target="_blank" rel="external">(原)从mp4,flv文件中解析出h264和aac,送解码器解码失败</a>:,avc1与H264区别在这里其实有人遇到了和我一样的问题：<a href="http://stackoverflow.com/questions/11330764/ffmpeg-cant-decode-h264-stream-frame-data" target="_blank" rel="external">http://stackoverflow.com/questions/11330764/ffmpeg-cant-decode-h264-stream-frame-data</a></p>
<p><a href="https://gitee.com/leixiaohua1020/simplest_mediadata_test" target="_blank" rel="external">simplest_mediadata_test</a></p>
<p><a href="https://github.com/runner365/rtmp_relay" target="_blank" rel="external">rtmp_relay</a>
<a href="https://github.com/gezhaoyou/RtmpMindmap" target="_blank" rel="external">RtmpMindmap</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流
    
    </summary>
    
      <category term="音视频封装" scheme="http://wodekouwei.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://wodekouwei.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="format" scheme="http://wodekouwei.com/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(一)技术调研</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-pluggable/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-pluggable/</id>
    <published>2017-12-05T09:15:57.000Z</published>
    <updated>2018-01-12T12:25:19.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有关APK更新的技术比较多，例如：增量更新、插件式开发、热修复、RN、静默安装。
下面简单介绍一下：</p>
<table>
<thead>
<tr>
<th>更新方式</th>
<th>签名</th>
</tr>
</thead>
<tbody>
<tr>
<td>增量更新</td>
<td>旧版本Apk（v1.0）和新（v2.0）、旧版本Apk（v1.0）生成的差分包（apk.patch 质量小）合并成为新版本Apk（v2.0）安装。</td>
</tr>
<tr>
<td>插件式开发</td>
<td>给宿主APK提供插件，扩展（需要的时候再下载），可以动态地替换。主要技术是动态代理的知识。</td>
</tr>
<tr>
<td>热修复</td>
<td>通过NDK底层去修复，也是C/C++的技术。</td>
</tr>
<tr>
<td>RN</td>
<td>通过JS脚本去修复APK。</td>
</tr>
<tr>
<td>静默安装</td>
<td>需要root权限，适配不同手机ROM很麻烦。</td>
</tr>
</tbody>
</table>
<p>插件化、热修复（思想）的发展历程</p>
<ul>
<li>2012年7月，AndroidDynamicLoader，大众点评，陶毅敏：思想是通过Fragment以及schema的方式实现的，这是一种可行的技术方案，但是还有限制太多，这意味这你的activity必须通过Fragment去实现，这在activity跳转和灵活性上有一定的不便，在实际的使用中会有一些很奇怪的bug不好解决，总之，这还是一种不是特别完备的动态加载技术。</li>
<li>2013年，23Code，自定义控件的动态下载：主要利用 Java ClassLoader 的原理，可动态加载的内容包括 apk、dex、jar等。</li>
<li>2014年初，Altas，阿里伯奎的技术分享：提出了插件化的思想以及一些思考的问题，相关资料比较少。</li>
<li>2014年底，Dynamic-load-apk，任玉刚：动态加载APK，通过Activity代理的方式给插件Activity添加生命周期。</li>
<li>2015年4月，OpenAltas/ACCD：Altas的开源项目，一款强大的Android非代理动态部署框架，目前已经处于稳定状态。</li>
<li>2015年8月，DroidPlugin，360的张勇：DroidPlugin 是360手机助手在 Android 系统上实现了一种新的插件机制：通过Hook思想来实现，它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。</li>
<li>2015年9月，AndFix，阿里：通过NDK的Hook来实现热修复。</li>
<li>2015年11月，Nuwa，大众点评：通过dex分包方案实现热修复。</li>
<li>2015年底，Small，林光亮：打通了宿主与插件之间的资源与代码共享。</li>
<li>2016年4月，ZeusPlugin，掌阅：ZeusPlugin最大特点是：简单易懂，核心类只有6个，类总数只有13个。</li>
</ul>
<h3 id="1-增量更新"><a href="#1-增量更新" class="headerlink" title="1.增量更新"></a>1.增量更新</h3><p>增量更新就是原有app的基础上只更新发生变化的地方，其余保持原样。
与原来每次更新都要下载完整apk包的做法相比，这样做的好处显而易见：每次变化的地方总是比较少，因此更新包的体积就会小很多。</p>
<h4 id="1-1增量更新的流程"><a href="#1-1增量更新的流程" class="headerlink" title="1.1增量更新的流程"></a>1.1增量更新的流程</h4><ol>
<li>APP检测最新版本：把当前版本告诉服务端，服务端进行判断。
如果有新版本，服务端需要对当前版本的APK与最新版本的APK进行一次差分，产生patch差分文件。（或者新版本的APK上传到服务端的时候就已经差分好了）</li>
<li>APP在后台下载差分文件，进行文件的MD5校验，在本地进行合并（跟本地的data目录下面的APK文件合并），合并出最新的APK之后，提示用户安装。</li>
<li>增量更新的最终目的：省流量地更新宿主APK。</li>
</ol>
<p>差分的处理比较麻烦的地方就是要针对不同的应用市场渠道和众多不同版本进行差分。
注意：新版本有可能比旧版本小，差分只是把变化的部分记录下来。</p>
<h4 id="1-2服务器端行为（后台工程师操作）"><a href="#1-2服务器端行为（后台工程师操作）" class="headerlink" title="1.2服务器端行为（后台工程师操作）"></a>1.2服务器端行为（后台工程师操作）</h4><h5 id="1-2-1下载拆分和合并要用的第三方库（bsdiff、bzip2）"><a href="#1-2-1下载拆分和合并要用的第三方库（bsdiff、bzip2）" class="headerlink" title="1.2.1下载拆分和合并要用的第三方库（bsdiff、bzip2）"></a>1.2.1下载拆分和合并要用的第三方库（bsdiff、bzip2）</h5><p>我们使用到的第三方库是：Binary diff，简称bsdiff，这个库专门用来实现文件的差分和合并的，它的官网如下：<a href="http://www.daemonology.net/bsdiff/" target="_blank" rel="external">http://www.daemonology.net/bsdiff/</a></p>
<h5 id="1-2-2Java代码调用"><a href="#1-2-2Java代码调用" class="headerlink" title="1.2.2Java代码调用:"></a>1.2.2Java代码调用:</h5><p>创建Web项目，用来做APP的服务端。创建工具类专门用于产生差分包：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class BsDiff &#123;</div><div class="line">    /**</div><div class="line">     * 差分</div><div class="line">     * @param oldfile</div><div class="line">     * @param newfile</div><div class="line">     * @param patchfile</div><div class="line">     */</div><div class="line">    public native static void diff(String oldfile,String newfile,String patchfile);</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.loadLibrary(&quot;bsdiff&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中JNI的实现如下（该实现写在bsdiff.cpp中）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT void JNICALL Java_com_haocai_bsdiff_BsDiff_diff</div><div class="line">(JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr) &#123;</div><div class="line">    int argc = 4;</div><div class="line">    char* oldfile = (char*)env-&gt;GetStringUTFChars(oldfile_jstr, NULL);</div><div class="line">    char* newfile = (char*)env-&gt;GetStringUTFChars(newfile_jstr, NULL);</div><div class="line">    char* patchfile = (char*)env-&gt;GetStringUTFChars(patchfile_jstr, NULL);</div><div class="line"></div><div class="line">    //参数(第一个参数无效)</div><div class="line">    char *argv[4];</div><div class="line">    argv[0] = &#123; &quot;bsdiff&quot; &#125;;</div><div class="line">    argv[1] = oldfile;</div><div class="line">    argv[2] = newfile;</div><div class="line">    argv[3] = patchfile;</div><div class="line"></div><div class="line">    bsdiff_main(argc, argv);</div><div class="line"></div><div class="line">    env-&gt;ReleaseStringUTFChars(oldfile_jstr, oldfile);</div><div class="line">    env-&gt;ReleaseStringUTFChars(newfile_jstr, newfile);</div><div class="line">    env-&gt;ReleaseStringUTFChars(patchfile_jstr, patchfile);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过研究bsdiff的源码，我们发现bsdiff.cpp里面的main函数就是入口函数，避免歧义把函数名main改为bsdiff_main，然后通过JNI去调用。根据bsdiff.cpp中bsdiff_main函数方法中有以下关键语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (argc != 4) errx(1, &quot;usage: %s oldfile newfile patchfile\n&quot;, argv[0]);</div></pre></td></tr></table></figure></p>
<p>根据提示需要传入4个参数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">argv[0] = &quot;bsdiff&quot;;//这个参数没用</div><div class="line">argv[1] = oldPath;//旧APK文件路径</div><div class="line">argv[2] = newPath;/新APK文件路径</div><div class="line">argv[3] = patchPath;//APK差分文件路径</div></pre></td></tr></table></figure></p>
<p>然后我们准备两个APK文件，不同版本的，最好Java代码、资源都不一样。</p>
<p>写一个Java测试类生成差分包：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.haocai.bsdiff;</div><div class="line"></div><div class="line">public class ConstantsWin &#123;</div><div class="line"></div><div class="line">    //路径不能包含中文</div><div class="line">    public static final String OLD_APK_PATH = &quot;D:/android_apks/test_old.apk&quot;;</div><div class="line"></div><div class="line">    public static final String NEW_APK_PATH = &quot;D:/android_apks/test_new.apk&quot;;</div><div class="line"></div><div class="line">    public static final String PATCH_PATH = &quot;D:/android_apks/apk.patch&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.haocai.bsdiff;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Administrator on 2017/11/14.</div><div class="line"> */</div><div class="line">public class BsDiffTest &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //得到差分包</div><div class="line">        BsDiff.diff(ConstantsWin.OLD_APK_PATH,ConstantsWin.NEW_APK_PATH,ConstantsWin.PATCH_PATH);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>test_new.apk、test_old.apk 要先放在目标目录</li>
<li>bsdiff.cpp中生成差分包的程序方法是异步的，所以生成完整的apk.patch可能要等一下。apk.patch体积大小停止增长，表示生成结束。<h5 id="1-2-3简单搭建后台JavaWeb供Android前端下载apk-patch差分包"><a href="#1-2-3简单搭建后台JavaWeb供Android前端下载apk-patch差分包" class="headerlink" title="1.2.3简单搭建后台JavaWeb供Android前端下载apk.patch差分包"></a>1.2.3简单搭建后台JavaWeb供Android前端下载apk.patch差分包</h5></li>
</ul>
<h4 id="1-3Android客户端行为"><a href="#1-3Android客户端行为" class="headerlink" title="1.3Android客户端行为"></a>1.3Android客户端行为</h4><h5 id="1-3-1编译合并要用的第三方库（bsdiff、bzip2）"><a href="#1-3-1编译合并要用的第三方库（bsdiff、bzip2）" class="headerlink" title="1.3.1编译合并要用的第三方库（bsdiff、bzip2）"></a>1.3.1编译合并要用的第三方库（bsdiff、bzip2）</h5><p>对应的Java代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.haocai.app.update;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Xionghu on 2017/11/14.</div><div class="line"> * Desc:</div><div class="line"> */</div><div class="line"></div><div class="line">public class BsPatch &#123;</div><div class="line">    /**</div><div class="line">     * 合并</div><div class="line">     * @param oldfile</div><div class="line">     * @param newfile</div><div class="line">     * @param patchfile</div><div class="line">     */</div><div class="line">    public native static void patch(String oldfile,String newfile,String patchfile);</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.loadLibrary(&quot;bspatch&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Android端，我们需要把bzip2以及bsdiff的文件拷贝到jni目录里面，同样的，我们只需要编译一个bspatch.c源文件即可。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//合并</div><div class="line">JNIEXPORT void JNICALL Java_com_haocai_app_update_BsPatch_patch</div><div class="line">  (JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr)&#123;</div><div class="line">    int argc = 4;</div><div class="line">    char* oldfile = (char*)(*env)-&gt;GetStringUTFChars(env,oldfile_jstr, NULL);</div><div class="line">    char* newfile = (char*)(*env)-&gt;GetStringUTFChars(env,newfile_jstr, NULL);</div><div class="line">    char* patchfile = (char*)(*env)-&gt;GetStringUTFChars(env,patchfile_jstr, NULL);</div><div class="line"></div><div class="line">    //参数（第一个参数无效）</div><div class="line">    char *argv[4];</div><div class="line">    argv[0] = &quot;bspatch&quot;;</div><div class="line">    argv[1] = oldfile;</div><div class="line">    argv[2] = newfile;</div><div class="line">    argv[3] = patchfile;</div><div class="line"></div><div class="line">    bspatch_main(argc,argv);</div><div class="line"></div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,oldfile_jstr, oldfile);</div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,newfile_jstr, newfile);</div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,patchfile_jstr, patchfile);</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>代码v1.0差分包合并核心代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">package com.haocai.app.update;</div><div class="line"></div><div class="line">import android.Manifest;</div><div class="line">import android.content.pm.PackageManager;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Message;</div><div class="line">import android.support.annotation.NonNull;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.support.v4.app.ActivityCompat;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.text.format.Formatter;</div><div class="line">import android.widget.Toast;</div><div class="line">import com.lzy.okgo.OkGo;</div><div class="line">import com.lzy.okgo.callback.FileCallback;</div><div class="line">import com.lzy.okgo.model.Progress;</div><div class="line">import com.lzy.okgo.model.Response;</div><div class="line">import com.lzy.okgo.request.base.Request;</div><div class="line">import java.io.File;</div><div class="line">import java.text.NumberFormat;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final int REQUEST_PERMISSION_STORAGE = 0x01;</div><div class="line">    private Handler mHandler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            super.handleMessage(msg);</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case 0:</div><div class="line">                    Toast.makeText(MainActivity.this, &quot;您正在进行省流量更新&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    ApkUtils.installApk(MainActivity.this, Constants.NEW_APK_PATH);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    private NumberFormat numberFormat;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        setTitle(&quot;简单文件下载&quot;);</div><div class="line"></div><div class="line">        numberFormat = NumberFormat.getPercentInstance();</div><div class="line">        numberFormat.setMinimumFractionDigits(2);</div><div class="line"></div><div class="line">        checkSDCardPermission();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 因为后台没有写版本判断语句</div><div class="line">         * 在高版本下暂时先注释fileDownload(); 否则一直下载安装</div><div class="line">         *</div><div class="line">         * 低版本下运行fileDownload();</div><div class="line">         */</div><div class="line">         fileDownload();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 检查SD卡权限</div><div class="line">     */</div><div class="line">    protected void checkSDCardPermission() &#123;</div><div class="line">        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_PERMISSION_STORAGE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">        if (requestCode == REQUEST_PERMISSION_STORAGE) &#123;</div><div class="line">            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">                //获取权限</div><div class="line">                fileDownload();</div><div class="line">            &#125; else &#123;</div><div class="line">                Toast.makeText(getApplicationContext(), &quot;权限被禁止，无法下载文件！&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        //Activity销毁时，取消网络请求</div><div class="line">        OkGo.getInstance().cancelTag(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void fileDownload() &#123;</div><div class="line"></div><div class="line">        OkGo.&lt;File&gt;get(Constants.URL_PATCH_DOWNLOAD)//</div><div class="line">                .tag(this)//</div><div class="line">                .execute(new FileCallback(Constants.SD_CARD, Constants.PATCH_FILE) &#123;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onStart(Request&lt;File, ? extends Request&gt; request) &#123;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onSuccess(Response&lt;File&gt; response) &#123;</div><div class="line"></div><div class="line">                        new Thread(new Runnable() &#123;</div><div class="line">                            @Override</div><div class="line">                            public void run() &#123;</div><div class="line"></div><div class="line">                                try &#123;</div><div class="line">                                    //      File patchFile = new File(Constants.SD_CARD, Constants.PATCH_FILE);</div><div class="line">                                    String oldfile = ApkUtils.getSourceApkPath(MainActivity.this, getPackageName());</div><div class="line">                                    String newfile = Constants.NEW_APK_PATH;</div><div class="line">                                    String patchfile = Constants.SD_CARD + File.separator + Constants.PATCH_FILE;</div><div class="line">                                    BsPatch.patch(oldfile, newfile, patchfile);</div><div class="line"></div><div class="line">                                    mHandler.sendEmptyMessage(0);</div><div class="line">                                &#125; catch (Exception e) &#123;</div><div class="line">                                    e.printStackTrace();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;).start();</div><div class="line"></div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Response&lt;File&gt; response) &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void downloadProgress(Progress progress) &#123;</div><div class="line">                        System.out.println(progress);</div><div class="line"></div><div class="line">                        String downloadLength = Formatter.formatFileSize(getApplicationContext(), progress.currentSize);</div><div class="line">                        String totalLength = Formatter.formatFileSize(getApplicationContext(), progress.totalSize);</div><div class="line">                        String speed = Formatter.formatFileSize(getApplicationContext(), progress.speed);</div><div class="line">                        System.out.println(downloadLength);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：这里7.0可能会有问题，把路径暴露给别的app，需要FileProvider去实现（不难，这个留给大家去做吧）。</p>
<blockquote>
<p><a href="https://github.com/kpioneer123/DiffInstallApp" target="_blank" rel="external">源码下载</a>
作者: <a href="http://www.jianshu.com/p/4c80d732e7c3" target="_blank" rel="external">(简书)香沙小熊</a></p>
</blockquote>
<h3 id="2-插件化"><a href="#2-插件化" class="headerlink" title="2.插件化"></a>2.插件化</h3><p>插件化框架的一些对比，下面引用
<a href="https://github.com/wequick/Small/blob/master/Android/COMPARISION.md" target="_blank" rel="external">https://github.com/wequick/Small/blob/master/Android/COMPARISION.md</a></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>DynamicLoadApk</th>
<th>DynamicAPK</th>
<th>Small</th>
<th>DroidPlugin</th>
<th>VirtualAPK</th>
<th>RePlugin</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持四大组件</td>
<td>只支持Activity</td>
<td>只支持Activity</td>
<td>只支持Activity</td>
<td>全支持</td>
<td>全支持</td>
<td>全支持</td>
</tr>
<tr>
<td>组件无需在宿主manifest中预注册</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>插件可以依赖宿主</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>支持PendingIntent</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Android特性支持</td>
<td>大部分</td>
<td>大部分</td>
<td>大部分</td>
<td>几乎全部</td>
<td>几乎全部</td>
<td>几乎全部</td>
</tr>
<tr>
<td>兼容性适配</td>
<td>一般</td>
<td>一般</td>
<td>中等</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>插件构建</td>
<td>无</td>
<td>部署aapt</td>
<td>Gradle插件</td>
<td>无</td>
<td>Gradle插件</td>
<td>Gradle插件</td>
</tr>
<tr>
<td>源码</td>
<td><code>https://github.com/singwhatiwanna/dynamic-load-apk</code></td>
<td><code>https://github.com/CtripMobile/DynamicAPK</code></td>
<td><a href="https://github.com/wequick/Small" target="_blank" rel="external">https://github.com/wequick/Small</a></td>
<td><code>https://github.com/DroidPluginTeam/DroidPlugin</code></td>
<td><code>https://github.com/didi/VirtualAPK</code></td>
<td><code>https://github.com/Qihoo360/RePlugin</code></td>
</tr>
<tr>
<td>开发者</td>
<td>singwhatiwanna</td>
<td>CtripMobile</td>
<td></td>
<td>Lody</td>
<td>滴滴</td>
<td>360</td>
</tr>
</tbody>
</table>
<h4 id="2-1DynamicLoadApk"><a href="#2-1DynamicLoadApk" class="headerlink" title="2.1DynamicLoadApk"></a>2.1DynamicLoadApk</h4><h4 id="2-2VirtualAPK"><a href="#2-2VirtualAPK" class="headerlink" title="2.2VirtualAPK"></a>2.2VirtualAPK</h4><h5 id="2-2-1特性"><a href="#2-2-1特性" class="headerlink" title="2.2.1特性"></a>2.2.1特性</h5><table>
<thead>
<tr>
<th>Feature</th>
<th>Detail</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supported components</td>
<td>Activity, Service, Receiver and Provider</td>
</tr>
<tr>
<td>Manually register components in AndroidManifest.xml</td>
<td>No need</td>
</tr>
<tr>
<td>Access host app classes and resources</td>
<td>Supported</td>
</tr>
<tr>
<td>PendingIntent</td>
<td>Supported</td>
</tr>
<tr>
<td>Supported Android features</td>
<td>Almost all features</td>
</tr>
<tr>
<td>Compatibility</td>
<td>Almost all devices</td>
</tr>
<tr>
<td>Building system</td>
<td>Gradle plugin</td>
</tr>
<tr>
<td>Supported Android versions</td>
<td>API Level 15+</td>
</tr>
</tbody>
</table>
<h5 id="2-2-2架构"><a href="#2-2-2架构" class="headerlink" title="2.2.2架构"></a>2.2.2架构</h5><p><img src="http://images.wodekouwei.com/technology/virtualapk_arch.png" alt="image"></p>
<h5 id="2-2-3原理"><a href="#2-2-3原理" class="headerlink" title="2.2.3原理"></a>2.2.3原理</h5><h6 id="2-2-3-1基本原理"><a href="#2-2-3-1基本原理" class="headerlink" title="2.2.3.1基本原理"></a>2.2.3.1基本原理</h6><ul>
<li>合并宿主和插件的ClassLoader 需要注意的是，插件中的类不可以和宿主重复</li>
<li>合并插件和宿主的资源 重设插件资源的packageId，将插件资源和宿主资源合并</li>
<li>去除插件包对宿主的引用 构建时通过Gradle插件去除插件对宿主的代码以及资源的引用<h5 id="2-2-3-2四大组件的实现原理"><a href="#2-2-3-2四大组件的实现原理" class="headerlink" title="2.2.3.2四大组件的实现原理"></a>2.2.3.2四大组件的实现原理</h5></li>
<li>Activity 采用宿主manifest中占坑的方式来绕过系统校验，然后再加载真正的activity；</li>
<li>Service 动态代理AMS，拦截service相关的请求，将其中转给Service Runtime去处理，Service Runtime会接管系统的所有操作；</li>
<li>Receiver 将插件中静态注册的receiver重新注册一遍；</li>
<li>ContentProvider 动态代理IContentProvider，拦截provider相关的请求，将其中转给Provider Runtime去处理，Provider Runtime会接管系统的所有操作。</li>
</ul>
<h4 id="2-3RePlugin"><a href="#2-3RePlugin" class="headerlink" title="2.3RePlugin"></a>2.3RePlugin</h4><h5 id="2-3-1特性"><a href="#2-3-1特性" class="headerlink" title="2.3.1特性"></a>2.3.1特性</h5><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>组件</td>
<td>四大组件（含静态Receiver）</td>
</tr>
<tr>
<td>升级无需改主程序Manifest</td>
<td>完美支持</td>
</tr>
<tr>
<td>Android特性</td>
<td>支持近乎所有（包括SO库等）</td>
</tr>
<tr>
<td>TaskAffinity &amp; 多进程</td>
<td>支持（坑位方案）</td>
</tr>
<tr>
<td>插件类型</td>
<td>支持自带插件（自识别）、外置插件</td>
</tr>
<tr>
<td>插件间耦合</td>
<td>支持Binder、Class Loader、资源等</td>
</tr>
<tr>
<td>进程间通讯</td>
<td>支持同步、异步、Binder、广播等</td>
</tr>
<tr>
<td>自定义Theme &amp; AppComat</td>
<td>支持</td>
</tr>
<tr>
<td>DataBinding</td>
<td>支持</td>
</tr>
<tr>
<td>安全校验</td>
<td>支持</td>
</tr>
<tr>
<td>资源方案</td>
<td>独立资源 + Context传递（相对稳定）</td>
</tr>
<tr>
<td>Android 版本</td>
<td>API Level 9+ （2.3及以上）</td>
</tr>
</tbody>
</table>
<h5 id="2-3-2架构"><a href="#2-3-2架构" class="headerlink" title="2.3.2架构"></a>2.3.2架构</h5><p><img src="http://images.wodekouwei.com/technology/RePluginFramePic.jpeg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;有关APK更新的技术比较多，例如：增量更新、插件式开发、热修复、RN、静默安装。
下面简单介绍一下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>(转)总结Android开发中必备的代码Review清单</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-review/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-review/</id>
    <published>2017-12-05T06:11:25.000Z</published>
    <updated>2017-12-05T06:50:12.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文收集了我自己工作以来提交代码前的所有检查点。事实证明，这样能有效提高自己的代码质量和功能的稳定性。所以推荐大家以后每次提交代码前，都可以看下这份Review清单哈。</p>
<p>此外，可能还有些检查点我并没有发现，欢迎大家踊跃在评论区补充哈～</p>
<h3 id="清理操作"><a href="#清理操作" class="headerlink" title="清理操作"></a>清理操作</h3><ol>
<li>页面退出时，是否完成必要的清理操作<ol>
<li>是否调用Handler的removeCallbacksAndMessages(null)来清空Handler里的消息；</li>
<li>是否取消了还没完成的请求；</li>
<li>在页面里注册的监听，是否反注册；</li>
<li>假如自己用到观察者模式，是否反注册；</li>
<li>假如用了RxJava的话，是否解除订阅；</li>
</ol>
</li>
<li><p>数据库的游标是否已经关闭
这个点一般人都知道，出问题一般在于，没有考虑到多线程并发时的情况下，Cursor没有被释放。
所以数据库的操作需要加上同步代码块
详细可参考：<a href="http://www.2cto.com/kf/201408/329574.html" target="_blank" rel="external">http://www.2cto.com/kf/201408/329574.html</a></p>
</li>
<li><p>打开过的文件流是否关闭</p>
</li>
<li><p>Android 3.0以下的版本，使用完的Bitmap是否调用recycle()，否则会一直占用内存
而Android 3.0及以上的版本不需要调用recycle()，因为这些版本的Bitmap全部放到虚拟机的堆内存中，让GC自动回收。</p>
</li>
<li><p>WebView使用完是否调用了其destory()函数</p>
</li>
</ol>
<h3 id="是否能进一步优化自己的代码"><a href="#是否能进一步优化自己的代码" class="headerlink" title="是否能进一步优化自己的代码"></a>是否能进一步优化自己的代码</h3><ol>
<li><p>保存在内存中的图片，是否做过压缩处理再保存在内存里
否则可能由于图片质量太高，导致OOM</p>
</li>
<li><p>Intent传递的数据太大，会导致页面跳转过慢。太大的数据可以通过持久化的形式传递，例如读写文件</p>
</li>
<li><p>频繁地操作同一个文件或者执行同一个数据库操作，是否考虑把它用静态变量或者局部变量的形式缓存在内存里。用空间换时间</p>
</li>
<li><p>放在主页面的控件，是否可以考虑用ViewStub来优化启动速度</p>
</li>
</ol>
<h3 id="要小心第三方包"><a href="#要小心第三方包" class="headerlink" title="要小心第三方包"></a>要小心第三方包</h3><ol>
<li><p>build.gradle远程依赖第三方包时，版本号建议写死，不要使用+号
避免由于新版本的第三方包引入了新的问题</p>
</li>
<li><p>导入第三方工程时，记得把编码转换成自己工程当前是用的编码</p>
</li>
<li><p>调用第三方的包或者JDK的方法时，要跳进他们的源码，看要不要加 try-catch
否则可能会导致自己应用的崩溃</p>
</li>
<li><p>使用第三方包时，是否加上其混淆规则
若漏掉加上第三方包的混淆规则，会导致第三方包不该混淆的代码被混淆。在Debug版本没有发现问题，但是Release版本就会出现问题</p>
</li>
<li><p>系统应用添加so时，是否在固件对应的Android.mk文件上加入新增的so，否则系统可能编译不过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@lib/armeabi/libcommon.so \</div><div class="line">@lib/armeabi/libabcdefg.so \</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意要成对出现的地方"><a href="#注意要成对出现的地方" class="headerlink" title="注意要成对出现的地方"></a>注意要成对出现的地方</h3><ol>
<li><p>系统的、自己写的，注册和反注册的方法，是否成对出现</p>
</li>
<li><p>在生命周期的回调里，创建和销毁的代码是否对应起来
比如：onCreate()里面创建了Adapter，那么对应Adapter的退出处理操作(比如清空Image缓存)，一般就要写在onDestory()，而不能写在onDestoryView()。</p>
</li>
</ol>
<p>类似的生命周期对应的代码有：
onStart()、onStop();
onCreate()、onDestory();
onResume()、onPause();
onCreateView()、onDestoryView()</p>
<ol>
<li>若ListView的item复用了，对Item里View的操作是否成对出现
比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">switch (type) &#123;</div><div class="line">    case ArticleListItem.TYPE_AD:</div><div class="line">        ......</div><div class="line">        mTitleView.setText(tencentAdBean.title);</div><div class="line">        mGreenLabelView.setVisibility(VISIBLE);</div><div class="line">        mRedLabelView.setText(&quot;&quot;);</div><div class="line">        mRedLabelView.setVisibility(GONE);</div><div class="line">        break;</div><div class="line">    case ArticleListItem.TYPE_ARTICLE:</div><div class="line">        ......</div><div class="line">        mTitleView.setText(mzAdBean.adData.getTitle());</div><div class="line">        mGreenLabelView.setVisibility(GONE);</div><div class="line">        mRedLabelView.setText(&quot;ABC&quot;);</div><div class="line">        mRedLabelView.setVisibility(VISIBLE);</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>比如以上对mTitleView、mGreenLabelView和mRedLabelView的操作，都是成对出现。否则ListView可能会由于Item复用，导致Item显示错乱问题</p>
<h3 id="防内存泄漏"><a href="#防内存泄漏" class="headerlink" title="防内存泄漏"></a>防内存泄漏</h3><ol>
<li><p>内部类，比如Handler、Listener、Callback是否是成static class
因为非静态内部类会持有外部类的引用。</p>
</li>
<li><p>假如子线程持有了Activity，要用弱引用来持有
比如Request的Activity就应该用弱引用的形式，防止内存泄漏。</p>
</li>
<li><p>要求传入Activity作为参数的函数，是否可以改用getApplicationContext()来作为参数</p>
</li>
</ol>
<h3 id="Handler相关"><a href="#Handler相关" class="headerlink" title="Handler相关"></a>Handler相关</h3><ol>
<li>使用View.post()是否会有问题
因为在View处于detached状态期间，post()里面的Runnable是不会被执行的。只有在此View处于attached状态时才会被执行。</li>
</ol>
<p>如果想改Runnable每次肯定会被执行，那么应该是用Handler.post来替代</p>
<ol>
<li>假如程序可能多次在同一个Handler里post同一个Runnable，每次post之前都应该先清空这个Handler中还没执行的该Runnable
如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (mCloudRun != null) &#123;</div><div class="line">    mHandler.removeCallbacks(mCloudRun);</div><div class="line">    mCloudRun = null;</div><div class="line">&#125;</div><div class="line">mCloudRun = new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        CloudAccelerateSwitchRequest request = new CloudAccelerateSwitchRequest();</div><div class="line">        request.setPriority(RequestTask.PRIORITY_LOW);</div><div class="line">        RequestQueue.getInstance().addRequest(request);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">mHandler.post(mCloudRun);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><p>多思考某些情况下，某变量是否会为空
而且在函数体内，处理参数前，必须加上判空语句</p>
</li>
<li><p>回调函数是否处理好
回调函数很容易出问题。比如网络请求的回调，需要判断此时的Aciivity等是否还存在，再进行调用。因为异步操作回来，Activity可能就消失不存在了。
而且还要对一些可能被回收的变量进行判空。</p>
</li>
<li><p>修改数据库后，是否把数据库的版本号+1</p>
</li>
<li><p>启动第三方的Activity时，是否判断了该Intent能否被解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent sendIntent = new Intent(mContext, Demo.class);</div><div class="line">// 这种方式判断是否存在</div><div class="line">if (sendIntent.resolveActivity(getPackageManager()) != null) &#123;</div><div class="line">    startActivity(sendIntent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>若Activity不存在，会出现ActivityNotFoundException的异常</p>
<ol>
<li>新注册的Activity、Service或Provider，若AndroidManifest.xml中exported属性为true，要考虑是否会引发安全性问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;com.inkenka.DemoActivity&quot;</div><div class="line">            android:exported=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为exported属性为true时，外部应用就可以直接调用起该Activity。
可能导致的问题：</p>
<ul>
<li>若外部应用直接启动详情页，从而让某些验证页面直接被绕过</li>
<li>若外部应用给该Activity传递乱七八糟的Intent，可能让该应用崩溃。也就是Android中的拒绝服务漏洞</li>
</ul>
<ol>
<li><p>除数是否做了非0判断</p>
</li>
<li><p>不要在Activity的onCreate里调用PopupWindow的showAsLoaction方法，由于Activity还没被加载完，会报错</p>
</li>
</ol>
<h3 id="功能完成后，自测时的检查点"><a href="#功能完成后，自测时的检查点" class="headerlink" title="功能完成后，自测时的检查点"></a>功能完成后，自测时的检查点</h3><ol>
<li>思考某些情况下，某个变量是否会造成空指针问题</li>
<li>把手机横屏，检查布局是否有Bug</li>
<li>在不同分辨率的机型上，检查布局是否有Bug</li>
<li>切换到英文等外文字体下，检查外文是否能完整显示</li>
<li>从低版本升级上来，会不会有问题,比如可能会出现数据库不兼容的问题</li>
<li>按下Home再返回是否正常</li>
<li>熄灭屏幕再打开是否正常</li>
<li>切换成其它应用再切换回来会怎样</li>
<li>利用手机的开发者选项中的 “调试GPU过度绘制” ，“GPU呈现模式分析” 和 “显示FPS和功耗” 功能，看自己的新功能是否会导致过度绘制、是否会掉帧</li>
<li>测试看是否影响启动速度<code>adb shell am start -W 包名/Activity</code></li>
<li>对比看APK大小是否有增大</li>
<li>跑1小时Monkey，测试其稳定性</li>
</ol>
<blockquote>
<p>转自:
<a href="http://www.jianshu.com/p/4b65967fe4a0" target="_blank" rel="external">良心推荐：总结Android开发中必备的代码Review清单</a></p>
</blockquote>
<h2 id="补充-总结工作中的Android内存泄漏问题"><a href="#补充-总结工作中的Android内存泄漏问题" class="headerlink" title="补充:总结工作中的Android内存泄漏问题"></a>补充:<a href="http://www.jianshu.com/p/973ab884c397" target="_blank" rel="external">总结工作中的Android内存泄漏问题</a></h2><h3 id="简单判断是否有内存泄漏"><a href="#简单判断是否有内存泄漏" class="headerlink" title="简单判断是否有内存泄漏"></a>简单判断是否有内存泄漏</h3><p>判断内存泄漏的定位的大单位是Activity。</p>
<p>可以通过反复进入退出一个Activity，然后用adb shell dumpsys meminfo + 包名 查看虚拟机的堆是否有不断地增长</p>
<h3 id="定位内存泄漏"><a href="#定位内存泄漏" class="headerlink" title="定位内存泄漏"></a>定位内存泄漏</h3><h4 id="1-使用Leak-Canary"><a href="#1-使用Leak-Canary" class="headerlink" title="1.使用Leak Canary"></a>1.使用Leak Canary</h4><p>在代码上加入Leak Canary，然后不断跑Monkey或者手动反复进出不同页面。若出现内存泄漏问题，会自动导出来，生成以下页面。</p>
<h4 id="2-使用DDMS导出hprof，并用MAT工具进行分析"><a href="#2-使用DDMS导出hprof，并用MAT工具进行分析" class="headerlink" title="2.使用DDMS导出hprof，并用MAT工具进行分析"></a>2.使用DDMS导出hprof，并用MAT工具进行分析</h4><ul>
<li>强烈建议先跑30分钟Monkey测试</li>
<li>使用eclipse的ddms找到对应的进程，触发一次gc后，dump出里面的内存快照hprof文件以分析当前应用内存的堆有什么东西</li>
<li>使用Android SDK 里的platform-tools文件夹的 hprof-conv工具，对刚才 hprof 文件进行转换，以至于 后面MAT工具能正常打开</li>
<li>使用MAT打开hprof文件，进入Histogram。输入自己猜测可能泄漏的Activity（项目中Activity不多时，可每个Activity都重复以下3、4、5步骤）</li>
<li>键该其中一项，打开菜单选择list objects -&gt;with incoming refs将列出该类的实例</li>
<li>右健Path to GC Roots–&gt;exclue all phantom/weak/soft etc. reference，找出这个实例GC后，还会存在什么对象的引用关系。</li>
</ul>
<h3 id="常见导致内存泄漏的几个点"><a href="#常见导致内存泄漏的几个点" class="headerlink" title="常见导致内存泄漏的几个点"></a>常见导致内存泄漏的几个点</h3><h4 id="生命周期的原因"><a href="#生命周期的原因" class="headerlink" title="生命周期的原因"></a>生命周期的原因</h4><p>比如：Activity中关联了一个生命周期超过Activity的Thread，这个Thread 若持有该Activity的引用，就会导致内存泄漏。</p>
<h4 id="内部类的原因"><a href="#内部类的原因" class="headerlink" title="内部类的原因"></a>内部类的原因</h4><p>因为内部类会隐式地持有外部类的引用，若内部类不被释放，外部类也是无法释放。常见的有内部的Listener、Callback、Handler等导致。</p>
<p>情景1：若外部类应该释放的时候，内部类还在执行里面的函数，会导致外部类无法释放。</p>
<p>情景2：若一个异步操作，会回调内部类的Listener、Callback、Handler。当外部类应该释放的时候，但是这个异步操作还存在，而这个异步操作类又持有了Listener、Callback、Handler，导致外部类无法被释放。PS：这个原因也属于生命周期的原因。</p>
<h4 id="静态变量的原因"><a href="#静态变量的原因" class="headerlink" title="静态变量的原因"></a>静态变量的原因</h4><p>单例类里包含Activity</p>
<p>静态变量的类里引用到Activity</p>
<h4 id="注册与反注册、打开与关闭没成对出现的原因"><a href="#注册与反注册、打开与关闭没成对出现的原因" class="headerlink" title="注册与反注册、打开与关闭没成对出现的原因"></a>注册与反注册、打开与关闭没成对出现的原因</h4><p>比如：注册广播接收器、注册观察者（典型的譬如数据库的监听）等。或者自己写的跟Activity引用有关的clear()函数没有成对出现</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="解决内部类的问题（以Handler作为例子）"><a href="#解决内部类的问题（以Handler作为例子）" class="headerlink" title="解决内部类的问题（以Handler作为例子）"></a>解决内部类的问题（以Handler作为例子）</h4><ol>
<li>onDestroy时候remove所有msgActivity finish后未处理的msg是问题根源，所以清空所有未被执行的msg<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mHandler.removeCallbacksAndMessages(null);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：比如Listener、Callback等其他内部类的问题，页面退出的时候，应该完成必要的清理操作，比如Cancel 请求</p>
<ol>
<li>使用静态内部类 + weakReference
静态内部类不会保留对外部类的引用，如果一定要引用外部类，使用weakReference<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class MyHandler extends Handler &#123;</div><div class="line">        WeakReference&lt;Activity &gt; mActivityReference;</div><div class="line">        MyHandler(Activity activity) &#123;</div><div class="line">            mActivityReference= new WeakReference&lt;Activity&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            final Activity activity = mActivityReference.get();</div><div class="line">            if (activity != null) &#123;</div><div class="line">                mImageView.setImageBitmap(mBitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PS:比如Listener、Callback等其他内部类的问题，也可以通过这个方法来解决</p>
<h4 id="单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期"><a href="#单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期" class="headerlink" title="单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期"></a>单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期</h4><h4 id="对象的注册与反注册要成对出现"><a href="#对象的注册与反注册要成对出现" class="headerlink" title="对象的注册与反注册要成对出现"></a>对象的注册与反注册要成对出现</h4><h4 id="不使用WebView对象时，应该调用它的destory-函数来销毁它，并释放其占用的内存"><a href="#不使用WebView对象时，应该调用它的destory-函数来销毁它，并释放其占用的内存" class="headerlink" title="不使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存"></a>不使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存</h4><h4 id="因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View"><a href="#因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View" class="headerlink" title="因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View"></a>因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文收集了我自己工作以来提交代码前的所有检查点。事实证明，这样能有效提高自己的代码质量和功能的稳定性。所以推荐大家以后每次提交代码前，都可以
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>android架构</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-arch/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-arch/</id>
    <published>2017-12-05T03:59:48.000Z</published>
    <updated>2017-12-05T06:52:09.888Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/zqlxtt/p/6887938.html" target="_blank" rel="external">Android官方架构组件介绍之LifeCycle</a>,Android架构组件一共包括以下几个：</p>
<ul>
<li>LifeCycle ： 与Activity和Fragment的生命周期有关</li>
<li>LiveData ：异步可订阅数据，也是生命周期感知</li>
<li>ViewModel ：视图数据持有模型，也是生命周期感知</li>
<li>Room ：SQLite抽象层，用于简化SQLite数据存储</li>
</ul>
<p><a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank" rel="external">官网</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zqlxtt/p/6887938.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android官方架构组件介绍之LifeCycle&lt;/a&gt;,Android架构组件一共包括以下几个：&lt;
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>linux批量操作文件</title>
    <link href="http://wodekouwei.com/2017/11/30/tips-linux-rename/"/>
    <id>http://wodekouwei.com/2017/11/30/tips-linux-rename/</id>
    <published>2017-11-30T10:25:22.778Z</published>
    <updated>2017-11-30T10:34:25.610Z</updated>
    
    <content type="html"><![CDATA[<p>一个批量将mp4文件转成gif文件的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;*.mp4&quot; |sed &apos;s/.mp4$//g&apos;|xargs -i ffmpeg -i &#123;&#125;.mp4 &#123;&#125;.gif</div></pre></td></tr></table></figure>
<p><code>sed &#39;s/.mp4$//g&#39;</code>使用sed命令将mp4文件名的<code>.mp4</code>全部替换成空.<code>/g</code>是全局替换.s是sed的替换命令,替换格式<code>&#39;s/原文/要替换成的/&#39;</code></p>
<p>或者:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for file in $(find . -name &quot;*.mp4&quot; -type f);do ffmpeg -i &quot;$file&quot; &quot;$&#123;file%.*&#125;.gif&quot;;done</div></pre></td></tr></table></figure></p>
<p>找到所有<code>.mp4</code>文件进行循环,file是mp4文件全名,<code>${file%.*}</code>是剔除从右边最小匹配,即将<code>.mp4</code>去掉</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个批量将mp4文件转成gif文件的命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
    
    </summary>
    
      <category term="linux管理" scheme="http://wodekouwei.com/categories/linux%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>mac下Core Dump文件的行程与分析</title>
    <link href="http://wodekouwei.com/2017/11/17/env-mac-debug-c/"/>
    <id>http://wodekouwei.com/2017/11/17/env-mac-debug-c/</id>
    <published>2017-11-17T08:31:12.000Z</published>
    <updated>2017-11-17T08:56:36.978Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mac下生成core-dump"><a href="#mac下生成core-dump" class="headerlink" title="mac下生成core dump"></a>mac下生成core dump</h4><ol>
<li>使用<code>ulimit -c</code>查看ulimit设置,显示<code>unlimited</code>表示开启,显示0表示关闭,通过<code>ulimit -c unlimited</code>打开设置;
但是这个只在当前窗口有效果。如果需要变成系统全局设置。
就需要去改/etc/profile文件，打开，然后加上<code>ulimit -c unlimited</code>就可以了，这样当产生Crash的时候就会自动产生dump文件。</li>
<li><p>之后需要配置一下dump产生的规则和路径:<code>sudo sysctl kern.corefile=/cores/core.%N.%P</code>,其中%N表示进程名字，%P表示进程id。Linux还有%S,%T分别表示最后一个信号和时间，在MAC上没找到对应的。(mac默认生成的core dump在<code>/cores/</code>下).</p>
</li>
<li><p>最后如何用lldb来查看一个core dump文件<code>lldb -c core.xxx</code>. 在lldb命令下输入<code>bt</code>查看报错代码.</p>
</li>
</ol>
<p>生成太多core文件会占用电脑磁盘,可以关闭全局的core dump生成配置:</p>
<ol>
<li>永久关闭，则在/etc/sysctl.conf中加入一行（如果存在，则将其值修改为0），重启后生效：<code>kern.coredump=0</code></li>
<li>零时关闭，当前生效，重启后失效：<code>sudo sysctl -w kern.coredump=0</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;mac下生成core-dump&quot;&gt;&lt;a href=&quot;#mac下生成core-dump&quot; class=&quot;headerlink&quot; title=&quot;mac下生成core dump&quot;&gt;&lt;/a&gt;mac下生成core dump&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;ulim
    
    </summary>
    
      <category term="env" scheme="http://wodekouwei.com/categories/env/"/>
    
    
      <category term="Mac" scheme="http://wodekouwei.com/tags/Mac/"/>
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="C" scheme="http://wodekouwei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>android兼容性</title>
    <link href="http://wodekouwei.com/2017/11/14/tips-android-compatibility/"/>
    <id>http://wodekouwei.com/2017/11/14/tips-android-compatibility/</id>
    <published>2017-11-14T06:48:39.000Z</published>
    <updated>2017-11-14T07:06:52.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="oppo-r9s无法浮层无法显示问题"><a href="#oppo-r9s无法浮层无法显示问题" class="headerlink" title="oppo r9s无法浮层无法显示问题"></a>oppo r9s无法浮层无法显示问题</h3><p>oppo r9s,系统版本6.0.1,<code>wmParams.type = WindowManager.LayoutParams.TYPE_TOAST;</code>时无法正常弹出,改成<code>wmParams.type = WindowManager.LayoutParams.TYPE_PHONE;</code>可显示.</p>
<p>在activity中弹出浮层后马上将activity movetoback导致oppo r9s 浮层无法显示,moveTaskToBack后延迟一秒显示浮层可解决问题.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//moveTaskToBack</div><div class="line">val intent = Intent(Intent.ACTION_MAIN)</div><div class="line">                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK// 注意</div><div class="line">                intent.addCategory(Intent.CATEGORY_HOME)</div><div class="line">                aty.startActivity(intent)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;oppo-r9s无法浮层无法显示问题&quot;&gt;&lt;a href=&quot;#oppo-r9s无法浮层无法显示问题&quot; class=&quot;headerlink&quot; title=&quot;oppo r9s无法浮层无法显示问题&quot;&gt;&lt;/a&gt;oppo r9s无法浮层无法显示问题&lt;/h3&gt;&lt;p&gt;oppo r
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>SQL查询案例</title>
    <link href="http://wodekouwei.com/2017/11/08/db-sql-query/"/>
    <id>http://wodekouwei.com/2017/11/08/db-sql-query/</id>
    <published>2017-11-08T07:47:36.000Z</published>
    <updated>2017-11-08T08:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>如下数据库表:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Student(S#,Sname,Sage,Ssex)学生表</div><div class="line">S#：学号</div><div class="line">Sname：学生姓名</div><div class="line">Sage：学生年龄</div><div class="line">Ssex：学生性别</div><div class="line">Course(C#,Cname,T#)课程表</div><div class="line">C#：课程编号</div><div class="line">Cname：课程名称</div><div class="line">T#：教师编号</div><div class="line">SC(S#,C#,score)成绩表</div><div class="line">S#：学号</div><div class="line">C#：课程编号</div><div class="line">score：成绩</div><div class="line">Teacher(T#,Tname)教师表</div><div class="line">T#：教师编号：</div><div class="line">Tname：教师名字</div></pre></td></tr></table></figure></p>
<ol>
<li><p>查询“001”课程比“002”课程成绩高的所有学生的学号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select a.S# from (select S#,score from SC where C#=&apos;001&apos;)a, (select s#,score from SC where c#=&apos;002&apos;)b Where a.score&gt;b.score</div></pre></td></tr></table></figure>
</li>
<li><p>查询平均成绩大于60分的同学的学号和平均成绩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">查询平均成绩大于60分的同学的学号和平均成绩</div></pre></td></tr></table></figure>
</li>
<li><p>查询所有同学的学号、姓名、选课数、总成绩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select student.S#, student.Sname, count(sc.C#), sum(score) from student left outer join SC on student.S# = SC.S# group by S</div></pre></td></tr></table></figure>
</li>
<li><p>查询姓‘李’的老师的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select count(distinct(Tname))</div><div class="line">from teacher</div><div class="line">where tname like &apos;李%&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>查询没有学过“叶平”老师可的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select student.S#, student.Sname</div><div class="line">from Student</div><div class="line">where S# not in (select distinct(SC.S#) from SC,Course,Teacher</div><div class="line">where sc.c#=course.c# AND teacher.T#=course.T# AND Teahcer.Tname =&apos;叶平&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>查询学过“叶平”老师所教的所有课的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select S#,Sname   from Student    </div><div class="line">where S# in (select S# from SC ,Course ,Teacher</div><div class="line">where SC.C#=Course.C# and Teacher.T#=Course.T#</div><div class="line">and Teacher.Tname=&apos;叶平&apos; group by S#</div><div class="line">having count(SC.C#)=(select count(C#) from Course,Teacher  </div><div class="line">where Teacher.T#=Course.T# and Tname=&apos;叶平&apos;));</div></pre></td></tr></table></figure>
</li>
<li><p>查询学过“011”并且也学过编号“002”课程的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select Student.S#,Student.Sname</div><div class="line">from Student,SC where Student.S#=SC.S#</div><div class="line">and SC.C#=&apos;001&apos;and</div><div class="line">exists( Select * from SC as SC_2 where SC_2.S#=SC.S# and SC_2.C#=&apos;002&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Select S#,Sname</div><div class="line">from (select Student.S#,Student.Sname,score ,</div><div class="line">(select score from SC SC_2 where SC_2.S#=Student.S# and SC_2.C#=&apos;002&apos;) score2    </div><div class="line">from Student,SC</div><div class="line">where Student.S#=SC.S# and C#=&apos;001&apos;) S_2</div><div class="line">where score2 &lt; score;</div></pre></td></tr></table></figure>
</li>
<li><p>查询所有课程成绩小于60的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select S#, sname</div><div class="line">from student</div><div class="line">where s# not in</div><div class="line">(select student.s# from student, sc where s.s# = sc.s# and score&gt;60);</div></pre></td></tr></table></figure>
</li>
<li><p>查询没有学全所有课的同学的学号、姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select student.s#, student.sname</div><div class="line">from student, sc</div><div class="line">where student.s#=sc.s#</div><div class="line">group by student.s#, student.sname</div><div class="line">having count(c#)&lt;(select count(c#) from course);</div></pre></td></tr></table></figure>
</li>
<li><p>查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select s#, Sname</div><div class="line">from Student, SC</div><div class="line">where student.s# = sc.s#</div><div class="line">and c# in (select c# from SC where s#=&apos;1001&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select distinct sc.s# , sname</div><div class="line">from student, sc</div><div class="line">where student.s#=sc.s#</div><div class="line">and c# in (select C# from sc where s#=&apos;001&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Update Sc Set Score=(Select Avg(s2_Score) From sc s2 Where s2.c#=sc.c#)  </div><div class="line">Where c# IN</div><div class="line">(Select c# From sc cs INNER JOIN Teacher tc ON cs.t#=tc.t# WHERE tname =&apos;叶平&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p>查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select s# from sc where c#  in</div><div class="line">(select c# from sc where s#=&apos;1002&apos;)</div><div class="line">group by s# having count(*)=</div><div class="line">(select count(*) from sc where s#=&apos;1002&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>删除学习“叶平”老师课的SC表记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">delect sc</div><div class="line">from course, Teacher</div><div class="line">where course.c#=sc.c#</div><div class="line">and course.t#=teacher.t#</div><div class="line">and tname=&apos;叶平&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Insert SC select S#,&apos;002&apos;,</div><div class="line">(Select avg(score) from SC where C#=&apos;002&apos;)</div><div class="line">from Student where S# not in (Select S# from SC where C#=&apos;002&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示：学生ID，数据库，企业管理，英语，有效课程数，有效平均分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select s# as 学生ID,</div><div class="line">(select score from sc where sc.s#=t.s# and c#=&apos;004&apos;) as 数据库,</div><div class="line">(select score from sc where sc.s#=t.s# and c#=&apos;001&apos;) as 企业管理,</div><div class="line">(select score from sc where sc.s#=t.s# and c#=&apos;006&apos;) as 英语,</div><div class="line">count(*) as 有效课程数, avg(t.score) as 平局成绩</div><div class="line">from sc as t</div><div class="line">group by s#</div><div class="line">order by avg(t.score)</div></pre></td></tr></table></figure>
</li>
<li><p>查询各科成绩最高和最低的分： 以如下的形式显示：课程ID，最高分，最低分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">select L.c# as 课程ID, L.score as 最高分,</div><div class="line">R.score as 最低分</div><div class="line">from sc L, sc R</div><div class="line">where L.c# = R.c#</div><div class="line">and L.score = (select max(IL.score)</div><div class="line">        from sc IL, student as IM</div><div class="line">        where L.c#=IL.c# and IM.s#=IL.s#</div><div class="line">        group by IL.c#)</div><div class="line">and R.score = (select min(IR.score)</div><div class="line">        from sc as IR</div><div class="line">        where R.c#=IR.c#</div><div class="line">        group by IR.c#);</div></pre></td></tr></table></figure>
</li>
<li><p>按各科平均成绩从低到高和及格率的百分数从高到低顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT t.C# AS 课程号,</div><div class="line">max(course.Cname)AS 课程名,</div><div class="line">isnull(AVG(score),0) AS 平均成绩,</div><div class="line">100 * SUM(CASE WHEN  isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) AS 及格百分数     </div><div class="line">FROM SC T,Course     </div><div class="line">where t.C#=course.C#     </div><div class="line">GROUP BY t.C#      </div><div class="line">ORDER BY 100 * SUM(CASE WHEN  isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) DESC</div></pre></td></tr></table></figure>
</li>
<li><p>查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）：</p>
</li>
<li><p>查询不同老师所教不同课程平均分从高到低显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT max(Z.T#) AS 教师ID,</div><div class="line">MAX(Z.Tname) AS 教师姓名,</div><div class="line">C.C# AS 课程ID,</div><div class="line">AVG(Score) AS 平均成绩     </div><div class="line">FROM SC AS T,Course AS C ,Teacher AS Z    </div><div class="line">where T.C#=C.C# and C.T#=Z.T#   </div><div class="line">GROUP BY C.C#    </div><div class="line">ORDER BY AVG(Score) DESC</div></pre></td></tr></table></figure>
</li>
<li><p>查询如下课程成绩第3名到第6名的学生成绩单：企业管理(001)，马克思(002)，UML(003)，数据库(004)：</p>
</li>
<li><p>统计下列各科成绩，各分数段人数：课程ID，课程名称，[100-85],[85-70],[70-60],[ 小于60] ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT SC.C# as 课程ID, Cname as 课程名称,</div><div class="line">SUM(CASE WHEN score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS [100 - 85]  ,</div><div class="line">SUM(CASE WHEN score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS [85 - 70],</div><div class="line">SUM(CASE WHEN score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS [70 - 60],</div><div class="line">SUM(CASE WHEN score &lt; 60 THEN 1 ELSE 0 END) AS [60 -]     </div><div class="line">FROM SC,Course     </div><div class="line">where SC.C#=Course.C#     </div><div class="line">GROUP BY SC.C#,Cname;</div></pre></td></tr></table></figure>
</li>
<li><p>查询学生平均成绩及其名次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SELECT 1+(SELECT COUNT( distinct 平均成绩)                </div><div class="line">FROM (SELECT S#,AVG(score) AS 平均成绩                       </div><div class="line">FROM SC                   </div><div class="line">GROUP BY S#  ) AS T1  WHERE 平均成绩 &gt; T2.平均成绩) as 名次,       </div><div class="line">S# as 学生学号,平均成绩      </div><div class="line">FROM (SELECT S#,AVG(score) 平均成绩             </div><div class="line">FROM SC         </div><div class="line">GROUP BY S# ) AS T2      </div><div class="line">ORDER BY 平均成绩 desc;</div></pre></td></tr></table></figure>
</li>
<li><p>查询各科成绩前三名的记录（不考虑成绩并列情况）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SELECT t1.S# as 学生ID,t1.C# as 课程ID,Score as 分数       </div><div class="line">FROM SC t1        </div><div class="line">WHERE score IN</div><div class="line">(SELECT TOP 3 score               </div><div class="line">FROM SC               </div><div class="line">WHERE t1.C#= C#             </div><div class="line">ORDER BY score DESC)</div><div class="line">```        </div><div class="line">26. 查询每门课程被选修的学生数：</div></pre></td></tr></table></figure>
</li>
</ol>
<p>select c#, count(s#)
from sc
group by c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">27. 查询出只选修一门课程的全部学生的学号和姓名：</div></pre></td></tr></table></figure></p>
<p>select sc.s#, student.sname, count(c#) as 选课数
from sc,student
where sc.s# =student.s#
group by sc.s#,Student.sname
having count(c#)=1;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">28. 查询男生、女生人数：</div></pre></td></tr></table></figure></p>
<p>select count(Ssex) as 男生人数
from student
group by Ssex
having Ssex=’男’；
select count(Ssex) as 女生人数
from student
group by Ssex
having Ssex=’女’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">29. 查询姓“张”的学生名单：</div></pre></td></tr></table></figure></p>
<p>select sname
from student
where sname like ‘张%’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30. 查询同名同姓的学生名单，并统计同名人数：</div></pre></td></tr></table></figure></p>
<p>select sanme,count(<em>)
from student
group by sname
havang count(</em>)&gt;1;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">31. 1981年出生的学生名单（注：student表中sage列的类型是datetime）:</div></pre></td></tr></table></figure></p>
<p>select sname, convert(char(11),DATEPART(year,sage)) as age
from student
where convert(char(11),DATEPART(year,Sage))=’1981’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">32. 查询平均成绩大于85的所有学生的学号、姓名和平均成绩：</div></pre></td></tr></table></figure></p>
<p>select Sname,SC.S# ,avg(score)<br>from Student,SC<br>where Student.S#=SC.S#
group by SC.S#,Sname
having    avg(score)&gt;85;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">33. 查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列：</div></pre></td></tr></table></figure></p>
<p>select C#, avg(score)
from sc
group by c#
order by avg(score), c# desc;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">34. 查询课程名称为“数据库”，且分数低于60的学生名字和分数：</div></pre></td></tr></table></figure></p>
<p>select sname, isnull(score,0)
from student, sc ,course
where sc.s#=student.s#  and sc.c#=course.c# and course.cname=’数据库’ and score<60; <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">35. 查询所有学生的选课情况：</div></pre></td></tr></table></60;></p>
<p>select sc.s#,sc.c#,sname,cname
from sc,student course
where sc.s#=student.s# and sc.c#=course.c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">36. 查询任何一门课程成绩在70分以上的姓名、课程名称和分数：</div></pre></td></tr></table></figure></p>
<p>select distinct student.s#,student.sname,sc.c#,sc.score
from student,sc
where sc.score&gt;=70 and sc.s#=student.s#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">37. 查询不及格的课程，并按课程号从大到小的排列：</div></pre></td></tr></table></figure></p>
<p>select c#
from sc
where score<60 order="" by="" c#;="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">38. 查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名：</div></pre></td></tr></table></60></p>
<p>select sc.s#,student.sname
from sc,student
where sc.s#=student.s# and score&gt;80 and c#=’003’;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">39. 求选了课程的学生人数：</div></pre></td></tr></table></figure></p>
<p>select count(*) from sc;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">40. 查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩：</div></pre></td></tr></table></figure></p>
<p>select student.sname,score
from student,sc,course c, teacher
where student.s#=sc.S# and sc.c#=c.c#
and c.T#=teacher.T#
and teacher.tname=’叶平’
and sc.score=(select max(score) from sc where c#=c.c#);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">41. 查询各个课程及相应的选修人数：</div></pre></td></tr></table></figure></p>
<p>select count(*) from sc group by c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">42. 查询不同课程成绩相同的学生和学号、课程号、学生成绩：</div></pre></td></tr></table></figure></p>
<p>select distinct a.s#,b.score
from sc a ,sc b
where a.score=b.score
and a.c#&lt;&gt;b.c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">43. 查询每门课程成绩最好的前两名：</div></pre></td></tr></table></figure></p>
<p>select t1.s# as 学生ID,t1.c#  课程ID, Score as 分数
from sc t1
where score in (select top 2 score from sc
        where t1.c#=c#
        order by score desc)
order by t1.c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">44. 统计每门课程的学生选修人数(超过10人的课程才统计)。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序：</div></pre></td></tr></table></figure></p>
<p>select c# as 课程号,count(<em>) as 人数
from sc
group by c#
order by count(</em>) desc c#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">45. 检索至少选修两门课程的学生学号：</div></pre></td></tr></table></figure></p>
<p>select s#
from sc
group by s#
having count(*)&gt;=2;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">46. 查询全部学生选修的课程和课程号和课程名：</div></pre></td></tr></table></figure></p>
<p>select c# ,cname
from course
where c# in (select c# from sc group by c#);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">47. 查询没学过”叶平”老师讲授的任一门课程的学生姓名：</div></pre></td></tr></table></figure></p>
<p>select sname
from student
where s# not in (select s# from course,teacher,sc where course.t#=teacher.t# and sc.c#=course.c#
and tname=’叶平’);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">48. 查询两门以上不及格课程的同学的学号以及其平均成绩：</div></pre></td></tr></table></figure></p>
<p>select s#,avg(isnull(score,0))
from sc
where s# in (select s# from sc where score<60 group="" by="" s#="" having="" count(*)="">2)
group by s#;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">49. 检索“004”课程分数小于60，按分数降序排列的同学学号：</div></pre></td></tr></table></figure></60></p>
<p>select s#
from sc
where c#=’004’
and score<60 order="" by="" score="" desc;="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">50. 删除“002”同学的“001”课程的成绩：</div></pre></td></tr></table></60></p>
<p>delect from sc
where s#=’002’
and c#=’001’;
```</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如下数据库表:
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;
    
    </summary>
    
      <category term="db" scheme="http://wodekouwei.com/categories/db/"/>
    
    
      <category term="sql" scheme="http://wodekouwei.com/tags/sql/"/>
    
      <category term="db" scheme="http://wodekouwei.com/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>android-phone-compatibility</title>
    <link href="http://wodekouwei.com/2017/11/02/android-phone-compatibility/"/>
    <id>http://wodekouwei.com/2017/11/02/android-phone-compatibility/</id>
    <published>2017-11-02T09:26:11.000Z</published>
    <updated>2017-11-02T09:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="系统摄像视频文件格式"><a href="#系统摄像视频文件格式" class="headerlink" title="系统摄像视频文件格式"></a>系统摄像视频文件格式</h4><p>一般手机使用摄像头录制视频格式为yuv420p,而小米5录制出的为yuvj420p.格式转换是yuvj420p当成yuv420p处理即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;系统摄像视频文件格式&quot;&gt;&lt;a href=&quot;#系统摄像视频文件格式&quot; class=&quot;headerlink&quot; title=&quot;系统摄像视频文件格式&quot;&gt;&lt;/a&gt;系统摄像视频文件格式&lt;/h4&gt;&lt;p&gt;一般手机使用摄像头录制视频格式为yuv420p,而小米5录制出的为yuvj4
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="compatibility" scheme="http://wodekouwei.com/tags/compatibility/"/>
    
  </entry>
  
  <entry>
    <title>ndk编译常见问题</title>
    <link href="http://wodekouwei.com/2017/11/01/issue-ndk-compile/"/>
    <id>http://wodekouwei.com/2017/11/01/issue-ndk-compile/</id>
    <published>2017-11-01T02:27:28.000Z</published>
    <updated>2017-11-01T04:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="depends-on-undefined-modules"><a href="#depends-on-undefined-modules" class="headerlink" title="depends on undefined modules"></a>depends on undefined modules</h4><p>问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Users/shenjunwei/program/android-ndk-r14b/build/core/build-binary.mk:687: Android NDK: Module magicsdk_fmod depends on undefined modules: cutils</div><div class="line">/Users/shenjunwei/program/android-ndk-r14b/build/core/build-binary.mk:700: *** Android NDK: Aborting (set APP_ALLOW_MISSING_DEPS=true to allow missing dependencies)    .  Stop.</div></pre></td></tr></table></figure></p>
<p>解决方案:
Android.mk中增加<code>APP_ALLOW_MISSING_DEPS=true</code></p>
<h4 id="shared-library-text-segment-is-not-shareable"><a href="#shared-library-text-segment-is-not-shareable" class="headerlink" title="shared library text segment is not shareable"></a>shared library text segment is not shareable</h4><p>问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/shenjunwei/program/android-ndk-r14b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/../../../../arm-linux-androideabi/bin/ld: warning: shared library text segment is not shareable</div><div class="line">/Users/shenjunwei/program/android-ndk-r14b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/../../../../arm-linux-androideabi/bin/ld: error: treating warnings as errors</div><div class="line">clang++: error: linker command failed with exit code 1 (use -v to see invocation)</div><div class="line">make: *** [/Users/shenjunwei/Documents/repository/wonxing/normandy_android_app/modules-int/magicsdk_core/src/main/obj/local/armeabi-v7a/libmagicsdk_ex.so] Error 1</div></pre></td></tr></table></figure></p>
<p>解决:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from Android NDK r11 you can use</div><div class="line"></div><div class="line">LOCAL_LDLIBS += -Wl,--no-warn-shared-textrel</div><div class="line">You can also use</div><div class="line"></div><div class="line">LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true</div></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/19986523/shared-library-text-segment-is-not-shareable" target="_blank" rel="external">shared library text segment is not shareable</a></p>
</blockquote>
<h4 id="has-text-relocations"><a href="#has-text-relocations" class="headerlink" title="has text relocations"></a>has text relocations</h4><p>问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/data/app/com.wonxing.touchfa-2/lib/arm/libmagicsdk_ex.so: has text relocations</div><div class="line">E/FileUtil: access inferno failed! /data/app/com.wonxing.touchfa-2/lib/arm/libmagicsdk_ex.so</div><div class="line">                                                             java.lang.UnsatisfiedLinkError: dlopen failed: /data/app/com.wonxing.touchfa-2/lib/arm/libmagicsdk_ex.so: has text relocations</div><div class="line">                                                                 at java.lang.Runtime.load0(Runtime.java:897)</div><div class="line">                                                                 at java.lang.System.load(System.java:1505)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.util.FileUtil$EXLibUtil.load(FileUtil.java:465)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.MagicRecorder.loadEXLibrary(MagicRecorder.java:280)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.MagicRecorder.prepare(MagicRecorder.java:471)</div><div class="line">                                                                 at com.wonxing.magicsdk.core.MagicRecorder.prepare(MagicRecorder.java:352)</div><div class="line">                                                                 at com.wonxing.touchfa.ui.activity.VideoImportActivity.preparePlaySDK(VideoImportActivity.java:144)</div></pre></td></tr></table></figure></p>
<p>解决:</p>
<ol>
<li>方案一
This issue could be solved by checking the targetSDKVersion in the manifest file.</li>
</ol>
<p>Using “22” and not “23” as targetSDKVersion solved it. (See below)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;uses-sdk</div><div class="line">        android:minSdkVersion=&quot;15&quot;</div><div class="line">        android:targetSdkVersion=&quot;22&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>I also checked the build.gradle files for compile version and targetSDKversion:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">compileSdkVersion 22</div><div class="line">    buildToolsVersion &apos;22.0.1&apos;</div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        minSdkVersion 15</div><div class="line">        targetSdkVersion 22</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>方案二
It was caused by the ffmpeg, and it could also be solved by patching the latest ffmpeg code<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">libavcodec\arm\fft_fixed_neon.S</div><div class="line">libavcodec\arm\fft_neon.S</div><div class="line">libavcodec\arm\fft_vfp.S</div><div class="line">libavcodec\arm\mlpdsp_armv5te.S</div><div class="line">libutil\arm\asm.S</div></pre></td></tr></table></figure>
</li>
</ol>
<p>I took the latest from <a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">https://github.com/FFmpeg/FFmpeg</a></p>
<p>You will also need HAVE_SECTION_DATA_REL_RO declared somewhere in your build for the macro in asm.S to use the dynamic relocations option.</p>
<ol>
<li>方案三(Further informations:)
Previous versions of Android would warn if asked to load a shared library with text relocations:</li>
</ol>
<p>“libfoo.so has text relocations. This is wasting memory and prevents security hardening. Please fix.”.</p>
<p>Despite this, the OS will load the library anyway. Marshmallow rejects library if your app’s target SDK version is &gt;= 23. System no longer logs this because it assumes that your app will log the dlopen(3) failure itself, and include the text from dlerror(3) which does explain the problem. Unfortunately, lots of apps seem to catch and hide the UnsatisfiedLinkError throw by System.loadLibrary in this case, often leaving no clue that the library failed to load until you try to invoke one of your native methods and the VM complains that it’s not present.</p>
<p>You can use the command-line scanelf tool to check for text relocations. You can find advice on the subject on the internet; for example <a href="https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide" target="_blank" rel="external">https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide</a> is a useful guide.</p>
<p>And you can check if your shared lbirary has text relocations by doing this:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readelf -a path/to/yourlib.so | grep TEXTREL</div></pre></td></tr></table></figure></p>
<p>If it has text relocations, it will show you something like this:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x00000016 (TEXTREL)                    0x0</div></pre></td></tr></table></figure></p>
<p>If this is the case, you may recompile your shared library with the latest NDK version available:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ndk-build -B -j 8</div></pre></td></tr></table></figure>
<p>And if you check it again, the grep command will return nothing.</p>
<blockquote>
<p><a href="https://android-developers.googleblog.com/2016/06/android-changes-for-ndk-developers.html" target="_blank" rel="external">Android Developers Blog</a>
<a href="https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide#Introduction" target="_blank" rel="external">Hardened/Textrels Guide</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;depends-on-undefined-modules&quot;&gt;&lt;a href=&quot;#depends-on-undefined-modules&quot; class=&quot;headerlink&quot; title=&quot;depends on undefined modules&quot;&gt;&lt;/a&gt;de
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="issue" scheme="http://wodekouwei.com/tags/issue/"/>
    
      <category term="NDK" scheme="http://wodekouwei.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>最近应用杀掉进程application不销毁问题探讨</title>
    <link href="http://wodekouwei.com/2017/10/31/tips-android-application-recent/"/>
    <id>http://wodekouwei.com/2017/10/31/tips-android-application-recent/</id>
    <published>2017-10-31T12:15:34.000Z</published>
    <updated>2017-10-31T12:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>建雨在芝士圈应用的application中使用了全局静态变量标志是否正在录制中,开启直播后将该变量设置为录制中,录制中一些操作将被屏蔽.但是对某些手机(如htc d816)当从”最近应用”杀掉进程后有时候application不被回收,该状态变量无法通过application的onCreate中重新初始化,同时通知栏也未消失.在<a href="http://www.jianshu.com/p/169bd25ce96e" target="_blank" rel="external">Android 应用被杀后Notification不取消问题及应用深杀和浅杀时Service生命周期情况</a>探讨中找到service的<strong>onTaskRemoved</strong>方法可以监听到应用被从最近应用中移除.</p>
<p>关于&lt;<android 应用被杀后notification不取消问题及应用深杀和浅杀时service生命周期情况="">&gt;摘要:
目中有如下需求：后台service进行导入操作，要更新Notification。当运行系统清理使应用被杀时，Notification无法取消，仍然在通知栏显示。为解决这个问题进行了如下探索：</android></p>
<p>首先想到利用service的startForeground()来更新通知栏，这样当应用被杀掉时候Notification可以一起被去掉。但针对项目的需求：service可以同时导入多个文件，并且会对应显示多个通知。这种情况下用service.startForeground()更新通知栏时候，当应用被杀时候之后cancel掉最后一次调用startForeground对应id的Notification，而其他通知仍然不能被取消。</p>
<p>继续探索用其他方式取消通知栏：在进程被杀掉的时候，会调用service的哪些生命周期函数呢？service的onDestroy()方法只有在调用Context的stopService()或Service的stopSelf()后才会被调用，在应用被杀时候Service的onDestroy()不会被执行。</p>
<p>我们发现service的 onTaskRemoved()方法，该方法何时被调用呢？方法的注释说明是这么写的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* This is called if the service is currently running and the user has</div><div class="line">* removed a task that comes from the service&apos;s application.  If you have</div><div class="line">* set &#123;@linkandroid.content.pm.ServiceInfo#FLAG_STOP_WITH_TASK ServiceInfo.FLAG_STOP_WITH_TASK&#125;</div><div class="line">* then you will not receive this callback; instead, the service will simply</div><div class="line">* be stopped.</div><div class="line">*</div><div class="line">*@paramrootIntentThe original root Intent that was used to launch</div><div class="line">* the task that is being removed.</div><div class="line">*/</div><div class="line"></div><div class="line">public void onTaskRemoved(Intent rootIntent) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释表明onTaskRemoved()方法在当用户移除应用的一个Task栈时被调用。也就是当用户在最近任务界面把该应用的一个task划掉时，或者在最近任务界面进行清理时。这两种情况下onTaskRemoved()都会被调用，但在大多Android机型上，这两种情况有所不同：第一种情况即应用被浅杀(用户只划掉这一个Task)，该Task栈会被清理，但如果有后台service在运行，该应用的进程不会被杀掉，后台service仍然在运行。第二种即应用被深杀(用户在最近任务界面直接按清理按钮)，该应用的进程会被直接杀掉，后台的service当然也停止了。对于不同的手机品牌和机型在最近任务进行各种清理时过程可能不太一样，但应用浅杀和深杀对于所有Android手机都是有普遍意义的。</p>
<p>下面我们分析在应用被浅杀和被深杀以及先浅杀再深杀后的生命周期：</p>
<p>浅杀：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">04-21 17:55:13.733 8264-8264/com.qintong.test D/qintong: vCardService onTaskRemoved.</div></pre></td></tr></table></figure></p>
<p>深杀：
会出现两种情况：
(a).
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">04-26 16:20:00.349 32674-32674/? D/qintong: Service onTaskRemoved.</div><div class="line">04-26 16:21:01.621 2936-2936/? D/qintong: Service is being created.</div><div class="line">04-26 16:21:01.628 2936-2936/? D/qintong: Service onStartCommand.</div></pre></td></tr></table></figure></p>
<p>(b).
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">04-21 17:59:58.397 8264-8264/com.qintong.test D/qintong: Service onCreate.</div><div class="line">04-21 17:59:58.404 8264-8264/com.qintong.test D/qintong: Service onTaskRemoved.</div></pre></td></tr></table></figure></p>
<p>浅杀＋深杀 （service 的 onStartCommand 返回 STICKY）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">04-21 18:05:12.717 8264-8264/com.qintong.test D/qintong: Service onTaskRemoved.</div><div class="line">04-21 18:05:29.214 9207-9207/com.qintong.test D/qintong: Service onCreate.</div><div class="line">04-21 18:05:29.223 9207-9207/com.qintong.test D/qintong: Service onStartCommand.</div></pre></td></tr></table></figure></p>
<p>我们来分析这几种情况：
(1).浅杀时:应用进程没被杀掉，service仍然在执行，service的onTaskRemoved()立即被调用。</p>
<p>(2).深杀时：有两种情况：第一种情况是深杀后直接调用onTaskRemoved()且service停止，过段时间后service重启调用其onCreate()和onStartCommand()。第二种是应用的进程被杀掉，过一会后service的onCreate()方法被调用，紧接着onTaskRemoved()被调用。由于被深杀后应用的进程立刻停止了，所以service的onTaskRemoved()无法被立即调用。而过若干秒后，service重启，onCreate()被调用，紧接着onTaskRemoved()被调用。而这里service的其他方法并没有被调用，即使onStartCommand()返回STICKY，service重启后onStartCommand()方法也没有被调用。</p>
<p>(3).浅杀+深杀时(service 的 onStartCommand 返回 STICKY)：onTaskRemoved()立刻被调用(浅杀后)，深杀后过段时间onCreate()和onStartCommand()相继被调用。执行浅杀Task被清理，应用的进程还在，onTaskRemoved()被调用，过程与(1)一样。再执行深杀：由于该应用的Task栈已经没有了，所有再深杀onTaskRemoved()不会再被调用，深杀后service停止。而由于实验时候onStartCommand()返回STICKY，所有service过段时间会被再次启动，执行了onCreate()方法和onStartCommand()方法。</p>
<p>所以综上所述，service的onTaskRemoved()在应用浅杀后会被立即调用而在service被深杀后，会直接调用onTaskRemoved或service会被重启并调用onTaskRemoved()。</p>
<p>回到我们的问题：应用被杀后，如何取消Notification：
我们先看最后的解决方案，在来分析为何能work。
service的代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onCreate() &#123;</div><div class="line">  super.onCreate();</div><div class="line">  mBinder=newMyBinder();</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService is being created.&quot;);</div><div class="line">  mNotificationManager= ((NotificationManager)getSystemService(NOTIFICATION_SERVICE));</div><div class="line">  initExporterParams();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public int onStartCommand(Intent intent, intflags, intid) &#123;</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService onStartCommand.&quot;);</div><div class="line">  mNotificationManager.cancelAll();</div><div class="line">  return START_STICKY;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onTaskRemoved(Intent rootIntent) &#123;</div><div class="line">  if(DEBUG) Log.d(LOG_TAG,&quot;vCardService onTaskRemoved.&quot;);</div><div class="line">  mNotificationManager.cancelAll();</div><div class="line">  super.onTaskRemoved(rootIntent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上代码，在浅杀时候：只执行onTaskRemoved()，通知被取消，但service仍然在运行，所以还会继续发通知，正常运行。
深杀时：第一种情况直接调用onTaskRemoved()且service停止，通知被取消。第二种情况，进程被杀掉，几秒后service重启，onCreate() -&gt; onTaskRemoved()，运行结果就是深杀后过几秒后Notification被取消。
浅杀+深杀时：浅杀后onTaskRemoved()被调用，service仍在运行，通知仍然在更新。深杀时，onCreate() -&gt; onStartCommand()，在onStartCommand()时候取消通知。
另外，mNotificationManager.cancelAll()会清除应用的所有通知，如果应用想保留和该service无关其他通知，可以调用mNotificationManager.cancel(String tag, int id)或cancel(int id)清除指定通知。
当然，还可以有另一种方式：浅杀时后就把service后台执行的任务停止，并清理notification，我们可以根据需求来选择。</p>
<p>补充：
疑问：1.为啥有时候深杀不立即调用onTaskRemoved()，而是在重启之后调用的呢？
stackoverflow上的答复:<a href="https://stackoverflow.com/questions/32224233/ontaskremoved-called-after-oncreate-in-started-service-on-swipe-out-from-recent/41506752" target="_blank" rel="external">https://stackoverflow.com/questions/32224233/ontaskremoved-called-after-oncreate-in-started-service-on-swipe-out-from-recent/41506752</a>
大意是service执行较重UI操作时候service不会立即停止，而新的service会启动。不太确定这个解释的正确性……</p>
<blockquote>
<p>Calling onTaskRemoved of the running service(when app gets swiped out from recent apps) will be generally delayed if we are performing any heavy UI related stuff or broadcasting messages to receivers in service.
E.g , Assume you are downloading the file of size 50MB from web server, so from web server everytime you are reading 1024bytes of stream data as buffer and that data you are writing to a file in device.
Meanwhile you are updating the progress to the UI thread which means every KB you are updating to the UI thread, this will cause the application to freeze.
So in between if you swipe-out from recent app list , then the system will try to stop the service but since the service is in-contact with the UI thread, the system will be unable to stop that service, but it will create new service eventhough the old service is not yet stopped.
Once old service finishes the communication with the UI thread then onTaskRemoved() gets called and the old service will be stopped. The new service will be running in the background.
2.为何servive.startForeground()添加的Notification可以在service被杀死后去掉呢？我们分析源码：ActiveServices中killServicesLocked()-&gt;scheduleServiceRestartLocked()中调用了r.cancelNotification()，清除了notification:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public void cancelNotification() &#123;</div><div class="line">        if (foregroundId != 0) &#123;</div><div class="line">            // Do asynchronous communication with notification manager to</div><div class="line">            // avoid deadlocks.</div><div class="line">            final String localPackageName = packageName;</div><div class="line">            final int localForegroundId = foregroundId;</div><div class="line">            ams.mHandler.post(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    INotificationManager inm = NotificationManager.getService();</div><div class="line">                    if (inm == null) &#123;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                    try &#123;</div><div class="line">                        inm.cancelNotificationWithTag(localPackageName, null,</div><div class="line">                                localForegroundId, userId);</div><div class="line">                    &#125; catch (RuntimeException e) &#123;</div><div class="line">                        Slog.w(TAG, &quot;Error canceling notification for service&quot;, e);</div><div class="line">                    &#125; catch (RemoteException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建雨在芝士圈应用的application中使用了全局静态变量标志是否正在录制中,开启直播后将该变量设置为录制中,录制中一些操作将被屏蔽.但是对某些手机(如htc d816)当从”最近应用”杀掉进程后有时候application不被回收,该状态变量无法通过applicatio
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin语法</title>
    <link href="http://wodekouwei.com/2017/10/31/l-kotlin/"/>
    <id>http://wodekouwei.com/2017/10/31/l-kotlin/</id>
    <published>2017-10-31T12:13:42.000Z</published>
    <updated>2017-12-05T03:54:43.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;chaychan&quot;</div><div class="line">println(str1 == str2)</div></pre></td></tr></table></figure>
<p>比较两个字符串，如果两个字符串的内容一致，在Java中使用 str1 == str2 时，是比较两个字符串的地址值，很清楚两个字符串的地址不一样，返回false，但是在kotlin中，则不是如此，比较的只是字符串的内容，而===相当于Java中的==，用来比较引用对象, 上述代码返回的是true。</p>
<p><strong>equal函数</strong></p>
<ol>
<li><code>equals(str:String)</code></li>
</ol>
<p>方法中的参数是与之对比的字符串，默认不忽略大小写，即大小写敏感，比如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;ChayChan&quot;</div><div class="line">println(str1.equals(str2))</div></pre></td></tr></table></figure></p>
<p>打印结果为false，因为不忽略大小写的话，两个字符串内容对比是不一致的，所以返回false。</p>
<ol>
<li><code>equals(str:String,ignoreCase:Boolean)</code>
方法中有两个参数，第一个参数是与之对比的字符串，第二个参数是布尔类型的值，是否忽略大小写，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;chaychan&quot;</div><div class="line">var str2 = &quot;ChayChan&quot;</div><div class="line">println(str1.equals(str2,true))</div></pre></td></tr></table></figure>
</li>
</ol>
<p>返回结果为true。</p>
<h3 id="源码优化分析"><a href="#源码优化分析" class="headerlink" title="源码优化分析"></a>源码优化分析</h3><p><a href="https://github.com/googlesamples/android-architecture/tree/dev-todo-mvp-kotlin/" target="_blank" rel="external">源码</a></p>
<h4 id="1-Lateinit"><a href="#1-Lateinit" class="headerlink" title="1.Lateinit"></a>1.Lateinit</h4><p>在View声明阶段，都会需要使用lateinit来延迟声明变量。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class TaskActivity : AppCompatActivity()&#123;</div><div class="line">  private val CURRENT_FILTERING_KEY = &quot;CURRENT_FILTERING_KEY&quot;;</div><div class="line">  private lateinit var drawerLayout : DrawerLayout</div><div class="line">  private lateinit var tasksPresenter:TasksPresenter</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>kotlin中延迟声明还包括lazy的方式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val name:String by lazy &#123;&quot;cangwang&quot;&#125;</div><div class="line">lateinit var drawLayout:drawLayout</div></pre></td></tr></table></figure></p>
<p>区别在于:</p>
<ol>
<li>.lazy{}只能用再val类型,lateinit只能用在var类型</li>
<li>.lateinit不能用在可空的属性上和java的基本类型上<code>lateinit var name:String</code>会报错</li>
<li>.lateinit可以在任何位置初始化并且可以初始化多次,因为其衔接var变量.而lazy在第一次被调用时就被初始化,其衔接的是val常量,想要被改变只能重新定义</li>
</ol>
<h4 id="2-findViewById"><a href="#2-findViewById" class="headerlink" title="2.findViewById"></a>2.findViewById</h4><p>Api26前:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public View findViewById(@IdRes int id)&#123;</div><div class="line">  return getDelegate().findViewById(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Api26之后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;TypeParameterUnusedInFormals&quot;)</div><div class="line">@Override</div><div class="line">public &lt;T extends View&gt; T indViewById(@IdRes int id)&#123;</div><div class="line">  return getDelegate().findViewById(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="五个kotlin-Standard-kt里面的函数-apply-with-let-run-also"><a href="#五个kotlin-Standard-kt里面的函数-apply-with-let-run-also" class="headerlink" title="五个kotlin Standard.kt里面的函数:apply,with,let,run,also"></a>五个kotlin Standard.kt里面的函数:apply,with,let,run,also</h4><ol>
<li>apply作用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setSupportActionBar(findViewById&lt;Toolbar&gt;(R.id.toolbar))</div><div class="line">supportActionBar?.apply&#123;</div><div class="line">  setDisplayHomeAsUpEnabled(true)</div><div class="line">  setDisplayShowHomeEnabled(true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在函数内可以通过this指代该对象,返回值为该对象自己</p>
<ol>
<li>with函数
将某对象作为函数的参数,在函数内可以通过this指代该对象.返回值为函数块的最后一行或指定return表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">override fun getView(i:Int,view:View?,viewGroup:ViewGroup):View&#123;</div><div class="line">  val rowView=Vview?:LayoutInflater.from(viewGroup.context).inflate(R.layout.task_item,viewGroup,false)</div><div class="line">  val task = getItem(i)</div><div class="line">  with(rowView.findViewById&lt;TextView&gt;(R.id.title))&#123;</div><div class="line">    text = task.titleForList</div><div class="line">  &#125;</div><div class="line">  with(rowView.findViewById&lt;CheckBox&gt;(R.id.complete))&#123;</div><div class="line">    isChecked=task.isCompleted</div><div class="line">    rowView.setBackgroundDrawable(...)</div><div class="line">    setOnClickListener&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-lat函数"><a href="#3-lat函数" class="headerlink" title="3.lat函数"></a>3.lat函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private fun showMessage(message:String)&#123;</div><div class="line">  view?.let&#123;</div><div class="line">    Snackbar.make(it,message,Snackbar.LENGTH_LONG).show()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将对象作为函数参数,在函数块内可以通过it指代该对象.返回值为函数块的最后一行或指定return表达式</p>
<h4 id="4-run函数"><a href="#4-run函数" class="headerlink" title="4. run函数"></a>4. run函数</h4><p>其有两种表达式:</p>
<ul>
<li>第一种无参数输入</li>
<li>第二种会将对象本身this给函数调用
返回值为函数块最后一行,或者指定return表达式</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>单例对象是使用Object申明
Kotlin没有静态属性和方法,需要使用单例对象来实现类似的功能.</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>相当于java中定义的数据bean类,其可以直接在属性之后编写get和set方法</p>
<h3 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a><code>@JvmOverloads</code></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串比较&quot;&gt;&lt;a href=&quot;#字符串比较&quot; class=&quot;headerlink&quot; title=&quot;字符串比较&quot;&gt;&lt;/a&gt;字符串比较&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="kotlin" scheme="http://wodekouwei.com/tags/kotlin/"/>
    
  </entry>
  
</feed>
