<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老司机种菜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wodekouwei.com/"/>
  <updated>2018-02-11T09:56:33.520Z</updated>
  <id>http://wodekouwei.com/</id>
  
  <author>
    <name>轻口味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ts格式解析</title>
    <link href="http://wodekouwei.com/2018/02/11/m-f-ts/"/>
    <id>http://wodekouwei.com/2018/02/11/m-f-ts/</id>
    <published>2018-02-11T07:21:55.000Z</published>
    <updated>2018-02-11T09:56:33.520Z</updated>
    
    <content type="html"><![CDATA[<p>ts是日本高清摄像机拍摄下进行的封装格式，全称为MPEG2-TS。ts即”Transport Stream”的缩写。MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。MPEG2-TS主要应用于实时传送的节目，比如实时广播的电视节目。</p>
<h3 id="发展简要"><a href="#发展简要" class="headerlink" title="发展简要"></a>发展简要</h3><p>随着从HDTV录制的高清节目在网上的流传，发烧友们现在对TS这个名词大概已经不陌生了，但随之而来就是如何播放、如何添加字幕等等的一系列问题，本文将重点介绍一下这方面的应用操作。
先来简要介绍一下什么是MPEG2-TS吧。MPEG2格式大家都通过对DVD的接触而多多少少了解了一些，DVD节目中的MPEG2格式，确切地说是MPEG2-PS，全称是Program Stream，而TS的全称则是Transport Stream。MPEG2-PS主要应用于存储的具有固定时长的节目，如DVD电影，而MPEG-TS则主要应用于实时传送的节目，比如实时广播的电视节目。这两种格式的主要区别是什么呢？简单地打个比喻说，你将DVD上的VOB文件的前面一截cut掉（或者干脆就是数据损坏），那么就会导致整个文件无法解码了，而电视节目是你任何时候打开电视机都能解码（收看）的，所以，MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。</p>
<h3 id="学习多媒体容器格式的目的"><a href="#学习多媒体容器格式的目的" class="headerlink" title="学习多媒体容器格式的目的"></a>学习多媒体容器格式的目的</h3><p>主要是为了回答以下问题：</p>
<ul>
<li>该容器中数据是如何组织的？</li>
<li>该容器包含哪些编码格式的数据？这些数据是如何存储的？</li>
<li>该容器包含哪些元数据信息？包含哪些节目信息？</li>
<li>对于支持多节目的容器格式，如何找到对应的音频流、视频流、字幕流？</li>
<li>如何确定该容器的节目播放时长？</li>
<li>如何从该容器中提取音频、视频、字幕数据，并交给解码器解码，有时间戳否？</li>
<li>该容器是否支持seek？有哪些辅助信息？</li>
<li>是否支持直接流化？</li>
<li>哪里可以找到该容器格式最标准的文档资料？</li>
<li>有哪些可用的工具，方便分析容器格式异常或者错误？</li>
</ul>
<h3 id="TS流生成和解析的过程"><a href="#TS流生成和解析的过程" class="headerlink" title="TS流生成和解析的过程"></a>TS流生成和解析的过程</h3><p>TS流的形成过程：</p>
<ol>
<li>将原始音视频数据压缩之后，压缩结果组成一个基本码流（ES）。</li>
<li>对ES（基本码流）进行打包形成PES。</li>
<li>在PES包中加入时间戳信息(PTS/DTS)。</li>
<li>将PES包内容分配到一系列固定长度的传输包（TS Packet）中。</li>
<li>在传输包中加入定时信息(PCR)。</li>
<li>在传输包中加入节目专用信息(PSI) 。</li>
<li>连续输出传输包形成具有恒定比特率的MPEG-TS流。</li>
</ol>
<p>TS流的解析过程，可以说是生成的逆过程：</p>
<ol>
<li>从复用的MPEG-TS流中解析出TS包；</li>
<li>从TS包中获取PAT及对应的PMT（PSI中的表格）；</li>
<li>从而获取特定节目的音视频PID；</li>
<li>通过PID筛选出特定音视频相关的TS包，并解析出PES；</li>
<li>从PES中读取到PTS/DTS，并从PES中解析出基本码流ES；</li>
<li>将ES交给解码器，获得压缩前的原始音视频数据。</li>
</ol>
<h3 id="TS码流整体结构"><a href="#TS码流整体结构" class="headerlink" title="TS码流整体结构"></a>TS码流整体结构</h3><p>MPEG-2中规定TS传输包的长度为188 字节，包头为4个字节，负载为184个字节。但通信媒介会为包添加错误校验字节，从而有了不同于188字节的包长。例如：</p>
<p>DVB 规定中，使用204字节作为包长:</p>
<ol>
<li>通过调制器时，在每个传输包后增加了16 字节的里德所罗门前向纠错码，因而形成了204字节的数据包。调制后总存在204 字节的数据包。</li>
<li>调制之前存复用器插入RS码或虚构的RS码。</li>
</ol>
<p>ATSC规定中，使用208字节作为包长：添加20 字节的 RS（Reed-Solomon）前向纠错码。与DVB不同,ATSC规定RS码只能出现在调制的TS流中。</p>
<p>所有的TS包都分为包头和净荷部分。TS包中可以填入很多东西（填入的东西都是填入到净荷部分），有：视频、音频、数据（包括PSI、SI以及其它任何形式的数据）。
<img src="http://images.wodekouwei.com/M/F/ts-head2.jpg" alt="image"></p>
<h4 id="1、TS包包头"><a href="#1、TS包包头" class="headerlink" title="1、TS包包头"></a>1、TS包包头</h4><p>TS包的包头提供关于传输方面的信息：同步、有无差错、有无加扰、PCR（节目参考时钟）等标志。TS包的包头长度不固定，前32比特（4个字节）固定，后面可能跟有自适应字段（适配域）。32个比特（4个字节）是最小包头。</p>
<ul>
<li>sync_byte （同步字节）：固定为0100 0111 (0x47)；该字节由解码器识别，使包头和有效负载可相互分离。</li>
<li>transport_error_indicator（传输错误指示）：‘1’表示在相关的传输包中至少有一个不可纠正的错误位。当被置1后，在错误被纠正之前不能重置为0。</li>
<li>payload_unit_start_indicator（开始指示）：为1时，在前4个字节之后会有一个调整字节，其的数值为后面调整字段的长度length。因此有效载荷开始的位置应再偏移1+[length]个字节。</li>
<li>transport_priority（传输优先级）：‘1’表明优先级比其他具有相同PID 但此位没有被置‘1’的分组高。</li>
<li>PID：指示存储与分组有效负载中数据的类型。PID 值 0x0000—0x000F 保留。其中0x0000为PAT保留；0x0001为CAT保留；0x1fff为分组保留，即空包。</li>
<li>transport_scrambling_control（加扰控制）：表示TS流分组有效负载的加密模式。空包为‘00’，如果传输包包头中包括调整字段，不应被加密。</li>
<li>adaptation_field_control（适配域控制）：表示包头是否有调整字段或有效负载。‘00’为ISO/IEC未来使用保留；‘01’仅含有效载荷，无调整字段；‘10’ 无有效载荷，仅含调整字段；‘11’ 调整字段后为有效载荷，调整字段中的前一个字节表示调整字段的长度length，有效载荷开始的位置应再偏移[length]个字节。空包应为‘10’。</li>
<li>continuity_counter（连续性计数器）：随着每一个具有相同PID的TS流分组而增加，当它达到最大值后又回复到0。范围为0~15。</li>
<li>adaptation_field （自适应字段 ）：根据自适应控制字段填充负载。</li>
</ul>
<p><img src="http://images.wodekouwei.com/M/F/ts_head.png" alt="image"></p>
<h4 id="2、节目专用信息PSI。"><a href="#2、节目专用信息PSI。" class="headerlink" title="2、节目专用信息PSI。"></a>2、节目专用信息PSI。</h4><p>然，TS包也可以是空包。空包用来填充TS流，可能在重新进行多路复用时被插入或删除。</p>
<p>在系统复用时，视频、音频的ES流需进行打包形成视频、音频的 PES流，辅助数据（如图文电视信息）不需要打成PES包。PES包非定长，音频的PES包小于等于64K，视频的一般为一帧一个PES包。一帧图象的PES包通常要由许多个TS包来传输。MPEG-2中规定，一个PES包必须由整数个TS包来传输。如果承载一个PES包的最后一个TS包没能装满，则用填充字节来填满；当下一个新的PES包形成时，需用新的TS包来开始传输。</p>
<p>节目专用信息PSI(Program Specific Information）</p>
<p>管理各种类型的TS数据包，需要有些特殊的TS包来确立各个TS数据包之间的关系。这些特殊的TS包里所包含的信息就是节目专用信息。在不同的标准中它有不同的名字：</p>
<ul>
<li>MPEG-2中称为PSI；</li>
<li>DVB标准根据实际需要，对PSI扩展，称为SI信息；</li>
<li>ATSC标准中为PSIP信息</li>
</ul>
<p>MPEG-2中，规定的对PSI信息的描述方法有以下几种：</p>
<h5 id="1、表Table：-节目信息的结构性的描述；"><a href="#1、表Table：-节目信息的结构性的描述；" class="headerlink" title="1、表Table： 节目信息的结构性的描述；"></a>1、表Table： 节目信息的结构性的描述；</h5><ul>
<li>节目关联表Program Association Table (PAT) 0x0000</li>
<li>节目映射表Program Map Tables (PMT) PAT指定</li>
<li>条件接收表Conditional Access Table (CAT) 0x0001</li>
<li>网络信息表Network Information Table(NIT) 0x0010</li>
<li>传送流描述表Transport Stream Description Table (TSDT)<h5 id="2、节Section：-将表格的内容映射到TS流中；"><a href="#2、节Section：-将表格的内容映射到TS流中；" class="headerlink" title="2、节Section： 将表格的内容映射到TS流中；"></a>2、节Section： 将表格的内容映射到TS流中；</h5>专用段 Private_ section</li>
</ul>
<h5 id="3、描述符Descriptor：提供有关节目构成（视频流、音频流、语言、层次、系统时钟和码率等多方面）的信息；"><a href="#3、描述符Descriptor：提供有关节目构成（视频流、音频流、语言、层次、系统时钟和码率等多方面）的信息；" class="headerlink" title="3、描述符Descriptor：提供有关节目构成（视频流、音频流、语言、层次、系统时钟和码率等多方面）的信息；"></a>3、描述符Descriptor：提供有关节目构成（视频流、音频流、语言、层次、系统时钟和码率等多方面）的信息；</h5><p>ITU-T Rec.H.222.0|ISO /IEC 13818-1 中定义的 PSI表可被分成一段或多段置于传输流分组中。一段就是一个语法结构，用来将 ITU-T Rec.H.222.0|ISO /IEC 13818-1 中定义的 PSI表映射到传输流分组中。</p>
<h6 id="PAT表"><a href="#PAT表" class="headerlink" title="PAT表"></a>PAT表</h6><p>TS流中包含一个或者多个PAT表。PAT表由PID为0x0000的TS包传送，其作用是为复用的每一路传送流提供出所包含的节目和节目编号，以及对应节目的PMT的位置即PMT的TS包的PID值，同时还提供NIT的位置，即NIT的TS包的PID的值。</p>
<ul>
<li>table_id：固定为0x00，标志该表是PAT表。</li>
<li>section_syntax_indicator：段语法标志位，固定为1。</li>
<li>section_length：表示这个字节后面有用的字节数，包括CRC32。节目套数：（section length-9）/4</li>
<li>transport_stream_id：16位字段，表示该TS流的ID，区别于同一个网络中其它多路复用流。</li>
<li>version_number：表示PAT的版本号。</li>
<li>current_next_indicator：表示发送的PAT表是当前有效还是下一个PAT有效。</li>
<li>section_number：表示分段的号码。PAT可能分为多段传输，第一段为0，以后每个分段加1，最多可能有256个分段。</li>
<li>last_section_number：表示PAT最后一个分段的号码。</li>
<li>Program number：节目号</li>
<li>network_PID：网络信息表（NIT）的PID,节目号为0时对应ID为network_PID。</li>
<li>Program map PID：节目映射表（PMT）的PID号，节目号为大于等于1时，对应的ID为program_map_PID。一个PAT中可以有多个program_map_PID。</li>
<li>CRC_32：32位字段，CRC32校验码Cyclic RedundancyCheck。<h6 id="PMT表"><a href="#PMT表" class="headerlink" title="PMT表"></a>PMT表</h6></li>
</ul>
<p>PMT在传送流中用于指示组成某一套节目的视频、音频和数据在传送流中的位置，即对应的TS包的PID值，以及每路节目的节目时钟参考（PCR）字段的位置。</p>
<ul>
<li>Table id ：固定为0x02，标志该表是PMT 表。</li>
<li>Section syntax indicator：对于PMT表，设置为1 。</li>
<li>Section length：表示这个字节后面有用的字节数，包括CRC32 。</li>
<li>Program number：它指出该节目对应于可应用的Program map PID 。</li>
<li>Version number：指出PMT 的版本号。</li>
<li>Current next indicator：当该位置’1’时，当前传送的Program map section可用；当该位置’0’时，指示当前传送的Program map section不可用，下一个TS流的Programmap section 有效。</li>
<li>Section number：总是置为0x00（因为PMT表里表示一个service的信息，一个section 的长度足够）。</li>
<li>Last section number：该域的值总是0x00 。</li>
<li>PCR PID：节目中包含有效PCR字段的传送流中PID 。</li>
<li>Program info length：12bit域，前两位为00。该域指出跟随其后对节目信息的描述的byte 数。</li>
<li>Stream type：8bit域，指示特定PID的节目元素包的类型。该处PID由elementary PID 指定。</li>
</ul>
<h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p>HTTP Live Streaming（缩写是HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8)playlist文件，用于寻找可用的媒体流。
HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。
苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。但是，即使苹果偶尔地提交一些小的更新，IETF却没有关于制定此标准的有关进一步的动作。</p>
<p>HLS协议规定：</p>
<ul>
<li>视频的封装格式是TS。</li>
<li>视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。</li>
<li>除了TS视频文件本身，还定义了用来控制播放的m3u8文件（文本文件）。</li>
</ul>
<p>为什么苹果要提出HLS这个协议，其实他的主要是为了解决RTMP协议存在的一些问题。比如RTMP协议不使用标准的HTTP接口传输数据，所以在一些特殊的网络环境下可能被防火墙屏蔽掉。但是HLS由于使用的HTTP协议传输数据，不会遇到被防火墙屏蔽的情况（该不会有防火墙连80接口都不放过吧）。</p>
<p>另外于负载，RTMP是一种有状态协议，很难对视频服务器进行平滑扩展，因为需要为每一个播放视频流的客户端维护状态。而HLS基于无状态协议（HTTP），客户端只是按照顺序使用下载存储在服务器的普通TS文件，做负责均衡如同普通的HTTP文件服务器的负载均衡一样简单。</p>
<p>另外HLS协议本身实现了码率自适应，不同带宽的设备可以自动切换到最适合自己码率的视频播放。其实HLS最大的优势就是他的亲爹是苹果。苹果在自家的iOS设备上只提供对HLS的原生支持，并且放弃了flash。Android也迫于平果的“淫威”原生支持了HLS。这样一来flv，rtmp这些Adobe的视频方案要想在移动设备上播放需要额外下点功夫。当然flash对移动设备造成很大的性能压力确实也是自身的问题。</p>
<p>但HLS也有一些无法跨越的坑，比如采用HLS协议直播的视频延迟时间无法下到10秒以下，而RTMP协议的延迟最低可以到3、4秒左右。所以说对直播延迟比较敏感的服务请慎用HLS。</p>
<p><strong>播放模式</strong></p>
<ul>
<li>点播VOD的特点就是当前时间点可以获取到所有index文件和ts文件，二级index文件中记录了所有ts文件的地址。这种模式允许客户端访问全部内容。上面的例子中就是一个点播模式下的m3u8的结构。</li>
<li>Live 模式就是实时生成M3u8和ts文件。它的索引文件一直处于动态变化的，播放的时候需要不断下载二级index文件，以获得最新生成的ts文件播放视频。如果一个二级index文件的末尾没有#EXT-X-ENDLIST标志，说明它是一个Live视频流。<blockquote>
<p><a href="http://blog.csdn.net/c602273091/article/details/50372160" target="_blank" rel="external">TS码流分析</a>
<a href="https://www.cnblogs.com/tocy/p/media_container_6-mpegts.html" target="_blank" rel="external">多媒体文件格式之TS</a>
<a href="https://www.iso.org/standard/67331.html" target="_blank" rel="external">ISO/IEC 13818-1:2015</a></p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ts是日本高清摄像机拍摄下进行的封装格式，全称为MPEG2-TS。ts即”Transport Stream”的缩写。MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。MPEG2-TS主要应用于实时传送的节目，比如实时广播的电视节目。&lt;/p&gt;
&lt;h3
    
    </summary>
    
      <category term="音视频封装" scheme="http://wodekouwei.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://wodekouwei.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="format" scheme="http://wodekouwei.com/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>MPEG</title>
    <link href="http://wodekouwei.com/2018/02/08/media-mpeg/"/>
    <id>http://wodekouwei.com/2018/02/08/media-mpeg/</id>
    <published>2018-02-08T10:48:14.000Z</published>
    <updated>2018-02-11T07:20:35.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MPEG"><a href="#MPEG" class="headerlink" title="MPEG"></a>MPEG</h3><p>MPEG（Moving Picture Experts Group，动态图像专家组）是ISO（International Standardization Organization，国际标准化组织）与IEC（International Electrotechnical Commission，国际电工委员会）于1988年成立的专门针对运动图像和语音压缩制定国际标准的组织。</p>
<p>MPEG标准主要有以下五个，MPEG-1、MPEG-2、MPEG-4、MPEG-7及MPEG-21等。该专家组建于1988年，专门负责为CD建立视频和音频标准，而成员都是为视频、音频及系统领域的技术专家。及后，他们成功将声音和影像的记录脱离了传统的模拟方式，建立了ISO/IEC11172压缩编码标准，并制定出MPEG-格式，令视听传播方面进入了数码化时代。因此，大家现时泛指的MPEG-X版本，就是由ISO(International Organization for Standardization）所制定而发布的视频、音频、数据的压缩标准。</p>
<p>MPEG标准的视频压缩编码技术主要利用了具有运动补偿的帧间压缩编码技术以减小时间冗余度，利用DCT技术以减小图像的空间冗余度，利用熵编码则在信息表示方面减小了统计冗余度。这几种技术的综合运用，大大增强了压缩性能。</p>
<p>MPEG的缔造者们原先打算开发四个版本：MPEG1-MPEG4，以适用于不同带宽和数字影像质量的要求。后由于MPEG3被放弃，所以现存只有三个版本的MPEG：MPEG-1，MPEG-2，MPEG-4。总体来说，MPEG在三方面优于其他压缩/解压缩方案。首先，由于在一开始它就是做为一个国际化的标准来研究制定，所以，MPEG具有很好的兼容性。其次，MPEG能够比其他算法提供更好的压缩比，最高可达200:1。更重要的是，MPEG在提供高压缩比的同时，对数据的损失很小。</p>
<h4 id="MPEG-1"><a href="#MPEG-1" class="headerlink" title="MPEG-1"></a>MPEG-1</h4><p>MPEG-1制定于1992年，为工业级标准而设计，可适用于不同带宽的设备，如CD-ROM、Video-CD、CD-i。它可针对SIF标准分辨率（对于NTSC制为352X240；对于PAL制为352X288）的图象进行压缩，传输速率为1.5Mbits/sec，每秒播放30帧，具有CD（指激光唱盘）音质，质量级别基本与VHS相当。MPEG的编码速率最高可达4-5Mbits/sec，但随着速率的提高，其解码后的图象质量有所降低。
M
PEG-1也被用于数字电话网络上的视频传输，如非对称数字用户线路(ADSL），视频点播（VOD），以及教育网络等。同时，MPEG-1也可被用做记录媒体或是在INTERNET上传输音频。</p>
<h4 id="MPEG-2"><a href="#MPEG-2" class="headerlink" title="MPEG-2"></a>MPEG-2</h4><p>MPEG-2制定于1994年，设计目标是高级工业标准的图象质量以及更高的传输率。MPEG-2所能提供的传输率在3-10Mbits/sec间，其在NTSC制式下的分辨率可达720X486，MPEG-2也可提供并能够提供广播级的视像和CD级的音质。MPEG-2的音频编码可提供左右中及两个环绕声道，以及一个加重低音声道，和多达7个伴音声道（DVD可有8种语言配音的原因）。由于MPEG-2在设计时的巧妙处理，使得大多数MPEG-2解码器也可播放MPEG-1格式的数据，如VCD。</p>
<p>同时，由于MPEG-2的出色性能表现，已能适用于HDTV，使得原打算为HDTV设计的MPEG-3，还没出世就被抛弃了。（MPEG-3要求传输速率在20Mbits/sec-40Mbits/sec间，但这将使画面有轻度扭曲）。除了做为DVD的指定标准外，MPEG-2还可用于为广播，有线电视网，电缆网络以及卫星直播(DirectBroadcastSatellite）提供广播级的数字视频。</p>
<p>MPEG-2的另一特点是，其可提供一个较广的范围改变压缩比，以适应不同画面质量，存储容量，以及带宽的要求。</p>
<p>对于最终用户来说，由于现存电视机分辨率限制，MPEG-2所带来的高清晰度画面质量（如DVD画面）在电视上效果并不明显，到是其音频特性（如加重低音，多伴音声道等）更引人注目。</p>
<h4 id="MPEG-4"><a href="#MPEG-4" class="headerlink" title="MPEG-4"></a>MPEG-4</h4><p>MPEG专家组的专家们正在为MPEG-4的制定努力工作。MPEG-4标准主要应用于视像电话（videophone），视像电子邮件（VideoEmail）和电子新闻（Electronicnews）等，其传输速率要求较低，在4800-64000bits/sec之间，分辨率176X144。MPEG-4利用很窄的带宽，通过帧重建技术，压缩和传输数据，以求以最少的数据获得最佳的图象质量。</p>
<p>与MPEG-1和MPEG-2相比，MPEG-4的特点是其更适于交互AV服务以及远程监控。MPEG-4是第一个使你由被动变为主动（不再只是观看，允许你加入其中，即有交互性）的动态图象标准；它的另一个特点是其综合性；从根源上说，MPEG-4试图将自然物体与人造物体相溶合（视觉效果意义上的）。MPEG-4的设计目标还有更广的适应性和可扩展性。</p>
<h3 id="MPEG-1-1"><a href="#MPEG-1-1" class="headerlink" title="MPEG-1"></a>MPEG-1</h3><p>MPEG-1是MPEG组织制定的第一个视频和音频有损压缩标准。视频压缩算法于1990年定义完成。1992年底，MPEG-1正式被批准成为国际标准。MPEG-1是为CD光碟介质定制的的视频和音频压缩格式。一张70分钟的CD光碟传输速率大约在1.4Mbps。而MPEG-1采用了块方式的运动补偿、离散余弦变换（DCT）、量化等技术，并为1.2Mbps传输速率进行了优化。MPEG-1随后被Video CD采用作为核心技术。MPEG-1的输出质量大约和传统录像机VCR，信号质量相当，这也许是Video CD在发达国家未获成功的原因。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>MPEG-1是为CD光盘介质定制的视频和音频压缩格式。一张70分钟的CD光盘传输速率大约在1.4Mbps。而MPEG-1采用了块方式的运动补偿、离散余弦变换（DCT）、量化等技术，并为1.2Mbps传输速率进行了优化。MPEG-1随后被Video CD采用作为核心技术。VCD的分辨率只有约352×240，并使用固定的比特率（1.15Mbps），因此在播放快速动作的视频时，由于数据量不足，令压缩时宏区块无法全面调整，结果使视频画面出现模糊的方块。因此MPEG-1的输出质量大约和传统录像机VCR相当，这也许是Video CD在发达国家未获成功的原因。MPEG-1音频分三代，其中最著名的第三代协议被称为MPEG-1 Layer 3，简称MP3，已经成为广泛流传的音频压缩技术。MPEG-1音频技术在每一代之间，在保留相同的输出质量之外，压缩率都比上一代高。第一代协议MP1被应用在LD作为记录数字音频以及飞利浦公司的DGC上；而第二代协议MP2后来被应用于欧洲版的DVD音频层之一。</p>
<p>MPEG-1具有以下特点：</p>
<ul>
<li>随机访问</li>
<li>灵活的帧率</li>
<li>可变的图像尺寸</li>
<li>定义了I-帧、P-帧和B-帧</li>
<li>运动补偿可跨越多个帧</li>
<li>半像素精度的运动向量</li>
<li>量化矩阵</li>
<li>GOF结构</li>
<li>slice结构</li>
</ul>
<h4 id="音频分层"><a href="#音频分层" class="headerlink" title="音频分层"></a>音频分层</h4><p>MPEG-1音频分三层，分别为MPEG-1 Layer1，MPEG-Layer2以及MPEG-Layer3，并且高层兼容低层。其中第三层协议被称为MPEG-1 Layer 3，简称MP3。MP3已经成为广泛流传的的音频压缩技术。</p>
<ul>
<li>MPEG-1 Layer1采用每声道192kbit/s，每帧384个样本，32个等宽子带，固定分割数据块。子带编码用DCT(离散余弦变换)和(快速傅立叶变换)计算子带信号量化bit数。采用基于频域掩蔽效应的心理声学模型，使量化噪声低于掩蔽值。量化采用带死区的线性量化器，主要用于数字盒式磁带(DCC)。</li>
<li>MPEG-1 Layer2采用每声道128kbit/s，每帧1152个样本，32个子带，属不同分帧方式。采用共同频域和时域掩蔽效应的心理声学模型，并对高、中，低频段的比特分配进行限制，并对比特分配、比例因子，取样进行附加编码。Layer2 广泛用于数字电视，CD-ROM，CD-I和VCD等。</li>
<li>MPEG-1 Layer3采用每声道64kbit/s，用混合滤波器组提高频率分辨率，按信号分辨率分成6X32或18X32个子带，克服平均32个子带的Layer1，Layer2在中低频段分辨率偏低的缺点。采用心理声学模型2，增设不均匀量化器，量化值进行熵编码。主要用于ISDN(综合业务数字网)音频编码。</li>
</ul>
<p>MPEG-1制定于1992年，为工业级标准而设计，它可针对SIF标准分辨率(对于NTSC制为352X240；对于PAL制为352X288)的图像进行压缩，传输速率为1.5Mbits/sec，每秒播放30帧，具有CD(指激光唱盘)音质，质量级别基本与VHS相当。MPEG的编码速率最高可达4- 5Mbits/sec，但随着速率的提高，其解码后的图象质量有所降低。
MPEG-1也被用于数字电话网络上的视频传输，如非对称数字用户线路(ADSL)，视频点播(VOD)，以及教育网络等。同时，MPEG-1也可被用做记录媒体或是在INTERNET上传输音频。</p>
<h3 id="MPEG-2-1"><a href="#MPEG-2-1" class="headerlink" title="MPEG-2"></a>MPEG-2</h3><p>MPEG-2是MPEG（Moving Picture Experts Group，运动图像专家组）组织制定的视频和音频有损压缩标准之一，它的正式名称为“基于数字存储媒体运动图像和语音的压缩标准”。与MPEG-1标准相比，MPEG-2标准具有更高的图像质量、更多的图像格式和传输码率的图像压缩标准。MPEG-2标准不是MPEG-1的简单升级，而是在传输和系统方面做了更加详细的规定和进一步的完善。它是针对标准数字电视和高清晰电视在各种应用下的压缩方案，编码率从3 Mbit/s~100 Mbit/s。</p>
<p>MPEG-2音频是在1994年11月为数字电视而提出来的，其发展分为三个阶段：
第一阶段是对MPEG-1增加了低采样频率，有16KHZ，22.05KHZ，以及24KHZ。
第二阶段是对MPEG-1实施了向后兼容的多声道扩展，将其称为MPEG-2 BC。支持单声道，双声道，多声道等编码。并附加“低频加重”扩展声道，从而达到五声道编码。
第三阶段是向后不兼容，将其称为MPEG-2 AAC先进音频编码。采样频率可以低至8KHZ；而高至96KHZ范围内的1-48个通道可选的高音质音频编码。</p>
<h4 id="分部"><a href="#分部" class="headerlink" title="分部"></a>分部</h4><p>MPEG-2标准目前分为9个部分，统称为ISO/IEC13818国际标准。各部分的内容描述如下：</p>
<ul>
<li>一部分－ISO/IEC13818-1，System：系统，描述多个视频，音频和数据基本码流合成传输码流和节目码流的方式。</li>
<li>二部分－ISO/IEC13818-2，Video：视频，描述视频编码方法。</li>
<li>三部分－ISO/IEC13818-3，Audio：音频，描述与MPEG-1音频标准反向兼容的音频编码方法。</li>
<li>四部分－ISO/IEC13818-4，Compliance：符合测试，描述测试一个编码码流是否符合MPEG-2码流的方法。</li>
<li>五部分－ISO/IEC13818-5，Software：软件，描述了MPEG-2标准的第一、二、三部分的软件实现方法。</li>
<li>六部分－ISO/IEC13818-6，DSM-CC：数字存储媒体-命令与控制，描述交互式多媒体网络中服务器与用户间的会话信令集。</li>
</ul>
<p>上六个部分均已获得通过，成为正式的国际标准，并在数字电视等领域中得到了广泛的实际应用。此外，MPEG-2标准还有三个部分：</p>
<ul>
<li>第七部分规定不与MPEG-1音频反向兼容的多通道音频编码；</li>
<li>第八部分现已停止；</li>
<li>第九部分规定了传送码流的实时接口。</li>
</ul>
<p>1990年成立的ATM视频编码专家组与MPEG在ISO/IEC13818标准的第一和第二两个部分进行了合作，因此上述两个部分也成为ITU-T的
标准，分别为：ITU-T H.222.0和ITU-T H.262视频。</p>
<h3 id="MPEG-4-1"><a href="#MPEG-4-1" class="headerlink" title="MPEG-4"></a>MPEG-4</h3><p>MPEG-4，于MP4是一套用于音频、视频信息的压缩编码标准，由国际标准化组织（ISO）和国际电工委员会（IEC）下属的“动态图像专家组（Moving Picture Experts即MPEG制定，第一版在1998年10月通过，第二版在1999年12月通过。MPEG-4格式的主要用途在于网上流、光盘、语音发送（视频电话），以及电视广播。MPEG-4包含了MPEG-1及MPEG-2的绝大部份功能及其他格式的长处，并加入及扩充对虚拟现实模型语言（VRML，VirtualReality Modeling Language）的支持，面向对象的合成档案（包括音效，视讯及VRML对象），以及数字版权管理（DRM）及其他互动功能。而MPEG-4比MPEG-2更先进的其中一个特点，就是不再使用宏区块做影像分析，而是以影像上个体为变化记录，因此尽管影像变化速度很快、码率不足时，也不会出现方块画面。</p>
<h4 id="分部-1"><a href="#分部-1" class="headerlink" title="分部"></a>分部</h4><p>MPEG-4由一系列的子标准组成，被称为部(part)（有时也译为卷），包括以下的部分：</p>
<ul>
<li>第一部分（ISO/IEC14496-1）：系统：描述视讯和音频数据流的控制、同步以及混合方式（即混流Multiplexing，简写为MUX）。</li>
<li>第二部分（ISO/IEC14496-2）：视讯：定义了一个对各种视觉讯息（包括自然视讯、静止纹理、计算机合成图形等等）的编译码器。（例如XviD编码就属于MPEG-4Part2）</li>
<li>第三部分（ISO/IEC14496-3）：音讯：定义了一个对各种音频讯号进行编码的编译码器的集合。包括高阶音频编码（AdvancedAudioCoding，缩写为AAC）的若干变形和其他一些音频/语音编码工具。</li>
<li>第四部分（ISO/IEC14496-4）：一致性：定义了对本标准其他的部分进行一致性测试的程序。</li>
<li>第五部分（ISO/IEC4496-5）：参考软件：提供了用于演示功能和说明本标准其他部分功能的软件。</li>
<li>第六部分（ISO/IEC14496-6）：多媒体传输整合框架（DMIF for Delivery Multimedia IntegrationFramework）</li>
<li>第七部分（ISO/IEC14496-7）：优化的参考软件：提供了对实作进行优化的例子（这里的实作指的是第五部分）。</li>
<li>第八部分（ISO/IEC14496-8）：在IP网络上传输：定义了在IP网络上传输MPEG-4内容的方式。</li>
<li>第九部分（ISO/IEC14496-9）：参考硬件：提供了用于演示怎样在硬件上实作本标准其他部分功能的硬件设计方案。</li>
<li>第十部分（ISO/IEC14496-10）：进阶视讯编码或称高阶视讯编码（Advanced Video Coding，缩写为AVC）：定义了一个视讯编译码器（codec）。AVC和XviD都属于MPEG-4编码，但由于AVC属于MPEG-4Part10，在技术特性上比属于MPEG-4Part2的XviD要先进。另外，它和ITU-TH.264标准是一致的，故又称为H.264。</li>
<li>第十二部分（ISO/IEC14496-12）：基于ISO的媒体文件格式：定义了一个储存媒体内容的文件格式。</li>
<li>第十三部分（ISO/IEC14496-13）：知识产权管理和保护（IPMP for Intellectual Property Management andProtection）拓展。</li>
<li>第十四部分（ISO/IEC14496-14）：MPEG-4文件格式：定义了基于第十二部分的用于储存MPEG-4内容的视讯文件格式。</li>
<li>第十五部分（ISO/IEC14496-15）：AVC文件格式：定义了基于第十二部分的用于储存第十部分的视讯内容的文件格式。</li>
<li>第十六部分（ISO/IEC14496-16）：动画框架扩充功能（AFX:Animation Framework eXtension）。</li>
<li>第十七部分（ISO/IEC14496-17）：同步文字字幕格式。</li>
<li>第十八部分（ISO/IEC14496-18）：字型压缩和串流传输（针对开放字型格式 Open Font Format）。</li>
<li>第十九部分（ISO/IEC14496-19）：合成材质流（Synthesized Texture Stream）。</li>
<li>第二十部分（ISO/IEC14496-20）：简单场景表示（LASeR for Lightweight Scene Representation。</li>
<li>第二十一部分（ISO/IEC14496-21）：用于描绘（Rendering）的MPEG-J拓展。</li>
<li>第二十二部分（ISO/IEC14496-22）：开放字型格式（Open Font Format）。</li>
<li>第二十三部分（ISO/IEC14496-23）：符号化音乐表示（Symbolic Music Representation）。</li>
<li>第二十四部分（ISO/IEC14496-24）：音频与系统互动作用（Audio and systems interaction）。</li>
<li>第二十五部分（ISO/IEC14496-25）：3D图形压缩模型（3D GraphicsCompression Model）。</li>
<li>第二十六部分（ISO/IEC14496-26）：音讯一致性检查：定义了测试音频数据与ISO/IEC 14496-3是否一致的方法（Audioconformance）。</li>
<li>第二十七部分（ISO/IEC14496-27）：3D图形一致性检查：定义了测试3D图形数据与ISO/IEC14496-11:2005,ISO/IEC 14496-16:2006,ISO/IEC14496-21:2006,和ISO/IEC14496-25:2009是否一致的方法（3D Graphicsconformance）。</li>
</ul>
<p>Profiles是在每个部分内定义的，所以对某个部分的一个实作通常不是对该部分的完整实作。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对于不同的对象可采用不同的编码算法，从而进一步提高压缩效率；</li>
<li>对象各自相对独立，提高了多媒体数据的可重用性；</li>
<li>允许用户对单个的对象操作，提供前所未有的交互性；</li>
<li>允许在不同的对象之间灵活分配码率，对重要的对象可分配较多的字节，对次要的对象可分配较少的字节，从而能在低码率下获得较好的效果；</li>
<li>可以方便的集成自然音视频对象和合成音视频对象。</li>
</ul>
<h3 id="MPEG-7"><a href="#MPEG-7" class="headerlink" title="MPEG-7"></a>MPEG-7</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Moving_Picture_Experts_Group" target="_blank" rel="external">Moving Picture Experts Group</a>
<a href="https://en.wikipedia.org/wiki/ISO/IEC_JTC_1/SC_29" target="_blank" rel="external">ISO/IEC JTC 1/SC 29</a>
<a href="https://en.wikipedia.org/wiki/MPEG-1" target="_blank" rel="external">MPEG-1</a>
<a href="https://en.wikipedia.org/wiki/MPEG-2" target="_blank" rel="external">MPEG-2</a>
<a href="https://en.wikipedia.org/wiki/MPEG-4" target="_blank" rel="external">MPEG-4</a>
<a href="https://zh.wikipedia.org/wiki/MP3" target="_blank" rel="external">MP3</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MPEG&quot;&gt;&lt;a href=&quot;#MPEG&quot; class=&quot;headerlink&quot; title=&quot;MPEG&quot;&gt;&lt;/a&gt;MPEG&lt;/h3&gt;&lt;p&gt;MPEG（Moving Picture Experts Group，动态图像专家组）是ISO（International S
    
    </summary>
    
      <category term="media" scheme="http://wodekouwei.com/categories/media/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>基于深度学习的自动抠图</title>
    <link href="http://wodekouwei.com/2018/01/25/tips-ml-about-backgroundremoval/"/>
    <id>http://wodekouwei.com/2018/01/25/tips-ml-about-backgroundremoval/</id>
    <published>2018-01-25T07:27:43.000Z</published>
    <updated>2018-01-25T07:42:37.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul>
<li>原文:<a href="https://towardsdatascience.com/background-removal-with-deep-learning-c4f2104b3157" target="_blank" rel="external">Background removal with deep learning</a></li>
<li>译文:<a href="https://www.leiphone.com/news/201709/UlV8rwd3s6ZeEccW.html" target="_blank" rel="external">自拍抠图抠到手软？详解如何用深度学习消除背景</a></li>
<li><a href="https://gitlab.com/fast-science" target="_blank" rel="external">server代码地址</a></li>
<li><a href="https://github.com/Kjeanclaude/acGAN-Paper-Implementation" target="_blank" rel="external">acGAN-Paper-Implementation</a>:acGAN paper implementation and adaptation by KJeanclaude &amp; Gidi Shperber</li>
<li><a href="http://www.fast.ai/" target="_blank" rel="external">fast.ai course</a></li>
<li>作者:<a href="https://medium.com/@burgalon" target="_blank" rel="external">Alon Burg</a> ,<a href="https://towardsdatascience.com/@gidishperber" target="_blank" rel="external">Gidi Shperber</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;资源&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原文:&lt;a href=&quot;https://towardsdatascience.com/background-removal-wi
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>deep-photo-styletransfer介绍</title>
    <link href="http://wodekouwei.com/2018/01/21/tips-ml-dpst/"/>
    <id>http://wodekouwei.com/2018/01/21/tips-ml-dpst/</id>
    <published>2018-01-21T14:41:30.000Z</published>
    <updated>2018-01-25T07:22:47.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p><a href="https://github.com/luanfujun/deep-photo-styletransfer" target="_blank" rel="external">deep-photo-styletransfer</a>:</p>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><p>环境为mac10.13.2</p>
<h4 id="2-1安装依赖"><a href="#2-1安装依赖" class="headerlink" title="2.1安装依赖"></a>2.1安装依赖</h4><h5 id="2-1-1-Torch"><a href="#2-1-1-Torch" class="headerlink" title="2.1.1 Torch"></a>2.1.1 <a href="https://github.com/torch/torch7" target="_blank" rel="external">Torch</a></h5><p>Torch是基于Lua语言的深度学习框架.
安装:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -s https://raw.githubusercontent.com/torch/ezinstall/master/install-deps | bash</div><div class="line">git clone https://github.com/torch/distro.git ~/torch --recursive</div><div class="line">cd ~/torch; ./install.sh</div></pre></td></tr></table></figure></p>
<p>第一条命令安装了LuaJIT 和 Torch的依赖库。第二条命令安装LuaJIT, LuaRocks，然后用 LuaRocks （lua 包管理工具）安装核心包：torch, nn and paths, 和其它包。上面命令把 torch 加入到了你的PATH环境变量中了，用 source 更新一下让环境变量生效：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 在 Linux 上</div><div class="line">source ~/.bashrc</div><div class="line"># 在 OSX 上</div><div class="line">source ~/.profile</div><div class="line">或</div><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure></p>
<p>如果你想要卸载 torch，执行：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf ~/torch</div></pre></td></tr></table></figure></p>
<p>现在在你可以用 Luarocks 安装新的包
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">luarocks install image</div><div class="line">luarocks list</div></pre></td></tr></table></figure></p>
<p>安装完之后，你可以在终端用 th 命令运行 torch，现在进入了 torch 的交互模式，类似Python的交互模式。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ th</div><div class="line"></div><div class="line">  ______             __   |  Torch7</div><div class="line"> /_  __/__  ________/ /   |  Scientific computing for Lua.</div><div class="line">  / / / _ / __/ __/ _   |</div><div class="line"> /_/  ___/_/  __/_//_/  |  https://github.com/torch</div><div class="line">                          |  http://torch.ch</div><div class="line"></div><div class="line">th&gt; torch.Tensor&#123;1,2,3&#125;</div><div class="line"> 1</div><div class="line"> 2</div><div class="line"> 3</div><div class="line">[torch.DoubleTensor of dimension 3]</div><div class="line"></div><div class="line">th&gt;</div></pre></td></tr></table></figure></p>
<p>要退出交互模式，两次Ctrl+C，或输入 os.exit()。
要执行 file.lua, 写 th&gt; dofile “file.lua”。
在非交互模式下执行文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">th file.lua</div></pre></td></tr></table></figure></p>
<p>th 命令有很多选项，类似 perl 和 ruby。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ th -h</div><div class="line">Usage: th [options] [script.lua [arguments]]</div><div class="line"></div><div class="line">Options:</div><div class="line">  -l name            load library name</div><div class="line">  -e statement       execute statement</div><div class="line">  -h,--help          print this help</div><div class="line">  -a,--async         preload async (libuv) and start async repl (BETA)</div><div class="line">  -g,--globals       monitor global variables (print a warning on creation/access)</div><div class="line">  -gg,--gglobals     monitor global variables (throw an error on creation/access)</div><div class="line">  -x,--gfx           start gfx server and load gfx env</div><div class="line">  -i,--interactive   enter the REPL after executing a script</div><div class="line">Share the post &quot;Mac OS X／Ubuntu 安装 Torch&quot;</div></pre></td></tr></table></figure></p>
<p><strong>安装deep-photo-styletransfer所需依赖:</strong></p>
<ul>
<li><a href="https://github.com/soumith/matio-ffi.torch" target="_blank" rel="external">matio-ffi</a>:<code>luarocks install matio-ffi</code></li>
<li><a href="https://github.com/szagoruyko/loadcaffe" target="_blank" rel="external">loadcaffe</a>:<code>luarocks install loadcaffe</code></li>
</ul>
<h5 id="2-1-2Matlab-or-Octave"><a href="#2-1-2Matlab-or-Octave" class="headerlink" title="2.1.2Matlab or Octave"></a>2.1.2<a href="https://www.mathworks.com/" target="_blank" rel="external">Matlab</a> or <a href="https://www.gnu.org/software/octave/" target="_blank" rel="external">Octave</a></h5><p>Matlab较大,而且是商用软件,所以选择了octave
Octave是一款用于数值计算和绘图的开源软件, 精于矩阵运算:求解联立方程组、计算矩阵特征值和特征向量等等,并能够通过多种形式将数据可视化。Octave最简单的使用方式就是像使用一个计算器一样在命令提示符下输入相应的计算式。Octave能识别通常的计算表达式。例如,在终端输入
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">octave:##&gt;2+2</div></pre></td></tr></table></figure></p>
<p>mac下首先确保自己的Mac安装了Xcode和Command Line Tool，通过以下命令安装Command Line Tool，
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcode-select --install</div></pre></td></tr></table></figure></p>
<p>之后安装Mac下的包管理神器Homebrew，命令如下，
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1</div></pre></td></tr></table></figure></p>
<p>通过以下命令升级Homebrew:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo brew update &amp;&amp; sudo brew upgrade</div></pre></td></tr></table></figure></p>
<p>之后通过以下命令安装gcc、XQuartz，最后就可以通过Homebrew安装Octave了，
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo brew install gcc</div><div class="line">sudo brew install Caskroom/cask/xquartz</div><div class="line">sudo brew install octave</div></pre></td></tr></table></figure></p>
<p>mac下使用brew安装的octave是4.2版本,使用<code>imread</code>等函数时会提示:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">error: Magick++ exception: octave-cli-4.2: Unable to access configuration file (delegates.mgk) reported by magick/blob.c:2101 (GetConfigureBlob)</div><div class="line">error: called from</div><div class="line">    __imread__ at line 80 column 10</div><div class="line">    imageIO at line 117 column 26</div><div class="line">    imread at line 106 column 30</div></pre></td></tr></table></figure></p>
<p>未找到原因,最后在<a href="https://wiki.octave.org/Octave_for_macOS#Simple_Installation_Instructions_2中下载[Mac" target="_blank" rel="external">https://wiki.octave.org/Octave_for_macOS#Simple_Installation_Instructions_2中下载[Mac</a> OS X Bundle](<a href="https://sourceforge.net/projects/octave/files/Octave%20MacOSX%20Binary/2016-07-11-binary-octave-4.0.3/octave_gui_403_appleblas.dmg/download)中下载[4.0.3-gui](https://jaist.dl.sourceforge.net/project/octave/Octave%20MacOSX%20Binary/2016-07-11-binary-octave-4.0.3/octave_gui_403_appleblas.dmg)及[4.0.2" target="_blank" rel="external">https://sourceforge.net/projects/octave/files/Octave%20MacOSX%20Binary/2016-07-11-binary-octave-4.0.3/octave_gui_403_appleblas.dmg/download)中下载[4.0.3-gui](https://jaist.dl.sourceforge.net/project/octave/Octave%20MacOSX%20Binary/2016-07-11-binary-octave-4.0.3/octave_gui_403_appleblas.dmg)及[4.0.2</a> command line](<a href="https://jaist.dl.sourceforge.net/project/octave/Octave%20MacOSX%20Binary/2016-06-06-binary-octave-4.0.2/octave_cli_402.dmg)执行imread会出现" target="_blank" rel="external">https://jaist.dl.sourceforge.net/project/octave/Octave%20MacOSX%20Binary/2016-06-06-binary-octave-4.0.2/octave_cli_402.dmg)执行imread会出现</a>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">warning: your version of GraphicsMagick limits images to &lt;16&gt; bits per pixel</div></pre></td></tr></table></figure></p>
<p>根据<a href="http://wiki.octave.org/GraphicsMagick" target="_blank" rel="external">GraphicsMagick</a>中介绍是GraphicsMagick编译是参数不对,后下载(<a href="https://sourceforge.net/projects/graphicsmagick/files/?source=navbar" target="_blank" rel="external">地址</a>)使用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./configure --with-quantum-depth=16 --enable-shared --disable-static --with-magick-plus-plus=yes</div><div class="line">make</div><div class="line">make check</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p>
<p>仍然不对,好像bound包依赖的库不是默认安装路径的.
使用最新的GraphicsMagick为1.3.27,命令行下可以使用gm命令:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ gm</div><div class="line">GraphicsMagick 1.3.27  Q32 http://www.GraphicsMagick.org/</div><div class="line">Copyright (C) 2002-2017 GraphicsMagick Group.</div><div class="line">Additional copyrights and licenses apply to this software.</div><div class="line">See http://www.GraphicsMagick.org/www/Copyright.html for details.</div><div class="line">Usage: gm command [options ...]</div><div class="line"></div><div class="line">Where commands include:</div><div class="line">      batch - issue multiple commands in interactive or batch mode</div><div class="line">  benchmark - benchmark one of the other commands</div><div class="line">    compare - compare two images</div><div class="line">  composite - composite images together</div><div class="line">    conjure - execute a Magick Scripting Language (MSL) XML script</div><div class="line">    convert - convert an image or sequence of images</div><div class="line">       help - obtain usage message for named command</div><div class="line">   identify - describe an image or image sequence</div><div class="line">    mogrify - transform an image or sequence of images</div><div class="line">    montage - create a composite image (in a grid) from separate images</div><div class="line">       time - time one of the other commands</div><div class="line">    version - obtain release version</div></pre></td></tr></table></figure></p>
<p>可以使用pkg install -forge package安装<a href="https://octave.sourceforge.io/packages.php" target="_blank" rel="external">Octave-Forge </a>中的包,如默认使用的image包:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg install -forge image</div></pre></td></tr></table></figure></p>
<p>也可以下载其他版本的image包到本地执行<code>pkg install image-2.4.1.tar.gz</code>
<code>pkg list</code>可列出已安装的包,安装好后不能直接使用，使用前要load
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">warning: the &apos;col2im&apos; function belongs to the image package from Octave Forge which you have installed but not loaded.  To load the package, run &apos;pkg load image&apos; from the Octave prompt.</div></pre></td></tr></table></figure></p>
<p>有人使用docker容器解决了这个问题:<a href="https://github.com/martinbenson/deep-photo-styletransfer" target="_blank" rel="external">https://github.com/martinbenson/deep-photo-styletransfer</a>, 但是未尝试</p>
<blockquote>
<p><a href="http://www.graphicsmagick.org/INSTALL-unix.html#build-install" target="_blank" rel="external"> GraphicsMagick UNIX/Cygwin/MinGW Compilation</a>
<a href="https://trac.macports.org/ticket/38730" target="_blank" rel="external">octave-devel 3.6.3 GraphicsMagick limits images to 8 bits per pixel</a>
<a href="http://blog.csdn.net/pipisorry/article/details/43565653" target="_blank" rel="external"> Octave教程 Octave Tutorial</a>
<a href="https://github.com/luanfujun/deep-photo-styletransfer/issues/20" target="_blank" rel="external">Octave requirements </a>
<a href="https://github.com/luanfujun/deep-photo-styletransfer/issues/4" target="_blank" rel="external">Is removing the Matlab dependency possible?</a>
<a href="https://github.com/luanfujun/deep-photo-styletransfer/pull/12" target="_blank" rel="external">Added Matlab dependency alternative</a>
<a href="https://sourceforge.net/p/graphicsmagick/mailman/message/922420/" target="_blank" rel="external">Re: [GM-apis] PythonMagick</a></p>
</blockquote>
<h5 id="2-1-3CUDA-cudnn"><a href="#2-1-3CUDA-cudnn" class="headerlink" title="2.1.3CUDA cudnn"></a>2.1.3<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="external">CUDA</a> <a href="https://developer.nvidia.com/cudnn" target="_blank" rel="external">cudnn</a></h5><p>从<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="external">NVIDIA cuDNN官网</a>下载,<a href="http://developer.download.nvidia.com/compute/cuda/7.5/Prod/docs/sidebar/CUDA_Installation_Guide_Mac.pdf" target="_blank" rel="external">文档地址</a></p>
<ul>
<li><a href="http://124.205.69.171/files/1101000006472522/developer.download.nvidia.com/compute/cuda/7.5/Prod/local_installers/cuda_7.5.27_mac.dmg" target="_blank" rel="external">7.5下载地址</a></li>
<li><a href="http://124.205.69.163/files/82230000064800D3/developer2.download.nvidia.com/compute/cuda/9.1/secure/Prod/local_installers/cuda_9.1.85_mac.dmg" target="_blank" rel="external">9.1下载地址</a>
使用不同版本有兼容性问题</li>
</ul>
<h5 id="2-1-4下载VGG-19"><a href="#2-1-4下载VGG-19" class="headerlink" title="2.1.4下载VGG-19"></a>2.1.4下载VGG-19</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh models/download_models.sh</div></pre></td></tr></table></figure>
<h5 id="2-1-5Compile-cuda-utils-cu-Adjust-PREFIX-and-NVCC-PREFIX-in-makefile-for-your-machine"><a href="#2-1-5Compile-cuda-utils-cu-Adjust-PREFIX-and-NVCC-PREFIX-in-makefile-for-your-machine" class="headerlink" title="2.1.5Compile cuda_utils.cu (Adjust PREFIX and NVCC_PREFIX in makefile for your machine)"></a>2.1.5Compile cuda_utils.cu (Adjust PREFIX and NVCC_PREFIX in makefile for your machine)</h5><p>遇到问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">THC.h includes THCGeneral.h, does not exist</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/luanfujun/deep-photo-styletransfer/issues/19" target="_blank" rel="external">解决</a>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">I&apos;ve fixed this issue by executing the following commands in terminal:</div><div class="line"></div><div class="line">cd to you torch directory, and execute the update.sh script</div><div class="line">second, execute &quot;luarocks install cutorch&quot;</div></pre></td></tr></table></figure></p>
<p>可能有xcode Command Line Tool版本不兼容问题:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvcc fatal : The version (&apos;80100&apos;) of the host compiler (&apos;Apple clang&apos;) is not supported</div></pre></td></tr></table></figure></p>
<p>替换版本即可:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">登录 https://developer.apple.com/downloads/</div><div class="line">下载Xcode CLT (Command Line Tools) 8.2</div><div class="line">安装 CLT</div><div class="line">执行 sudo xcode-select --switch /Library/Developer/CommandLineTools</div><div class="line">输入命令行查看clang版本 clang --version</div></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/torch/cutorch/issues/737" target="_blank" rel="external">THC.h includes THCGeneral.h, does not exist</a></p>
</blockquote>
<h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul>
<li><a href="http://blog.csdn.net/zhangjunhit/article/details/70845704" target="_blank" rel="external">深度摄影风格转换–Deep Photo Style Transfer</a></li>
<li><a href="http://blog.csdn.net/guoyunfei20/article/details/78191599" target="_blank" rel="external">cuDNN</a></li>
<li><a href="http://blog.csdn.net/augusdi/article/details/12833235" target="_blank" rel="external">CUDA从入门到精通</a></li>
<li><a href="https://www.jianshu.com/p/9c6d90e4f20e" target="_blank" rel="external">VGG论文笔记</a></li>
<li><a href="https://github.com/LouieYang/deep-photo-styletransfer-tf" target="_blank" rel="external">deep-photo-styletransfer-tf</a>:Tensorflow (Python API) implementation of Deep Photo Style Transfer</li>
<li><a href="https://github.com/floydhub/deep-photo-styletransfer" target="_blank" rel="external">floydhub/deep-photo-styletransfer</a>:Jupyter Notebook to train photorealistic style transfer</li>
<li><a href="https://askubuntu.com/questions/652004/how-do-i-rebuild-octave-and-link-in-graphicsmagick" target="_blank" rel="external">How do I rebuild Octave and link in GraphicsMagick?</a></li>
<li><a href="ftp://ftp.gnu.org/gnu/octave/" target="_blank" rel="external">/gnu/octave/ 的索引</a></li>
</ul>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ol>
<li><code>configure :error: No usable version of sed found:</code>
I did ./configure to make a makefile</li>
</ol>
<p>but it ran into an error: configure :error: No usable version of sed found:</p>
<p>I then typed which see</p>
<p>it shows /usr/bin/sed.</p>
<p>so, what’s wrong? why can’t ./configure find sed?</p>
<p>I happened to have this problem on my mac. This is because OS X uses an old version of sed. Installing gnu-sed by <code>brew install gnu-sed</code> and <code>alias gsed=sed</code> solved this problem. You may install gnu-sed with other method.</p>
<p><a href="https://stackoverflow.com/questions/26351285/configure-error-no-usable-version-of-sed-found" target="_blank" rel="external">https://stackoverflow.com/questions/26351285/configure-error-no-usable-version-of-sed-found</a></p>
<ol>
<li><code>gm-bin convert: Unable to access configuration file (delegates.mgk) [No such file or directory].</code></li>
</ol>
<p>I am attempting to install GraphicsMagick in a hosting account…</p>
<p>I used this info to get it to work in most cases:</p>
<p><a href="https://superuser.com/questions/192573/how-do-you-specify-the-location-of-libraries-to-a-binary-linux" target="_blank" rel="external">How do you specify the location of libraries to a binary? (linux)</a></p>
<p>However, it still cannot find the delegates.mgk (which is in ./lib/GraphicsMagick-1.3.14/delegates.mgk) as witnessed in this error:</p>
<p>gm-bin convert: Unable to access configuration file (delegates.mgk) [No such file or directory].</p>
<p>Either, a) how do find out where the binary thinks this file should be, or b) how do I extend the wrapper script to help it out?</p>
<p>Figured it out after looking through the binary for /PATH/</p>
<p>The binaries require these additional path variables:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$MAGICK_CONFIG_PATH</div><div class="line">$MAGICK_CODER_MODULE_PATH</div><div class="line">$MAGICK_FILTER_MODULE_PATH</div></pre></td></tr></table></figure></p>
<p>…here is the resulting script modification form my setup:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">if [ -n &quot;$LD_LIBRARY_PATH&quot; ]; then</div><div class="line">  LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/USER/lib</div><div class="line">else</div><div class="line">  LD_LIBRARY_PATH=/home/USER/lib</div><div class="line">fi</div><div class="line">[ -z &quot;$&#123;MAGICK_CONFIGURE_PATH&#125;&quot; ] &amp;&amp; export MAGICK_CONFIGURE_PATH=/home/USER/lib/GraphicsMagick-1.3.14/config</div><div class="line">[ -z &quot;$&#123;MAGICK_CODER_MODULE_PATH&#125;&quot; ] &amp;&amp; export MAGICK_CODER_MODULE_PATH=/home/USER/lib/GraphicsMagick-1.3.14/modules-Q8/coders</div><div class="line">[ -z &quot;$&#123;MAGICK_FILTER_MODULE_PATH&#125;&quot; ] &amp;&amp; export MAGICK_FILTER_MODULE_PATH=/home/USER/lib/GraphicsMagick-1.3.14/modules-Q8/filters</div><div class="line">export LD_LIBRARY_PATH</div><div class="line">exec /home/USER/bin/gm-bin &quot;$@&quot;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/luanfujun/deep-photo-styletransfer
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>python常见问题</title>
    <link href="http://wodekouwei.com/2018/01/16/issue-python/"/>
    <id>http://wodekouwei.com/2018/01/16/issue-python/</id>
    <published>2018-01-16T10:09:41.000Z</published>
    <updated>2018-01-16T10:12:59.172Z</updated>
    
    <content type="html"><![CDATA[<h5 id="OSError-Errno-1-Operation-not-permitted-39-tmp-pip-g3bg0s-uninstall-System-Library-Frameworks-Pyt"><a href="#OSError-Errno-1-Operation-not-permitted-39-tmp-pip-g3bg0s-uninstall-System-Library-Frameworks-Pyt" class="headerlink" title="OSError: [Errno 1] Operation not permitted: &#39;/tmp/pip-g3bg0s-uninstall/System/Library/Frameworks/Pyt"></a><code>OSError: [Errno 1] Operation not permitted: &#39;/tmp/pip-g3bg0s-uninstall/System/Library/Frameworks/Pyt</code></h5><p>在用下列名字安装时
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo -H pip install Scrapy</div><div class="line">sudo pip install virtualenvwrapper</div></pre></td></tr></table></figure></p>
<p>出现下列错误
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">Found existing installation: six 1.4.1</div><div class="line"></div><div class="line">    DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project.</div><div class="line"></div><div class="line">    Uninstalling six-1.4.1:</div><div class="line"></div><div class="line">Exception:</div><div class="line"></div><div class="line">Traceback (most recent call last):</div><div class="line"></div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/basecommand.py&quot;, line 215, in main</div><div class="line"></div><div class="line">    status = self.run(options, args)</div><div class="line"></div><div class="line">  File &quot;/Library/python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/commands/install.py&quot;, line 342, in run</div><div class="line"></div><div class="line">    prefix=options.prefix_path,</div><div class="line"></div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/req/req_set.py&quot;, line 778, in install</div><div class="line"></div><div class="line">    requirement.uninstall(auto_confirm=True)</div><div class="line"></div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/req/req_install.py&quot;, line 754, in uninstall</div><div class="line"></div><div class="line">    paths_to_remove.remove(auto_confirm)</div><div class="line"></div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/req/req_uninstall.py&quot;, line 115, in remove</div><div class="line"></div><div class="line">    renames(path, new_path)</div><div class="line"></div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/utils/__init__.py&quot;, line 267, in renames</div><div class="line"></div><div class="line">    shutil.move(old, new)</div><div class="line"></div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 302, in move</div><div class="line"></div><div class="line">    copy2(src, real_dst)</div><div class="line"></div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 131, in copy2</div><div class="line"></div><div class="line">    copystat(src, dst)</div><div class="line"></div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 103, in copystat</div><div class="line"></div><div class="line">    os.chflags(dst, st.st_flags)</div><div class="line"></div><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-g3bg0s-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&apos;</div></pre></td></tr></table></figure></p>
<p>Scrapy，virtualenvwrapper需要依赖six，在安装six的时候发现系统已经有一个six-1.4.1，但是virtualenvwrapper需要six-1.9.0，于是想先卸载老版本的six，此时问题来了，发现没有权限卸载，此时我就纳闷，加上sudo，还是没权限。于是Google之，最终还是在万能的GitHub找到答案。six-1.4.1是系统内置的packages，因 系统集成保护 你是没有权限去修改/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info目录的。因此在安装virtualenvwrapper的时候需要选择忽略six的安装：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenvwrapper --upgrade --ignore-installed six</div><div class="line">sudo pip install Scrapy --upgrade --ignore-installed six</div></pre></td></tr></table></figure></p>
<p>如果使用requirements安装,也使用:<code>sudo -H pip install -r requirements.txt --upgrade --ignore-installed six</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;OSError-Errno-1-Operation-not-permitted-39-tmp-pip-g3bg0s-uninstall-System-Library-Frameworks-Pyt&quot;&gt;&lt;a href=&quot;#OSError-Errno-1-Operati
    
    </summary>
    
      <category term="python" scheme="http://wodekouwei.com/categories/python/"/>
    
    
      <category term="issue" scheme="http://wodekouwei.com/tags/issue/"/>
    
  </entry>
  
  <entry>
    <title>android逆向(1)之root方式注入apk</title>
    <link href="http://wodekouwei.com/2018/01/16/tips-android-inject1/"/>
    <id>http://wodekouwei.com/2018/01/16/tips-android-inject1/</id>
    <published>2018-01-16T10:06:20.000Z</published>
    <updated>2018-01-17T04:08:24.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一步-注入动态库到目标进程"><a href="#第一步-注入动态库到目标进程" class="headerlink" title="第一步,注入动态库到目标进程"></a>第一步,注入动态库到目标进程</h3><ol>
<li>启动注入程序,入口main函数中输入将被注入的进程名称以及欲注入动态库路径;</li>
<li>根据进程名获取进程id:打开<code>/proc</code>目录,读取<code>/proc/%d/cmdline</code>;</li>
<li>attach到目标进程:<code>ptrace(PTRACE_ATTACH, pid, NULL, 0)</code>并暂停目前进程;</li>
<li>读取寄存器值:<code>ptrace(PTRACE_GETREGS, pid, NULL, regs)</code>,并保持读取到的寄存器;</li>
<li>获取被加载的动态库中mmap函数地址,获取被加载动态库中函数地址的方法是,获取本地libc.so模块和被加载动态库中libc.so模块中各自起始地址,local_addr-local_handle的值为指定函数(如mmap)在该模块中的偏移量，然后再加上remote_handle，结果就为指定函数在目的进程的虚拟地址,获取模块起始地址的方法是读取进程对应的<code>/proc/self/maps</code>或<code>/proc/%d/maps</code>文件;</li>
<li>调用被加载库的mmap方法申请空间:<code>ptrace_call(target_pid, (uint32_t)func_addr, parameters, param_num, regs)</code>;</li>
<li>获取申请空间时的R0寄存器,arm中R0~R3作为传递参数的寄存器,R0可以获取到申请空间的起始地址;</li>
<li>获取被加载库中dlopen,dlsym,dlclose,dlerror函数地址;</li>
<li>将被加载动态库的路径写入到mmap分配的栈空间:<code>ptrace(PTRACE_PEEKTEXT, pid, dest, 0);</code>;</li>
<li>调用远程函数的dlopen函数打开要被注入的动态库;</li>
<li>调用<code>dlsym</code>获取加载动态库目标函数符号对应地址,并调用目标函数,完成注入;</li>
<li>调用dlclose关闭被注入库;</li>
<li>完成注入;</li>
</ol>
<h3 id="动态库中加载目标apk-aar"><a href="#动态库中加载目标apk-aar" class="headerlink" title="动态库中加载目标apk(aar)"></a>动态库中加载目标apk(aar)</h3><ol>
<li>入口函数中启动新线程,并调用<code>pthread_detach(tid)</code>将新线程设置为detach状态,可自动回收资源;</li>
<li>新线程中调用<code>AndroidRuntime::getJavaVM();</code>获取JavaVM对象并Attach当前线程到JavaVM:<code>jvm-&gt;AttachCurrentThread(&amp;jni_env, NULL);</code>获取到jni env;</li>
<li>找到<code>dalvik/system/DexClassLoader</code>类,并获取其构造方法<code>public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</code>的methodid及<code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>的methodid;</li>
<li>找到类<code>java/lang/ClassLoader</code>,获取其静态方法<code>Gpublic static ClassLoader getSystemClassLoader()</code>的MethodID,调用静态方法getSystemClassLoader获取系统ClassLoader;</li>
<li>基于系统ClassLoader,以及DexClassClassLoader构造方法MethodID创建DexClassLoader对象:<code>jni_env-&gt;NewObject(dexloader_claxx, dexloader_init_method, apk_path, dex_out_path, lib_path, class_loader);</code>,要传入DexClassloader jclass,DexClassLoader构造方法id,要被加载的apk路径,dex输出路径,动态库路径,以及父(即系统)ClassLoader;</li>
<li>调用DexClassLoader的loadClass方法id加载apk中被调起的类:<code>jclass entry_class = static_cast&lt;jclass&gt;(jni_env-&gt;CallObjectMethod(dex_loader_obj, loadClass_method, class_name));</code>;</li>
<li>调用动态加载到的apk中类的方法:<code>jclass entry_class = static_cast&lt;jclass&gt;(jni_env-&gt;CallObjectMethod(dex_loader_obj, loadClass_method, class_name));</code>;</li>
<li>线程与JavaVM脱离:<code>jvm-&gt;DetachCurrentThread();</code>;</li>
</ol>
<h3 id="java中获取context"><a href="#java中获取context" class="headerlink" title="java中获取context"></a>java中获取context</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一步-注入动态库到目标进程&quot;&gt;&lt;a href=&quot;#第一步-注入动态库到目标进程&quot; class=&quot;headerlink&quot; title=&quot;第一步,注入动态库到目标进程&quot;&gt;&lt;/a&gt;第一步,注入动态库到目标进程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;启动注入程序,入口main函数中
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>docker简介及环境搭建</title>
    <link href="http://wodekouwei.com/2018/01/15/docker-env-create/"/>
    <id>http://wodekouwei.com/2018/01/15/docker-env-create/</id>
    <published>2018-01-15T08:00:03.000Z</published>
    <updated>2018-01-15T09:33:34.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h3><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<h3 id="Docker-三个基本概念"><a href="#Docker-三个基本概念" class="headerlink" title="Docker 三个基本概念"></a>Docker 三个基本概念</h3><ul>
<li>镜像（Image）:Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li>
<li>容器（Container）:镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</li>
<li>仓库（Repository）:镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest作为默认标签。用 Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。因此 DaoCloud等加速器服务商 推出了加速器工具解决这个难题，通过智能路由和缓存机制，极大提升了国内网络访问 Docker Hub 的速度，目前已经拥有了广泛的用户群体，并得到了 Docker 官方的大力推荐。如果您是在国内的网络环境使用 Docker，那么 Docker 加速器一定能帮助到您。docker常用仓库:<a href="https://hub.docker.com/explore/" target="_blank" rel="external">https://hub.docker.com/explore/</a></li>
</ul>
<blockquote>
<p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="external">docker daocloud加速器</a>:</p>
<ul>
<li>linux:<code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://311e425f.m.daocloud.io</code>,该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同</li>
<li>Mac:右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入下面的镜像地址:<code>http://311e425f.m.daocloud.io</code>,点击 Apply &amp; Restart 按钮使设置生效。</li>
<li>Windows: 在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把下面的地址:<code>http://311e425f.m.daocloud.io</code>,加到”registry-mirrors”的数组里。点击 Apply 。</li>
</ul>
</blockquote>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="mac下安装docker"><a href="#mac下安装docker" class="headerlink" title="mac下安装docker"></a>mac下安装docker</h4><p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">官方mac的安装步骤</a>
下载<a href="https://link.jianshu.com/?t=https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="external">docker.dmg</a>文件，然后点击，一步步操作</p>
<p>检测Docker Engine, Docker Compose, 和Docker Machine的版本:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">docker version</div><div class="line">Client:</div><div class="line"> Version:      17.03.1-ce</div><div class="line"> API version:  1.27</div><div class="line"> Go version:   go1.7.5</div><div class="line"> Git commit:   c6d412e</div><div class="line"> Built:        Tue Mar 28 00:40:02 2017</div><div class="line"> OS/Arch:      darwin/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      17.03.1-ce</div><div class="line"> API version:  1.27 (minimum version 1.12)</div><div class="line"> Go version:   go1.7.5</div><div class="line"> Git commit:   c6d412e</div><div class="line"> Built:        Fri Mar 24 00:00:50 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"> Experimental: true</div><div class="line"></div><div class="line">docker-compose --version</div><div class="line">docker-compose version 1.11.2, build dfed245</div><div class="line"></div><div class="line">docker-machine --version</div><div class="line">docker-machine version 0.10.0, build 76ed2a6</div></pre></td></tr></table></figure></p>
<h3 id="运行官网提供的二个简单列子"><a href="#运行官网提供的二个简单列子" class="headerlink" title="运行官网提供的二个简单列子"></a>运行官网提供的二个简单列子</h3><p>拉取hello-world镜像
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull hello-world</div></pre></td></tr></table></figure></p>
<p>查看hello-world镜像信息：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker images hello-world</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">hello-world         latest              1815c82652c0        5 days ago          1.84 kB</div></pre></td></tr></table></figure></p>
<p>根据镜像生成对应容器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run hello-world</div></pre></td></tr></table></figure></p>
<p>ps不加参数只会把当前运行的Community打印出来，查看当前所有的Community，加上-a参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -a</div></pre></td></tr></table></figure></p>
<p>当然也可以根据镜像生成一个具体名称的镜像，先删除当前容器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm 60</div></pre></td></tr></table></figure></p>
<p>当然如果当前容器正在运行，要删除这个容器，则使用命令
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f 60</div></pre></td></tr></table></figure></p>
<p>使用镜像生成具体名称的容器：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name miaozhihao hello-world</div></pre></td></tr></table></figure></p>
<p>于更多的docker run的命令可以使用来查看
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --help</div></pre></td></tr></table></figure></p>
<p><strong>第二个examples，启动docker的web服务</strong>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker pull nginx</div><div class="line">docker run -d -p 80:80 --name webserver nginx</div></pre></td></tr></table></figure></p>
<p>-p参数是使用宿主机的80映射容器的80端口
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">curl localhost:80</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</div><div class="line">&lt;style&gt;</div><div class="line">    body &#123;</div><div class="line">        width: 35em;</div><div class="line">        margin: 0 auto;</div><div class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</div><div class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</div><div class="line">working. Further configuration is required.&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;p&gt;For online documentation and support please refer to</div><div class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</div><div class="line">Commercial support is available at</div><div class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>交互式终端方式进入 webserver容器，
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it webserver bash</div></pre></td></tr></table></figure></p>
<p>修改nginx的显示页面：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@41b6804c716e:/# echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div><div class="line">root@41b6804c716e:/# exit</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">docker diff webserver</div><div class="line">C /root</div><div class="line">A /root/.bash_history</div><div class="line">C /run</div><div class="line">A /run/nginx.pid</div><div class="line">C /usr/share/nginx/html/index.html</div><div class="line">C /var/cache/nginx</div><div class="line">A /var/cache/nginx/client_temp</div><div class="line">A /var/cache/nginx/fastcgi_temp</div><div class="line">A /var/cache/nginx/proxy_temp</div><div class="line">A /var/cache/nginx/scgi_temp</div><div class="line">A /var/cache/nginx/uwsgi_temp</div></pre></td></tr></table></figure></p>
<p>使用docker commit生成镜像
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker commit --author &quot;zhihao.miao &lt;1026145686@qq.com&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2</div><div class="line">sha256:0a34c054b8a826d85dddf4d1dbdd3028ab890feff4c8a0844e9b98dd146c2e07</div></pre></td></tr></table></figure></p>
<p>–autho 指定作者 –message表示容器的一些信息
查看当前nginx镜像：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker images nginx</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx               v2                  0a34c054b8a8        11 seconds ago      109 MB</div><div class="line">nginx               latest              958a7ae9e569        4 weeks ago         109 MB</div></pre></td></tr></table></figure></p>
<p>查看当前所有的容器，包括运行的和停止的
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker ps -a</div><div class="line">\CONTAINER ID        IMAGE                                 COMMAND                  CREATED             STATUS                    PORTS                NAMES</div><div class="line">41b6804c716e        nginx                                 &quot;nginx -g &apos;daemon ...&quot;   3 minutes ago       Up 3 minutes              0.0.0.0:80-&gt;80/tcp   webserver</div><div class="line">85612b405cda        miaozhihao001dockerhub/commit_test1   &quot;nginx -g &apos;daemon ...&quot;   20 hours ago        Exited (0) 3 hours ago                         nginx_web</div><div class="line">9ef1fb35d7aa        ubuntu:14.04                          &quot;/bin/bash&quot;              20 hours ago        Exited (0) 20 hours ago                        commit_test</div><div class="line">bf8320b9e445        ubuntu:14.04                          &quot;/bin/bash&quot;              24 hours ago        Exited (0) 24 hours ago                        sharp_curie</div><div class="line">9f9767eb8aaf        hello-world                           &quot;/hello&quot;                 10 days ago         Exited (0) 10 days ago                         miaozhihao</div></pre></td></tr></table></figure></p>
<p>启动新的容器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run --name newwebserver -d -p 80:80 nginx:v2</div><div class="line">3619b34ed347cf1ae2ee3ab32c419140871f3084b9a1325ab5d8c6155d43bf06</div><div class="line">➜ curl localhost:80</div><div class="line">&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</div></pre></td></tr></table></figure></p>
<h3 id="创建自己的docker镜像"><a href="#创建自己的docker镜像" class="headerlink" title="创建自己的docker镜像"></a>创建自己的docker镜像</h3><p>编辑Dockerfile文件，填入以下内容：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FROM docker/whalesay:latest</div><div class="line">RUN apt-get -y update &amp;&amp; apt-get install -y fortunes</div><div class="line">CMD /usr/games/fortune -a | cowsay</div></pre></td></tr></table></figure></p>
<p>运行以下命令创建名为docker-whale的镜像：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t docker-whale .</div></pre></td></tr></table></figure></p>
<ul>
<li><code>-t</code>： 给tag命令</li>
<li><code>.</code>： Dockerfile文件所在路径</li>
</ul>
<h4 id="docker-tag-push-pull"><a href="#docker-tag-push-pull" class="headerlink" title="docker tag push pull"></a>docker tag push pull</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag 8e15421920b1 xulingfeng/docker-whale:latest</div></pre></td></tr></table></figure>
<p>上传操作
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push xulingfeng/docker-whale</div></pre></td></tr></table></figure></p>
<p>下载操作
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull centos</div></pre></td></tr></table></figure></p>
<h4 id="交互式的操作"><a href="#交互式的操作" class="headerlink" title="交互式的操作"></a>交互式的操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -t -i ubuntu /bin/bash</div></pre></td></tr></table></figure>
<ul>
<li>t 分配了一个终端在新的容器中</li>
<li><code>-i</code> 允许你和容器进行交互操作</li>
<li><code>/bin/bash</code> 启动容器中的Bash shell</li>
</ul>
<h4 id="docker的守护状态，也就是后台运行"><a href="#docker的守护状态，也就是后台运行" class="headerlink" title="docker的守护状态，也就是后台运行"></a>docker的守护状态，也就是后台运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div></pre></td></tr></table></figure>
<ul>
<li>docker run 运行容器</li>
<li>-d 让容器在后台运行</li>
<li>ubuntu 你希望运行容器的镜像</li>
</ul>
<h4 id="查看docker容器运行日志"><a href="#查看docker容器运行日志" class="headerlink" title="查看docker容器运行日志"></a>查看docker容器运行日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs -f 容器名</div></pre></td></tr></table></figure>
<ul>
<li><code>-f</code> 类似与 <code>tail -f</code></li>
</ul>
<h4 id="使用docker运行web应用"><a href="#使用docker运行web应用" class="headerlink" title="使用docker运行web应用"></a>使用docker运行web应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -P training/webapp python app.py</div></pre></td></tr></table></figure>
<ul>
<li><code>-d</code>：代表后台运行该容器</li>
<li><code>-P</code>：映射容器中的web应用端口号到你的主机上32768-61000中的某一个端口。这样你可以访问该容器中的web应用</li>
<li><code>training/webapp</code>： 一个已经构建好的镜像，包含一个简单的python flask框架web应用</li>
<li><code>python app.py</code>：这个命令用来启动容器中的web</li>
</ul>
<p>成功运行以上命令后，运行：
<code>docker ps</code>
查看到容器的5000端口号映射到了本地的32768，浏览器访问<a href="http://127.0.0.1:32768" target="_blank" rel="external">http://127.0.0.1:32768</a> 看到helloworld 成功提示</p>
<h4 id="自定义主机端口号"><a href="#自定义主机端口号" class="headerlink" title="自定义主机端口号"></a>自定义主机端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 80:5000 training/webapp python app.py</div></pre></td></tr></table></figure>
<ul>
<li>-p 80:5000 将本机的80端口绑定容器内的5000端口，本地直接访问 <code>http://127.0.0.1</code> 即可</li>
</ul>
<h4 id="查看容器的进程"><a href="#查看容器的进程" class="headerlink" title="查看容器的进程"></a>查看容器的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top 容器名</div></pre></td></tr></table></figure>
<h4 id="检查容器的状态信息"><a href="#检查容器的状态信息" class="headerlink" title="检查容器的状态信息"></a>检查容器的状态信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect 容器名</div></pre></td></tr></table></figure>
<h4 id="镜像搜索"><a href="#镜像搜索" class="headerlink" title="镜像搜索"></a>镜像搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search 内容</div></pre></td></tr></table></figure>
<h4 id="创建一个给pycharm开发用的镜像，包含python3，Django，-Flask，-requests，-PyMySQL，-ldap3，-jira，celery，-simplejson"><a href="#创建一个给pycharm开发用的镜像，包含python3，Django，-Flask，-requests，-PyMySQL，-ldap3，-jira，celery，-simplejson" class="headerlink" title="创建一个给pycharm开发用的镜像，包含python3，Django， Flask， requests， PyMySQL， ldap3， jira，celery， simplejson"></a>创建一个给pycharm开发用的镜像，包含python3，Django， Flask， requests， PyMySQL， ldap3， jira，celery， simplejson</h4><p><strong>centos镜像，分解步骤如下</strong></p>
<ul>
<li>首先添加额外源:<code>yum install -y epel-release</code></li>
<li>安装编译环境:<code>yum install -y gcc automake autoconf libtool make gcc-c++</code></li>
<li>安装wget命令:<code>yum install -y wget</code></li>
<li>安装openssl-devel python的pip命令依赖:<code>yum install -y openssl-devel</code></li>
<li>下载python3.5.2最新包:<code>wget https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tgz -P /software/</code></li>
<li>解压python3.5.2压缩包并编译安装:<code>tar -zxvf /software/Python-3.5.2.tgz -C /software/</code>与<code>./configure &amp;&amp; make -j2&amp;&amp; make install -j2</code></li>
<li>更新pip:<code>pip install --upgrade pip</code>与<code>pip install --upgrade setuptools</code></li>
<li>安装所需的第三方包:<code>pip install Django Flask requests PyMySQL ldap3 jira celery simplejson</code></li>
</ul>
<h4 id="通过Dockerfile构建镜像"><a href="#通过Dockerfile构建镜像" class="headerlink" title="通过Dockerfile构建镜像"></a>通过Dockerfile构建镜像</h4><p>Dockerfile:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FROM centos:latest</div><div class="line">RUN yum install -y epel-release</div><div class="line">RUN yum install -y gcc automake autoconf libtool make gcc-c++</div><div class="line">RUN yum install -y wget</div><div class="line">RUN yum install -y openssl-devel</div><div class="line">RUN wget https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tgz -P /software/</div><div class="line">RUN tar -zxvf /software/Python-3.5.2.tgz -C /software/</div><div class="line">RUN cd /software/Python-3.5.2/ &amp;&amp; ./configure python3 &amp;&amp; make -j2&amp;&amp; make install -j2</div><div class="line">RUN pip install --upgrade pip</div><div class="line">RUN pip install --upgrade setuptools</div><div class="line">RUN pip install Django Flask requests PyMySQL ldap3 jira celery simplejson</div></pre></td></tr></table></figure></p>
<p>在Dockerfile目录中执行：<code>docker build -t 名字:版本 .</code></p>
<h4 id="兼容docker-for-mac-和-pycharm"><a href="#兼容docker-for-mac-和-pycharm" class="headerlink" title="兼容docker for mac 和 pycharm"></a>兼容docker for mac 和 pycharm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install socat</div><div class="line">socat TCP-LISTEN:2376,reuseaddr,fork,bind=127.0.0.1 UNIX-CLIENT:/var/run/docker.sock</div></pre></td></tr></table></figure>
<h3 id="一些docker命令总结"><a href="#一些docker命令总结" class="headerlink" title="一些docker命令总结"></a>一些docker命令总结</h3><ul>
<li>docker images :查看当前宿主机的所有镜像。</li>
<li>docker images ubuntu：根据仓库名列出镜像</li>
<li>docker images ubuntu:14.04:指定仓库名和标签</li>
<li>docker build -t webservice .:表示使用当前目录下的DockerFile来生成镜像，-t参数的值表示镜像的tagname，如果DockerFile在当前路径下则使用.，如果不在当前路径下则使用相对路径。</li>
<li>docker ps -a: 没有-a参数表示显示当前宿主机的正在运行的容器，加上-a表示显示当前宿主机所有的容器，包括已经退出的容器。</li>
<li>docker run -d -p 2222:22 –name base centos:7.1
表示根据指定的镜像后台运行容器，容器的名字是base（–name就是指定容器的名字)，centos:7.1表示镜像的名字，-p参数表示当前宿主机的2222端口对应容器的22端口。-d参数表示（Run container in background and print container ID）</li>
<li>docker exec -it base /bin/bash
以交互式命令进入base容器并且执行/bin/bash命令</li>
<li>docker rmi webservice:删除webservice镜像</li>
<li>docker rm base: 删除base容器，如果base正在运行，则可以使用docker rm -f base进行强行删除</li>
<li>docker start 启动容器</li>
<li>docker stop 停止容器</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;docker是什么&quot;&gt;&lt;a href=&quot;#docker是什么&quot; class=&quot;headerlink&quot; title=&quot;docker是什么&quot;&gt;&lt;/a&gt;docker是什么&lt;/h3&gt;&lt;p&gt;Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Lin
    
    </summary>
    
      <category term="docker" scheme="http://wodekouwei.com/categories/docker/"/>
    
    
      <category term="虚拟化" scheme="http://wodekouwei.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="docker" scheme="http://wodekouwei.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(六)基础之Binder</title>
    <link href="http://wodekouwei.com/2018/01/14/tips-android-pluggable-7/"/>
    <id>http://wodekouwei.com/2018/01/14/tips-android-pluggable-7/</id>
    <published>2018-01-14T05:47:58.000Z</published>
    <updated>2018-01-14T05:48:47.084Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(五)基础之用到Android源码类探讨</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-6/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-6/</id>
    <published>2018-01-12T12:23:00.000Z</published>
    <updated>2018-01-14T06:36:09.597Z</updated>
    
    <content type="html"><![CDATA[<h6 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h6><p>获取:通过Context的getPackageManager()
常用方法:</p>
<ol>
<li><code>getInstalledPackages(int flags)</code>:可以得到所有安装在机器上的程序的包信息类对象List<packageinfo>，PackageInfo类中有一值applicationInfo可以得到Application的对象。</packageinfo></li>
<li><code>getPackageArchiveInfo(dexPath,
PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES)</code>:取自身应用以外其他apk的信息方法</li>
<li><code>getInstalledApplications(int flags)</code>:得到所有安装在机器上的程序的application对象List<applicationinfo>；</applicationinfo></li>
<li><code>getApplicationIcon(String packageName)</code>,<code>getApplicationIcon(ApplicationInfo info)</code>:获得应用程序的图片</li>
<li><code>getApplicationLabel(ApplicationInfo info)</code>:方法可以获得应用程序的名字</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;PackageManager&quot;&gt;&lt;a href=&quot;#PackageManager&quot; class=&quot;headerlink&quot; title=&quot;PackageManager&quot;&gt;&lt;/a&gt;PackageManager&lt;/h6&gt;&lt;p&gt;获取:通过Context的getPackag
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(四)基础之文件存储</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-5/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-5/</id>
    <published>2018-01-12T12:22:57.000Z</published>
    <updated>2018-01-14T06:14:08.755Z</updated>
    
    <content type="html"><![CDATA[<h3 id="android文件存储解析"><a href="#android文件存储解析" class="headerlink" title="android文件存储解析"></a>android文件存储解析</h3><p>安卓中提供了Context中的方法与Environment类来操作文件。</p>
<h4 id="Context文件操作方法"><a href="#Context文件操作方法" class="headerlink" title="Context文件操作方法"></a>Context文件操作方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public File getFileStreamPath(String name)</div><div class="line">public String[] fileList()</div><div class="line">public File getFilesDir()</div><div class="line">public File getNoBackupFilesDir()</div><div class="line">public File getExternalFilesDir(String type)</div><div class="line">public File[] getExternalFilesDirs(String type)</div><div class="line">public File getObbDir()</div><div class="line">public File[] getObbDirs()</div><div class="line">public File getCacheDir()</div><div class="line">public File getCodeCacheDir()</div><div class="line">public File getExternalCacheDir()</div><div class="line">public File[] getExternalCacheDirs()</div><div class="line">public File[] getExternalMediaDirs()</div><div class="line">public File getDir(String name, int mode)</div></pre></td></tr></table></figure>
<p>用Log把它们都显示出来
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Log.d(&quot;context&quot;, &quot;context.getFileStreamPath--&gt;&quot; +</div><div class="line">    this.getFileStreamPath(&quot;test&quot;).toString());</div><div class="line">Log.d(&quot;context&quot;, &quot;context.getDir--&gt;&quot; +</div><div class="line">    this.getDir(&quot;test&quot;, Context.MODE_PRIVATE).toString());</div><div class="line">Log.d(&quot;context&quot;, &quot;context.getFilesDir--&gt;&quot; +</div><div class="line">    this.getFilesDir().toString());</div><div class="line">Log.d(&quot;context&quot;, &quot;context.getNoBackupFilesDir&quot; +</div><div class="line">    this.getNoBackupFilesDir().toString());</div><div class="line">Log.d(&quot;context&quot;, &quot;context.getCacheDir--&gt;&quot; +</div><div class="line">    this.getCacheDir().toString());</div><div class="line">Log.d(&quot;context&quot;, &quot;context.getCodeCacheDir&quot; +</div><div class="line">    this.getCodeCacheDir().toString());</div><div class="line">Log.d(&quot;context&quot;, &quot;context.getDatabasePath--&gt;&quot; +</div><div class="line">    this.getDatabasePath(&quot;test&quot;).toString());</div><div class="line">Log.d(&quot;context&quot;, &quot;context.getObbDir--&gt;&quot; +</div><div class="line">    this.getObbDir().toString());</div><div class="line"></div><div class="line">File[] files1 = this.getObbDirs();</div><div class="line">for (File file : files1) &#123;</div><div class="line">    Log.d(&quot;context&quot;, &quot;context.getObbDirs--&gt;&quot; + file.toString());</div><div class="line">&#125;</div><div class="line">File[] files2 = this.getExternalMediaDirs();</div><div class="line">for (File file : files2) &#123;</div><div class="line">    Log.d(&quot;context&quot;, &quot;context.getExternalMediaDirs&quot; + file.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">Log.d(&quot;context&quot;, &quot;context.getExternalCacheDir--&gt;&quot; + this.getExternalCacheDir().toString());</div><div class="line">File[] files3 = this.getExternalCacheDirs();</div><div class="line">for (File file : files3) &#123;</div><div class="line">    Log.d(&quot;context&quot;, &quot;context.getExternalCacheDirs--&gt;&quot; + file.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">Log.d(&quot;context&quot;, &quot;context.getExternalFilesDir--&gt;&quot; + this.getExternalFilesDir(Environment.DIRECTORY_ALARMS).toString());</div><div class="line"></div><div class="line">File[] files4 = this.getExternalFilesDirs(Environment.DIRECTORY_ALARMS);</div><div class="line">for (File file : files4) &#123;</div><div class="line">    Log.d(&quot;context&quot;, &quot;context.getExternalFilesDirs--&gt;&quot; + file.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>og输出结果(不同版本的安卓系统，目录可能也不相同):
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">context.getFileStreamPath--&gt;/data/data/cn.hufeifei.environmenttest/files/test</div><div class="line">context.getDir--&gt;/data/data/cn.hufeifei.environmenttest/app_test</div><div class="line">context.getFilesDir--&gt;/data/data/cn.hufeifei.environmenttest/files</div><div class="line">context.getNoBackupFilesDir/data/data/cn.hufeifei.environmenttest/no_backup</div><div class="line">context.getCacheDir--&gt;/data/data/cn.hufeifei.environmenttest/cache</div><div class="line">context.getCodeCacheDir/data/data/cn.hufeifei.environmenttest/code_cache</div><div class="line">context.getDatabasePath--&gt;/data/data/cn.hufeifei.environmenttest/databases/test</div><div class="line">context.getObbDir--&gt;/storage/emulated/0/Android/obb/cn.hufeifei.environmenttest</div><div class="line">context.getObbDirs--&gt;/storage/emulated/0/Android/obb/cn.hufeifei.environmenttest</div><div class="line">context.getExternalMediaDirs/storage/emulated/0/Android/media/cn.hufeifei.environmenttest</div><div class="line">context.getExternalCacheDir--&gt;/storage/emulated/0/Android/data/cn.hufeifei.environmenttest/cache</div><div class="line">context.getExternalCacheDirs--&gt;/storage/emulated/0/Android/data/cn.hufeifei.environmenttest/cache</div><div class="line">context.getExternalFilesDir--&gt;/storage/emulated/0/Android/data/cn.hufeifei.environmenttest/files/Alarms</div><div class="line">context.getExternalFilesDirs--&gt;/storage/emulated/0/Android/data/cn.hufeifei.environmenttest/files/Alarms</div></pre></td></tr></table></figure></p>
<h4 id="Environment工具类中提供了以下几个方法："><a href="#Environment工具类中提供了以下几个方法：" class="headerlink" title="Environment工具类中提供了以下几个方法："></a>Environment工具类中提供了以下几个方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Environment.getDataDirectory();</div><div class="line">Environment.getRootDirectory();</div><div class="line">Environment.getDownloadCacheDirectory();</div><div class="line">Environment.getExternalStoragePublicDirectory(String type);</div><div class="line">Environment.getExternalStorageDirectory();</div><div class="line">Environment.getExternalStorageState();</div><div class="line">Environment.getExternalStorageState(File path)</div><div class="line">Environment.getStorageState();//已被getExternalStorageState取代</div></pre></td></tr></table></figure>
<h5 id="1-前三个方法"><a href="#1-前三个方法" class="headerlink" title="1.前三个方法"></a>1.前三个方法</h5><p>用Log输出来：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//IS标识内部存储</div><div class="line">Log.d(&quot;Environment-IS&quot;, Environment.getDataDirectory().toString());</div><div class="line">Log.d(&quot;Environment-IS&quot;, Environment.getDownloadCacheDirectory().toString());</div><div class="line">Log.d(&quot;Environment-IS&quot;, Environment.getRootDirectory().toString());</div></pre></td></tr></table></figure></p>
<p>输出结果为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D/Environment-IS: /data</div><div class="line">D/Environment-IS: /cache</div><div class="line">D/Environment-IS: /system</div></pre></td></tr></table></figure></p>
<h5 id="2-getExternalStoragePublicDirectory方法"><a href="#2-getExternalStoragePublicDirectory方法" class="headerlink" title="2.getExternalStoragePublicDirectory方法"></a>2.getExternalStoragePublicDirectory方法</h5><p>getExternalStoragePublicDirectory方法用来获取安卓外部存储中系统应用经常用到的公共文件夹，
在Environment中定义了这些文件夹的名字：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Environment.DIRECTORY_MUSIC = &quot;Music&quot;</div><div class="line">Environment.DIRECTORY_PODCASTS = &quot;Podcasts&quot;</div><div class="line">Environment.DIRECTORY_RINGTONES = &quot;Ringtones&quot;</div><div class="line">Environment.DIRECTORY_ALARMS = &quot;Alarms&quot;</div><div class="line">Environment.DIRECTORY_NOTIFICATIONS = &quot;Notifications&quot;</div><div class="line">Environment.DIRECTORY_PICTURES = &quot;Pictures&quot;</div><div class="line">Environment.DIRECTORY_MOVIES = &quot;Movies&quot;</div><div class="line">Environment.DIRECTORY_DOWNLOADS = &quot;Download&quot;</div><div class="line">Environment.DIRECTORY_DCIM = &quot;DCIM&quot;</div><div class="line">Environment.DIRECTORY_DOCUMENTS = &quot;Documents&quot;</div></pre></td></tr></table></figure></p>
<p>它们的目录一般在/storage/emulated/0/<dir_name> (dir_name就是Environment中定义的这些字符串常量)</dir_name></p>
<h5 id="3-最后的三个方法"><a href="#3-最后的三个方法" class="headerlink" title="3.最后的三个方法"></a>3.最后的三个方法</h5><p>最后面三个方法是用来获取挂载点的状态(在Linux中把一些特殊目录称为所谓的挂载点，有点类似于Windows中的分区)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Environment.MEDIA_REMOVED;//媒体存储已经移除了</div><div class="line">Environment.MEDIA_UNMOUNTED;//存储媒体没有挂载</div><div class="line">Environment.MEDIA_CHECKING;//正在检查存储媒体</div><div class="line">Environment.MEDIA_NOFS;//存储媒体是空白或是不支持的文件系统no_file_system</div><div class="line">Environment.MEDIA_MOUNTED;//存储媒体已经挂载，并且挂载点可读/写</div><div class="line">Environment.MEDIA_MOUNTED_READ_ONLY;//存储媒体已经挂载，挂载点只读</div><div class="line">Environment.MEDIA_SHARED;//存储媒体正在通过USB共享</div><div class="line">Environment.MEDIA_BAD_REMOVAL;//在没有挂载前存储媒体已经被移除</div><div class="line">Environment.MEDIA_UNMOUNTABLE;//存储媒体无法挂载,可能是文件系统损坏了</div><div class="line">Environment.MEDIA_EJECTING;//存储媒体正在移除</div><div class="line">Environment.MEDIA_UNKNOWN;//未知的存储状态</div></pre></td></tr></table></figure></p>
<p>下面图片大概地概括了上面的方法
<img src="http://images.wodekouwei.com/technology/android-storage.png" alt="image"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><ul>
<li>Context中的方法或得到的路径都与应用包名相关*</li>
<li>Environment中的方法与整个系统有关*</li>
</ul>
<h3 id="storage-sdcard0，-sdcard，-mnt-sdcard-，-storage-emulated-legacy-的区别"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard-，-storage-emulated-legacy-的区别" class="headerlink" title="/storage/sdcard0， /sdcard， /mnt/sdcard ，/storage/emulated/legacy 的区别"></a><code>/storage/sdcard0</code>， <code>/sdcard</code>， <code>/mnt/sdcard</code> ，<code>/storage/emulated/legacy</code> 的区别</h3><p>关于android的4.2的0文件夹的详解</p>
<h4 id="android-4-0"><a href="#android-4-0" class="headerlink" title="android 4.0"></a>android 4.0</h4><p>在galaxy nexus（GN）手机上userdata分区很大，被挂在/data目录，用户的数据通常是放在sd卡上，然而gn是没有sd卡的，所以google想了一个办法，就是虚拟一个。</p>
<p>所以，在userdata分区下有个目录叫media，是内置sd卡的数据存储位置，使用fuse技术将<code>/data/media</code>虚拟成为一个叫做<code>/dev/fuse</code>的设备，为了让程序能认出来，被同时挂载在 <code>/mnt/sdcard</code> 目录，
又为了兼容以前的程序，做了一个快捷方式（linux系统里叫软连接） <code>/sdcard</code>指向的是 <code>/mnt/sdcard</code> .</p>
<p>当然，这些都是4.0的做法。</p>
<h4 id="android-4-1"><a href="#android-4-1" class="headerlink" title="android 4.1"></a>android 4.1</h4><p>在4.1里，同样也会使用fuse技术，<code>/dev/fuse</code> 会被同时挂载到<code>/storage/sdcard0</code> 目录，这个sdcard0表示第一个sd卡（如果有外置sd卡，那会多一个 <code>/storage/sdcard1</code>，比如我的xoom）， <code>/sdcard</code> 软连接会指向 <code>/storage/sdcard0</code> ，此时<code>/mnt/sdcard</code> 也是个软连接，会指向<code>/storage/sdcard0</code>。
如果你通过otg线接U盘，会被挂载到 <code>/storage/usb0</code>目录，stickmount这个软件为了让图库、快图、mx player等软件，能看到u盘里的数据，又同时挂载到 <code>/storage/sdcard0/usStorage/sda1</code>.</p>
<p>也许你会问，为什么不是usb0，而是sda1，这是linux的对硬盘的命名方式，如果你的u盘有多个分区，就分别是sda1,sda2这样一直排下去了。</p>
<h4 id="android-4-2"><a href="#android-4-2" class="headerlink" title="android 4.2"></a>android 4.2</h4><p>谷歌是不是没事干啊，非要给android搞个多用户，你想想啊，在中国，可能因为经济问题，家里不是每人一个电脑，在美国，几乎需要用电脑的人，都会自己有一台或多台，一台电脑多人用的情况少之又少，这就是为什么叫PC了，顾名思义，个人电脑。像手机和平板这些东西，更加私人化了，很少公用了吧，我想在中国也是如此吧。</p>
<p>当然，谷歌也不完全是抽风，因为他有更大的战略部署，而且平板也的确有多人用的可能。</p>
<p>所以谷歌搞出来一个多用户，那每个人的应用、数据、个性配置都要分开吧。 应用和个性配置好弄，想想啊，通过权限控制，每人只能看自己的应用就行了，桌面也可以用自己的。</p>
<p>那数据怎么办？？？？</p>
<p>好吧，调整用户数据的挂载结构。android 4.2，同样也会使用fuse技术/dev/fuse 会被挂载到<code>/storage/emulated/0</code> 目录，为什么是0呢，你还记得上边的sdcard0吧，第一个的意思。（如果有第二个，应该就是<code>/storage/emulated/1</code>，我们的三儿子没有外置sd卡，所以没法验证）</p>
<p>为了兼容以前，同时挂载到 <code>/storage/emulated/legacy</code> （故名思议，传统的），还建立三个软连接 <code>/storage/sdcard0</code> ，<code>/sdcard</code>，<code>/mnt/sdcard</code> ，都指向  <code>/storage/emulated/legacy</code></p>
<p>还有值得一提的是，4.2刚出来，这块变动又比较大，所以stickmount要升级到2.2之后，才可以通过otg挂载u盘了。</p>
<p>也许你会问，这个0和多用户有什么关系呢，那是因为多用户这个新特性，只在平板上才启用，在手机上会被禁用的。但是底层实现是一致的。 <code>/mnt/shell/emulated</code> 目录和 <code>/storage/emulated</code> 下的文件夹是一样的。（注意，这个<code>/mnt/shell/emulated</code>  不是挂载出来的）</p>
<p><code>/mnt/shell/</code>是为了多用户准备的，因为linux的多用户是基于shell实现的。</p>
<p>4.2在平板上的多用户
我前一段时间给XOOM Wifi刷上了CM10.1的4.2.1，成功开启多用户特性。新建的用户id从10开始。</p>
<ul>
<li>默认用户的sdcard目录： <code>/storage/emulated/0</code></li>
<li>新建的第一个用户的sdcard目录：  <code>/storage/emulated/10</code></li>
<li>新建的第二个用户的sdcard目录：  <code>/storage/emulated/11</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;android文件存储解析&quot;&gt;&lt;a href=&quot;#android文件存储解析&quot; class=&quot;headerlink&quot; title=&quot;android文件存储解析&quot;&gt;&lt;/a&gt;android文件存储解析&lt;/h3&gt;&lt;p&gt;安卓中提供了Context中的方法与Environm
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(四)基础之Hook</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-4/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-4/</id>
    <published>2018-01-12T12:22:24.000Z</published>
    <updated>2018-01-13T09:39:40.444Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、寻找Hook点的原则"><a href="#1、寻找Hook点的原则" class="headerlink" title="1、寻找Hook点的原则"></a>1、寻找Hook点的原则</h4><p>Android中主要是依靠分析系统源码类来做到的，首先我们得找到被Hook的对象，我称之为Hook点；什么样的对象比较好Hook呢？一般来说，静态变量和单例变量是相对不容易改变，是一个比较好的hook点，而普通的对象有易变的可能，每个版本都不一样，处理难度比较大。我们根据这个原则找到所谓的Hook点。</p>
<h4 id="2、寻找Hook点"><a href="#2、寻找Hook点" class="headerlink" title="2、寻找Hook点"></a>2、寻找Hook点</h4><p>通常点击一个Button就开始Activity跳转了，这中间发生了什么，我们如何Hook,来实现Activity启动的拦截呢？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void start(View view) &#123;</div><div class="line">        Intent intent = new Intent(this, OtherActivity.class);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们的目的是要拦截startActivity方法，跟踪源码，发现最后启动Activity是由Instrumentation类的execStartActivity做到的。其实这个类相当于启动Activity的中间者，启动Activity中间都是由它来操作的
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public ActivityResult execStartActivity(</div><div class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</div><div class="line">            Intent intent, int requestCode, Bundle options) &#123;</div><div class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</div><div class="line">        ....</div><div class="line">        try &#123;</div><div class="line">            intent.migrateExtraStreamToClipData();</div><div class="line">            intent.prepareToLeaveProcess(who);</div><div class="line"></div><div class="line">        //通过ActivityManagerNative.getDefault()获取一个对象，开始启动新的Activity</div><div class="line">            int result = ActivityManagerNative.getDefault()</div><div class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</div><div class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</div><div class="line">                        token, target != null ? target.mEmbeddedID : null,</div><div class="line">                        requestCode, 0, null, options);</div><div class="line"></div><div class="line"></div><div class="line">            checkStartActivityResult(result, intent);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于ActivityManagerNative这个东东，熟悉Activity/Service启动过程的都不陌生
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager</div></pre></td></tr></table></figure></p>
<p>继承了Binder，实现了一个IActivityManager接口，这就是为了远程服务通信做准备的”Stub”类，一个完整的AID L有两部分，一个是个跟服务端通信的Stub,一个是跟客户端通信的Proxy。ActivityManagerNative就是Stub,阅读源码发现在ActivityManagerNative 文件中还有个ActivityManagerProxy，这里就多不扯了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static public IActivityManager getDefault() &#123;</div><div class="line">    return gDefault.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ActivityManagerNative.getDefault()获取的是一个IActivityManager对象，由IActivityManager去启动Activity，IActivityManager的实现类是ActivityManagerService，ActivityManagerService是在另外一个进程之中，所有Activity 启动是一个跨进程的通信的过程，所以真正启动Activity的是通过远端服务ActivityManagerService来启动的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">        protected IActivityManager create() &#123;</div><div class="line">            IBinder b = ServiceManager.getService(&quot;activity&quot;);</div><div class="line">            if (false) &#123;</div><div class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</div><div class="line">            &#125;</div><div class="line">            IActivityManager am = asInterface(b);</div><div class="line">            if (false) &#123;</div><div class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</div><div class="line">            &#125;</div><div class="line">            return am;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>实gDefalut借助Singleton实现的单例模式，而在内部可以看到先从ServiceManager中获取到AMS远端服务的Binder对象，然后使用asInterface方法转化成本地化对象，我们目的是拦截startActivity,所以改变IActivityManager对象可以做到这个一点，这里gDefault又是静态的，根据Hook原则，这是一个比较好的Hook点。</p>
<h4 id="3、Hook掉startActivity，输出日志"><a href="#3、Hook掉startActivity，输出日志" class="headerlink" title="3、Hook掉startActivity，输出日志"></a>3、Hook掉startActivity，输出日志</h4><p>我们先实现一个小需求，启动Activity的时候打印一条日志，写一个工具类HookUtil。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class HookUtil &#123;</div><div class="line"></div><div class="line">    private Class&lt;?&gt; proxyActivity;</div><div class="line"></div><div class="line">    private Context context;</div><div class="line"></div><div class="line">    public HookUtil(Class&lt;?&gt; proxyActivity, Context context) &#123;</div><div class="line">        this.proxyActivity = proxyActivity;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void hookAms() &#123;</div><div class="line"></div><div class="line">        //一路反射，直到拿到IActivityManager的对象</div><div class="line">        try &#123;</div><div class="line">            Class&lt;?&gt; ActivityManagerNativeClss = Class.forName(&quot;android.app.ActivityManagerNative&quot;);</div><div class="line">            Field defaultFiled = ActivityManagerNativeClss.getDeclaredField(&quot;gDefault&quot;);</div><div class="line">            defaultFiled.setAccessible(true);</div><div class="line">            Object defaultValue = defaultFiled.get(null);</div><div class="line">            //反射SingleTon</div><div class="line">            Class&lt;?&gt; SingletonClass = Class.forName(&quot;android.util.Singleton&quot;);</div><div class="line">            Field mInstance = SingletonClass.getDeclaredField(&quot;mInstance&quot;);</div><div class="line">            mInstance.setAccessible(true);</div><div class="line">            //到这里已经拿到ActivityManager对象</div><div class="line">            Object iActivityManagerObject = mInstance.get(defaultValue);</div><div class="line"></div><div class="line"></div><div class="line">            //开始动态代理，用代理对象替换掉真实的ActivityManager，瞒天过海</div><div class="line">            Class&lt;?&gt; IActivityManagerIntercept = Class.forName(&quot;android.app.IActivityManager&quot;);</div><div class="line"></div><div class="line">            AmsInvocationHandler handler = new AmsInvocationHandler(iActivityManagerObject);</div><div class="line"></div><div class="line">            Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]&#123;IActivityManagerIntercept&#125;, handler);</div><div class="line"></div><div class="line">            //现在替换掉这个对象</div><div class="line">            mInstance.set(defaultValue, proxy);</div><div class="line"></div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private class AmsInvocationHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">        private Object iActivityManagerObject;</div><div class="line"></div><div class="line">        private AmsInvocationHandler(Object iActivityManagerObject) &#123;</div><div class="line">            this.iActivityManagerObject = iActivityManagerObject;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line"></div><div class="line">            Log.i(&quot;HookUtil&quot;, method.getName());</div><div class="line">            //我要在这里搞点事情</div><div class="line">            if (&quot;startActivity&quot;.contains(method.getName())) &#123;</div><div class="line">                Log.e(&quot;HookUtil&quot;,&quot;Activity已经开始启动&quot;);</div><div class="line">                Log.e(&quot;HookUtil&quot;,&quot;小弟到此一游！！！&quot;);</div><div class="line">            &#125;</div><div class="line">            return method.invoke(iActivityManagerObject, args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结合注释应该很容易看懂，在Application中配置一下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MyApplication extends Application &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        HookUtil hookUtil=new HookUtil(SecondActivity.class, this);</div><div class="line">        hookUtil.hookAms()；</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，我们成功的Hook掉了startActivity，输出了一条日志。有了上面的基础，现在我们开始来点有用的东西，Activity不用在清单文件中注册，就可以启动起来，这个怎么搞呢？</p>
<h4 id="4、无需注册，启动Activity"><a href="#4、无需注册，启动Activity" class="headerlink" title="4、无需注册，启动Activity"></a>4、无需注册，启动Activity</h4><p>如下，TargetActivity没有在清单文件中注册，怎么去启动TargetActivity？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void start(View view) &#123;</div><div class="line">        Intent intent = new Intent(this, TargetActivity.class);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个思路可以是这样，上面已经拦截了启动Activity流程，在invoke中我们可以得到启动参数intent信息，那么就在这里，我们可以自己构造一个假的Activity信息的intent，这个Intent启动的Activity是在清单文件中注册的，当真正启动的时候（ActivityManagerService校验清单文件之后），用真实的Intent把代理的Intent在调换过来，然后启动即可。</p>
<p>首先获取真实启动参数intent信息
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line">            if (&quot;startActivity&quot;.contains(method.getName())) &#123;</div><div class="line">                //换掉</div><div class="line">                Intent intent = null;</div><div class="line">                int index = 0;</div><div class="line">                for (int i = 0; i &lt; args.length; i++) &#123;</div><div class="line">                    Object arg = args[i];</div><div class="line">                    if (arg instanceof Intent) &#123;</div><div class="line">                        //说明找到了startActivity的Intent参数</div><div class="line">                        intent = (Intent) args[i];</div><div class="line">                        //这个意图是不能被启动的，因为Acitivity没有在清单文件中注册</div><div class="line">                        index = i;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               //伪造一个代理的Intent，代理Intent启动的是proxyActivity</div><div class="line">                Intent proxyIntent = new Intent();</div><div class="line">                ComponentName componentName = new ComponentName(context, proxyActivity);</div><div class="line">                proxyIntent.setComponent(componentName);</div><div class="line">                proxyIntent.putExtra(&quot;oldIntent&quot;, intent);</div><div class="line">                args[index] = proxyIntent;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return method.invoke(iActivityManagerObject, args);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>有了上面的两个步骤,这个代理的Intent是可以通过ActivityManagerService检验的，因为我在清单文件中注册过
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.ProxyActivity&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>为了不启动ProxyActivity，现在我们需要找一个合适的时机，把真实的Intent换过了来，启动我们真正想启动的Activity。看过Activity的启动流程的朋友，我们都知道这个过程是由Handler发送消息来实现的，可是通过Handler处理消息的代码来看，消息的分发处理是有顺序的，下面是Handler处理消息的代码:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">        if (msg.callback != null) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (mCallback != null) &#123;</div><div class="line">                if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>handler处理消息的时候，首先去检查是否实现了callback接口，如果有实现的话，那么会直接执行接口方法，然后才是handleMessage方法，最后才是执行重写的handleMessage方法，我们一般大部分时候都是重写了handleMessage方法,而ActivityThread主线程用的正是重写的方法，这种方法的优先级是最低的，我们完全可以实现接口来替换掉系统Handler的处理过程。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void hookSystemHandler() &#123;</div><div class="line">        try &#123;</div><div class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class="line">            Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);</div><div class="line">            currentActivityThreadMethod.setAccessible(true);</div><div class="line">            //获取主线程对象</div><div class="line">            Object activityThread = currentActivityThreadMethod.invoke(null);</div><div class="line">            //获取mH字段</div><div class="line">            Field mH = activityThreadClass.getDeclaredField(&quot;mH&quot;);</div><div class="line">            mH.setAccessible(true);</div><div class="line">            //获取Handler</div><div class="line">            Handler handler = (Handler) mH.get(activityThread);</div><div class="line">            //获取原始的mCallBack字段</div><div class="line">            Field mCallBack = Handler.class.getDeclaredField(&quot;mCallback&quot;);</div><div class="line">            mCallBack.setAccessible(true);</div><div class="line">            //这里设置了我们自己实现了接口的CallBack对象</div><div class="line">            mCallBack.set(handler, new ActivityThreadHandlerCallback(handler)) ;</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>自定义Callback类
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private class ActivityThreadHandlerCallback implements Handler.Callback &#123;</div><div class="line"></div><div class="line">        private Handler handler;</div><div class="line"></div><div class="line">        private ActivityThreadHandlerCallback(Handler handler) &#123;</div><div class="line">            this.handler = handler;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public boolean handleMessage(Message msg) &#123;</div><div class="line">            Log.i(&quot;HookAmsUtil&quot;, &quot;handleMessage&quot;);</div><div class="line">            //替换之前的Intent</div><div class="line">            if (msg.what ==100) &#123;</div><div class="line">                Log.i(&quot;HookAmsUtil&quot;,&quot;lauchActivity&quot;);</div><div class="line">                handleLauchActivity(msg);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            handler.handleMessage(msg);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void handleLauchActivity(Message msg) &#123;</div><div class="line">            Object obj = msg.obj;//ActivityClientRecord</div><div class="line">            try&#123;</div><div class="line">                Field intentField = obj.getClass().getDeclaredField(&quot;intent&quot;);</div><div class="line">                intentField.setAccessible(true);</div><div class="line">                Intent proxyInent = (Intent) intentField.get(obj);</div><div class="line">                Intent realIntent = proxyInent.getParcelableExtra(&quot;oldIntent&quot;);</div><div class="line">                if (realIntent != null) &#123;</div><div class="line">                    proxyInent.setComponent(realIntent.getComponent());</div><div class="line">                &#125;</div><div class="line">            &#125;catch (Exception e)&#123;</div><div class="line">                Log.i(&quot;HookAmsUtil&quot;,&quot;lauchActivity falied&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后在application中注入
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MyApplication extends Application &#123;</div><div class="line">    @Override</div><div class="line">    public void onCreate() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        //这个ProxyActivity在清单文件中注册过，以后所有的Activitiy都可以用ProxyActivity无需声明，绕过监测</div><div class="line">        HookAmsUtil hookAmsUtil = new HookAmsUtil(ProxyActivity.class, this);</div><div class="line">        hookAmsUtil.hookSystemHandler();</div><div class="line">        hookAmsUtil.hookAms();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、寻找Hook点的原则&quot;&gt;&lt;a href=&quot;#1、寻找Hook点的原则&quot; class=&quot;headerlink&quot; title=&quot;1、寻找Hook点的原则&quot;&gt;&lt;/a&gt;1、寻找Hook点的原则&lt;/h4&gt;&lt;p&gt;Android中主要是依靠分析系统源码类来做到的，首先我们得
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(三)基础之Android应用程序资源的编译和打包过程分析</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-3/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-3/</id>
    <published>2018-01-12T12:19:09.000Z</published>
    <updated>2018-01-13T10:25:46.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-Apk打包流程"><a href="#Android-Apk打包流程" class="headerlink" title="Android Apk打包流程"></a>Android Apk打包流程</h3><ol>
<li>打包资源文件,生成R.java文件;</li>
<li>处理aidl文件,生成相应java文件;</li>
<li>编译工程源文件,生成相应class文件;</li>
<li>转换所有class文件,生成classes.dex文件;</li>
<li>打包生成apk文件;</li>
<li>对apk文件进行签名;</li>
<li>对签名后的apk文件进行对齐处理;</li>
</ol>
<p><img src="http://images.wodekouwei.com/technology/app_package.png" alt="image"></p>
<p>打包过程使用的工具</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能介绍</th>
<th>在操作系统中的路径</th>
<th>源码路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>aapt（Android Asset Package Tool）</td>
<td>Android资源打包工具</td>
<td><code>${ANDROID_SDK_HOME} /build-tools/</code> <code>ANDROID_VERSION/aapt</code></td>
<td><code>frameworks\base\tools\aap</code></td>
</tr>
<tr>
<td>aidl（android interface definition language）</td>
<td>Android接口描述语言，将aidl转化为.java文件的工具</td>
<td><code>${ANDROID_SDK_HOME}/build-tools/</code> <code>ANDROID_VERSION/aidl</code></td>
<td><code>frameworks\base\tools\aidl</code></td>
</tr>
<tr>
<td>javac</td>
<td>Java Compiler</td>
<td><code>${JDK_HOME}/javac</code>或<code>/usr/bin/javac</code></td>
</tr>
<tr>
<td>dex</td>
<td>转化.class文件为Davik VM能识别的.dex文件</td>
<td><code>${ANDROID_SDK_HOME}/build-tools/</code> <code>ANDROID_VERSION/dx</code></td>
<td></td>
</tr>
<tr>
<td>apkbuilder</td>
<td>生成apk包</td>
<td><code>${ANDROID_SDK_HOME}/tools/apkbuilder</code></td>
<td><code>sdk\sdkmanager\libs\sdklib\</code> <code>src\com\android\sdklib\build\ApkBuilderMain.java</code></td>
</tr>
<tr>
<td>jarsigner</td>
<td>.jar文件的签名工具</td>
<td>${JDK_HOME}/jarsigner或/usr/bin/jarsigner</td>
<td></td>
</tr>
<tr>
<td>zipalign</td>
<td>字节码对齐工具</td>
<td><code>${ANDROID_SDK_HOME}/tools</code>和<code>/zipalign</code></td>
</tr>
</tbody>
</table>
<h5 id="第一步-打包资源文件-生成R-java文件"><a href="#第一步-打包资源文件-生成R-java文件" class="headerlink" title="第一步: 打包资源文件,生成R.java文件"></a>第一步: 打包资源文件,生成R.java文件</h5><p>【输入】Resource文件（就是工程中res中的文件）、Assets文件（相当于另外一种资源，这种资源Android系统并不像对res中的文件那样优化它）、AndroidManifest.xml文件（包名就是从这里读取的，因为生成R.java文件需要包名）、Android基础类库（Android.jar文件）
【工具】aapt工具
【输出】打包好的资源（bin目录中的resources.ap<em>文件）、R.java文件（gen目录中）
打包资源的工具aapt，大部分文本格式的XML资源文件会被编译成二进制格式的XML资源文件，除了assets和res/raw资源被原装不动地打包进APK之外，其它的资源都会被编译或者处理。 。
生成过程主要是调用了aapt源码目录下的Resource.cpp文件中的buildResource（）函数，该函数首先检查AndroidManifest.xml的合法性，然后对res目录下的资源子目录进行处理，处理的函数为makeFileResource（），处理的内容包括资源文件名的合法性检查，向资源表table添加条目等，处理完后调用compileResourceFile（）函数编译res与asserts目录下的资源并生成resources.arsc文件，compileResourceFile（）函数位于aapt源码目录的ResourceTable.cpp文件中，该函数最后会调用parseAndAddEntry（）函数生成R.java文件，完成资源编译后，接下来调用compileXmlfile()函数对res目录的子目录下的xml文件分别进行编译，这样处理过的xml文件就简单的被“加密”了，最后将所有的资源与编译生成的resorces.arsc文件以及“加密”过的AndroidManifest.xml文件打包压缩成resources.ap</em>文件（使用Ant工具命令行编译则会生成与build.xml中“project name”指定的属性同名的ap_文件）。
关于这一步更详细的流程可阅读<a href="http://blog.csdn.net/luoshengyang/article/details/8744683" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/article/details/8744683</a></p>
<p>res目录有9种目录</p>
<ul>
<li>–animator。这类资源以XML文件保存在res/animator目录下，用来描述属性动画。</li>
<li>–anim。这类资源以XML文件保存在res/anim目录下，用来描述补间动画。</li>
<li>–color。这类资源以XML文件保存在res/color目录下，用描述对象颜色状态选择子。</li>
<li>–drawable。这类资源以XML或者Bitmap文件保存在res/drawable目录下，用来描述可绘制对象。例如，我们可以在里面放置一些图片（.png, .9.png, .jpg, .gif），来作为程序界面视图的背景图。注意，保存在这个目录中的Bitmap文件在打包的过程中，可能会被优化的。例如，一个不需要多于256色的真彩色PNG文件可能会被转换成一个只有8位调色板的PNG面板，这样就可以无损地压缩图片，以减少图片所占用的内存资源。</li>
<li>–layout。这类资源以XML文件保存在res/layout目录下，用来描述应用程序界面布局。</li>
<li>–menu。这类资源以XML文件保存在res/menu目录下，用来描述应用程序菜单。</li>
<li>–raw。这类资源以任意格式的文件保存在res/raw目录下，它们和assets类资源一样，都是原装不动地打包在apk文件中的，不过它们会被赋予资源ID，这样我们就可以在程序中通过ID来访问它们。例如，假设在res/raw目录下有一个名称为filename的文件，并且它在编译的过程，被赋予的资源ID为R.raw.filename，那么就可以使用以下代码来访问它：<code>Resources res = getResources();  
InputStream is = res .openRawResource(R.raw.filename);</code></li>
<li>–values。这类资源以XML文件保存在res/values目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值分别保存在名称为arrays.xml、colors.xml、dimens.xml、strings.xml和styles.xml文件中。</li>
<li>–xml。这类资源以XML文件保存在res/xml目录下，一般就是用来描述应用程序的配置信息。</li>
</ul>
<h5 id="第二步：处理aidl文件，生成相应的java文件。"><a href="#第二步：处理aidl文件，生成相应的java文件。" class="headerlink" title="第二步：处理aidl文件，生成相应的java文件。"></a>第二步：处理aidl文件，生成相应的java文件。</h5><p>输入】源码文件、aidl文件、framework.aidl文件
【工具】aidl工具
【输出】对应的.java文件
对于没有使用到aidl的android工程，这一步可以跳过。aidl工具解析接口定义文件并生成相应的java代码供程序调用。</p>
<h5 id="第三步：编译工程源代码，生成下相应的class文件。"><a href="#第三步：编译工程源代码，生成下相应的class文件。" class="headerlink" title="第三步：编译工程源代码，生成下相应的class文件。"></a>第三步：编译工程源代码，生成下相应的class文件。</h5><p>【输入】源码文件（包括R.java和AIDL生成的.java文件）、库文件（.jar文件）
【工具】javac工具
【输出】.class文件
这一步调用了javac编译工程src目录下所有的java源文件，生成的class文件位于工程的<code>bin\classes</code>目录下，上图假定编译工程源代码时程序是基于android SDK开发的，实际开发过程中，也有可能会使用android NDK来编译native代码，因此，如果可能的话，这一步还需要使用android NDK编译C/C++代码，当然，编译C/C++代码的步骤也可以提前到第一步或第二步。</p>
<h5 id="第四步：转换所有的class文件，生成classes-dex文件。"><a href="#第四步：转换所有的class文件，生成classes-dex文件。" class="headerlink" title="第四步：转换所有的class文件，生成classes.dex文件。"></a>第四步：转换所有的class文件，生成classes.dex文件。</h5><p>【输入】 .class文件（包括Aidl生成.class文件，R生成的.class文件，源文件生成的.class文件），库文件（.jar文件）
【工具】javac工具
【输出】.dex文件
前面多次提到，android系统dalvik虚拟机的可执行文件为dex格式，程序运行所需的classes.dex文件就是在这一步生成的，使用的工具为dx，dx工具主要的工作是将java字节码转换为dalvik字节码、压缩常量池、消除冗余信息等。</p>
<h5 id="第五步：打包生成apk。"><a href="#第五步：打包生成apk。" class="headerlink" title="第五步：打包生成apk。"></a>第五步：打包生成apk。</h5><p>【输入】打包后的资源文件、打包后类文件（.dex文件）、libs文件（包括.so文件，当然很多工程都没有这样的文件，如果你不使用C/C++开发的话）
【工具】apkbuilder工具
【输出】未签名的.apk文件
打包工具为apkbuilder，apkbuilder为一个脚本文件，实际调用的是<code>android-sdk\tools\lib\sdklib.jar</code>文件中的<code>com.android.sdklib.build.ApkBuilderMain</code>类。它的代码实现位于android系统源码的<code>sdk\sdkmanager\libs\sdklib\src\com\android\sdklib\build\ApkBuilderMain.java</code>文件，代码构建了一个ApkBuilder类，然后以包含resources.arsc的文件为基础生成apk文件，这个文件一般为ap_结尾，接着调用addSourceFolder()函数添加工程资源，addSourceFolder()会调用processFileForResource（）函数往apk文件中添加资源，处理的内容包括res目录与asserts目录中的文件，添加完资源后调用addResourceFromJar（）函数往apk文件中写入依赖库，接着调用addNativeLibraries()函数添加工程libs目录下的Native库（通过android NDK编译生成的so或bin文件），最后调用sealApk（）关闭apk文件。</p>
<h5 id="第六步：对apk文件进行签名。"><a href="#第六步：对apk文件进行签名。" class="headerlink" title="第六步：对apk文件进行签名。"></a>第六步：对apk文件进行签名。</h5><p>【输入】未签名的.apk文件
【工具】jarsigner
【输出】签名的.apk文件
android的应用程序需要签名才能在android设备上安装，签名apk文件有两种情况：一种是在调试程序时进行签名，使用eclipse开发android程序时，在编译调试程序时会自己使用一个debug.keystore对apk进行签名；另一种是打包发布时对程序进行签名，这种情况下需要提供一个符合android开发文档中要求的签名文件。签名的方法也分两种：一种是使用jdk中提供的jarsigner工具签名；另一种是使用android源码中提供的signapk工具，它的代码位于android系统源码<code>build\tools\signapk</code>目录下。</p>
<h5 id="第七步：对签名后的apk文件进行对齐处理。"><a href="#第七步：对签名后的apk文件进行对齐处理。" class="headerlink" title="第七步：对签名后的apk文件进行对齐处理。"></a>第七步：对签名后的apk文件进行对齐处理。</h5><p>【输入】签名后的.apk文件
【工具】zipalign工具
【输出】对齐后的.apk文件
这一步需要使用的工具为zipalign，它位于<code>android-sdk\tools</code>目录，源码位于android系统源码的<code>build\tools\zipalign</code>目录，它的主要工作是将spk包进行对齐处理，使spk包中的所有资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时速度会更快，验证apk文件是否对齐过的工作由ZipAlign.cpp文件的verify()函数完成，处理对齐的工作则由process（）函数完成。</p>
<p>以一个具体项目中包含的具体文件为例作图如下：
<img src="http://images.wodekouwei.com/technology/app_package2.png" alt="image"></p>
<h3 id="APK文件内容解析"><a href="#APK文件内容解析" class="headerlink" title="APK文件内容解析"></a>APK文件内容解析</h3><p>android的项目经过编译和打包，形成了:</p>
<ul>
<li>.dex 文件</li>
<li>resources.arsc</li>
<li>uncompiled resources</li>
<li>AndroidManifest.xml</li>
</ul>
<p>解压一个普通的apk文件,解压出来的文件如下:</p>
<ul>
<li>META-INF文件夹</li>
<li>res文件夹</li>
<li>AndroidManifest.xml</li>
<li>classes.dex</li>
<li>resources.arsc</li>
</ul>
<p>classes.dex 是.dex文件。
resources.arsc是resources resources文件。
AndroidManifest.xml是AndroidManifest.xml文件。
res是uncompiled resources。
META-INF是签名文件夹。</p>
<p>META-INF其中有三个文件：</p>
<ul>
<li>CERT.RSA</li>
<li>CERT.SF</li>
<li>MANIFEST.MF</li>
</ul>
<p>MANIFEST.MF文件
版本号以及每一个文件的哈希值（BASE64）。包括资源文件。这个是对每个文件的整体进行SHA1(hash)。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Manifest-Version: 1.0</div><div class="line">Built-By: Generated-by-ADT</div><div class="line">Created-By: Android Gradle 2.2.0</div><div class="line">Name: res/drawable-xhdpi-v4/abc_scrubber_control_to_pressed_mtrl_005.png</div><div class="line">SHA1-Digest: I9s6aQ5VyOLrNo4odqSij549Oyo=</div><div class="line">Name: res/drawable-mdpi-v4/abc_textfield_search_default_mtrl_alpha.9.png</div><div class="line">SHA1-Digest: D6dilO+UMcglambujyMOhNbLZuY=</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>CERT.SF
这个是对每个文件的头3行进行SHA1 hash。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Signature-Version: 1.0</div><div class="line">X-Android-APK-Signed: 2</div><div class="line">SHA1-Digest-Manifest: QxOfCCAuQtZnHh0YRNnoxmiHT80=</div><div class="line">Created-By: 1.0 (Android)</div><div class="line">Name: res/drawable-xhdpi-v4/abc_scrubber_control_to_pressed_mtrl_005.png</div><div class="line">SHA1-Digest: I9s6aQ5VyOLrNo4odqSij549Oyo=</div><div class="line">Name: res/drawable-mdpi-v4/abc_textfield_search_default_mtrl_alpha.9.png</div><div class="line">SHA1-Digest: D6dilO+UMcglambujyMOhNbLZuY=</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>CERT.RSA
这个文件保存了签名和公钥证书。</p>
<h3 id="插件化中资源冲突解决"><a href="#插件化中资源冲突解决" class="headerlink" title="插件化中资源冲突解决"></a>插件化中资源冲突解决</h3><p>如果需要宿主、插件之间使用同一套资源管理器，那么我们需要将插件的资源路径添加到宿主的AssetManager中。</p>
<p>我们知道，apk包括代码和资源，在apk编译过程中，dex工具将代码打包成.dex文件，资源文件会由aapt工具生成对应的ID，aapt在打包的时候组织成resources.arsc文件，resources.arsc文件是用来描述资源ID和资源位置配置信息，从18个维度描述了一个资源ID的配置信息（语言、分辨率等），就是资源ID和资源的索引表。资源的ID生成是有规则的，规则：0xPPTTNNNN，由8位16进制组成，其中：
PP段：表示资源的包空间：0x01表示系统资源空间，0x7f表示应用资源空间。
TT段：表示资源类型。
NNNN段：4个16进制表示资源id，一个apk中同一类型资源从0000开始递增。
例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">nt anim pop_dialog_in 0x7f040000</div><div class="line">int anim pop_dialog_out 0x7f040001</div><div class="line">int anim slide_left_in 0x7f040002</div><div class="line">int anim slide_left_out 0x7f040003</div><div class="line">int anim slide_right_in 0x7f040004</div><div class="line">int anim slide_right_out 0x7f040005</div><div class="line">int anim update_loading_progressbar_anim 0x7f040006</div><div class="line">int array indicator_tab_icon 0x7f050001</div><div class="line">int array indicator_tab_titlt 0x7f050000</div></pre></td></tr></table></figure></p>
<p>现在问题来了，宿主apk和插件apk是独立编译出来的两个独立的apk，那么其中就有资源ID相同的情况出现，从而产生资源ID冲突。如何解决这个问题？看了一些开源框架，解决的办法就是修改资源ID的PP段，大体有两种做法：</p>
<ol>
<li><strong>修改aapt源码，定制aapt工具编译期间修改PP段。</strong>
DynamicAPK的做法就是如此，定制aapt，替换google的原始aapt，在编译的时候可以传入参数修改PP段：例如传入0x05编译得到的资源的PP段就是0x05。个人觉得这个做法不是太灵活，入侵了原有的开发编译流程，不好维护。</li>
<li><strong>修改aapt的产物，即，编译后期重新整理插件Apk的资源，编排ID。</strong>
前面说过apk编译之后会生成ID以及对应的索引表resorce.arsc，那么我们能不能后期修改相关ID及索引表呢？答案是肯定的，个人比较赞同这种思路，不用入侵原有编译流程。</li>
</ol>
<p>插件可能是 Apk 也可能是 so 格式，不管哪一种，都不会生成 R.id ，从而没办法使用。这个问题有好几种解决方案。一种是是重写 Context 的 getAsset 、 getResource 之类的方法，偷换概念，让插件读取插件里的资源，但缺点就是宿主和插件的资源 id 会冲突，需要重写 AAPT 。另一种是重写 AMS中保存的插件列表，从而让宿主和插件分别去加载各自的资源而不会冲突。第三种方法，就是打包后，执行一个脚本，修改生成包中资源id。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Android-Apk打包流程&quot;&gt;&lt;a href=&quot;#Android-Apk打包流程&quot; class=&quot;headerlink&quot; title=&quot;Android Apk打包流程&quot;&gt;&lt;/a&gt;Android Apk打包流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;打包资源文件,生成R.j
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(三)基础之反射与代理</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-2/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-2/</id>
    <published>2018-01-12T08:38:36.000Z</published>
    <updated>2018-01-12T12:25:27.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h3><p>反射机制中的类：</p>
<ul>
<li>java.lang.Class;                </li>
<li>java.lang.reflect.Constructor;</li>
<li>java.lang.reflect.Field;</li>
<li>java.lang.reflect.Method;</li>
<li>java.lang.reflect.Modifier;</li>
</ul>
<ol>
<li><p>获取Class的三种方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/第一种方式：  </div><div class="line">Classc1 = Class.forName(&quot;Employee&quot;);  </div><div class="line">//第二种方式：  </div><div class="line">//java中每个类型都有class 属性.  </div><div class="line">Classc2 = Employee.class;  </div><div class="line"></div><div class="line">//第三种方式：  </div><div class="line">//java语言中任何一个java对象都有getClass 方法  </div><div class="line">Employeee = new Employee();  </div><div class="line">Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)</div></pre></td></tr></table></figure>
</li>
<li><p>创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class c =Class.forName(&quot;Employee&quot;);  </div><div class="line"></div><div class="line">//创建此Class 对象所表示的类的一个新实例  </div><div class="line">Objecto = c.newInstance(); //调用了Employee的无参数构造方法.</div></pre></td></tr></table></figure>
</li>
<li><p>获取属性：分为所有的属性和指定的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//获取整个类  </div><div class="line">Class c = Class.forName(&quot;java.lang.Integer&quot;);  </div><div class="line">  //获取所有的属性?  </div><div class="line">Field[] fs = c.getDeclaredFields();  </div><div class="line"></div><div class="line">//定义可变长的字符串，用来存储属性  </div><div class="line">StringBuffer sb = new StringBuffer();  </div><div class="line">//通过追加的方法，将每个属性拼接到此字符串中  </div><div class="line">//最外边的public定义  </div><div class="line">sb.append(Modifier.toString(c.getModifiers()) + &quot; class &quot; + c.getSimpleName() +&quot;&#123;\n&quot;);  </div><div class="line">//里边的每一个属性  </div><div class="line">for(Field field:fs)&#123;  </div><div class="line">    sb.append(&quot;\t&quot;);//空格  </div><div class="line">    sb.append(Modifier.toString(field.getModifiers())+&quot; &quot;);//获得属性的修饰符，例如public，static等等  </div><div class="line">    sb.append(field.getType().getSimpleName() + &quot; &quot;);//属性的类型的名字  </div><div class="line">    sb.append(field.getName()+&quot;;\n&quot;);//属性的名字+回车  </div><div class="line">&#125;  </div><div class="line">sb.append(&quot;&#125;&quot;);  </div><div class="line">System.out.println(sb);  </div><div class="line"></div><div class="line"></div><div class="line">//获取特定属性</div><div class="line">//获取类  </div><div class="line">Class c = Class.forName(&quot;User&quot;);  </div><div class="line">//获取id属性  </div><div class="line">Field idF = c.getDeclaredField(&quot;id&quot;);  </div><div class="line">//实例化这个类赋给o  </div><div class="line">Object o = c.newInstance();  </div><div class="line">//打破封装  </div><div class="line">idF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。  </div><div class="line">//给o对象的id属性赋值&quot;110&quot;  </div><div class="line">idF.set(o, &quot;110&quot;); //set  </div><div class="line">//get  </div><div class="line">System.out.println(idF.get(o));</div></pre></td></tr></table></figure>
</li>
<li><p>关键字</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredMethods()</td>
<td>获取所有的方法</td>
</tr>
<tr>
<td>getReturnType()</td>
<td>获得方法的放回类型</td>
</tr>
<tr>
<td>getParameterTypes()</td>
<td>获得方法的传入参数类型</td>
</tr>
<tr>
<td>getDeclaredMethod(“方法名”,参数类型.class,……)</td>
<td>获得特定的方法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>构造方法关键字</td>
<td>含义</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>获取所有的构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructor(参数类型.class,……)</td>
<td>获取特定的构造方法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>父类和父接口</td>
<td>含义</td>
</tr>
<tr>
<td>getSuperclass()</td>
<td>获取某类的父类</td>
</tr>
<tr>
<td>getInterfaces()</td>
<td>获取某类实现的接口</td>
</tr>
</tbody>
</table>
<h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a>2.代理模式</h3><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。
<img src="http://images.wodekouwei.com/technology/oh3VMNs.gif" alt="image"></p>
<ul>
<li>RealSubject 是原对象（本文把原对象称为”委托对象”），Proxy 是代理对象。</li>
<li>Subject 是委托对象和代理对象都共同实现的接口。</li>
<li>Request() 是委托对象和代理对象共同拥有的方法。</li>
</ul>
<p>Java 实现上面的UML图的代码（即实现静态代理）为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class ProxyDemo &#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        RealSubject subject = new RealSubject();</div><div class="line">        Proxy p = new Proxy(subject);</div><div class="line">        p.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Subject&#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RealSubject implements Subject&#123;</div><div class="line">    public void request()&#123;</div><div class="line">        System.out.println(&quot;request&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Proxy implements Subject&#123;</div><div class="line">    private Subject subject;</div><div class="line">    public Proxy(Subject subject)&#123;</div><div class="line">        this.subject = subject;</div><div class="line">    &#125;</div><div class="line">    public void request()&#123;</div><div class="line">        System.out.println(&quot;PreProcess&quot;);</div><div class="line">        subject.request();</div><div class="line">        System.out.println(&quot;PostProcess&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代理的实现分为：</p>
<ul>
<li>静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。</li>
<li>动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</li>
</ul>
<h4 id="2-1Java-实现动态代理"><a href="#2-1Java-实现动态代理" class="headerlink" title="2.1Java 实现动态代理"></a>2.1Java 实现动态代理</h4><p>首先先说明几个词：</p>
<ul>
<li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例。</li>
<li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li>
</ul>
<p>Java实现动态代理的大致步骤如下：</p>
<ol>
<li>定义一个委托类和公共接口。</li>
<li>自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li>
<li>生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li>
</ol>
<p>Java 实现动态代理主要涉及以下几个类：
<code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 DynamicProxyClass extends Proxy。
<code>java.lang.reflect.InvocationHandler</code>: 这里称他为”调用处理器”，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。</p>
<p>Proxy 类主要方法为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建代理对象  </div><div class="line">static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</div></pre></td></tr></table></figure></p>
<p>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么）。这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用newProxyInstance()时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)</div><div class="line">&#123;</div><div class="line">    //1. 根据类加载器和接口创建代理类</div><div class="line">    Class clazz = Proxy.getProxyClass(loader, interfaces);</div><div class="line">    //2. 获得代理类的带参数的构造函数</div><div class="line">    Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;);</div><div class="line">    //3. 创建代理对象，并制定调用处理器实例为参数传入</div><div class="line">    Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123;handler&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Proxy 类还有一些静态方法，比如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InvocationHandler getInvocationHandler(Object proxy): 获得代理对象对应的调用处理器对象。</div><div class="line">Class getProxyClass(ClassLoader loader, Class[] interfaces): 根据类加载器和实现的接口获得代理类。</div></pre></td></tr></table></figure></p>
<p>Proxy 类中有一个映射表，映射关系为：(<classloader>,(<interfaces>,<proxyclass>) )，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</proxyclass></interfaces></classloader></p>
<p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class DynamicProxyDemo01 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        RealSubject realSubject = new RealSubject();    //1.创建委托对象</div><div class="line">        ProxyHandler handler = new ProxyHandler(realSubject);   //2.创建调用处理器对象</div><div class="line">        Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject.class.getClassLoader(),</div><div class="line">        RealSubject.class.getInterfaces(), handler);    //3.动态生成代理对象</div><div class="line">        proxySubject.request(); //4.通过代理对象调用方法</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 接口</div><div class="line"> */</div><div class="line">interface Subject&#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 委托类</div><div class="line"> */</div><div class="line">class RealSubject implements Subject&#123;</div><div class="line">    public void request()&#123;</div><div class="line">        System.out.println(&quot;====RealSubject Request====&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 代理类的调用处理器</div><div class="line"> */</div><div class="line">class ProxyHandler implements InvocationHandler&#123;</div><div class="line">    private Subject subject;</div><div class="line">    public ProxyHandler(Subject subject)&#123;</div><div class="line">        this.subject = subject;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">            throws Throwable &#123;</div><div class="line">        System.out.println(&quot;====before====&quot;);//定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作</div><div class="line">        Object result = method.invoke(subject, args);</div><div class="line">        System.out.println(&quot;====after====&quot;);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>InvocationHandler 接口中有方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">invoke(Object proxy, Method method, Object[] args)</div></pre></td></tr></table></figure></p>
<p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</p>
<p>动态生成的代理类具有几个特点：</p>
<ul>
<li>继承 Proxy 类，并实现了在Proxy.newProxyInstance()中提供的接口数组。</li>
<li>public final。</li>
<li>命名方式为 $ProxyN，其中N会慢慢增加，一开始是 $Proxy1，接下来是$Proxy2…</li>
<li>有一个参数为 InvocationHandler 的构造函数。这个从 Proxy.newProxyInstance() 函数内部的clazz.getConstructor(new Class[] { InvocationHandler.class }) 可以看出。</li>
</ul>
<p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p>
<blockquote>
<p>不难发现，代理类的实现是有很多共性的（重复代码），动态代理的好处在于避免了这些重复代码，只需要关注操作。</p>
</blockquote>
<h4 id="2-2Java-动态代理的内部实现"><a href="#2-2Java-动态代理的内部实现" class="headerlink" title="2.2Java 动态代理的内部实现"></a>2.2Java 动态代理的内部实现</h4><p>现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 InvocationHandler 的 invoke() 方法的？</p>
<p>这就涉及到动态代理的内部实现。假设有一个接口 Subject，且里面有 int request(int i) 方法，则生成的代理类大致如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final class $Proxy1 extends Proxy implements Subject&#123;</div><div class="line">    private InvocationHandler h;</div><div class="line">    private $Proxy1()&#123;&#125;</div><div class="line">    public $Proxy1(InvocationHandler h)&#123;</div><div class="line">        this.h = h;</div><div class="line">    &#125;</div><div class="line">    public int request(int i)&#123;</div><div class="line">        Method method = Subject.class.getMethod(&quot;request&quot;, new Class[]&#123;int.class&#125;); //创建method对象</div><div class="line">        return (Integer)h.invoke(this, method, new Object[]&#123;new Integer(i)&#125;); //调用了invoke方法</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面的方法就成功调用了 invoke() 方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-反射&quot;&gt;&lt;a href=&quot;#1-反射&quot; class=&quot;headerlink&quot; title=&quot;1.反射&quot;&gt;&lt;/a&gt;1.反射&lt;/h3&gt;&lt;p&gt;反射机制中的类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.lang.Class;                &lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(二)基础之类加载器</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable-1/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable-1/</id>
    <published>2018-01-12T08:35:40.000Z</published>
    <updated>2018-01-12T12:25:31.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是ClassLoader"><a href="#1-什么是ClassLoader" class="headerlink" title="1.什么是ClassLoader"></a>1.什么是ClassLoader</h3><p>当我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。</p>
<h3 id="2-Java-ClassLoader"><a href="#2-Java-ClassLoader" class="headerlink" title="2.Java ClassLoader"></a>2.Java ClassLoader</h3><h4 id="2-1-Java默认提供的三个ClassLoader"><a href="#2-1-Java默认提供的三个ClassLoader" class="headerlink" title="2.1.Java默认提供的三个ClassLoader"></a>2.1.Java默认提供的三个ClassLoader</h4><ol>
<li>BootStrap ClassLoader：
称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();  </div><div class="line">for (int i = 0; i &lt; urls.length; i++) &#123;  </div><div class="line">    System.out.println(urls[i].toExternalForm());  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以下内容是上述程序从本机JDK环境所获得的结果：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/resources.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/rt.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/sunrsasign.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jsse.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jce.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/charsets.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jfr.jar</div><div class="line">file:/Applications/Android%20Studio.app/Contents/jre/jdk/Contents/Home/jre/classes</div></pre></td></tr></table></figure></p>
<p>其实上述结果也是通过查找sun.boot.class.path这个系统属性所得知的。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</div></pre></td></tr></table></figure></p>
<p>打印结果:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/resources.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/rt.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/sunrsasign.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jsse.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jce.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/charsets.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/lib/jfr.jar:/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/jre/classes</div></pre></td></tr></table></figure></p>
<ol>
<li>Extension ClassLoader：
称为扩展类加载器，负责加载Java的扩展类库，默认加载<code>JAVA_HOME/jre/lib/ext/</code>目下的所有jar。</li>
<li>App ClassLoader：
称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</li>
</ol>
<p>除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</p>
<h4 id="2-2ClassLoader加载类的原理"><a href="#2-2ClassLoader加载类的原理" class="headerlink" title="2.2ClassLoader加载类的原理"></a>2.2ClassLoader加载类的原理</h4><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p>
<p>这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p>
<p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。现在通过实例来验证上述所描述的是否正确:</p>
<ol>
<li>在web服务器上建一个org.classloader.simple.NetClassLoaderSimple.java类<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package org.classloader.simple;  </div><div class="line"></div><div class="line">public class NetClassLoaderSimple &#123;  </div><div class="line"></div><div class="line">    private NetClassLoaderSimple instance;  </div><div class="line"></div><div class="line">    public void setNetClassLoaderSimple(Object obj) &#123;  </div><div class="line">        this.instance = (NetClassLoaderSimple)obj;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>org.classloader.simple.NetClassLoaderSimple类的setNetClassLoaderSimple方法接收一个Object类型参数，并将它强制转换成org.classloader.simple.NetClassLoaderSimple类型。</p>
<ol>
<li>测试两个class是否相同
<code>NetWorkClassLoader.java</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">package classloader;</div><div class="line"></div><div class="line">import java.io.ByteArrayOutputStream;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 加载网络class的ClassLoader</div><div class="line"> */</div><div class="line">public class NetworkClassLoader extends ClassLoader &#123;</div><div class="line"></div><div class="line">	private String rootUrl;</div><div class="line"></div><div class="line">	public NetworkClassLoader(String rootUrl) &#123;</div><div class="line">		this.rootUrl = rootUrl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class="line">		Class clazz = null;//this.findLoadedClass(name); // 父类已加载</div><div class="line">		//if (clazz == null) &#123;	//检查该类是否已被加载过</div><div class="line">			byte[] classData = getClassData(name);	//根据类的二进制名称,获得该class文件的字节码数组</div><div class="line">			if (classData == null) &#123;</div><div class="line">				throw new ClassNotFoundException();</div><div class="line">			&#125;</div><div class="line">			clazz = defineClass(name, classData, 0, classData.length);	//将class的字节码数组转换成Class类的实例</div><div class="line">		//&#125;</div><div class="line">		return clazz;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private byte[] getClassData(String name) &#123;</div><div class="line">		InputStream is = null;</div><div class="line">		try &#123;</div><div class="line">			String path = classNameToPath(name);</div><div class="line">			URL url = new URL(path);</div><div class="line">			byte[] buff = new byte[1024*4];</div><div class="line">			int len = -1;</div><div class="line">			is = url.openStream();</div><div class="line">			ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class="line">			while((len = is.read(buff)) != -1) &#123;</div><div class="line">				baos.write(buff,0,len);</div><div class="line">			&#125;</div><div class="line">			return baos.toByteArray();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; finally &#123;</div><div class="line">			if (is != null) &#123;</div><div class="line">			   try &#123;</div><div class="line">			      is.close();</div><div class="line">			   &#125; catch(IOException e) &#123;</div><div class="line">			      e.printStackTrace();</div><div class="line">			   &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private String classNameToPath(String name) &#123;</div><div class="line">		return rootUrl + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package classloader;  </div><div class="line"></div><div class="line">public class NewworkClassLoaderTest &#123;  </div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        try &#123;  </div><div class="line">            //测试加载网络中的class文件  </div><div class="line">            String rootUrl = &quot;http://localhost:8080/httpweb/classes&quot;;  </div><div class="line">            String className = &quot;org.classloader.simple.NetClassLoaderSimple&quot;;  </div><div class="line">            NetworkClassLoader ncl1 = new NetworkClassLoader(rootUrl);  </div><div class="line">            NetworkClassLoader ncl2 = new NetworkClassLoader(rootUrl);  </div><div class="line">            Class&lt;?&gt; clazz1 = ncl1.loadClass(className);  </div><div class="line">            Class&lt;?&gt; clazz2 = ncl2.loadClass(className);  </div><div class="line">            Object obj1 = clazz1.newInstance();  </div><div class="line">            Object obj2 = clazz2.newInstance();  </div><div class="line">            clazz1.getMethod(&quot;setNetClassLoaderSimple&quot;, Object.class).invoke(obj1, obj2);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得网络上一个class文件的二进制名称，然后通过自定义的类加载器NetworkClassLoader创建两个实例，并根据网络地址分别加载这份class，并得到这两个ClassLoader实例加载后生成的Class实例clazz1和clazz2，最后将这两个Class实例分别生成具体的实例对象obj1和obj2，再通过反射调用clazz1中的setNetClassLoaderSimple方法。</p>
<p>结果抛出<code>java.lang.ClassCastgException</code>,虽然是同一份class字节码文件，但是由于被两个不同的ClassLoader实例所加载，所以JVM认为它们就是两个不同的类。</p>
<h4 id="2-3ClassLoader的体系架构："><a href="#2-3ClassLoader的体系架构：" class="headerlink" title="2.3ClassLoader的体系架构："></a>2.3ClassLoader的体系架构：</h4><p><img src="http://images.wodekouwei.com/technology/classloader.gif" alt="iamge"></p>
<p>打印ClassLoader类的层次结构:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ClassLoader loader = ClassLoaderTest.class.getClassLoader();    //获得加载ClassLoaderTest.class这个类的类加载器  </div><div class="line">while(loader != null) &#123;  </div><div class="line">    System.out.println(loader);  </div><div class="line">    loader = loader.getParent();    //获得父类加载器的引用  </div><div class="line">&#125;  </div><div class="line">System.out.println(loader);</div></pre></td></tr></table></figure></p>
<p>输出:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</div><div class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</div><div class="line">null</div></pre></td></tr></table></figure></p>
<p>第一行结果说明：ClassLoaderTest的类加载器是AppClassLoader。</p>
<p>第二行结果说明：AppClassLoader的类加器是ExtClassLoader，即parent=ExtClassLoader。</p>
<p>第三行结果说明：ExtClassLoader的类加器是Bootstrap ClassLoader，因为Bootstrap ClassLoader不是一个普通的Java类，所以ExtClassLoader的parent=null，所以第三行的打印结果为null就是这个原因。</p>
<ul>
<li>将ClassLoaderTest.class打包成ClassLoaderTest.jar，放到Extension ClassLoader的加载目录下（JAVA_HOME/jre/lib/ext）可以测试Extension ClassLoader</li>
<li>在jvm中添加-Xbootclasspath参数，指定Bootstrcp ClassLoader加载类的路径，并追加我们自已的jar（ClassTestLoader.jar）或 将class文件放到JAVA_HOME/jre/classes/目录下测试用Bootstrcp ClassLoader加载ClassLoaderTest.class.</li>
</ul>
<h4 id="2-4定义自己的ClassLoader"><a href="#2-4定义自己的ClassLoader" class="headerlink" title="2.4定义自己的ClassLoader:"></a>2.4定义自己的ClassLoader:</h4><p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</p>
<p><strong>定义自已的类加载器分为两步：</strong></p>
<ol>
<li>继承java.lang.ClassLoader</li>
<li>重写父类的findClass方法</li>
</ol>
<blockquote>
<p>参考:<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="external">深入探讨 Java 类加载器</a></p>
<h3 id="3-Android-ClassLoader"><a href="#3-Android-ClassLoader" class="headerlink" title="3.Android ClassLoader"></a>3.Android ClassLoader</h3><p>Android ClassLoader种类：</p>
<ul>
<li>DexClassLoader：可以加载文件系统上的jar、dex、apk</li>
<li>PathClassLoader：可以加载/data/app目录下的apk，这也意味着，它只能加载已经安装的apk</li>
<li>URLClassLoader：可以加载java中的jar，但是由于dalvik不能直接识别jar，所以此方法在android中无法使用</li>
</ul>
</blockquote>
<p>Android开发和普通的java开发不同的地方是把class文件再重新打包成dex类型的文件，这种重新打包会对Class文件内部的各种函数表、变量表等进行优化。dex文件是一种经过android打包工具优化后的Class文件，因此加载这样特殊的Class文件就需要特殊的类装载器，所以android中提供了DexClassLoader类。加载流程如下：</p>
<ol>
<li>通过PacageMangager获得指定的apk的安装的目录，dex的解压缩目录，c/c++库的目录</li>
<li>创建一个 DexClassLoader实例</li>
<li>加载指定的类返回一个Class</li>
<li>然后使用反射调用这个Class</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-什么是ClassLoader&quot;&gt;&lt;a href=&quot;#1-什么是ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;1.什么是ClassLoader&quot;&gt;&lt;/a&gt;1.什么是ClassLoader&lt;/h3&gt;&lt;p&gt;当我们写好一个Java程序之
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化(一)技术调研</title>
    <link href="http://wodekouwei.com/2018/01/12/tips-android-pluggable/"/>
    <id>http://wodekouwei.com/2018/01/12/tips-android-pluggable/</id>
    <published>2018-01-12T04:21:57.000Z</published>
    <updated>2018-01-13T10:38:31.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有关APK更新的技术比较多，例如：增量更新、插件式开发、热修复、RN、静默安装。
下面简单介绍一下：</p>
<table>
<thead>
<tr>
<th>更新方式</th>
<th>签名</th>
</tr>
</thead>
<tbody>
<tr>
<td>增量更新</td>
<td>旧版本Apk（v1.0）和新（v2.0）、旧版本Apk（v1.0）生成的差分包（apk.patch 质量小）合并成为新版本Apk（v2.0）安装。</td>
</tr>
<tr>
<td>插件式开发</td>
<td>给宿主APK提供插件，扩展（需要的时候再下载），可以动态地替换。主要技术是动态代理的知识。</td>
</tr>
<tr>
<td>热修复</td>
<td>通过NDK底层去修复，也是C/C++的技术。</td>
</tr>
<tr>
<td>RN</td>
<td>通过JS脚本去修复APK。</td>
</tr>
<tr>
<td>静默安装</td>
<td>需要root权限，适配不同手机ROM很麻烦。</td>
</tr>
</tbody>
</table>
<p>插件化、热修复（思想）的发展历程</p>
<ul>
<li>2012年7月，AndroidDynamicLoader，大众点评，陶毅敏：思想是通过Fragment以及schema的方式实现的，这是一种可行的技术方案，但是还有限制太多，这意味这你的activity必须通过Fragment去实现，这在activity跳转和灵活性上有一定的不便，在实际的使用中会有一些很奇怪的bug不好解决，总之，这还是一种不是特别完备的动态加载技术。</li>
<li>2013年，23Code，自定义控件的动态下载：主要利用 Java ClassLoader 的原理，可动态加载的内容包括 apk、dex、jar等。</li>
<li>2014年初，Altas，阿里伯奎的技术分享：提出了插件化的思想以及一些思考的问题，相关资料比较少。</li>
<li>2014年底，Dynamic-load-apk，任玉刚：动态加载APK，通过Activity代理的方式给插件Activity添加生命周期。</li>
<li>2015年4月，OpenAltas/ACCD：Altas的开源项目，一款强大的Android非代理动态部署框架，目前已经处于稳定状态。</li>
<li>2015年8月，DroidPlugin，360的张勇：DroidPlugin 是360手机助手在 Android 系统上实现了一种新的插件机制：通过Hook思想来实现，它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。</li>
<li>2015年9月，AndFix，阿里：通过NDK的Hook来实现热修复。</li>
<li>2015年11月，Nuwa，大众点评：通过dex分包方案实现热修复。</li>
<li>2015年底，Small，林光亮：打通了宿主与插件之间的资源与代码共享。</li>
<li>2016年4月，ZeusPlugin，掌阅：ZeusPlugin最大特点是：简单易懂，核心类只有6个，类总数只有13个。</li>
</ul>
<h3 id="1-增量更新"><a href="#1-增量更新" class="headerlink" title="1.增量更新"></a>1.增量更新</h3><p>增量更新就是原有app的基础上只更新发生变化的地方，其余保持原样。
与原来每次更新都要下载完整apk包的做法相比，这样做的好处显而易见：每次变化的地方总是比较少，因此更新包的体积就会小很多。</p>
<h4 id="1-1增量更新的流程"><a href="#1-1增量更新的流程" class="headerlink" title="1.1增量更新的流程"></a>1.1增量更新的流程</h4><ol>
<li>APP检测最新版本：把当前版本告诉服务端，服务端进行判断。
如果有新版本，服务端需要对当前版本的APK与最新版本的APK进行一次差分，产生patch差分文件。（或者新版本的APK上传到服务端的时候就已经差分好了）</li>
<li>APP在后台下载差分文件，进行文件的MD5校验，在本地进行合并（跟本地的data目录下面的APK文件合并），合并出最新的APK之后，提示用户安装。</li>
<li>增量更新的最终目的：省流量地更新宿主APK。</li>
</ol>
<p>差分的处理比较麻烦的地方就是要针对不同的应用市场渠道和众多不同版本进行差分。
注意：新版本有可能比旧版本小，差分只是把变化的部分记录下来。</p>
<h4 id="1-2服务器端行为（后台工程师操作）"><a href="#1-2服务器端行为（后台工程师操作）" class="headerlink" title="1.2服务器端行为（后台工程师操作）"></a>1.2服务器端行为（后台工程师操作）</h4><h5 id="1-2-1下载拆分和合并要用的第三方库（bsdiff、bzip2）"><a href="#1-2-1下载拆分和合并要用的第三方库（bsdiff、bzip2）" class="headerlink" title="1.2.1下载拆分和合并要用的第三方库（bsdiff、bzip2）"></a>1.2.1下载拆分和合并要用的第三方库（bsdiff、bzip2）</h5><p>我们使用到的第三方库是：Binary diff，简称bsdiff，这个库专门用来实现文件的差分和合并的，它的官网如下：<a href="http://www.daemonology.net/bsdiff/" target="_blank" rel="external">http://www.daemonology.net/bsdiff/</a></p>
<h5 id="1-2-2Java代码调用"><a href="#1-2-2Java代码调用" class="headerlink" title="1.2.2Java代码调用:"></a>1.2.2Java代码调用:</h5><p>创建Web项目，用来做APP的服务端。创建工具类专门用于产生差分包：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class BsDiff &#123;</div><div class="line">    /**</div><div class="line">     * 差分</div><div class="line">     * @param oldfile</div><div class="line">     * @param newfile</div><div class="line">     * @param patchfile</div><div class="line">     */</div><div class="line">    public native static void diff(String oldfile,String newfile,String patchfile);</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.loadLibrary(&quot;bsdiff&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中JNI的实现如下（该实现写在bsdiff.cpp中）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT void JNICALL Java_com_haocai_bsdiff_BsDiff_diff</div><div class="line">(JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr) &#123;</div><div class="line">    int argc = 4;</div><div class="line">    char* oldfile = (char*)env-&gt;GetStringUTFChars(oldfile_jstr, NULL);</div><div class="line">    char* newfile = (char*)env-&gt;GetStringUTFChars(newfile_jstr, NULL);</div><div class="line">    char* patchfile = (char*)env-&gt;GetStringUTFChars(patchfile_jstr, NULL);</div><div class="line"></div><div class="line">    //参数(第一个参数无效)</div><div class="line">    char *argv[4];</div><div class="line">    argv[0] = &#123; &quot;bsdiff&quot; &#125;;</div><div class="line">    argv[1] = oldfile;</div><div class="line">    argv[2] = newfile;</div><div class="line">    argv[3] = patchfile;</div><div class="line"></div><div class="line">    bsdiff_main(argc, argv);</div><div class="line"></div><div class="line">    env-&gt;ReleaseStringUTFChars(oldfile_jstr, oldfile);</div><div class="line">    env-&gt;ReleaseStringUTFChars(newfile_jstr, newfile);</div><div class="line">    env-&gt;ReleaseStringUTFChars(patchfile_jstr, patchfile);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过研究bsdiff的源码，我们发现bsdiff.cpp里面的main函数就是入口函数，避免歧义把函数名main改为bsdiff_main，然后通过JNI去调用。根据bsdiff.cpp中bsdiff_main函数方法中有以下关键语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (argc != 4) errx(1, &quot;usage: %s oldfile newfile patchfile\n&quot;, argv[0]);</div></pre></td></tr></table></figure></p>
<p>根据提示需要传入4个参数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">argv[0] = &quot;bsdiff&quot;;//这个参数没用</div><div class="line">argv[1] = oldPath;//旧APK文件路径</div><div class="line">argv[2] = newPath;/新APK文件路径</div><div class="line">argv[3] = patchPath;//APK差分文件路径</div></pre></td></tr></table></figure></p>
<p>然后我们准备两个APK文件，不同版本的，最好Java代码、资源都不一样。</p>
<p>写一个Java测试类生成差分包：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.haocai.bsdiff;</div><div class="line"></div><div class="line">public class ConstantsWin &#123;</div><div class="line"></div><div class="line">    //路径不能包含中文</div><div class="line">    public static final String OLD_APK_PATH = &quot;D:/android_apks/test_old.apk&quot;;</div><div class="line"></div><div class="line">    public static final String NEW_APK_PATH = &quot;D:/android_apks/test_new.apk&quot;;</div><div class="line"></div><div class="line">    public static final String PATCH_PATH = &quot;D:/android_apks/apk.patch&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.haocai.bsdiff;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Administrator on 2017/11/14.</div><div class="line"> */</div><div class="line">public class BsDiffTest &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //得到差分包</div><div class="line">        BsDiff.diff(ConstantsWin.OLD_APK_PATH,ConstantsWin.NEW_APK_PATH,ConstantsWin.PATCH_PATH);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>test_new.apk、test_old.apk 要先放在目标目录</li>
<li>bsdiff.cpp中生成差分包的程序方法是异步的，所以生成完整的apk.patch可能要等一下。apk.patch体积大小停止增长，表示生成结束。<h5 id="1-2-3简单搭建后台JavaWeb供Android前端下载apk-patch差分包"><a href="#1-2-3简单搭建后台JavaWeb供Android前端下载apk-patch差分包" class="headerlink" title="1.2.3简单搭建后台JavaWeb供Android前端下载apk.patch差分包"></a>1.2.3简单搭建后台JavaWeb供Android前端下载apk.patch差分包</h5></li>
</ul>
<h4 id="1-3Android客户端行为"><a href="#1-3Android客户端行为" class="headerlink" title="1.3Android客户端行为"></a>1.3Android客户端行为</h4><h5 id="1-3-1编译合并要用的第三方库（bsdiff、bzip2）"><a href="#1-3-1编译合并要用的第三方库（bsdiff、bzip2）" class="headerlink" title="1.3.1编译合并要用的第三方库（bsdiff、bzip2）"></a>1.3.1编译合并要用的第三方库（bsdiff、bzip2）</h5><p>对应的Java代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.haocai.app.update;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Xionghu on 2017/11/14.</div><div class="line"> * Desc:</div><div class="line"> */</div><div class="line"></div><div class="line">public class BsPatch &#123;</div><div class="line">    /**</div><div class="line">     * 合并</div><div class="line">     * @param oldfile</div><div class="line">     * @param newfile</div><div class="line">     * @param patchfile</div><div class="line">     */</div><div class="line">    public native static void patch(String oldfile,String newfile,String patchfile);</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.loadLibrary(&quot;bspatch&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Android端，我们需要把bzip2以及bsdiff的文件拷贝到jni目录里面，同样的，我们只需要编译一个bspatch.c源文件即可。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//合并</div><div class="line">JNIEXPORT void JNICALL Java_com_haocai_app_update_BsPatch_patch</div><div class="line">  (JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr)&#123;</div><div class="line">    int argc = 4;</div><div class="line">    char* oldfile = (char*)(*env)-&gt;GetStringUTFChars(env,oldfile_jstr, NULL);</div><div class="line">    char* newfile = (char*)(*env)-&gt;GetStringUTFChars(env,newfile_jstr, NULL);</div><div class="line">    char* patchfile = (char*)(*env)-&gt;GetStringUTFChars(env,patchfile_jstr, NULL);</div><div class="line"></div><div class="line">    //参数（第一个参数无效）</div><div class="line">    char *argv[4];</div><div class="line">    argv[0] = &quot;bspatch&quot;;</div><div class="line">    argv[1] = oldfile;</div><div class="line">    argv[2] = newfile;</div><div class="line">    argv[3] = patchfile;</div><div class="line"></div><div class="line">    bspatch_main(argc,argv);</div><div class="line"></div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,oldfile_jstr, oldfile);</div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,newfile_jstr, newfile);</div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env,patchfile_jstr, patchfile);</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>代码v1.0差分包合并核心代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">package com.haocai.app.update;</div><div class="line"></div><div class="line">import android.Manifest;</div><div class="line">import android.content.pm.PackageManager;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Message;</div><div class="line">import android.support.annotation.NonNull;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.support.v4.app.ActivityCompat;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.text.format.Formatter;</div><div class="line">import android.widget.Toast;</div><div class="line">import com.lzy.okgo.OkGo;</div><div class="line">import com.lzy.okgo.callback.FileCallback;</div><div class="line">import com.lzy.okgo.model.Progress;</div><div class="line">import com.lzy.okgo.model.Response;</div><div class="line">import com.lzy.okgo.request.base.Request;</div><div class="line">import java.io.File;</div><div class="line">import java.text.NumberFormat;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final int REQUEST_PERMISSION_STORAGE = 0x01;</div><div class="line">    private Handler mHandler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            super.handleMessage(msg);</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case 0:</div><div class="line">                    Toast.makeText(MainActivity.this, &quot;您正在进行省流量更新&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    ApkUtils.installApk(MainActivity.this, Constants.NEW_APK_PATH);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    private NumberFormat numberFormat;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        setTitle(&quot;简单文件下载&quot;);</div><div class="line"></div><div class="line">        numberFormat = NumberFormat.getPercentInstance();</div><div class="line">        numberFormat.setMinimumFractionDigits(2);</div><div class="line"></div><div class="line">        checkSDCardPermission();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 因为后台没有写版本判断语句</div><div class="line">         * 在高版本下暂时先注释fileDownload(); 否则一直下载安装</div><div class="line">         *</div><div class="line">         * 低版本下运行fileDownload();</div><div class="line">         */</div><div class="line">         fileDownload();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 检查SD卡权限</div><div class="line">     */</div><div class="line">    protected void checkSDCardPermission() &#123;</div><div class="line">        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_PERMISSION_STORAGE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">        if (requestCode == REQUEST_PERMISSION_STORAGE) &#123;</div><div class="line">            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">                //获取权限</div><div class="line">                fileDownload();</div><div class="line">            &#125; else &#123;</div><div class="line">                Toast.makeText(getApplicationContext(), &quot;权限被禁止，无法下载文件！&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        //Activity销毁时，取消网络请求</div><div class="line">        OkGo.getInstance().cancelTag(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void fileDownload() &#123;</div><div class="line"></div><div class="line">        OkGo.&lt;File&gt;get(Constants.URL_PATCH_DOWNLOAD)//</div><div class="line">                .tag(this)//</div><div class="line">                .execute(new FileCallback(Constants.SD_CARD, Constants.PATCH_FILE) &#123;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onStart(Request&lt;File, ? extends Request&gt; request) &#123;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onSuccess(Response&lt;File&gt; response) &#123;</div><div class="line"></div><div class="line">                        new Thread(new Runnable() &#123;</div><div class="line">                            @Override</div><div class="line">                            public void run() &#123;</div><div class="line"></div><div class="line">                                try &#123;</div><div class="line">                                    //      File patchFile = new File(Constants.SD_CARD, Constants.PATCH_FILE);</div><div class="line">                                    String oldfile = ApkUtils.getSourceApkPath(MainActivity.this, getPackageName());</div><div class="line">                                    String newfile = Constants.NEW_APK_PATH;</div><div class="line">                                    String patchfile = Constants.SD_CARD + File.separator + Constants.PATCH_FILE;</div><div class="line">                                    BsPatch.patch(oldfile, newfile, patchfile);</div><div class="line"></div><div class="line">                                    mHandler.sendEmptyMessage(0);</div><div class="line">                                &#125; catch (Exception e) &#123;</div><div class="line">                                    e.printStackTrace();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;).start();</div><div class="line"></div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Response&lt;File&gt; response) &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void downloadProgress(Progress progress) &#123;</div><div class="line">                        System.out.println(progress);</div><div class="line"></div><div class="line">                        String downloadLength = Formatter.formatFileSize(getApplicationContext(), progress.currentSize);</div><div class="line">                        String totalLength = Formatter.formatFileSize(getApplicationContext(), progress.totalSize);</div><div class="line">                        String speed = Formatter.formatFileSize(getApplicationContext(), progress.speed);</div><div class="line">                        System.out.println(downloadLength);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：这里7.0可能会有问题，把路径暴露给别的app，需要FileProvider去实现（不难，这个留给大家去做吧）。</p>
<blockquote>
<p><a href="https://github.com/kpioneer123/DiffInstallApp" target="_blank" rel="external">源码下载</a>
作者: <a href="http://www.jianshu.com/p/4c80d732e7c3" target="_blank" rel="external">(简书)香沙小熊</a></p>
</blockquote>
<h3 id="2-插件化"><a href="#2-插件化" class="headerlink" title="2.插件化"></a>2.插件化</h3><p>插件化框架的一些对比，下面引用
<a href="https://github.com/wequick/Small/blob/master/Android/COMPARISION.md" target="_blank" rel="external">https://github.com/wequick/Small/blob/master/Android/COMPARISION.md</a></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>DynamicLoadApk</th>
<th>DynamicAPK</th>
<th>Small</th>
<th>DroidPlugin</th>
<th>VirtualAPK</th>
<th>RePlugin</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持四大组件</td>
<td>只支持Activity</td>
<td>只支持Activity</td>
<td>只支持Activity</td>
<td>全支持</td>
<td>全支持</td>
<td>全支持</td>
</tr>
<tr>
<td>组件无需在宿主manifest中预注册</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>插件可以依赖宿主</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>支持PendingIntent</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Android特性支持</td>
<td>大部分</td>
<td>大部分</td>
<td>大部分</td>
<td>几乎全部</td>
<td>几乎全部</td>
<td>几乎全部</td>
</tr>
<tr>
<td>兼容性适配</td>
<td>一般</td>
<td>一般</td>
<td>中等</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>插件构建</td>
<td>无</td>
<td>部署aapt</td>
<td>Gradle插件</td>
<td>无</td>
<td>Gradle插件</td>
<td>Gradle插件</td>
</tr>
<tr>
<td>源码</td>
<td><code>https://github.com/singwhatiwanna/dynamic-load-apk</code></td>
<td><code>https://github.com/CtripMobile/DynamicAPK</code></td>
<td><a href="https://github.com/wequick/Small" target="_blank" rel="external">https://github.com/wequick/Small</a></td>
<td><code>https://github.com/DroidPluginTeam/DroidPlugin</code></td>
<td><code>https://github.com/didi/VirtualAPK</code></td>
<td><code>https://github.com/Qihoo360/RePlugin</code></td>
</tr>
<tr>
<td>开发者</td>
<td>singwhatiwanna</td>
<td>CtripMobile</td>
<td></td>
<td>Lody</td>
<td>滴滴</td>
<td>360</td>
</tr>
</tbody>
</table>
<h4 id="2-1DynamicLoadApk"><a href="#2-1DynamicLoadApk" class="headerlink" title="2.1DynamicLoadApk"></a>2.1DynamicLoadApk</h4><p>基于静态代理的实现</p>
<h4 id="2-2VirtualAPK"><a href="#2-2VirtualAPK" class="headerlink" title="2.2VirtualAPK"></a>2.2VirtualAPK</h4><h5 id="2-2-1特性"><a href="#2-2-1特性" class="headerlink" title="2.2.1特性"></a>2.2.1特性</h5><table>
<thead>
<tr>
<th>Feature</th>
<th>Detail</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supported components</td>
<td>Activity, Service, Receiver and Provider</td>
</tr>
<tr>
<td>Manually register components in AndroidManifest.xml</td>
<td>No need</td>
</tr>
<tr>
<td>Access host app classes and resources</td>
<td>Supported</td>
</tr>
<tr>
<td>PendingIntent</td>
<td>Supported</td>
</tr>
<tr>
<td>Supported Android features</td>
<td>Almost all features</td>
</tr>
<tr>
<td>Compatibility</td>
<td>Almost all devices</td>
</tr>
<tr>
<td>Building system</td>
<td>Gradle plugin</td>
</tr>
<tr>
<td>Supported Android versions</td>
<td>API Level 15+</td>
</tr>
</tbody>
</table>
<h5 id="2-2-2架构"><a href="#2-2-2架构" class="headerlink" title="2.2.2架构"></a>2.2.2架构</h5><p><img src="http://images.wodekouwei.com/technology/virtualapk_arch.png" alt="image"></p>
<h5 id="2-2-3原理"><a href="#2-2-3原理" class="headerlink" title="2.2.3原理"></a>2.2.3原理</h5><h6 id="2-2-3-1基本原理"><a href="#2-2-3-1基本原理" class="headerlink" title="2.2.3.1基本原理"></a>2.2.3.1基本原理</h6><ul>
<li>合并宿主和插件的ClassLoader 需要注意的是，插件中的类不可以和宿主重复</li>
<li>合并插件和宿主的资源 重设插件资源的packageId，将插件资源和宿主资源合并</li>
<li>去除插件包对宿主的引用 构建时通过Gradle插件去除插件对宿主的代码以及资源的引用<h5 id="2-2-3-2四大组件的实现原理"><a href="#2-2-3-2四大组件的实现原理" class="headerlink" title="2.2.3.2四大组件的实现原理"></a>2.2.3.2四大组件的实现原理</h5></li>
<li>Activity 采用宿主manifest中占坑的方式来绕过系统校验，然后再加载真正的activity；</li>
<li>Service 动态代理AMS，拦截service相关的请求，将其中转给Service Runtime去处理，Service Runtime会接管系统的所有操作；</li>
<li>Receiver 将插件中静态注册的receiver重新注册一遍；</li>
<li>ContentProvider 动态代理IContentProvider，拦截provider相关的请求，将其中转给Provider Runtime去处理，Provider Runtime会接管系统的所有操作。</li>
</ul>
<h4 id="2-3RePlugin"><a href="#2-3RePlugin" class="headerlink" title="2.3RePlugin"></a>2.3RePlugin</h4><h5 id="2-3-1特性"><a href="#2-3-1特性" class="headerlink" title="2.3.1特性"></a>2.3.1特性</h5><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>组件</td>
<td>四大组件（含静态Receiver）</td>
</tr>
<tr>
<td>升级无需改主程序Manifest</td>
<td>完美支持</td>
</tr>
<tr>
<td>Android特性</td>
<td>支持近乎所有（包括SO库等）</td>
</tr>
<tr>
<td>TaskAffinity &amp; 多进程</td>
<td>支持（坑位方案）</td>
</tr>
<tr>
<td>插件类型</td>
<td>支持自带插件（自识别）、外置插件</td>
</tr>
<tr>
<td>插件间耦合</td>
<td>支持Binder、Class Loader、资源等</td>
</tr>
<tr>
<td>进程间通讯</td>
<td>支持同步、异步、Binder、广播等</td>
</tr>
<tr>
<td>自定义Theme &amp; AppComat</td>
<td>支持</td>
</tr>
<tr>
<td>DataBinding</td>
<td>支持</td>
</tr>
<tr>
<td>安全校验</td>
<td>支持</td>
</tr>
<tr>
<td>资源方案</td>
<td>独立资源 + Context传递（相对稳定）</td>
</tr>
<tr>
<td>Android 版本</td>
<td>API Level 9+ （2.3及以上）</td>
</tr>
</tbody>
</table>
<h5 id="2-3-2架构"><a href="#2-3-2架构" class="headerlink" title="2.3.2架构"></a>2.3.2架构</h5><p><img src="http://images.wodekouwei.com/technology/RePluginFramePic.jpeg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;有关APK更新的技术比较多，例如：增量更新、插件式开发、热修复、RN、静默安装。
下面简单介绍一下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="Pluggable" scheme="http://wodekouwei.com/tags/Pluggable/"/>
    
  </entry>
  
  <entry>
    <title>(转)聊一聊机器学习的MLE和MAP:最大似然估计和最大后验估计</title>
    <link href="http://wodekouwei.com/2018/01/08/tips-ml-mle-map/"/>
    <id>http://wodekouwei.com/2018/01/08/tips-ml-mle-map/</id>
    <published>2018-01-08T09:36:01.000Z</published>
    <updated>2018-01-08T10:15:40.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TLDR-or-the-take-away"><a href="#TLDR-or-the-take-away" class="headerlink" title="TLDR (or the take away)"></a>TLDR (or the take away)</h3><ul>
<li>概率学派 - Frequentist - Maximum Likelihood Estimation(MLE,最大似然估计)</li>
<li>贝叶斯学派 - Baysesian - Maximum A Posteriori(MAP, 最大后验估计)</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>有时候和别人聊天，对方会说自己有很多机器学习经验，深入一聊发现，对方竟然对MLE和MAP一知半解，至少在我看来，这位同学的机器学习基础并不扎实。难道在这个深度学习盛行的年代，不少同学都只注重调参数？</p>
<p>现代机器学习的终极问题都会转化为解目标函数的优化问题，MLE和MAP是生成这个函数的很基本的思想，因此我们对二者的认知是非常重要的。这次就和大家认真聊一聊MLE和MAP这两种estimator。</p>
<h3 id="两大学派的争论"><a href="#两大学派的争论" class="headerlink" title="两大学派的争论"></a>两大学派的争论</h3><p>抽象一点来讲，频率学派和贝叶斯学派对世界的认知有本质不同：频率学派认为世界是确定的，有一个本体，这个本体的真值是不变的，我们的目标就是要找到这个真值或真值所在的范围；而贝叶斯学派认为世界是不确定的，人们对世界先有一个预判，而后通过观测数据对这个预判做调整，我们的目标是要找到最优的描述这个世界的概率分布。</p>
<p>在对事物建模时，用 θ  表示模型的参数，请注意，解决问题的本质就是求θ 。那么：
<strong>(1) 频率学派：</strong> 存在唯一真值 θ  。举一个简单直观的例子–抛硬币，我们用 P(head) 来表示硬币的bias。抛一枚硬币100次，有20次正面朝上，要估计抛硬币正面朝上的bias P(head)=θ。在频率学派来看，θ = 20 / 100 = 0.2，很直观。当数据量趋于无穷时，这种方法能给出精准的估计；然而缺乏数据时则可能产生严重的偏差。例如，对于一枚均匀硬币，即 θ = 0.5，抛掷5次，出现5次正面 (这种情况出现的概率是1/2^5=3.125%)，频率学派会直接估计这枚硬币 θ = 1，出现严重错误。</p>
<p><strong>(2) 贝叶斯学派：</strong> θ 是一个随机变量，符合一定的概率分布。在贝叶斯学派里有两大输入和一大输出，输入是先验 (prior)和似然 (likelihood)，输出是后验 (posterior)。先验，即 P(θ) ，指的是在没有观测到任何数据时对 θ 的预先判断，例如给我一个硬币，一种可行的先验是认为这个硬币有很大的概率是均匀的，有较小的概率是是不均匀的；似然，即 P(X|θ) ，是假设 θ 已知后我们观察到的数据应该是什么样子的；后验，即 P(θ|X) ，是最终的参数分布。贝叶斯估计的基础是贝叶斯公式，如下：</p>
<p>$P(\theta|X)=\frac{P(X|\theta) \times P(\theta)}{P(X)}$</p>
<p>同样是抛硬币的例子，对一枚均匀硬币抛5次得到5次正面，那么 P(head) ，即 P(θ|X) ，是一个distribution，最大值会介于0.5~1之间，而不是武断的 θ = 1。</p>
<p>这里有两点值得注意的地方：</p>
<p>随着数据量的增加，参数分布会越来越向数据靠拢，先验的影响力会越来越小
如果先验是uniform distribution，则贝叶斯方法等价于频率方法。因为直观上来讲，先验是uniform distribution本质上表示对事物没有任何预判</p>
<h3 id="MLE-最大似然估计"><a href="#MLE-最大似然估计" class="headerlink" title="MLE - 最大似然估计"></a>MLE - 最大似然估计</h3><p>Maximum Likelihood Estimation, MLE是频率学派常用的估计方法！</p>
<p>假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。其中i.i.d.表示Independent and identical distribution，独立同分布。那么MLE对 $\theta$ 的估计方法可以如下推导：</p>
<p>Maximum Likelihood Estimation, MLE是频率学派常用的估计方法！</p>
<p>假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。其中i.i.d.表示Independent and identical distribution，独立同分布。那么MLE对 $\theta$ 的估计方法可以如下推导：</p>
<p>最后这一行所优化的函数被称为Negative Log Likelihood (NLL)，这个概念和上面的推导是非常重要的！</p>
<p>我们经常在不经意间使用MLE，例如</p>
<ul>
<li>上文中关于频率学派求硬币概率的例子，其方法其实本质是由优化NLL得出。本文末尾附录中给出了具体的原因 :-)</li>
<li>给定一些数据，求对应的高斯分布时，我们经常会算这些数据点的均值和方差然后带入到高斯分布的公式，其理论依据是优化NLL</li>
<li>深度学习做分类任务时所用的cross entropy loss，其本质也是MLE</li>
</ul>
<h3 id="MAP-最大后验估计"><a href="#MAP-最大后验估计" class="headerlink" title="MAP - 最大后验估计"></a>MAP - 最大后验估计</h3><p>Maximum A Posteriori, MAP是贝叶斯学派常用的估计方法！</p>
<p>同样的，假设数据 x_1, x_2, …, x_n  是i.i.d.的一组抽样，X = (x_1, x_2, …, x_n) 。那么MLE对 $\theta$ 的估计方法可以如下推导：
其中，第二行到第三行使用了贝叶斯定理，第三行到第四行P(X) 可以丢掉因为与 $\theta$ 无关。注意 $-\log P(X|\theta )$ 其实就是NLL，所以MLE和MAP在优化时的不同就是在于先验项 - $\log P(\theta) $。好的，那现在我们来研究一下这个先验项，假定先验是一个高斯分布，即</p>
<p>$P(\theta) = \text{constant} \times e^{-\frac{\theta^2}{2\sigma^2}}$</p>
<p>那么， $-\log P(\theta) = \text{constant} + \frac{\theta^2}{2\sigma^2} $。至此，一件神奇的事情发生了 – 在MAP中使用一个高斯分布的先验等价于在MLE中采用L2的regularizaton！</p>
<p>再稍微补充几点：</p>
<ul>
<li>我们不少同学大学里学习概率论时，最主要的还是频率学派的思想，其实贝叶斯学派思想也非常流行，而且实战性很强</li>
<li>CMU的很多老师都喜欢用贝叶斯思想解决问题；我本科时的导师朱军老师也在做<a href="https://arxiv.org/abs/1709.05870" target="_blank" rel="external">贝叶斯深度学习</a>的工作，有兴趣可以关注一下。</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>有的同学说：“了解这些没用，现在大家都不用了。”这种想法是不对的，因为这是大家常年在用的知识，是推导优化函数的核心，而优化函数又是机器学习 (包含深度学习) 的核心之一。这位同学有这样的看法，说明对机器学习的本质并没有足够的认识，而让我吃惊的是，竟然有不少其他同学为这种看法点赞。内心感到有点儿悲凉，也引发了我写这篇文章的动力，希望能帮到一些朋友 :-)</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>[1] <a href="http://link.zhihu.com/?target=http%3A//www.utdallas.edu/%7Enrr150130/cs7301/2016fa/lects/Lecture_14_Bayes.pdf" target="_blank" rel="external">Bayesian Method Lecture</a>, UT Dallas.</p>
</li>
<li><p>[2] <a href="http://link.zhihu.com/?target=http%3A//www.utdallas.edu/%7Enrr150130/cs7301/2016fa/lects/Lecture_14_Bayes.pdf" target="_blank" rel="external">MLE, MAP, Bayes classification Lecture</a>, CMU.</p>
</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>为什么说频率学派求硬币概率的算法本质是在优化NLL？</p>
<p>因为抛硬币可以表示为参数为 $\theta$  的Bernoulli分布，即</p>
<p>$P(x_i; \theta) =\left{ \begin{array}{ll} \theta &amp; x_i = 1 \ 1 - \theta &amp; x_i = 0 \ \end{array} \right. \ = \theta^{x_i} (1- \theta)^{1-x_i}$</p>
<p>其中 x_i = 1 表示第 i 次抛出正面。那么，</p>
<p>$\text{NLL} = -\sum_{i=1}^n \log P(x<em>i; \theta) = -\sum</em>{i=1}^n \log \theta^{x_i} (1- \theta)^{1-x_i}$</p>
<p>求导数并使其等于零，得到</p>
<p>$\text{NLL}’ = -\sum_{i=1}^n\Big(\frac{x_i}{\theta} + (1-x_i)\frac{-1}{1-\theta}\Big) = 0$</p>
<p>即 $\hat{\theta} = \frac{\sum_{i=1}^n x_i}{n}$ ，也就是出现正面的次数除以总共的抛掷次数。</p>
<blockquote>
<p>转自<a href="https://zhuanlan.zhihu.com/p/32480810" target="_blank" rel="external">聊一聊机器学习的MLE和MAP：最大似然估计和最大后验估计</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TLDR-or-the-take-away&quot;&gt;&lt;a href=&quot;#TLDR-or-the-take-away&quot; class=&quot;headerlink&quot; title=&quot;TLDR (or the take away)&quot;&gt;&lt;/a&gt;TLDR (or the take awa
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
      <category term="reprint" scheme="http://wodekouwei.com/tags/reprint/"/>
    
  </entry>
  
  <entry>
    <title>机器学习资源</title>
    <link href="http://wodekouwei.com/2017/12/29/tips-ml-res/"/>
    <id>http://wodekouwei.com/2017/12/29/tips-ml-res/</id>
    <published>2017-12-29T01:59:09.000Z</published>
    <updated>2018-01-30T07:04:29.686Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/andabi/deep-voice-conversion" target="_blank" rel="external">deep-voice-conversion</a>:Deep neural networks for voice conversion (voice style transfer) in Tensorflow</p>
<p><a href="https://prismalabs.ai/" target="_blank" rel="external">Prisma</a></p>
<p><a href="https://techcrunch.com/2017/08/19/prisma-shifts-focus-to-b2b-with-an-api-for-ai-powered-mobile-effects/" target="_blank" rel="external">Prisma shifts focus to b2b with an API for AI-powered mobile effects</a></p>
<p><a href="http://techcrunch.cn/2017/07/11/prismas-next-ai-project-is-a-fun-selfie-sticker-maker-called-sticky/" target="_blank" rel="external">Prisma 团队推出基于人工智能的贴纸制作应用 Sticky</a></p>
<p><a href="https://techcrunch.com/2016/12/20/prisma-launches-a-social-feed-to-see-if-style-can-transfer-into-a-platform/" target="_blank" rel="external">Prisma launches a social feed to see if style can transfer into a platform</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/andabi/deep-voice-conversion&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;deep-voice-conversion&lt;/a&gt;:Deep neural networks f
    
    </summary>
    
      <category term="ml" scheme="http://wodekouwei.com/categories/ml/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
      <category term="ml" scheme="http://wodekouwei.com/tags/ml/"/>
    
      <category term="res" scheme="http://wodekouwei.com/tags/res/"/>
    
  </entry>
  
  <entry>
    <title>FLV格式解析</title>
    <link href="http://wodekouwei.com/2017/12/20/m-f-flv/"/>
    <id>http://wodekouwei.com/2017/12/20/m-f-flv/</id>
    <published>2017-12-20T06:49:06.000Z</published>
    <updated>2018-01-08T11:37:26.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流的视频网站无一例外地使用了FLV格式。另外由于当前浏览器与Flash Player紧密的结合，使得网页播放FLV视频轻而易举，也是FLV流行的原因之一。</p>
<p>FLV是流媒体封装格式，我们可以将其数据看为二进制字节流。总体上看，FLV包括文件头（File Header）和文件体（File Body）两部分，其中文件体由一系列的Tag及Tag Size对组成。
<img src="http://images.wodekouwei.com/M/F/flv-struct.jpg" alt="flv-struct"></p>
<h3 id="FLV格式解析"><a href="#FLV格式解析" class="headerlink" title="FLV格式解析"></a>FLV格式解析</h3><p>先来一张图，这是《科比退役演讲》下载）的一个FLV视频。我使用的是UltraEdit的二进制查看工具。
<img src="http://images.wodekouwei.com/M/F/flv1.png" alt="flv-head"></p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>头部分由一下几部分组成
Signature(3 Byte)+Version(1 Byte)+Flags(1 Bypte)+DataOffset(4 Byte)</p>
<ul>
<li>signature 占3个字节 固定FLV三个字符作为标示。一般发现前三个字符为FLV时就认为他是flv文件。图中0x46 0x4C 0x56,代表FLV</li>
<li>Version 占1个字节 标示FLV的版本号。这里我们看到是1</li>
<li>Flags 占1个字节 内容标示。第0位和第2位,分别表示 video 与 audio 存在的情况.(1表示存在,0表示不存在)。截图看到是0x05，也就是00000101，代表既有视频，也有音频。</li>
<li>DataOffset 4个字节 表示FLV的header长度。这里可以看到固定是9</li>
</ul>
<h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>FLV的body部分是一系列的back-pointers+tag构成的</p>
<ul>
<li>back-pointers固定4个字节,表示前一个tag的size</li>
<li><p>tag分三种类型:video,audio,scripts.</p>
<h5 id="tag组成"><a href="#tag组成" class="headerlink" title="tag组成"></a>tag组成</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tag type+tag data size+Timestamp+TimestampExtended+stream id+ tag data</div></pre></td></tr></table></figure>
</li>
<li><p>type 1个字节。8为Audio,9为Video,18为scripts</p>
</li>
<li>tag data size 3个字节。表示tag data的长度。从streamd id 后算起。</li>
<li>Timestreamp 3个字节。时间戳</li>
<li>TimestampExtended 1个字节。时间戳扩展字段</li>
<li>stream id 3个字节。总是0</li>
<li>tag data 数据部分</li>
</ul>
<p>图上第一个tag:</p>
<ul>
<li>type=0x12=18,表示是一个scripts,FLV中,header后的第一个tag是script tag,script tag内容是amf格式数据,包含两个amf.</li>
<li>size=0x00 0x01 0x74 = 372</li>
<li>timpestreamp = 0x00 0x00 0x00</li>
<li>TimestampExtended=0x00</li>
<li>streamid=0x00 0x00 0x00</li>
<li>tag data部分:
<img src="http://images.wodekouwei.com/M/F/flv2.png" alt="FLV-TAG"></li>
</ul>
<h5 id="tag的划分"><a href="#tag的划分" class="headerlink" title="tag的划分"></a>tag的划分</h5><p>图中红色部分是我标出”(“与”)”前后的的两个back-pointers，都是4个字节。而括号中间就是第一个TAG。那是怎么计算的呢？我们就以这个做个示例。</p>
<ul>
<li>首先第一个back-pointers是0x00000000，那是因为后面是第一个TAG。所以他为0。</li>
<li>然后根据我们我们前面格式获取到size是0x00 0x01 0x74 = 372。也就是说从stream id后面再加上372个字节就到了第一个TAG的末尾，我们数一下。tag header有11个字节。那么到第一个TAG，总共有372+11=383=0x17f。</li>
<li>接下来我们找到0x17f的地址，从工具上很容易找到，正好就是后括号”)”的前面。红0x00 0x00 0x01 0x7F=372，这代表的是上一个TAG的大小。</li>
<li>最后我们计算一下，上一个TAG数据部分是372个字节，前面type、stream id等字段占了11个字节。正好是匹配的。
上面我们已经知道了怎么取划分每个TAG。接下来我们就看TAG的具体内容:</li>
</ul>
<h5 id="tag的内容"><a href="#tag的内容" class="headerlink" title="tag的内容"></a>tag的内容</h5><p>前面已经提到tag分3种。我们一个个看</p>
<h6 id="script"><a href="#script" class="headerlink" title="script"></a>script</h6><p>脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。
首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。</p>
<p>一般来说，该Tag Data结构包含两个AMF包。AMF（Action Message Format）是Adobe设计的一种通用数据封装格式，在Adobe的很多产品中应用，简单来说，AMF将不同类型的数据用统一的格式来描述。第一个AMF包封装字符串类型数据，用来装入一个“onMetaData”标志，这个标志与Adobe的一些API调用有，在此不细述。第二个AMF包封装一个数组类型(srs返回为object类型)，这个数组中包含了音视频信息项的名称和值。具体说明如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Number type</td>
<td>8 Bypte Double</td>
</tr>
<tr>
<td>1</td>
<td>Boolean type</td>
<td>1 Bypte bool</td>
</tr>
<tr>
<td>2</td>
<td>String type</td>
<td>后面2个字节为长度</td>
</tr>
<tr>
<td>3</td>
<td>Object type</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>MovieClip type</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Null type</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>Undefined type</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Reference type</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ECMA array type</td>
<td>数组,类似Map</td>
</tr>
<tr>
<td>10</td>
<td>Strict array type</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>Date type</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>Long string type</td>
<td>后面4个字节为长度</td>
</tr>
</tbody>
</table>
<p><img src="http://images.wodekouwei.com/M/F/flv3.png" alt="FLV-script-1.png">
上图为第一个AMF包</p>
<ul>
<li>type=0x02对应String</li>
<li>size=0A=10</li>
<li>value=onMetaData 正好是10个字节。</li>
</ul>
<p><img src="http://images.wodekouwei.com/M/F/flv4.png" alt="FLV_script-2.png">
上图为第二个AMF</p>
<ul>
<li>type=0x08 对应ECMA array type。</li>
</ul>
<blockquote>
<p>表示数组，类似Map。后面4个字节为数组的个数。然后是键值对，第一个为键，2个字节为长度。后面跟具体的内容。接着3个字节表示值的类型，然后根据类型判断长度。
上图我们可以判断，总共有13个键值对。
第一个长度为8个字节是duration。值类型是0x004073，第一个字节是00，所以是double，8个字节。
第二个长度5个字节是width。值也是double类型，8个字节。
依次解析下去…</p>
</blockquote>
<h6 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h6><p><img src="http://images.wodekouwei.com/M/F/flv5.png" alt="flv-audio1">
<img src="http://images.wodekouwei.com/M/F/flv6.png" alt="flv-audio2">
<img src="http://images.wodekouwei.com/M/F/flv7.png" alt="flv-audio3">
<img src="http://images.wodekouwei.com/M/F/flv8.png" alt="flv-audio4">
视频中第二个tag为音频tag</p>
<p>stream-id之后:</p>
<ul>
<li>前4位为音频格式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Linear PCM, platform endian</td>
</tr>
<tr>
<td>1</td>
<td>ADPCM</td>
</tr>
<tr>
<td>2</td>
<td>MP3</td>
</tr>
<tr>
<td>3</td>
<td>Linear PCM, little endian</td>
</tr>
<tr>
<td>4</td>
<td>Nellymoser 16-kHz mono</td>
</tr>
<tr>
<td>5</td>
<td>Nellymoser 8-kHz mono</td>
</tr>
<tr>
<td>6</td>
<td>Nellymoser</td>
</tr>
<tr>
<td>7</td>
<td>G.711 A-law logarithmic PCM</td>
</tr>
<tr>
<td>8</td>
<td>G.711 mu-law logarithmic PCM</td>
</tr>
<tr>
<td>9</td>
<td>reserved</td>
</tr>
<tr>
<td>10</td>
<td>AAC</td>
</tr>
<tr>
<td>11</td>
<td>Speex</td>
</tr>
<tr>
<td>14</td>
<td>MP3 8-Khz</td>
</tr>
<tr>
<td>15</td>
<td>Device-specific sound</td>
</tr>
</tbody>
</table>
<ul>
<li>接着2位为采样率(对于AAC总是3)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>5.5-kHz</td>
</tr>
<tr>
<td>1</td>
<td>11-kHz</td>
</tr>
<tr>
<td>2</td>
<td>22-kHz</td>
</tr>
<tr>
<td>3</td>
<td>44-kHz</td>
</tr>
</tbody>
</table>
<ul>
<li>接着1位为采样的长度(压缩过的音视频都是16bit)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>snd8Bit</td>
</tr>
<tr>
<td>1</td>
<td>snd16Bit</td>
</tr>
</tbody>
</table>
<ul>
<li>接着1位为音频类型(对于AAC总是1)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>sndMono</td>
</tr>
<tr>
<td>1</td>
<td>sndStereo</td>
</tr>
</tbody>
</table>
<h6 id="video"><a href="#video" class="headerlink" title="video"></a>video</h6><p>由于kobe视频音频编码是pcm,查找视频tag太难,使用&lt;&lt;东风破&gt;&gt; mv视频
<img src="http://images.wodekouwei.com/M/F/flv9.png" alt="flv-video1"></p>
<ul>
<li>type=0x09=9。这里应该是一个video。</li>
<li>size=0x000030=48。长度为48。</li>
<li>timestreamp=0x000000。</li>
<li>TimestampExtended =0x00。</li>
<li>stream id =0x000000</li>
</ul>
<p>我们看到数据部分：
视频信息+数据
视频信息，1个字节。</p>
<blockquote>
<p>StreamId之后的数据就表示是VideoTagHeader,如果是avc,VideoTagHeader会多出4个字节的信息就是AVCPacketType和CompositionTime</p>
</blockquote>
<ul>
<li>前4位为帧类型Frame Type</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>keyframe (for AVC, a seekable frame) 关键帧</td>
</tr>
<tr>
<td>2</td>
<td>inter frame (for AVC, a non-seekable frame)</td>
</tr>
<tr>
<td>3</td>
<td>disposable inter frame (H.263 only)</td>
</tr>
<tr>
<td>4</td>
<td>generated keyframe (reserved for server use only)</td>
</tr>
<tr>
<td>5</td>
<td>video info/command frame</td>
</tr>
</tbody>
</table>
<ul>
<li>后4位为编码ID (CodecID)</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>JPEG (currently unused)</td>
</tr>
<tr>
<td>2</td>
<td>Sorenson H.263</td>
</tr>
<tr>
<td>3</td>
<td>Screen video</td>
</tr>
<tr>
<td>4</td>
<td>On2 VP6</td>
</tr>
<tr>
<td>5</td>
<td>On2 VP6 with alpha channel</td>
</tr>
<tr>
<td>6</td>
<td>Screen video version 2</td>
</tr>
<tr>
<td>7</td>
<td>AVC</td>
</tr>
</tbody>
</table>
<p>特殊情况
视频的格式(CodecID)是AVC（H.264）的话，VideoTagHeader会多出4个字节的信息，AVCPacketType 和CompositionTime。</p>
<ul>
<li>AVCPacketType 占1个字节</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>AVCDecoderConfigurationRecord(AVC sequence header)</td>
</tr>
<tr>
<td>1</td>
<td>AVC NALU</td>
</tr>
<tr>
<td>2</td>
<td>AVC end of sequence (lower level NALU sequence ender is not required or supported)</td>
</tr>
</tbody>
</table>
<p>AVCDecoderConfigurationRecord.包含着是H.264解码相关比较重要的sps和pps信息，再给AVC解码器送数据流之前一定要把sps和pps信息送出，否则的话解码器不能正常解码。而且在解码器stop之后再次start之前，如seek、快进快退状态切换等，都需要重新送一遍sps和pps的信息.AVCDecoderConfigurationRecord在FLV文件中一般情况也是出现1次，也就是第一个video tag.</p>
<ul>
<li>CompositionTime 占3个字节</li>
</ul>
<table>
<thead>
<tr>
<th>条件</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVCPacketType ==1</td>
<td>Composition time offset</td>
</tr>
<tr>
<td>AVCPacketType !=1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>再看到第二个video tag
<img src="http://images.wodekouwei.com/M/F/flv10.png" alt="flv-video"></p>
<p>我们看到 AVCPacketType =1，而后面三个字节为000043。这是一个视频帧数据。
解析到的数据完全符合上面的理论。</p>
<p>sps pps
前面我们提到第一个video 一般存放的是sps和pps。这里我们具体解析下sps和pps内容。先看下存储的格）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x01+sps[1]+sps[2]+sps[3]+0xFF+0xE1+sps size+sps+01+pps size+pps</div></pre></td></tr></table></figure></p>
<p>sps[1]=0x64
sps[2]=00
sps[3]=0D
sps size=0x001B=27(占两个字节)
跳过27个字节后，是0x01
pps size=0x0005=118(占两个字节)
跳过5个字节，就到了back-pointers。</p>
<p>视频帧数据
解析出sps和pps tag后，后面的video tag就是真正的视频数据内容了
<img src="http://images.wodekouwei.com/M/F/flv11.png" alt="flv-video3">
这是第二个video tag其实和之前图一样，只是我圈出来关键信息。先看下格式
frametype=0x17=00010111
AVCPacketType =1
Composition Time=0x000043
后面就是NALU DATA</p>
<blockquote>
<p>引用:</p>
<p><a href="http://www.jianshu.com/p/7ffaec7b3be6" target="_blank" rel="external">flv格式详解+实例剖析</a></p>
<p><a href="http://blog.csdn.net/bsplover/article/details/7426511" target="_blank" rel="external">FLV视频封装格式详解</a></p>
<p><a href="https://blog.evanxia.com/2017/07/1378" target="_blank" rel="external">【总结】FLV（AAC/AVC）学习笔记</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932368" target="_blank" rel="external">将h.264视频流封装成flv格式文件（一.flv格式）</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932431" target="_blank" rel="external">将h.264视频流封装成flv格式文件（二.开始动手）</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/7932585" target="_blank" rel="external">RTMP协议中的AMF数据</a></p>
<p><a href="http://blog.csdn.net/yeyumin89/article/details/8011362" target="_blank" rel="external">rtmp协议简单解析以及用其发送h264的flv文件</a></p>
<p><a href="https://chensi.moe/blog/2015/11/20/flv-format/" target="_blank" rel="external">FLV 文件格式解析</a></p>
<p><a href="http://www.cnblogs.com/lihaiping/p/5285166.html" target="_blank" rel="external">(原)从mp4,flv文件中解析出h264和aac,送解码器解码失败</a>:,avc1与H264区别在这里其实有人遇到了和我一样的问题：<a href="http://stackoverflow.com/questions/11330764/ffmpeg-cant-decode-h264-stream-frame-data" target="_blank" rel="external">http://stackoverflow.com/questions/11330764/ffmpeg-cant-decode-h264-stream-frame-data</a></p>
<p><a href="https://gitee.com/leixiaohua1020/simplest_mediadata_test" target="_blank" rel="external">simplest_mediadata_test</a></p>
<p><a href="https://github.com/runner365/rtmp_relay" target="_blank" rel="external">rtmp_relay</a>
<a href="https://github.com/gezhaoyou/RtmpMindmap" target="_blank" rel="external">RtmpMindmap</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流
    
    </summary>
    
      <category term="音视频封装" scheme="http://wodekouwei.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://wodekouwei.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="format" scheme="http://wodekouwei.com/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>(转)总结Android开发中必备的代码Review清单</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-review/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-review/</id>
    <published>2017-12-05T06:11:25.000Z</published>
    <updated>2017-12-05T06:50:12.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文收集了我自己工作以来提交代码前的所有检查点。事实证明，这样能有效提高自己的代码质量和功能的稳定性。所以推荐大家以后每次提交代码前，都可以看下这份Review清单哈。</p>
<p>此外，可能还有些检查点我并没有发现，欢迎大家踊跃在评论区补充哈～</p>
<h3 id="清理操作"><a href="#清理操作" class="headerlink" title="清理操作"></a>清理操作</h3><ol>
<li>页面退出时，是否完成必要的清理操作<ol>
<li>是否调用Handler的removeCallbacksAndMessages(null)来清空Handler里的消息；</li>
<li>是否取消了还没完成的请求；</li>
<li>在页面里注册的监听，是否反注册；</li>
<li>假如自己用到观察者模式，是否反注册；</li>
<li>假如用了RxJava的话，是否解除订阅；</li>
</ol>
</li>
<li><p>数据库的游标是否已经关闭
这个点一般人都知道，出问题一般在于，没有考虑到多线程并发时的情况下，Cursor没有被释放。
所以数据库的操作需要加上同步代码块
详细可参考：<a href="http://www.2cto.com/kf/201408/329574.html" target="_blank" rel="external">http://www.2cto.com/kf/201408/329574.html</a></p>
</li>
<li><p>打开过的文件流是否关闭</p>
</li>
<li><p>Android 3.0以下的版本，使用完的Bitmap是否调用recycle()，否则会一直占用内存
而Android 3.0及以上的版本不需要调用recycle()，因为这些版本的Bitmap全部放到虚拟机的堆内存中，让GC自动回收。</p>
</li>
<li><p>WebView使用完是否调用了其destory()函数</p>
</li>
</ol>
<h3 id="是否能进一步优化自己的代码"><a href="#是否能进一步优化自己的代码" class="headerlink" title="是否能进一步优化自己的代码"></a>是否能进一步优化自己的代码</h3><ol>
<li><p>保存在内存中的图片，是否做过压缩处理再保存在内存里
否则可能由于图片质量太高，导致OOM</p>
</li>
<li><p>Intent传递的数据太大，会导致页面跳转过慢。太大的数据可以通过持久化的形式传递，例如读写文件</p>
</li>
<li><p>频繁地操作同一个文件或者执行同一个数据库操作，是否考虑把它用静态变量或者局部变量的形式缓存在内存里。用空间换时间</p>
</li>
<li><p>放在主页面的控件，是否可以考虑用ViewStub来优化启动速度</p>
</li>
</ol>
<h3 id="要小心第三方包"><a href="#要小心第三方包" class="headerlink" title="要小心第三方包"></a>要小心第三方包</h3><ol>
<li><p>build.gradle远程依赖第三方包时，版本号建议写死，不要使用+号
避免由于新版本的第三方包引入了新的问题</p>
</li>
<li><p>导入第三方工程时，记得把编码转换成自己工程当前是用的编码</p>
</li>
<li><p>调用第三方的包或者JDK的方法时，要跳进他们的源码，看要不要加 try-catch
否则可能会导致自己应用的崩溃</p>
</li>
<li><p>使用第三方包时，是否加上其混淆规则
若漏掉加上第三方包的混淆规则，会导致第三方包不该混淆的代码被混淆。在Debug版本没有发现问题，但是Release版本就会出现问题</p>
</li>
<li><p>系统应用添加so时，是否在固件对应的Android.mk文件上加入新增的so，否则系统可能编译不过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@lib/armeabi/libcommon.so \</div><div class="line">@lib/armeabi/libabcdefg.so \</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意要成对出现的地方"><a href="#注意要成对出现的地方" class="headerlink" title="注意要成对出现的地方"></a>注意要成对出现的地方</h3><ol>
<li><p>系统的、自己写的，注册和反注册的方法，是否成对出现</p>
</li>
<li><p>在生命周期的回调里，创建和销毁的代码是否对应起来
比如：onCreate()里面创建了Adapter，那么对应Adapter的退出处理操作(比如清空Image缓存)，一般就要写在onDestory()，而不能写在onDestoryView()。</p>
</li>
</ol>
<p>类似的生命周期对应的代码有：
onStart()、onStop();
onCreate()、onDestory();
onResume()、onPause();
onCreateView()、onDestoryView()</p>
<ol>
<li>若ListView的item复用了，对Item里View的操作是否成对出现
比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">switch (type) &#123;</div><div class="line">    case ArticleListItem.TYPE_AD:</div><div class="line">        ......</div><div class="line">        mTitleView.setText(tencentAdBean.title);</div><div class="line">        mGreenLabelView.setVisibility(VISIBLE);</div><div class="line">        mRedLabelView.setText(&quot;&quot;);</div><div class="line">        mRedLabelView.setVisibility(GONE);</div><div class="line">        break;</div><div class="line">    case ArticleListItem.TYPE_ARTICLE:</div><div class="line">        ......</div><div class="line">        mTitleView.setText(mzAdBean.adData.getTitle());</div><div class="line">        mGreenLabelView.setVisibility(GONE);</div><div class="line">        mRedLabelView.setText(&quot;ABC&quot;);</div><div class="line">        mRedLabelView.setVisibility(VISIBLE);</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>比如以上对mTitleView、mGreenLabelView和mRedLabelView的操作，都是成对出现。否则ListView可能会由于Item复用，导致Item显示错乱问题</p>
<h3 id="防内存泄漏"><a href="#防内存泄漏" class="headerlink" title="防内存泄漏"></a>防内存泄漏</h3><ol>
<li><p>内部类，比如Handler、Listener、Callback是否是成static class
因为非静态内部类会持有外部类的引用。</p>
</li>
<li><p>假如子线程持有了Activity，要用弱引用来持有
比如Request的Activity就应该用弱引用的形式，防止内存泄漏。</p>
</li>
<li><p>要求传入Activity作为参数的函数，是否可以改用getApplicationContext()来作为参数</p>
</li>
</ol>
<h3 id="Handler相关"><a href="#Handler相关" class="headerlink" title="Handler相关"></a>Handler相关</h3><ol>
<li>使用View.post()是否会有问题
因为在View处于detached状态期间，post()里面的Runnable是不会被执行的。只有在此View处于attached状态时才会被执行。</li>
</ol>
<p>如果想改Runnable每次肯定会被执行，那么应该是用Handler.post来替代</p>
<ol>
<li>假如程序可能多次在同一个Handler里post同一个Runnable，每次post之前都应该先清空这个Handler中还没执行的该Runnable
如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (mCloudRun != null) &#123;</div><div class="line">    mHandler.removeCallbacks(mCloudRun);</div><div class="line">    mCloudRun = null;</div><div class="line">&#125;</div><div class="line">mCloudRun = new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        CloudAccelerateSwitchRequest request = new CloudAccelerateSwitchRequest();</div><div class="line">        request.setPriority(RequestTask.PRIORITY_LOW);</div><div class="line">        RequestQueue.getInstance().addRequest(request);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">mHandler.post(mCloudRun);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><p>多思考某些情况下，某变量是否会为空
而且在函数体内，处理参数前，必须加上判空语句</p>
</li>
<li><p>回调函数是否处理好
回调函数很容易出问题。比如网络请求的回调，需要判断此时的Aciivity等是否还存在，再进行调用。因为异步操作回来，Activity可能就消失不存在了。
而且还要对一些可能被回收的变量进行判空。</p>
</li>
<li><p>修改数据库后，是否把数据库的版本号+1</p>
</li>
<li><p>启动第三方的Activity时，是否判断了该Intent能否被解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent sendIntent = new Intent(mContext, Demo.class);</div><div class="line">// 这种方式判断是否存在</div><div class="line">if (sendIntent.resolveActivity(getPackageManager()) != null) &#123;</div><div class="line">    startActivity(sendIntent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>若Activity不存在，会出现ActivityNotFoundException的异常</p>
<ol>
<li>新注册的Activity、Service或Provider，若AndroidManifest.xml中exported属性为true，要考虑是否会引发安全性问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;com.inkenka.DemoActivity&quot;</div><div class="line">            android:exported=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为exported属性为true时，外部应用就可以直接调用起该Activity。
可能导致的问题：</p>
<ul>
<li>若外部应用直接启动详情页，从而让某些验证页面直接被绕过</li>
<li>若外部应用给该Activity传递乱七八糟的Intent，可能让该应用崩溃。也就是Android中的拒绝服务漏洞</li>
</ul>
<ol>
<li><p>除数是否做了非0判断</p>
</li>
<li><p>不要在Activity的onCreate里调用PopupWindow的showAsLoaction方法，由于Activity还没被加载完，会报错</p>
</li>
</ol>
<h3 id="功能完成后，自测时的检查点"><a href="#功能完成后，自测时的检查点" class="headerlink" title="功能完成后，自测时的检查点"></a>功能完成后，自测时的检查点</h3><ol>
<li>思考某些情况下，某个变量是否会造成空指针问题</li>
<li>把手机横屏，检查布局是否有Bug</li>
<li>在不同分辨率的机型上，检查布局是否有Bug</li>
<li>切换到英文等外文字体下，检查外文是否能完整显示</li>
<li>从低版本升级上来，会不会有问题,比如可能会出现数据库不兼容的问题</li>
<li>按下Home再返回是否正常</li>
<li>熄灭屏幕再打开是否正常</li>
<li>切换成其它应用再切换回来会怎样</li>
<li>利用手机的开发者选项中的 “调试GPU过度绘制” ，“GPU呈现模式分析” 和 “显示FPS和功耗” 功能，看自己的新功能是否会导致过度绘制、是否会掉帧</li>
<li>测试看是否影响启动速度<code>adb shell am start -W 包名/Activity</code></li>
<li>对比看APK大小是否有增大</li>
<li>跑1小时Monkey，测试其稳定性</li>
</ol>
<blockquote>
<p>转自:
<a href="http://www.jianshu.com/p/4b65967fe4a0" target="_blank" rel="external">良心推荐：总结Android开发中必备的代码Review清单</a></p>
</blockquote>
<h2 id="补充-总结工作中的Android内存泄漏问题"><a href="#补充-总结工作中的Android内存泄漏问题" class="headerlink" title="补充:总结工作中的Android内存泄漏问题"></a>补充:<a href="http://www.jianshu.com/p/973ab884c397" target="_blank" rel="external">总结工作中的Android内存泄漏问题</a></h2><h3 id="简单判断是否有内存泄漏"><a href="#简单判断是否有内存泄漏" class="headerlink" title="简单判断是否有内存泄漏"></a>简单判断是否有内存泄漏</h3><p>判断内存泄漏的定位的大单位是Activity。</p>
<p>可以通过反复进入退出一个Activity，然后用adb shell dumpsys meminfo + 包名 查看虚拟机的堆是否有不断地增长</p>
<h3 id="定位内存泄漏"><a href="#定位内存泄漏" class="headerlink" title="定位内存泄漏"></a>定位内存泄漏</h3><h4 id="1-使用Leak-Canary"><a href="#1-使用Leak-Canary" class="headerlink" title="1.使用Leak Canary"></a>1.使用Leak Canary</h4><p>在代码上加入Leak Canary，然后不断跑Monkey或者手动反复进出不同页面。若出现内存泄漏问题，会自动导出来，生成以下页面。</p>
<h4 id="2-使用DDMS导出hprof，并用MAT工具进行分析"><a href="#2-使用DDMS导出hprof，并用MAT工具进行分析" class="headerlink" title="2.使用DDMS导出hprof，并用MAT工具进行分析"></a>2.使用DDMS导出hprof，并用MAT工具进行分析</h4><ul>
<li>强烈建议先跑30分钟Monkey测试</li>
<li>使用eclipse的ddms找到对应的进程，触发一次gc后，dump出里面的内存快照hprof文件以分析当前应用内存的堆有什么东西</li>
<li>使用Android SDK 里的platform-tools文件夹的 hprof-conv工具，对刚才 hprof 文件进行转换，以至于 后面MAT工具能正常打开</li>
<li>使用MAT打开hprof文件，进入Histogram。输入自己猜测可能泄漏的Activity（项目中Activity不多时，可每个Activity都重复以下3、4、5步骤）</li>
<li>键该其中一项，打开菜单选择list objects -&gt;with incoming refs将列出该类的实例</li>
<li>右健Path to GC Roots–&gt;exclue all phantom/weak/soft etc. reference，找出这个实例GC后，还会存在什么对象的引用关系。</li>
</ul>
<h3 id="常见导致内存泄漏的几个点"><a href="#常见导致内存泄漏的几个点" class="headerlink" title="常见导致内存泄漏的几个点"></a>常见导致内存泄漏的几个点</h3><h4 id="生命周期的原因"><a href="#生命周期的原因" class="headerlink" title="生命周期的原因"></a>生命周期的原因</h4><p>比如：Activity中关联了一个生命周期超过Activity的Thread，这个Thread 若持有该Activity的引用，就会导致内存泄漏。</p>
<h4 id="内部类的原因"><a href="#内部类的原因" class="headerlink" title="内部类的原因"></a>内部类的原因</h4><p>因为内部类会隐式地持有外部类的引用，若内部类不被释放，外部类也是无法释放。常见的有内部的Listener、Callback、Handler等导致。</p>
<p>情景1：若外部类应该释放的时候，内部类还在执行里面的函数，会导致外部类无法释放。</p>
<p>情景2：若一个异步操作，会回调内部类的Listener、Callback、Handler。当外部类应该释放的时候，但是这个异步操作还存在，而这个异步操作类又持有了Listener、Callback、Handler，导致外部类无法被释放。PS：这个原因也属于生命周期的原因。</p>
<h4 id="静态变量的原因"><a href="#静态变量的原因" class="headerlink" title="静态变量的原因"></a>静态变量的原因</h4><p>单例类里包含Activity</p>
<p>静态变量的类里引用到Activity</p>
<h4 id="注册与反注册、打开与关闭没成对出现的原因"><a href="#注册与反注册、打开与关闭没成对出现的原因" class="headerlink" title="注册与反注册、打开与关闭没成对出现的原因"></a>注册与反注册、打开与关闭没成对出现的原因</h4><p>比如：注册广播接收器、注册观察者（典型的譬如数据库的监听）等。或者自己写的跟Activity引用有关的clear()函数没有成对出现</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="解决内部类的问题（以Handler作为例子）"><a href="#解决内部类的问题（以Handler作为例子）" class="headerlink" title="解决内部类的问题（以Handler作为例子）"></a>解决内部类的问题（以Handler作为例子）</h4><ol>
<li>onDestroy时候remove所有msgActivity finish后未处理的msg是问题根源，所以清空所有未被执行的msg<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mHandler.removeCallbacksAndMessages(null);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：比如Listener、Callback等其他内部类的问题，页面退出的时候，应该完成必要的清理操作，比如Cancel 请求</p>
<ol>
<li>使用静态内部类 + weakReference
静态内部类不会保留对外部类的引用，如果一定要引用外部类，使用weakReference<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class MyHandler extends Handler &#123;</div><div class="line">        WeakReference&lt;Activity &gt; mActivityReference;</div><div class="line">        MyHandler(Activity activity) &#123;</div><div class="line">            mActivityReference= new WeakReference&lt;Activity&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            final Activity activity = mActivityReference.get();</div><div class="line">            if (activity != null) &#123;</div><div class="line">                mImageView.setImageBitmap(mBitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PS:比如Listener、Callback等其他内部类的问题，也可以通过这个方法来解决</p>
<h4 id="单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期"><a href="#单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期" class="headerlink" title="单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期"></a>单例类里面尽量不要传入Activity，最好穿入ApplicationContext。假如传入了Activity，持有的时长也不能大于Activity的生命周期</h4><h4 id="对象的注册与反注册要成对出现"><a href="#对象的注册与反注册要成对出现" class="headerlink" title="对象的注册与反注册要成对出现"></a>对象的注册与反注册要成对出现</h4><h4 id="不使用WebView对象时，应该调用它的destory-函数来销毁它，并释放其占用的内存"><a href="#不使用WebView对象时，应该调用它的destory-函数来销毁它，并释放其占用的内存" class="headerlink" title="不使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存"></a>不使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存</h4><h4 id="因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View"><a href="#因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View" class="headerlink" title="因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View"></a>因为View会持有Context，所以注意不要异步引用View，不要让静态对象持有View，不要在集合框架中存储View</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文收集了我自己工作以来提交代码前的所有检查点。事实证明，这样能有效提高自己的代码质量和功能的稳定性。所以推荐大家以后每次提交代码前，都可以
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>android架构</title>
    <link href="http://wodekouwei.com/2017/12/05/tips-android-arch/"/>
    <id>http://wodekouwei.com/2017/12/05/tips-android-arch/</id>
    <published>2017-12-05T03:59:48.000Z</published>
    <updated>2017-12-05T06:52:09.888Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/zqlxtt/p/6887938.html" target="_blank" rel="external">Android官方架构组件介绍之LifeCycle</a>,Android架构组件一共包括以下几个：</p>
<ul>
<li>LifeCycle ： 与Activity和Fragment的生命周期有关</li>
<li>LiveData ：异步可订阅数据，也是生命周期感知</li>
<li>ViewModel ：视图数据持有模型，也是生命周期感知</li>
<li>Room ：SQLite抽象层，用于简化SQLite数据存储</li>
</ul>
<p><a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank" rel="external">官网</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zqlxtt/p/6887938.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android官方架构组件介绍之LifeCycle&lt;/a&gt;,Android架构组件一共包括以下几个：&lt;
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
</feed>
