<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老司机种菜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wodekouwei.com/"/>
  <updated>2019-03-05T11:25:01.232Z</updated>
  <id>http://wodekouwei.com/</id>
  
  <author>
    <name>轻口味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>应用targetSdkVersion升级指导</title>
    <link href="http://wodekouwei.com/2019/03/05/tips-android-targetsdkversion/"/>
    <id>http://wodekouwei.com/2019/03/05/tips-android-targetsdkversion/</id>
    <published>2019-03-05T08:00:20.000Z</published>
    <updated>2019-03-05T11:25:01.232Z</updated>
    
    <content type="html"><![CDATA[<p>应电信终端产业协会（TAF）发布的《移动应用软件高 API 等级预置与分发自律公约》（以下简称《公约》）要求：截止到2019年5月1日所有新发布的应用 API 必须为26或更高，2019年8月1日现有应用 API 必须升级为26或更高。《公约》发布至今得到了国内主流互联网及终端制造企业的积极响应。</p>
<ul>
<li>对应用开发者来说，不按时更新Target SDK版本的应用，应用市场将采取强制下架的策略，已上架应用将无法更新。</li>
<li>对用户来说，未适配Android M或更高版本的应用安装在Android M或更高版本时，会默认授予申请的所有权限，且应用运行时无弹框授权提示。其中包括通讯录、电话、短信、通讯记录、位置、麦克风、相机等危险权限，导致用户在不知情的情况下泄露隐私信息，对用户个人信息安全造成危害。</li>
</ul>
<p><strong>应用targetSdkVersion升级流程</strong>
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935161819.jpg" alt="tips-android-targetsdkversion-201935161819"></p>
<h2 id="targetSdkVersion-相关变更介绍"><a href="#targetSdkVersion-相关变更介绍" class="headerlink" title="targetSdkVersion 相关变更介绍"></a>targetSdkVersion 相关变更介绍</h2><h3 id="Android5-x（22-19）及以下版本变更"><a href="#Android5-x（22-19）及以下版本变更" class="headerlink" title="Android5.x（22-19）及以下版本变更"></a>Android5.x（22-19）及以下版本变更</h3><p><img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935184537.jpg" alt="tips-android-targetsdkversion-201935184537"></p>
<h3 id="Android6-0变更"><a href="#Android6-0变更" class="headerlink" title="Android6.0变更"></a>Android6.0变更</h3><h4 id="（一）相关变更"><a href="#（一）相关变更" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><p><strong>运行时权限</strong></p>
<p>此版本引入了一种新的权限模式，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，为安装的应用分别授予或撤销权限，同时为开发者精简了安装和自动更新过程。</p>
<p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。确定应用是否已被授予权限，可调用新增的 checkSelfPermission() 方法。请求权限，可调用新增的 requestPermissions() 方法。具体参考：</p>
<p><a href="https://developer.android.google.cn/training/permissions/requesting" target="_blank" rel="external">https://developer.android.google.cn/training/permissions/requesting</a></p>
<p>####（二）适配指导</p>
<p>• 解释需要权限的原因：系统在开发者调用 requestPermissions() 时显示的权限对话框将说明应用需要的权限，但不会解释为何需要这些权限。某些情况下，用户可能会感到困惑，因此，建议在调用 requestPermissions() 之前向用户解释应用需要相应权限的原因。</p>
<ul>
<li>仅申请应用真正需要的权限</li>
<li>如果应用在启动之后一次要求用户提供多项权限，用户可能会感到无所适从并因此退出应用 。建议开发者应根据需要请求权限，对于某一些权限应用可以在真正需要使用的时候再尝试申请用户动态授权。</li>
</ul>
<h3 id="Android7-0"><a href="#Android7-0" class="headerlink" title="Android7.0"></a>Android7.0</h3><h4 id="（一）相关变更-1"><a href="#（一）相关变更-1" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><h5 id="1-系统禁止链接到非-NDK-库"><a href="#1-系统禁止链接到非-NDK-库" class="headerlink" title="1.系统禁止链接到非 NDK 库"></a>1.系统禁止链接到非 NDK 库</h5><p>从 Android 7.0 开始，系统将阻止应用动态链接非公开 NDK 库，原因为NDK 库可能会导致应用崩溃，此行为变更主要目的在为跨平台更新和不同设备提供统一的应用体验。即使应用中的代码不会链接私有库，但第三方静态库可能会进行链接，因此建议所有开发者都需进行相应检查，确保应用不会在运行 Android 7.0 的设备上崩溃。如果应用使用的是原生代码，则只能使用公开 NDK API。（<a href="https://developer.android.com/ndk/guides/stable_apis）" target="_blank" rel="external">https://developer.android.com/ndk/guides/stable_apis）</a></p>
<h5 id="2-低电耗模式DOZE（系统状态）"><a href="#2-低电耗模式DOZE（系统状态）" class="headerlink" title="2.低电耗模式DOZE（系统状态）"></a>2.低电耗模式DOZE（系统状态）</h5><p>进入条件：灭屏、未充电、静止持续1小时
退出条件：亮屏或移动或充电</p>
<p>限制资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停应用的Sync任务</li>
<li>暂停应用的JobScheduler任务</li>
<li>忽略应用的wakelocks</li>
<li>标准Alarm推迟到维护窗口</li>
<li>不执行wifi扫描</li>
</ul>
<h5 id="3-低电耗模式Lite-Idle（系统状态）"><a href="#3-低电耗模式Lite-Idle（系统状态）" class="headerlink" title="3.低电耗模式Lite Idle（系统状态）"></a>3.低电耗模式Lite Idle（系统状态）</h5><p>进入条件：灭屏、未充电持续5分钟(Android P调整为3分钟）
退出条件：亮屏或充电
限制资源</p>
<ul>
<li>限制应用访问网络。</li>
<li>暂停应用运行Sync任务 。</li>
<li>暂停应用运行JobScheduler任务。</li>
</ul>
<h5 id="4-AppStandby模式（应用状态）"><a href="#4-AppStandby模式（应用状态）" class="headerlink" title="4.AppStandby模式（应用状态）"></a>4.AppStandby模式（应用状态）</h5><p>进入AppIdle条件：应用后台空闲总时间&gt;48小时且亮屏后台空闲时间 &gt; 12小时
排除&amp;退出条件：前台应用、有前台服务的应用、通知栏或锁屏通知消息的应用或进行充电
不限制的应用：系统应用UID&lt;10000的，Persist常驻应用，电池优化白名单，系统关联的其他应用
限制的资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停执行应用的Sync任务</li>
<li>暂停执行应用的JobScheduler任务</li>
</ul>
<h5 id="5-App-Standby-Bucket-应用待机分组模式-Android-P特性）"><a href="#5-App-Standby-Bucket-应用待机分组模式-Android-P特性）" class="headerlink" title="5.App Standby Bucket 应用待机分组模式( Android P特性）"></a>5.App Standby Bucket 应用待机分组模式( Android P特性）</h5><p>应用待机分组模式是在Doze模式未生效时（亮屏或刚刚灭屏时），对运行在后台的用户不可感知应用的耗电管控扩展。</p>
<h4 id="（二）适配指导"><a href="#（二）适配指导" class="headerlink" title="（二）适配指导"></a>（二）适配指导</h4><p>低电耗模式和应用待机模式适配指导如下：</p>
<p>• 前台服务</p>
<p>应用需要在后台访问网络或者使用CPU时可以通过此方式。</p>
<p>• Doze白名单</p>
<p>查询应用是不是再doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PowerManager powerManager = (PowerManager)getSystemService(POWER_SERVICE);</div><div class="line">boolean hasIgnored = powerManager.isIgnoringBatteryOptimizations(activity.getPackageName());</div></pre></td></tr></table></figure></p>
<p>向用户申请授权添加doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);</div><div class="line">intent.setData(Uri.parse(&quot;package:&quot;+activity.getPackageName()));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<h3 id="Android8-0-变更"><a href="#Android8-0-变更" class="headerlink" title="Android8.0 变更"></a>Android8.0 变更</h3><h4 id="1-后台服务限制"><a href="#1-后台服务限制" class="headerlink" title="1.后台服务限制"></a>1.后台服务限制</h4><h5 id="①哪些应用会受到后台服务限制？"><a href="#①哪些应用会受到后台服务限制？" class="headerlink" title="①哪些应用会受到后台服务限制？"></a>①哪些应用会受到后台服务限制？</h5><ul>
<li>TargetSDK&gt;=26的应用</li>
<li>TargetSDK&lt;26且被用户主动设置为限制后台活动的应用（华为EMUI8.x未提供配置）</li>
</ul>
<p>注意：Doze 白名单中的应用不受限制（用户可以设置，手机管家配置有默认值白名单）</p>
<h5 id="②前台如何定义？"><a href="#②前台如何定义？" class="headerlink" title="②前台如何定义？"></a>②前台如何定义？</h5><ul>
<li>前台有可见 Activity</li>
<li>前台服务可以后台播放</li>
<li>绑定服务的情况<h5 id="③后台服务限制，限制了哪些行为？"><a href="#③后台服务限制，限制了哪些行为？" class="headerlink" title="③后台服务限制，限制了哪些行为？"></a>③后台服务限制，限制了哪些行为？</h5></li>
<li>应用进入 uidldle 后，会被调用 Service.stopself()</li>
<li>应用进入 uidldle 后，不允许通过 startService启动服务</li>
<li>应用进程仍然存在，JobScheduler、Alarm、广播等均能触发</li>
<li>广播接收线程处理短暂业务，无法拉起后台服务</li>
<li>非安卓组件线程 CPU 超标时，谷歌原生机制会强制kill进程<h5 id="④临时白名单机制"><a href="#④临时白名单机制" class="headerlink" title="④临时白名单机制"></a>④临时白名单机制</h5>系统调用应用时，少量场景会将应用添加到临时白名单（有效时间30秒~300秒）：</li>
<li>处理高优先级 FCM 消息</li>
<li>接收短信彩信</li>
<li>用户点击通知栏，执行 PendingIntent<h5 id="⑤用户设置限制后台活动之后的影响（Android-P优化）"><a href="#⑤用户设置限制后台活动之后的影响（Android-P优化）" class="headerlink" title="⑤用户设置限制后台活动之后的影响（Android P优化）"></a>⑤用户设置限制后台活动之后的影响（Android P优化）</h5></li>
<li>应用退后台，1分钟就会被停止 Service（包括正在执行的前台任务）</li>
<li>限制访问网络</li>
<li>限制 Alarm 触发</li>
<li>限制 JobScheduler 执行</li>
</ul>
<h4 id="2-广播限制"><a href="#2-广播限制" class="headerlink" title="2.广播限制"></a>2.广播限制</h4><p>Android 8.0 的应用无法继续在其清单中为隐式广播注册广播接收器,但也存在例外情况：</p>
<ul>
<li>应用可以继续在清单中注册显式广播</li>
<li>应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注 册接收器</li>
<li>需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用 ，而不会发送至设备上的所有应用</li>
<li>白名单豁免隐式广播的列表：<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="external">https://developer.android.com/guide/components/broadcast-exceptions</a></li>
</ul>
<p>后台执行限制的适配建议</p>
<ul>
<li>使用 JobScheduler 代替</li>
<li>增加前台服务</li>
<li>加 Doze 白名单（不推荐）</li>
</ul>
<h4 id="3-最大屏幕纵横比"><a href="#3-最大屏幕纵横比" class="headerlink" title="3.最大屏幕纵横比"></a>3.最大屏幕纵横比</h4><p>以 Android 7.1（API 级别 25）或更低版本为目标平台中应用默认的最大屏幕纵横比为1.86。针对 Android 8.0 或更高版本的应用没有默认的最大纵横比，如需设置请在应用 androidmanifest 文件定义 maxAspectRatio 属性（注意：如果应用没有显示申明不支持 resizeableActivity，系统将会忽略应用设置的 maxAspectRatio属性）</p>
<h4 id="4-其他变更"><a href="#4-其他变更" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>提醒窗口</td>
<td>使用SYSTEM_ALERT_WINDOW权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口:TYPE_PHONE,TYPE_PRIORITY_PHONE,TYPE_SYSTEM_ALERT,TYPE_SYSTEM_OVERLAY,TYPE_SYSTEM_ERROR,应用必须使用名为TYPE_APPLICATION_OVERLAY的新窗口类型</td>
</tr>
<tr>
<td>权限</td>
<td>在Android8.0之前,如果应用在运行时请求权限并且被授予该权限,系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用.对于针对8.0的应用,此行为已被纠正.系统只会授予应用明确请求的权限.然而,一旦用户为应用授予某个权限,则所有后续对该权限组中权限的请求都被自动批准.建议应用在使用所有的敏感权限之前,都先判断一下权限是否已经被授予,如果没有授予需要申请动态权限.</td>
</tr>
<tr>
<td>Linker</td>
<td>O版本在linker中新增加检查就是在load之前检测一下需要加载的section的权限,被加载的段不允许同事具有E(可执行)和W(可写)权限.如果有这样的段,则linker报错</td>
</tr>
<tr>
<td>Build.SERIAL弃用</td>
<td>需要知道硬件序列号的应用应改为使用新的Build.getSerial()函数,该函数要求具有READ_PHONE_STATE权限</td>
</tr>
</tbody>
</table>
<h3 id="Android9-0-变更"><a href="#Android9-0-变更" class="headerlink" title="Android9.0 变更"></a>Android9.0 变更</h3><h4 id="1-非SDK管控"><a href="#1-非SDK管控" class="headerlink" title="1.非SDK管控"></a>1.非SDK管控</h4><table>
<thead>
<tr>
<th>名单类型</th>
<th>影响</th>
<th>名单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浅灰名单</td>
<td>targetSDK&gt;=P时,警告</td>
<td>已有应用在使用非SDK接口,仍然可以继续使用</td>
</tr>
<tr>
<td>深灰名单</td>
<td>targetSDK<p时,警告;>=时,不允许调用</p时,警告;></td>
<td>应用可能还在使用</td>
</tr>
<tr>
<td>黑名单</td>
<td>所有三方应用不允许调用</td>
<td>灰名单(深灰+浅灰)之外的其他所有非SDK接口都会被添加到黑名单,应用发现有使用黑名单的接口需要马上整改,或者反馈给谷歌申请加灰名单</td>
</tr>
</tbody>
</table>
<p>使用谷歌提供的非 SDK 扫描工具查看应用使用的深灰名单和黑名单非 SDK 接口： <a href="https://android.googlesource.com/platform/prebuilts/runtime/+/" target="_blank" rel="external">https://android.googlesource.com/platform/prebuilts/runtime/+/</a> master/appcompat/</p>
<h4 id="2-Apache-HTTP-客户端弃用"><a href="#2-Apache-HTTP-客户端弃用" class="headerlink" title="2. Apache HTTP 客户端弃用"></a>2. Apache HTTP 客户端弃用</h4><p>默认情况下该内容库已从 bootclasspath 中移除且不可用于应用，应用不能使用系统的 classloader 加载 org.apache.http.* 库，否则会抛 NoClassDefFoundError。</p>
<p>适配建议</p>
<ul>
<li>方法一：如果要继续使用 Apache HTTP 客户端，以 Android 9.0及更高版本为目标的应用可以向其 AndroidManifest.xml 添加以下内容：<code>&lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot;/&gt;</code></li>
<li>方法二：如果必须要继续使用 Apache HTTP 客户端，开发者可以将 org.apache.http.legacy库打包进自己的apk。</li>
<li>推荐方法：使用 HttpURLConnection 类替代 apache-http</li>
</ul>
<h4 id="3-内联方法不允许跨dex"><a href="#3-内联方法不允许跨dex" class="headerlink" title="3.内联方法不允许跨dex"></a>3.内联方法不允许跨dex</h4><p>Google 在 Android P 新增检测：如果调用某个 inline 方法的类与 inline 方法所在的类由不同的 classloader 加载，就会主动发起 abort（inline不允许跨dex文件）导致应用 crash。
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935181033.jpg" alt="tips-android-targetsdkversion-201935181033"></p>
<h5 id="兼容性影响"><a href="#兼容性影响" class="headerlink" title="兼容性影响"></a>兼容性影响</h5><p>对使用插件和热修复的应用有很大影响，需要重点测试。</p>
<h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><ul>
<li>启动应用，构造热修复场景，在 app 侧触发热修复</li>
<li><code>adb shell cmd package compile -m speed -f my-package 应用包名 (inline编译)</code></li>
<li>重启应用，检查是否会出现闪退问题</li>
</ul>
<h5 id="适配建议"><a href="#适配建议" class="headerlink" title="适配建议"></a>适配建议</h5><ul>
<li>尽量避免使用不同的 classloader 加载相关的类。</li>
<li>如果一定要这样做的话，需要避免内联，比如在函数里面加 try catch， 这样 compiler就不会将这个函数 inline。</li>
</ul>
<h4 id="4-其他变更-1"><a href="#4-其他变更-1" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>前台服务</td>
<td>使用前台服务的应用必须请求FOREGROUND_SERVICE权限.这是普通权限,因此,系统会自动为请求权限的应用授予此权限.如果针对Android9或更高版本的应用尝试创建一个前台服务且未请求FOREGROUND_SERVICE,则系统会引发SecurityException.</td>
</tr>
<tr>
<td>DNS隐私</td>
<td>应用应采用私有DNS API.具体而言,当系统解析程序正在执行DNS-over-TLS时,应用应确保任何内置DNS客户端均使用加密的DNS查找和系统相同的主机名,或停用它而改用系统解析程序</td>
</tr>
<tr>
<td>默认情况下启用网络传输层安全协议(TLS)</td>
<td>默认情况下isCleartextTrafficPermitted()函数返回false.如果您的应用需要为特定域名启动明文,您必须在应用的网络安全性配置中针对这些域名将cleartextTrafficPermitted显式设置为true</td>
</tr>
<tr>
<td>webview数据目录不允许共享</td>
<td>应用无法再让多个进程公用同一个WebView数据目录.如果应用中的多个进程需要访问同一网络数据,您需要自行在这些进程之间复制数据.例如,您可以调用getCookie()和setCooki(),在不同进程之间手动传输Cookie数据</td>
</tr>
<tr>
<td>以应用为单位的SELinux域名</td>
<td>应用的私有数据只能由该应用访问.要与其他应用共享文件,请使用contentprovider</td>
</tr>
</tbody>
</table>
<p>其他的变更和非 TargetSdkVersion 相关的变更以及新特性，可以在谷歌开发者网站查阅：<a href="https://developer.android.google.cn/about/versions/oreo/" target="_blank" rel="external">https://developer.android.google.cn/about/versions/oreo/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应电信终端产业协会（TAF）发布的《移动应用软件高 API 等级预置与分发自律公约》（以下简称《公约》）要求：截止到2019年5月1日所有新发布的应用 API 必须为26或更高，2019年8月1日现有应用 API 必须升级为26或更高。《公约》发布至今得到了国内主流互联网及
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Android启动过程深入解析</title>
    <link href="http://wodekouwei.com/2019/03/05/tips-android-system-load/"/>
    <id>http://wodekouwei.com/2019/03/05/tips-android-system-load/</id>
    <published>2019-03-05T06:11:16.000Z</published>
    <updated>2019-03-05T06:29:37.391Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>A当按下Android设备电源键时究竟发生了什么？</li>
<li>Android的启动过程是怎么样的？</li>
<li>A什么是Linux内核？</li>
<li>A桌面系统linux内核与Android系统linux内核有什么区别？</li>
<li>A什么是引导装载程序？</li>
<li>A什么是Zygote？</li>
<li>A什么是X86以及ARM linux？</li>
<li>A什么是init.rc?</li>
<li>A什么是系统服务？
当我们想到Android启动过程时，脑海中总是冒出很多疑问。本文将介绍Android的启动过程，希望能帮助你找到上面这些问题的答案。</li>
</ul>
<p>Android是一个基于Linux的开源操作系统。x86（x86是一系列的基于intel 8086 CPU的计算机微处理器指令集架构）是linux内核部署最常见的系统。然而，所有的Android设备都是运行在ARM处理器（ARM 源自进阶精简指令集机器，源自ARM架构）上，除了英特尔的Xolo设备(<a href="http://xolo.in/xolo-x900-features)。Xolo来源自凌动1.6GHz" target="_blank" rel="external">http://xolo.in/xolo-x900-features)。Xolo来源自凌动1.6GHz</a> x86处理器。Android设备或者嵌入设备或者基于linux的ARM设备的启动过程与桌面版本相比稍微有些差别。这篇文章中，我将解释Android设备的启动过程。<a href="http://www.ibm.com/developerworks/linux/library/l-linuxboot/" target="_blank" rel="external">深入linux启动</a>过程是一篇讲桌面linux启动过程的好文。</p>
<p>当你按下电源开关后Android设备执行了以下步骤。</p>
<p><img src="http://images.wodekouwei.com/tips-android-system-load-201935141326.png" alt="tips-android-system-load-201935141326"></p>
<h3 id="第一步：启动电源以及系统启动"><a href="#第一步：启动电源以及系统启动" class="headerlink" title="第一步：启动电源以及系统启动"></a>第一步：启动电源以及系统启动</h3><p>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。</p>
<h3 id="第二步：引导程序"><a href="#第二步：引导程序" class="headerlink" title="第二步：引导程序"></a>第二步：引导程序</h3><p>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如<a href="http://ecos.sourceware.org/redboot/" target="_blank" rel="external">redboot</a>、<a href="http://www.denx.de/wiki/U-Boot" target="_blank" rel="external">uboot</a>、<a href="http://wiki.openmoko.org/wiki/Qi" target="_blank" rel="external">qi bootloader</a>或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。</p>
<p>引导程序分两个阶段执行。第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。</p>
<p>Android引导程序可以在<code>\bootable\bootloader\legacy\usbloader</code>找到。
传统的加载器包含的个文件，需要在这里说明：</p>
<ul>
<li>init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；</li>
<li>main.c初始化硬件（闹钟、主板、键盘、控制台），创建linux标签。
更多关于Android引导程序的可以在<a href="https://motorola-global-portal.custhelp.com/app/answers/detail/a_id/86208/~/bootloader-frequently-asked-questions" target="_blank" rel="external">这里</a>了解。</li>
</ul>
<h3 id="第三步：内核"><a href="#第三步：内核" class="headerlink" title="第三步：内核"></a>第三步：内核</h3><p>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p>
<h3 id="第四步：init进程"><a href="#第四步：init进程" class="headerlink" title="第四步：init进程"></a>第四步：init进程</h3><p>init是第一个进程，我们可以说它是root进程或者说有进程的父进程。init进程有两个责任，一是挂载目录，比如/sys、/dev、/proc，二是运行init.rc脚本。</p>
<p>init进程可以在/system/core/init找到。
init.rc文件可以在/system/core/rootdir/init.rc找到。
readme.txt可以在/system/core/init/readme.txt找到。
对于init.rc文件，Android中有特定的格式以及规则。在Android中，我们叫做Android初始化语言。
Android初始化语言由四大类型的声明组成，即Actions（动作）、Commands（命令）、Services（服务）、以及Options（选项）。</p>
<h4 id="Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。"><a href="#Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。" class="headerlink" title="Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。"></a>Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。</h4><p>语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; html-script: false ]</div><div class="line">    on &amp;lt;trigger&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div><div class="line">        &amp;lt;command&amp;gt;</div></pre></td></tr></table></figure></p>
<h4 id="Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。"><a href="#Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。" class="headerlink" title="Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。"></a>Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。</h4><p>语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; html-script: false ]</div><div class="line">service &amp;lt;name&amp;gt; &amp;lt;pathname&amp;gt; [&amp;lt;argument&amp;gt;]*</div><div class="line">    &amp;lt;option&amp;gt;</div><div class="line">    &amp;lt;option&amp;gt;</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h4 id="Options（选项）"><a href="#Options（选项）" class="headerlink" title="Options（选项）"></a>Options（选项）</h4><p>选项是对服务的描述。它们影响init进程如何以及何时启动服务。
咱们来看看默认的init.rc文件。这里我只列出了主要的事件以及服务。
Table
|—|—|
|Action/Service|    描述|
|on early-init    |设置init进程以及它创建的子进程的优先级，设置init进程的安全环境|
|on init    |设置全局环境，为cpu accounting创建cgroup(资源控制)挂载点|
|on fs    |挂载mtd分区|
|on post-fs    |改变系统目录的访问权限|
|on post-fs-data    |改变/data目录以及它的子目录的访问权限|
|on boot    |基本网络的初始化，内存管理等等|
|service servicemanager    |启动系统管理器管理所有的本地服务，比如位置、音频、Shared preference等等…|
|service zygote    |启动zygote作为应用进程|
在这个阶段你可以在设备的屏幕上看到“Android”logo了。</p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>在Java中，我们知道不同的虚拟机实例会为不同的应用分配不同的内存。假如Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。Zygote是一个虚拟器进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是Android SDK或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。</p>
<p>Zygote加载进程</p>
<ol>
<li>加载ZygoteInit类，源代码：<code>/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></li>
<li>registerZygoteSocket()为zygote命令连接注册一个服务器套接字。</li>
<li>preloadClassed “preloaded-classes”是一个简单的包含一系列需要预加载类的文本文件，你可以在<android source="">/frameworks/base找到“preloaded-classes”文件。</android></li>
<li>preloadResources() preloadResources也意味着本地主题、布局以及android.R文件中包含的所有东西都会用这个方法加载。
在这个阶段，你可以看到启动动画。</li>
</ol>
<h3 id="第六步：系统服务或服务"><a href="#第六步：系统服务或服务" class="headerlink" title="第六步：系统服务或服务"></a>第六步：系统服务或服务</h3><p>完成了上面几步之后，运行环境请求Zygote运行系统服务。系统服务同时使用native以及java编写，系统服务可以认为是一个进程。同一个系统服务在Android SDK可以以System Services形式获得。系统服务包含了所有的System Services。</p>
<p>Zygote创建新的进程去启动系统服务。你可以在ZygoteInit类的”startSystemServer”方法中找到源代码。</p>
<p>核心服务：</p>
<ol>
<li>启动电源管理器；</li>
<li>创建Activity管理器；</li>
<li>启动电话注册；</li>
<li>启动包管理器；</li>
<li>设置Activity管理服务为系统进程；</li>
<li>启动上下文管理器；</li>
<li>启动系统Context Providers；</li>
<li>启动电池服务；</li>
<li>启动定时管理器；</li>
<li>启动传感服务；</li>
<li>启动窗口管理器；</li>
<li>启动蓝牙服务；</li>
<li>启动挂载服务</li>
</ol>
<p>其他服务：</p>
<ol>
<li>启动状态栏服务；</li>
<li>启动硬件服务；</li>
<li>启动网络状态服务；</li>
<li>启动网络连接服务；</li>
<li>启动通知管理器；</li>
<li>启动设备存储监视服务；</li>
<li>启动定位管理器；</li>
<li>启动搜索服务；</li>
<li>启动剪切板服务；</li>
<li>启动登记服务；</li>
<li>启动壁纸服务；</li>
<li>启动音频服务；</li>
<li>启动耳机监听；</li>
<li>启动AdbSettingsObserver（处理adb命令）。</li>
</ol>
<h3 id="第七步：引导完成"><a href="#第七步：引导完成" class="headerlink" title="第七步：引导完成"></a>第七步：引导完成</h3><p>一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;A当按下Android设备电源键时究竟发生了什么？&lt;/li&gt;
&lt;li&gt;Android的启动过程是怎么样的？&lt;/li&gt;
&lt;li&gt;A什么是Linux内核？&lt;/li&gt;
&lt;li&gt;A桌面系统linux内核与Android系统linux内核有什么区别？&lt;/li&gt;
&lt;li&gt;A
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>解决方案之美团APP对Crash的治理之路</title>
    <link href="http://wodekouwei.com/2019/03/05/tips-solution-2/"/>
    <id>http://wodekouwei.com/2019/03/05/tips-solution-2/</id>
    <published>2019-03-05T02:06:36.000Z</published>
    <updated>2019-03-05T14:36:16.604Z</updated>
    
    <content type="html"><![CDATA[<p>Crash率是衡量一款APP质量好坏的重要指标之一，不仅会影响用户体验，也可能影响用户存量。一旦出现问题，可能会给企业带来严重损失。</p>
<p>本文由美团技术专家谌天洲分享美团APP Crash率从千分之一到万分之一治理过程中所做的大量实践工作。</p>
<h3 id="美团Crash治理背景"><a href="#美团Crash治理背景" class="headerlink" title="美团Crash治理背景"></a>美团Crash治理背景</h3><p>美团作为一个平台化的APP，背后有20+团队设计和30+业务。</p>
<p>在Crash治理过程中面对的挑战有三项：体量大、迭代快和日活高。这三项挑战带来的直接影响是沟通成本上升和防范难度加大。因此在实际治理过程，主要围绕基础能力、治理效率两个层面进行探索和优化建设。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223013.jpg" alt="tips-solution-2-201935223013"></p>
<h4 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h4><p>Crash治理的基础能力主要体现在三个层面：能发现、能定位和能修复。</p>
<p>在发现能力层面，美团有一套异常监控退出系统，可发现除Java&amp;JNI Crash&amp;ANR以外其他类型的异常退出。在定位能力层面，有可提供内存泄漏路径及OOM时的内存快照的内存监控体系，有可提供线程现场及任务现场的线程管控体系。除此以外，还有动态日志系统提供额外的方法调用链及参数信息。</p>
<h4 id="内存监控体系"><a href="#内存监控体系" class="headerlink" title="内存监控体系"></a>内存监控体系</h4><p>内存问题最典型的呈现形式是OOM，其中80%通过Leak监控系统发现预防，另外20%的内存问题，对于大体量APP需要从全局对内存资源问题进行监控和调查分析。</p>
<p>美团的内存监控体系分为线下和线上两个场景。线下通过Leak监控系统能预防发现80%的OOM问题，线上建立随时获取OOM内存现场的监控能力
<img src="http://images.wodekouwei.com/tips-solution-2-201935223125.jpg" alt="tips-solution-2-201935223125"></p>
<h4 id="动态日志"><a href="#动态日志" class="headerlink" title="动态日志"></a>动态日志</h4><p>美团APP经常会遇到用户个性化的使用场景无法复现和定位的问题。对此，美团提出了一套动态日志系统——</p>
<p>在编译期对应用代码通过插桩实现代理，运行期同步记录，出现异常时可主动触发上报，也可以由服务端主动回捞。基于插桩实现的代理逻辑，可实施获取原方法执行时的方法名、入参和返回值信息，再将这些信息序列化后存储到数据库，由此可在必要的时候获取到较完善的方法调用栈历史，进而定位问题。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223215.jpg" alt="tips-solution-2-201935223215">
<img src="http://images.wodekouwei.com/tips-solution-2-201935223229.jpg" alt="tips-solution-2-201935223229"></p>
<h4 id="修复能力"><a href="#修复能力" class="headerlink" title="修复能力"></a>修复能力</h4><p>在修复能力层面，美团APP一度深受机型多、系统杂带来的framework层的问题困扰。此外，美团APP也经常会遇到常规日志体系无法覆盖的接口问题。</p>
<p>针对这两类问题，参考热修复的方法替换原理，开发并完善了一套小工具——“Graft”。它的基本原理是在native层通过方法替换实现对Java层方法的hook和代理，进而在Java层实现方法代理和方法替换。</p>
<p>这套工具可以动态代理或替换几乎所有Java层的方法（包括framework层），使得美团APP的修复能力从自有代码和第三方代码有效覆盖到framework层。</p>
<p><img src="http://images.wodekouwei.com/tips-solution-2-201935223340.jpg" alt="tips-solution-2-201935223340">
<img src="http://images.wodekouwei.com/tips-solution-2-201935223353.jpg" alt="tips-solution-2-201935223353"></p>
<h4 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h4><p>为了提高治理效率，实际治理过程逐渐形成PR检查流程、自动检查平台和Crash平台三大流程和平台。</p>
<p>PR检查流程主要针对PR阶段进行代码规范性检查、代码准入检查和稳定性案例检查；自动检查平台针对以往案例进行定制化防范检查。Crash平台是整个稳定性治理的核心，在建设的考量中主要遵循规范化、流程化、自动化，它主要涵盖接入管控、聚合策略、频道工单、报警系统、基础工具、模块覆盖，可以通过强大的复用能力快速接入并管理几乎所有稳定性相关的问题。
<img src="http://images.wodekouwei.com/tips-solution-2-201935223433.jpg" alt="tips-solution-2-201935223433"></p>
<h3 id="Crash平台"><a href="#Crash平台" class="headerlink" title="Crash平台"></a>Crash平台</h3><p>Crash平台是整个稳定性治理的核心，在建设的考量中主要遵循规范化、流程化、自动化，它主要涵盖接入管控、聚合策略、频道工单、报警系统、基础工具、模块覆盖，可以通过强大的复用能力快速接入并管理几乎所有稳定性相关的问题。</p>
<p>在PR阶段，PR检查流程可自动识别出增量代码是否被现有体系覆盖，并通过Crash平台的接入管控系统督促增量代码的责任人完善基本信息、频道信息、聚合配合及自动工单配置等等。</p>
<p>在开发或全量过程中一旦发现异常，Crash平台会自动完成堆栈聚合、频道识别、报警评估及工单跟踪等工作。</p>
<p><img src="http://images.wodekouwei.com/tips-solution-2-201935223539.jpg" alt="tips-solution-2-201935223539">
<img src="http://images.wodekouwei.com/tips-solution-2-20193522365.jpg" alt="tips-solution-2-20193522365"></p>
<p>Crash率是APP最重要的指标之一，谌天洲建议开发者建立解决Crash的长效机制，找到最合理的解决方案。随着版本的不断迭代，Crash治理之路才能离目标越来越近。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Crash率是衡量一款APP质量好坏的重要指标之一，不仅会影响用户体验，也可能影响用户存量。一旦出现问题，可能会给企业带来严重损失。&lt;/p&gt;
&lt;p&gt;本文由美团技术专家谌天洲分享美团APP Crash率从千分之一到万分之一治理过程中所做的大量实践工作。&lt;/p&gt;
&lt;h3 id=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能度量指标及数据平台</title>
    <link href="http://wodekouwei.com/2019/03/04/tips-solution-1/"/>
    <id>http://wodekouwei.com/2019/03/04/tips-solution-1/</id>
    <published>2019-03-04T15:25:17.000Z</published>
    <updated>2019-03-05T06:11:50.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能和稳定性系统化提升方案"><a href="#性能和稳定性系统化提升方案" class="headerlink" title="性能和稳定性系统化提升方案"></a>性能和稳定性系统化提升方案</h2><h3 id="高可用平台的定义及指标-自动化测试框架和性能稳定性数据平台"><a href="#高可用平台的定义及指标-自动化测试框架和性能稳定性数据平台" class="headerlink" title="高可用平台的定义及指标,自动化测试框架和性能稳定性数据平台"></a>高可用平台的定义及指标,自动化测试框架和性能稳定性数据平台</h3><h4 id="高可用的定义及度量指标"><a href="#高可用的定义及度量指标" class="headerlink" title="高可用的定义及度量指标"></a>高可用的定义及度量指标</h4><h5 id="移动端高可用定义"><a href="#移动端高可用定义" class="headerlink" title="移动端高可用定义"></a>移动端高可用定义</h5><p>移动端高可用旨在通过设计关键的度量指标,以期望能够客观反映和量化用户再使用过程中的真是感受,同时通过指标，建⽴一系列的工具和平台，从线下到线上快速发现、分析、定位和解决包括稳定性、性能、功能等各类问题，以进一步提升用户体验的系统化解决方案。</p>
<h5 id="可高勇度量指标"><a href="#可高勇度量指标" class="headerlink" title="可高勇度量指标"></a>可高勇度量指标</h5><p>高可用度量指标由 <strong>性能</strong> 和 <strong>稳定性</strong> 两大度量指标组成。性能度量指标有七个维度，分别是卡顿率、启动时长、页面秒开率、帧率、ANR率、流量、耗电；稳定性度量指标主要是Crash率，分为Java Crash率和Native Crash率。</p>
<p><img src="http://images.wodekouwei.com/tips-solution-1-201935105618.jpg" alt="tips-solution-1-201935105618"></p>
<h4 id="自动化测试框架及性能稳定性数据平台"><a href="#自动化测试框架及性能稳定性数据平台" class="headerlink" title="自动化测试框架及性能稳定性数据平台"></a>自动化测试框架及性能稳定性数据平台</h4><h5 id="自动化测试框架"><a href="#自动化测试框架" class="headerlink" title="自动化测试框架"></a>自动化测试框架</h5><h5 id="性能稳定性数据平台"><a href="#性能稳定性数据平台" class="headerlink" title="性能稳定性数据平台"></a>性能稳定性数据平台</h5><p>性能稳定性数据平台，由四个模块组成，用来展示各个维度的监控数据。
<img src="http://images.wodekouwei.com/tips-solution-1-201935111941.jpg" alt="tips-solution-1-201935111941"></p>
<h6 id="1-崩溃分析"><a href="#1-崩溃分析" class="headerlink" title="1.崩溃分析"></a>1.崩溃分析</h6><p>主要是Java Crash和Native Crash分析，Java Crash包含了Crash当时调用栈，当前页面、用户历史访问页面、当前内存水位以及logcat信息，帮助开发同学快速分析Java崩溃的原因，从而快速解决问题。Native崩溃主要包含了崩溃的信号量、崩溃使用的调用栈、其他线程的调度栈、logcat信息以及已加载的so信息，通过这些信息，可以让开发同学快速地发现Native崩溃原因。</p>
<h6 id="2-异常分析"><a href="#2-异常分析" class="headerlink" title="2.异常分析"></a>2.异常分析</h6><p>各个性能维度的指标会在这里展示，主线程卡顿主要是哪条消息超过了阈值，它的调用栈是什么样子的。ANR展示的主要是/data/anr下的文件信息，发生ANR的现场是什么样子的。主线程IO这块展示的是主线程操作IO的一些调用栈以及它的耗时。内存泄露这块分两部分，Java泄露组件的名称，Native泄露的so名称，通过这两部分可以快速地定位内存泄露的原因。资源泄露这块主要展示开发同学调用资源open时的调用栈信息。</p>
<h6 id="3-性能APM"><a href="#3-性能APM" class="headerlink" title="3.性能APM"></a>3.性能APM</h6><p>启动性能监控了用户点击图标到真正进入页面可视可交互的时间。页面性能是从点击页面图表到下一个页面真正可视可交互的时间。系统监控启动所有阶段子任务的耗时，通过数据变化决策版本的发布是否符合质量标准。如果符合质量标准，可以发布；如果不符合，再进一步分析子任务耗时，具体是哪些任务导致不能正常发布。快速地定位分析，最终解决问题。手淘把数据能力开放给各个业务，通过他们个性化的需求自定义配置性能报表。</p>
<h6 id="4-远程工具"><a href="#4-远程工具" class="headerlink" title="4.远程工具"></a>4.远程工具</h6><p>远程工具主要是针对特殊用户的特殊案例。当线上用户向舆情平台反馈设备存在某一个性能问题时，通过这个工具，快速地从用户那里获取远程日志、Dump内存和每个方法的耗时，快速分析原因，从而给出解决方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;性能和稳定性系统化提升方案&quot;&gt;&lt;a href=&quot;#性能和稳定性系统化提升方案&quot; class=&quot;headerlink&quot; title=&quot;性能和稳定性系统化提升方案&quot;&gt;&lt;/a&gt;性能和稳定性系统化提升方案&lt;/h2&gt;&lt;h3 id=&quot;高可用平台的定义及指标-自动化测试框架和性
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Android系统图形栈(一):OpenGL 介绍</title>
    <link href="http://wodekouwei.com/2019/03/01/gl-introduce/"/>
    <id>http://wodekouwei.com/2019/03/01/gl-introduce/</id>
    <published>2019-03-01T10:06:18.000Z</published>
    <updated>2019-03-01T10:22:21.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OpenGL基本概念"><a href="#OpenGL基本概念" class="headerlink" title="OpenGL基本概念"></a>OpenGL基本概念</h3><p>OpenGL的结构可以从逻辑上划分为下面3个部分:</p>
<ul>
<li>图元(Primitives)</li>
<li>缓冲区(Buffers)</li>
<li>光栅化(Rasterize)</li>
</ul>
<h4 id="图元-Primitives"><a href="#图元-Primitives" class="headerlink" title="图元(Primitives)"></a>图元(Primitives)</h4><p>在 OpenGL 的世界里，我们只能画点、线、三角形这三种基本图形，而其它复杂的图形都可以通过三角形来组成。所以这里的图元指的就是这三种基础图形：</p>
<ul>
<li>点：点存在于三维空间，坐标用（x,y,z）表示。</li>
<li>线：由两个三维空间中的点组成。</li>
<li>三角形：由三个三维空间的点组成。</li>
</ul>
<h4 id="缓冲区（Buffers）"><a href="#缓冲区（Buffers）" class="headerlink" title="缓冲区（Buffers）"></a>缓冲区（Buffers）</h4><p>OpenGL 中主要有 3 种 Buffer：</p>
<ul>
<li>帧缓冲区（Frame Buffers） 帧缓冲区：这个是存储OpenGL 最终渲染输出结果的地方，它是一个包含多个图像的集合，例如颜色图像、深度图像、模板图像等。</li>
<li>渲染缓冲区（Render Buffers） 渲染缓冲区：渲染缓冲区就是一个图像，它是 Frame Buffer 的一个子集。</li>
<li>缓冲区对象（Buffer Objects） 缓冲区对象就是程序员输入到 OpenGL 的数据，分为结构类和索引类的。前者被称为“数组缓冲区对象”或“顶点缓冲区对象”（“Array Buffer Object”或“Vertex Buff er Object”），即用来描述模型的数组，如顶点数组、纹理数组等； 后者被称为“索引缓冲区对象”（“Index Buffer Object”），是对上述数组的索引。</li>
</ul>
<h4 id="光栅化（Rasterize）"><a href="#光栅化（Rasterize）" class="headerlink" title="光栅化（Rasterize）"></a>光栅化（Rasterize）</h4><p>在介绍光栅化之前，首先来补充 OpenGL 中的两个非常重要的概念：</p>
<ul>
<li>Vertex Vertex 就是图形中顶点，一系列的顶点就围成了一个图形。</li>
<li>Fragment Fragment 是三维空间的点、线、三角形这些基本图元映射到二维平面上的映射区域，通常一个 Fragment 对应于屏幕上的一个像素，但高分辨率的屏幕可能会用多个像素点映射到一个 Fragment，以减少 GPU 的工作。</li>
</ul>
<p>而光栅化是把点、线、三角形映射到屏幕上的像素点的过程。</p>
<h4 id="着色器程序（Shader）"><a href="#着色器程序（Shader）" class="headerlink" title="着色器程序（Shader）"></a>着色器程序（Shader）</h4><p>Shader 用来描述如何绘制（渲染），GLSL 是 OpenGL 的编程语言，全称 OpenGL Shader Language，它的语法类似于 C 语言。OpenGL 渲染需要两种 Shader：Vertex Shader 和 Fragment Shader。</p>
<ul>
<li>Vertex Shader Vertex Shader 对于3D模型网格的每个顶点执行一次，主要是确定该顶点的最终位置。</li>
<li>Fragment Shader Fragment Shader对光栅化之后2D图像中的每个像素处理一次。3D物体的表面最终显示成什么样将由它决定，例如为模型的可见表面添加纹理，处理光照、阴影的影响等等。</li>
</ul>
<h4 id="OpenGL-流水线"><a href="#OpenGL-流水线" class="headerlink" title="OpenGL 流水线"></a>OpenGL 流水线</h4><p>OpenGL 中有两种流水线，一种是固定流水线，另外一种则是可编程流水线。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OpenGL基本概念&quot;&gt;&lt;a href=&quot;#OpenGL基本概念&quot; class=&quot;headerlink&quot; title=&quot;OpenGL基本概念&quot;&gt;&lt;/a&gt;OpenGL基本概念&lt;/h3&gt;&lt;p&gt;OpenGL的结构可以从逻辑上划分为下面3个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li
    
    </summary>
    
      <category term="OpenGL" scheme="http://wodekouwei.com/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="http://wodekouwei.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>软件架构思考</title>
    <link href="http://wodekouwei.com/2019/03/01/tips-engineering/"/>
    <id>http://wodekouwei.com/2019/03/01/tips-engineering/</id>
    <published>2019-03-01T06:07:48.000Z</published>
    <updated>2019-03-01T06:30:35.766Z</updated>
    
    <content type="html"><![CDATA[<p>架构是对工程整体结构与组件的抽象描述，是软件工程的基础骨架。架构在工程层面不分领域，且思想是通用的。引用维基百科对于软件架构的定义：</p>
<blockquote>
<p>软件体系结构是构建计算机软件实践的基础。与建筑师设定建筑项目的设计原则和目标，作为绘图员画图的基础一样，软件架构师或者系统架构师陈述软件架构以作为满足不同客户需求的实际系统设计方案的基础。从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。一个软件架构师需要有广泛的软件理论知识和相应的经验来实施和管理软件产品的高级设计。软件架构师定义和设计软件的模块化，模块之间的交互，用户界面风格，对外接口方法，创新的设计特性，以及高层事物的对象操作、逻辑和流程。</p>
</blockquote>
<p>架构的合理设计可以解决面对复杂系统时可能面临的很多问题，例如：</p>
<ol>
<li>业务边界与模块职责划分问题</li>
<li>代码权限控制问题（数据库不应直接被业务方调用）</li>
<li>代码重复，逻辑分支多，坏味道多的问题</li>
<li>由于考虑不周，可能存在隐藏bug</li>
<li>修改一个逻辑需要修改N个地方代码逻辑</li>
</ol>
<p>移动端通用架构:</p>
<ol>
<li>Toolkit/ToolkitSDK module :工具类及与工具类相关的SDK的集合。工具类属于工程架构里最基础的模块，提供了通用的方法与工具类服务（工具类服务是指可以被抽象成一个独立的与业务无关的基础服务，如缓存、数据库操作等）。工具类通常作为最底层的module，被其他所有模块引用。</li>
<li>基础组件库/基础组件库module:基础组件库提供与业务相关的基础组件，是构建一个移动端应用所需要的通用组件的集合。它与工具类的区别在于基础组件库可能会包含少量业务逻辑代码，是无法拆分给其他应用使用的；另一方面，基础组件库是基础服务接口的实现，是不对业务层暴露的，避免了业务层与基础SDK打交道，有利于整体替换底层基础框架的实现（例如Volley替换为OkHttp、Fresco替换为Glide）</li>
<li>基础服务接口/业务服务接口module:基础服务接口声明了一组通用的基础服务，业务层通过基础服务接口获取基础服务，如网络请求、图片加载等。业务服务接口声明了一组该模块提供给其他模块的服务，业务之间的通信也是通过服务接口来完成的。例如首页模块需要获取购物车的商品数量，首先通过服务调度中心获取购物车的服务接口，再通过服务接口调用购物车获取商品数量的接口方法即可。</li>
<li>服务调度中心module:服务调度中心，是一个接口收集与管理的容器。服务调度中心将所有基础服务接口与业务接口收集起来，通过一定的方式与它们的实现类进行绑定。所有的业务都需要通过服务调度中心才能够获取到服务。服务的注册与发现和Spring容器的IoC思想是类似的</li>
<li>业务module:务层是每个业务的具体实现的集合。业务层的业务之间是没有直接引用关系的，业务层提供了业务服务接口中暴露的服务的具体实现。业务之间的通信需要通过服务调度中心获取其他业务的服务接口。</li>
</ol>
<p>后端通用架构:</p>
<ol>
<li>展示层（View）:展示层是系统与用户打交道的地方，提供与用户交互的界面。对于用户而言，只有展示层是可见的、可操作的。展示层对于某些工程来说不是必须的，例如提供纯后台服务的工程。</li>
<li>控制层（Controller）:主要负责与Model和View打交道，但同时又保持其相对独立。Controller决定使用哪些Model，对Model执行什么操作，为视图准备哪些数据，是MVC中沟通的桥梁。在Controller层提供了http服务供展示层调用。在依赖管理中，控制层需要依赖服务层提供服务。</li>
<li>服务层（Service/Facade）:服务层是业务逻辑实现的地方，上层需要使用的功能都在服务层来实现具体的业务逻辑。服务层就是将底层的数据通过一定的条件和方式进行数据组装并提供给上层调用。服务层可以拆分为业务接口和业务实现，业务实现可以对外部隐藏。在投放工程中，控制层既依赖了业务接口，又依赖了业务实现。后面的改造我们可以看到，编译期红色线依赖是完全没有必要的。服务层需要依赖数据关系映射层与持久层的数据打交道。</li>
<li>对象关系映射层（ORM）:对象关系映射层的作用是在持久层和业务实体对象之间作一层数据实体的映射，这样在具体操作业务对象时，只需简单的操作对象的属性和方法，不需要去和复杂的SQL语句打交道。ORM使得业务不需要关心底层数据库的任何细节，包括使用的数据库类型、数据库连接与释放细节等。对象关系映射层只依赖数据服务层提供服务。</li>
<li>数据服务层（Data Server）:数据服务就是提供数据源的地方。数据服务可以提供持久化数据及缓存数据。持久，即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。而缓存是将信息（数据或页面）放在内存中以避免频繁的数据库存储或执行整个页面的生命周期，直到缓存的信息过期或依赖变更才再次从数据库中读取数据或重新执行页面的生命周期。数据服务层是数据源头，处于架构的最底层。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构是对工程整体结构与组件的抽象描述，是软件工程的基础骨架。架构在工程层面不分领域，且思想是通用的。引用维基百科对于软件架构的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;软件体系结构是构建计算机软件实践的基础。与建筑师设定建筑项目的设计原则和目标，作为绘图员画图的基础一
    
    </summary>
    
      <category term="tips" scheme="http://wodekouwei.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>android自动化测试(三):常见问题</title>
    <link href="http://wodekouwei.com/2019/02/28/at-android-issue/"/>
    <id>http://wodekouwei.com/2019/02/28/at-android-issue/</id>
    <published>2019-02-28T09:36:00.000Z</published>
    <updated>2019-02-28T09:46:55.985Z</updated>
    
    <content type="html"><![CDATA[<p>####### 1.appium执行登录按钮的click在华为(FRD-AL10)手机上执行完不起作用
最开始怀疑是因为输入法遮挡,后来调用hide_keyboard后无法隐藏键盘(在三星手机Samsung SM-N9200上调用hide_keyboard会抛异常,华为手机不显示输入法调用也没有问题),最后在设置-系统设置-语言和输入法中关闭”安全输入”,软件盘就不再弹出了,但是还是执行完不生效,最后appium中指定automationName=UiAutomator2,使用UiAutomator2后该问题得到解决.</p>
<p>有人说需要打开安全设置中的”允许模拟点击”,但是并没有找到这个开关</p>
<p>注意:元素必须先出现在页面上，才可以使用click/tap方法。所以需要先使用isDisplay()方法判读该元素出现， 然后点击该元素。但是有可能即使isDisplay()返回的结果为true， 该元素还会因为不可见而点击报错。因为虽然该元素的isDisplay()返回了true，但是该元素的中心点可能仍然不在屏幕上。 tap方法其实点击的就是元素的中心点。可以使用swipe方法再滑动一下屏幕让这个元素完全显示在屏幕上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####### 1.appium执行登录按钮的click在华为(FRD-AL10)手机上执行完不起作用
最开始怀疑是因为输入法遮挡,后来调用hide_keyboard后无法隐藏键盘(在三星手机Samsung SM-N9200上调用hide_keyboard会抛异常,华为手机
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>at-android-appium-introduce</title>
    <link href="http://wodekouwei.com/2019/02/28/at-android-appium-introduce/"/>
    <id>http://wodekouwei.com/2019/02/28/at-android-appium-introduce/</id>
    <published>2019-02-28T03:45:15.000Z</published>
    <updated>2019-02-28T03:45:41.084Z</updated>
    
    <content type="html"><![CDATA[<p>Appium UiAutomator2 Server 运行原理分析
<a href="https://testerhome.com/topics/9240" target="_blank" rel="external">https://testerhome.com/topics/9240</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Appium UiAutomator2 Server 运行原理分析
&lt;a href=&quot;https://testerhome.com/topics/9240&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://testerhome.com/topi
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>android自动化测试(N):UiAutomator用法</title>
    <link href="http://wodekouwei.com/2019/02/28/at-android-uiautomator-usage/"/>
    <id>http://wodekouwei.com/2019/02/28/at-android-uiautomator-usage/</id>
    <published>2019-02-28T03:09:22.000Z</published>
    <updated>2019-02-28T04:14:42.449Z</updated>
    
    <content type="html"><![CDATA[<p>它是一个Android自动化测试框架，是谷歌在Android4.1版本发布时推出的一款用Java编写的UI测试框架。它只能用于UI也就是黑盒方面的测试。所以UiAutomator只能运行在4.1以后的版本中。其最大的特点就是可以跨进程操作，我们可以使用uiautomator框架提供的一些方便的API来对安卓应用进行一系列的自动化测试操作，如点击、滑动、键盘输入、长按以及常用的断言方法等。可以替代以前繁琐的手工测试。</p>
<p>下面总结一下该框架的几个优点：</p>
<ol>
<li>Google自家推出的，其稳定性和后续的维护更新可以得到保障，运行时也有更多的权限。</li>
<li>可以跨进程操作，这点比起其它基于instrumentation框架的自动化工具如Robotium是无法直接做到的。</li>
<li>运行速度快。
缺点：</li>
<li>不支持Android4.1以下的版本。</li>
<li>不支持Webview，所以一般无法对浏览器应用进行测试。</li>
</ol>
<h6 id="UiAutomator-框架原理分析："><a href="#UiAutomator-框架原理分析：" class="headerlink" title="UiAutomator 框架原理分析："></a>UiAutomator 框架原理分析：</h6><p>首先，UiAutomator是Google参考微软的UiAutomation提供的一套用在Android上的自动化测试框架。基于Android AccessilibilityService提供。那么至于什么是AccessilibilityService，在这里简单介绍下：Android AccessilibilityService，是一个可访问服务，它是一个为增强用户界面并帮助残疾用户的应用程序，或者用户可能无法完全与设备的交互。举个简单的例子，假如一个用户在开车。那么用户就有可能需要添加额外的或者替代的用户反馈方式。其应用方式一般有两种：</p>
<p>第一种方法是：UiAutomatorView + monkey。它与hierachyview + monkey差不多。其区别是：UiAutomatorView通过ADB向设备侧发送一个dump命令，而不是建立一个socket，下载一个包含当前界面控件布局信息的xml文件。相比较hierachyview下载的内容而言，该文件小很多。因此，从效率上讲，这种方法比第一种应用模式快很多。</p>
<p>第二种方法是： 直接调用UiAutomator框架对外提供的API，主要有UiDevice、UiSelector、UiObject和 UiScrollable等。其原理与第一种方式即HierachyView + Monkey差不多。其过程大致是：首先，UiAutomator测试框架通过Accessibilityservice，获取当前窗口的控件层次关系及属性信息，并查找到目标控件。若是点击事件，则计算出该控件的中心点坐标。其次，UiAutomator通过 InputManager.getInstance().injectInputEvent隐藏接口来注入用户事件（点击、输入类操作），从而实现跨进程自动化的目的。</p>
<p>UiAutomatorTestCase ：这个类是继承自Junit TestCase （Junit），对外提供setup、teardown等，以便初始化用例、清除环境等。所以我们在编写的UiAutomator 的脚本时一般都要继承这个类，这样就可以直接使用它的一些方法和Junit单元测试框架中的Assert断言机制。</p>
<h6 id="UIAutomator2-0"><a href="#UIAutomator2-0" class="headerlink" title="UIAutomator2.0"></a>UIAutomator2.0</h6><p>We’re pleased to announce the release of UIAutomator 2.0! This version is a significant update from the previous release. Most importantly, UI Automator is now based on Android Instrumentation and you can build and run tests with the ‘./gradlew connectedCheck’ command.</p>
<p>UiAutomator2.0的jar包并不是在以前SDK/platforms/android-19/下。现在我们要这么做</p>
<ol>
<li>通过Android SDK Manager中的 Android Support Repository 项进行安装</li>
<li>下载下来的jar包的路径为/extras/android/m2repository</li>
<li>新建一个android项目，编写一个简单的应用</li>
<li><p>在build.gradle中配置依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  androidTestCompile &apos;com.android.support.test:runner:0.3&apos;</div><div class="line">  // Set this dependency to use JUnit 4 rules</div><div class="line">  androidTestCompile &apos;com.android.support.test:rules:0.3&apos;</div><div class="line">  // Set this dependency to build and run Espresso tests</div><div class="line">  androidTestCompile &apos;com.android.support.test.espresso:espresso-core:2.2&apos;</div><div class="line">  // Set this dependency to build and run UI Automator tests</div><div class="line">  androidTestCompile &apos;com.android.support.test.uiautomator:uiautomator-v18:2.1.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设置AndroidJunitRunner为默认的testInstrumentationRunner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编写测试代码，在androidTest目录下面新建测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class LoginTest extends InstrumentationTestCase &#123;</div><div class="line"></div><div class="line">    protected UiDevice device = null;</div><div class="line">    protected String appName = &quot;magicCard&quot;;</div><div class="line"></div><div class="line">    public void runApp(String appName) throws UiObjectNotFoundException, RemoteException &#123;</div><div class="line">        device = UiDevice.getInstance(getInstrumentation());</div><div class="line">        device.pressHome();</div><div class="line">        device.waitForWindowUpdate(&quot;&quot;, 2000);</div><div class="line"></div><div class="line">        UiObject2 allAppsButton = device.findObject(By.desc(&quot;Apps&quot;));</div><div class="line">        allAppsButton.click();</div><div class="line">        device.waitForWindowUpdate(&quot;&quot;, 2000);</div><div class="line"></div><div class="line">        UiScrollable appViews = new UiScrollable(new UiSelector().scrollable(true));</div><div class="line">        appViews.setAsHorizontalList();</div><div class="line"></div><div class="line">        UiObject settingsApp = appViews.getChildByText(new UiSelector().className(TextView.class.getName()), appName);</div><div class="line">        settingsApp.clickAndWaitForNewWindow();</div><div class="line"></div><div class="line">        assertTrue(&quot;Unable to detect app&quot;, settingsApp != null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setUp() throws RemoteException, UiObjectNotFoundException &#123;</div><div class="line">        this.runApp(appName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void tearDown() throws RemoteException, UiObjectNotFoundException &#123;</div><div class="line">        //Empty for the moment</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void testUS1() &#123;</div><div class="line">        UiObject2 usernameLabel = device.findObject(By.clazz(TextView.class.getName()).text(&quot;Username&quot;));</div><div class="line">        assertTrue(&quot;Username label not found&quot;, usernameLabel != null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>基于Instrument的方便一点就是不需要remote debug的方式进行调试。并且做参数化之类的也方便了很多。
2.0不用再继承UiAutomatorTestCase，但却需要继承InstrumentationTestCase。</p>
<p>获取设备的方式也变化了，UiDevice.getInstance(getInstrumentation()) 这才是正确的使用方法。之前常用的两种方式都不再可行。</p>
<p>可以通过如下的adb命令调用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am instrument -w -r   -e debug false -e class com.cxq.uiautomatordemo.UiTest com.cxq.uiautomatordemo.test/android.test.InstrumentationTestRunner</div></pre></td></tr></table></figure></p>
<p>在dependencies中用到了compile、testCompile、androidTestCompile三种依赖方式，让我们来看看他们有什么区别：</p>
<p>compile：参与编译，并且会打包到debug/release apk中。
testCompile：只参与单元测试编译，不会打包到debug/release apk包中，不需要设备支持。
androidTestCompile：只参与UI测试编译，不会打包到debug/release apk包中，需要设备支持。</p>
<p>除此之外还有Provided、APK、Debug compile和Release compile：</p>
<p>Provided：只参与编译，不会打包到debug/release apk中。
APK：不参与编译，只会打包到debug/release apk中。
Debug compile：只参与debug编译，只会打包到debug apk中。
Release compile：只参与release编译，只会打包到release apk中。</p>
<h6 id="UIAutomator1-0"><a href="#UIAutomator1-0" class="headerlink" title="UIAutomator1.0"></a>UIAutomator1.0</h6><ol>
<li>新建Java工程</li>
<li>导入lib包 android.jar 和 uiautomator.jar ，选中点击右键Add to buildPath</li>
<li><p>新建测试类demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class Demo extends UiAutomatorTestCase&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>写测试方法A，B，C（testcase）</p>
</li>
<li>编译运行：
5.1. <code>&lt;android-sdk&gt;/tools/android create uitest-project -n &lt;name&gt; -t 1 -p &lt;path&gt;</code>
说明一下各个参数的作用，如果已经将android sdk的路径配置到了系统的path中，输入命令“android create uitest-project”就可以查看到相应的帮助</li>
</ol>
<ul>
<li><code>-n --name : Project name.</code>  就是在eclipse中创建的项目的名字。</li>
<li><code>-t --target  : Target ID of the new project. [required]</code>  这个id是本机上android targets的id，可以通过命令 “android list”来查询，得到结果，选择android-17以上版本前面所对应的id,运行完成后，工作空间下生成文件build.xml</li>
</ul>
<p>5.2. 修改build.xml 将help改为build
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;            </div><div class="line">&lt;project name=&quot;demo1&quot; default=&quot;build&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>5.3.在build.xml上点击右键，选择“Run As” -&gt; “Ant Build”,编译成功，在工作空间bin下生成一个jar包demo.jar</p>
<p>5.4. <code>adb  push  demo.jar   /data/local/tmp/</code></p>
<p>5.5. <code>adb shell uiautomator runtest  demo.jar  -c A -c B -c C</code>（可指定多个testcase,不指定则运行所有)</p>
<p>uiautomator的help帮助：
支持三个子命令:rutest/dump/events</p>
<ul>
<li>runtest命令－c指定要测试的class文件，用逗号分开，没有指定的话默认执行测试脚本jar包的所有测试类.注意用户可以以格式$class/$method来指定只是测试该class的某一个指定的方法</li>
<li>runtest命令－e参数可以指定是否开启debug模式</li>
<li>runtest命令－e参数可以指定test runner，不指定就使用系统默认。我自己从来没有指定过</li>
<li>runtest命令－e参数还可以通过键值对来指定传递给测试类的参数</li>
</ul>
<p>UiAutomator2改进</p>
<ol>
<li>基于 Instrumentation，可以获取应用Context，使用 Android服务及接口</li>
<li>基于 Junit4，测试用例无需继承于任何父类，方法名不限，使用注解 Annotation进行</li>
<li>UI执行效率比 1.0 快，测试执行可使用AndroidJunit 方式及gradle 方式</li>
<li><p>API 更新，新增UiObject2、Until、By、BySelector等：APIFor UI Automator</p>
</li>
<li><p>Log 输出变更，以往使用System.out.print输出流回显至执行端，2.0 输出至Logcat</p>
</li>
</ol>
<p><a href="https://developer.android.com/reference/androidx/test/runner/AndroidJUnitRunner.html" target="_blank" rel="external">AndroidJUnitRunner</a>
<a href="https://developer.android.com/training/testing/junit-runner.html#using-android-test-orchestrator" target="_blank" rel="external">AndroidJUnitRunner</a>
<a href="https://developer.android.com/reference/android/test/InstrumentationTestRunner.html" target="_blank" rel="external">InstrumentationTestRunner</a>
<a href="https://developer.android.com/training/testing/fundamentals" target="_blank" rel="external">Fundamentals of Testing</a>
<a href="https://developer.android.com/training/testing/ui-automator.html#java" target="_blank" rel="external">UI Automator</a>
<a href="https://developer.android.com/reference/androidx/test/package-summary.html" target="_blank" rel="external">androidx.test</a>
<a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html" target="_blank" rel="external">Test UI for multiple apps</a>
<a href="https://developer.android.com/reference/android/app/Instrumentation.html" target="_blank" rel="external">Instrumentation</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;它是一个Android自动化测试框架，是谷歌在Android4.1版本发布时推出的一款用Java编写的UI测试框架。它只能用于UI也就是黑盒方面的测试。所以UiAutomator只能运行在4.1以后的版本中。其最大的特点就是可以跨进程操作，我们可以使用uiautomator
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Android TextView对URL识别</title>
    <link href="http://wodekouwei.com/2019/02/26/tips-android-weburl-regular/"/>
    <id>http://wodekouwei.com/2019/02/26/tips-android-weburl-regular/</id>
    <published>2019-02-26T03:32:25.000Z</published>
    <updated>2019-02-26T03:55:45.800Z</updated>
    
    <content type="html"><![CDATA[<p>IM开发过程中,对文本消息中的超练级进行点击处理,使用系统的<code>tv.setAutoLinkMask(Linkify.PHONE_NUMBERS | Linkify.WEB_URLS);</code>方法:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * 拦截超链接</div><div class="line">   */</div><div class="line">  public static void interceptHyperLink(TextView tv, ChatContext chatContext, int msg_type,</div><div class="line">      long msg_id, String send_ucid) &#123;</div><div class="line">    tv.setAutoLinkMask(Linkify.PHONE_NUMBERS | Linkify.WEB_URLS);</div><div class="line">    tv.setMovementMethod(LinkMovementMethod.getInstance());</div><div class="line">    CharSequence text = tv.getText();</div><div class="line">    if (text instanceof Spannable) &#123;</div><div class="line">      int end = text.length();</div><div class="line">      Spannable spannable = (Spannable) tv.getText();</div><div class="line">      URLSpan[] urlSpans = spannable.getSpans(0, end, URLSpan.class);</div><div class="line">      if (urlSpans.length == 0) &#123;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(text);</div><div class="line">      for (URLSpan uri : urlSpans) &#123;</div><div class="line">        String url = uri.getURL();</div><div class="line">        CustomURLSpan custom = new CustomURLSpan(url, chatContext, msg_type, msg_id, send_ucid);</div><div class="line">        spannableStringBuilder.setSpan(custom, spannableStringBuilder.getSpanStart(uri),</div><div class="line">            spannableStringBuilder.getSpanEnd(uri), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</div><div class="line">      &#125;</div><div class="line">      tv.setText(spannableStringBuilder);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>Android自带的表达式(android.util.Patterns)，在不同的ROM上表现形式是不一样的，在一些比较诡异的case上基本识别不出来,比如对于<code>http://lianjia.com/xxx 啊啊啊</code>这种连接,华为手机正常识别了,三星手机把后面的汉字也一起识别了,手机兼容性问题,最后只能自己写正则去匹配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line">public class LinkifySpannableUtils &#123;</div><div class="line"></div><div class="line">    public static LinkifySpannableUtils mInstance;</div><div class="line"></div><div class="line">    private Context mContext;</div><div class="line">    private TextView mTextView;</div><div class="line">    private SpannableStringBuilder mSpannableStringBuilder;</div><div class="line"></div><div class="line">    private LinkifySpannableUtils() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static LinkifySpannableUtils getInstance() &#123;</div><div class="line">        if (mInstance == null) &#123;</div><div class="line">            mInstance = new LinkifySpannableUtils();</div><div class="line">        &#125;</div><div class="line">        return mInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSpan(Context context, TextView textView) &#123;</div><div class="line">        this.mContext = context;</div><div class="line">        this.mTextView = textView;</div><div class="line">        addLinks();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void addLinks() &#123;</div><div class="line">        Linkify.addLinks(mTextView, WEB_URL, null);</div><div class="line">        Linkify.addLinks(mTextView, EMAIL_ADDRESS, null);</div><div class="line">        Linkify.addLinks(mTextView, PHONE, null);</div><div class="line"></div><div class="line">        CharSequence cSequence = mTextView.getText();</div><div class="line">        if (cSequence instanceof Spannable) &#123;</div><div class="line">            int end = mTextView.getText().length();</div><div class="line">            Spannable sp = (Spannable) mTextView.getText();</div><div class="line">            URLSpan[] urls = sp.getSpans(0, end, URLSpan.class);</div><div class="line">            mSpannableStringBuilder = new SpannableStringBuilder(sp);</div><div class="line">            mSpannableStringBuilder.clearSpans();</div><div class="line"></div><div class="line">            for (URLSpan url : urls) &#123;</div><div class="line">                String urlString = url.getURL();</div><div class="line">                PatternURLSpan patternURLSpan = new PatternURLSpan(urlString);</div><div class="line">                if (urlString != null &amp;&amp; urlString.length() &gt; 0) &#123;</div><div class="line">                    int _start = sp.getSpanStart(url);</div><div class="line">                    int _end = sp.getSpanEnd(url);</div><div class="line">                    try &#123;</div><div class="line">                        mSpannableStringBuilder.setSpan(patternURLSpan, _start, _end, Spannable.SPAN_EXCLUSIVE_INCLUSIVE);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mTextView.setLinkTextColor(ColorStateList.valueOf(Color.BLUE));</div><div class="line">            mTextView.setHighlightColor(Color.parseColor(&quot;#AAAAAA&quot;));</div><div class="line">            mTextView.setText(mSpannableStringBuilder);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class PatternURLSpan extends ClickableSpan &#123;</div><div class="line"></div><div class="line">        private String mString;</div><div class="line"></div><div class="line">        PatternURLSpan(String str) &#123;</div><div class="line">            this.mString = str;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onClick(View widget) &#123;</div><div class="line">                if (EMAIL_ADDRESS.matcher(mString).find()) &#123;</div><div class="line">                    sendEmail(mString);</div><div class="line">                &#125; else if (WEB_URL.matcher(mString).find()) &#123;</div><div class="line">                    openUrl(mString);</div><div class="line">                &#125; else if (PHONE.matcher(mString).find()) &#123;</div><div class="line">                    dialNum(mString);</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (mString.contains(&quot;.&quot;)) &#123;</div><div class="line">                        if (mString.startsWith(&quot;http&quot;)) &#123;</div><div class="line">                            openUrl(mString);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            openUrl(&quot;http://&quot; + mString);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 打开系统浏览器</div><div class="line">     * @param url</div><div class="line">     */</div><div class="line">    private void openUrl(String url) &#123;</div><div class="line">        Intent intent = new Intent(Intent.ACTION_VIEW);</div><div class="line">        intent.setData(Uri.parse(url));</div><div class="line">        intent.setClassName(&quot;com.android.browser&quot;,   </div><div class="line">                &quot;com.android.browser.BrowserActivity&quot;);  </div><div class="line">        mContext.startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 拨打电话</div><div class="line">     * @param num</div><div class="line">     */</div><div class="line">    private void dialNum(final String num) &#123;</div><div class="line">        if (num != null &amp;&amp; num.length() &gt; 0) &#123;</div><div class="line">            call(num, mContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 调用邮箱</div><div class="line">     * @param address</div><div class="line">     */</div><div class="line">    private void sendEmail(String address) &#123;</div><div class="line">        String[] receive = new String[]&#123;address&#125;;</div><div class="line">        Intent intent = new Intent(Intent.ACTION_SEND);</div><div class="line">        intent.setType(&quot;plain/text&quot;);</div><div class="line">        intent.putExtra(Intent.EXTRA_EMAIL, receive);</div><div class="line">        mContext.startActivity(Intent.createChooser(intent, &quot;&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private void call(final String mobile, final Context activity) &#123;</div><div class="line">        if (mobile == null || mobile.length() == 0) &#123;</div><div class="line">            Toast.makeText(activity, &quot;电话号码为空&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        String phone = mobile.toLowerCase();</div><div class="line">        if (!phone.startsWith(&quot;tel:&quot;)) &#123;</div><div class="line">            phone = &quot;tel:&quot; + mobile;</div><div class="line">        &#125;</div><div class="line">        final String callMobile = phone;</div><div class="line"></div><div class="line">        //适配6.0系统，申请权限</div><div class="line">        if (ActivityCompat.checkSelfPermission(activity, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line"></div><div class="line">            ActivityCompat.requestPermissions((Activity) activity,</div><div class="line">                    new String[]&#123;Manifest.permission.CALL_PHONE&#125;,</div><div class="line">                    MainActivity.REQUESTCODE);</div><div class="line">        &#125;else &#123;</div><div class="line">            callPhone(activity,callMobile);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void callPhone(Context activity, String callMobile) &#123;</div><div class="line">        Intent intent = new Intent(Intent.ACTION_CALL, Uri.parse(callMobile));</div><div class="line">        if (ActivityCompat.checkSelfPermission(activity, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        activity.startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =</div><div class="line">            &quot;(?:&quot;</div><div class="line">                    + &quot;(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])&quot;</div><div class="line">                    + &quot;|(?:biz|b[abdefghijmnorstvwyz])&quot;</div><div class="line">                    + &quot;|(?:cat|com|coop|c[acdfghiklmnoruvxyz])&quot;</div><div class="line">                    + &quot;|d[ejkmoz]&quot;</div><div class="line">                    + &quot;|(?:edu|e[cegrstu])&quot;</div><div class="line">                    + &quot;|f[ijkmor]&quot;</div><div class="line">                    + &quot;|(?:gov|g[abdefghilmnpqrstuwy])&quot;</div><div class="line">                    + &quot;|h[kmnrtu]&quot;</div><div class="line">                    + &quot;|(?:info|int|i[delmnoqrst])&quot;</div><div class="line">                    + &quot;|(?:jobs|j[emop])&quot;</div><div class="line">                    + &quot;|k[eghimnprwyz]&quot;</div><div class="line">                    + &quot;|l[abcikrstuvy]&quot;</div><div class="line">                    + &quot;|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])&quot;</div><div class="line">                    + &quot;|(?:name|net|n[acefgilopruz])&quot;</div><div class="line">                    + &quot;|(?:org|om)&quot;</div><div class="line">                    + &quot;|(?:pro|p[aefghklmnrstwy])&quot;</div><div class="line">                    + &quot;|qa&quot;</div><div class="line">                    + &quot;|r[eosuw]&quot;</div><div class="line">                    + &quot;|s[abcdeghijklmnortuvyz]&quot;</div><div class="line">                    + &quot;|(?:tel|travel|t[cdfghjklmnoprtvwz])&quot;</div><div class="line">                    + &quot;|u[agksyz]&quot;</div><div class="line">                    + &quot;|v[aceginu]&quot;</div><div class="line">                    + &quot;|w[fs]&quot;</div><div class="line">                    + &quot;|(?:\u03b4\u03bf\u03ba\u03b9\u03bc\u03ae|\u0438\u0441\u043f\u044b\u0442\u0430\u043d\u0438\u0435|\u0440\u0444|\u0441\u0440\u0431|\u05d8\u05e2\u05e1\u05d8|\u0622\u0632\u0645\u0627\u06cc\u0634\u06cc|\u0625\u062e\u062a\u0628\u0627\u0631|\u0627\u0644\u0627\u0631\u062f\u0646|\u0627\u0644\u062c\u0632\u0627\u0626\u0631|\u0627\u0644\u0633\u0639\u0648\u062f\u064a\u0629|\u0627\u0644\u0645\u063a\u0631\u0628|\u0627\u0645\u0627\u0631\u0627\u062a|\u0628\u06be\u0627\u0631\u062a|\u062a\u0648\u0646\u0633|\u0633\u0648\u0631\u064a\u0629|\u0641\u0644\u0633\u0637\u064a\u0646|\u0642\u0637\u0631|\u0645\u0635\u0631|\u092a\u0930\u0940\u0915\u094d\u0937\u093e|\u092d\u093e\u0930\u0924|\u09ad\u09be\u09b0\u09a4|\u0a2d\u0a3e\u0a30\u0a24|\u0aad\u0abe\u0ab0\u0aa4|\u0b87\u0ba8\u0bcd\u0ba4\u0bbf\u0baf\u0bbe|\u0b87\u0bb2\u0b99\u0bcd\u0b95\u0bc8|\u0b9a\u0bbf\u0b99\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0bc2\u0bb0\u0bcd|\u0baa\u0bb0\u0bbf\u0b9f\u0bcd\u0b9a\u0bc8|\u0c2d\u0c3e\u0c30\u0c24\u0c4d|\u0dbd\u0d82\u0d9a\u0dcf|\u0e44\u0e17\u0e22|\u30c6\u30b9\u30c8|\u4e2d\u56fd|\u4e2d\u570b|\u53f0\u6e7e|\u53f0\u7063|\u65b0\u52a0\u5761|\u6d4b\u8bd5|\u6e2c\u8a66|\u9999\u6e2f|\ud14c\uc2a4\ud2b8|\ud55c\uad6d|xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-3e0b707e|xn\\-\\-45brj9c|xn\\-\\-80akhbyknj4f|xn\\-\\-90a3ac|xn\\-\\-9t4b11yi5a|xn\\-\\-clchc0ea0b2g2a9gcd|xn\\-\\-deba0ad|xn\\-\\-fiqs8s|xn\\-\\-fiqz9s|xn\\-\\-fpcrj9c3d|xn\\-\\-fzc2c9e2c|xn\\-\\-g6w251d|xn\\-\\-gecrj9c|xn\\-\\-h2brj9c|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-j6w193g|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-kprw13d|xn\\-\\-kpry57d|xn\\-\\-lgbbat1ad8j|xn\\-\\-mgbaam7a8h|xn\\-\\-mgbayh7gpa|xn\\-\\-mgbbh1a71e|xn\\-\\-mgbc0a9azcg|xn\\-\\-mgberp4a5d4ar|xn\\-\\-o3cw4h|xn\\-\\-ogbpf8fl|xn\\-\\-p1ai|xn\\-\\-pgbs0dh|xn\\-\\-s9brj9c|xn\\-\\-wgbh1c|xn\\-\\-wgbl6a|xn\\-\\-xkc2al3hye2a|xn\\-\\-xkc2dl3a5ee0h|xn\\-\\-yfro4i67o|xn\\-\\-ygbi2ammx|xn\\-\\-zckzah|xxx)&quot;</div><div class="line">                    + &quot;|y[et]&quot; + &quot;|z[amw]))&quot;;</div><div class="line"></div><div class="line">    public final String GOOD_IRI_CHAR = &quot;a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF&quot;;</div><div class="line"></div><div class="line"></div><div class="line">    public final Pattern WEB_URL = Pattern</div><div class="line">            .compile(&quot;((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\&apos;\\(\\)&quot;</div><div class="line">                    + &quot;\\,\\;\\?\\&amp;\\=]|(?:\\%[a-fA-F0-9]&#123;2&#125;))&#123;1,64&#125;(?:\\:(?:[a-zA-Z0-9\\$\\-\\_&quot;</div><div class="line">                    + &quot;\\.\\+\\!\\*\\&apos;\\(\\)\\,\\;\\?\\&amp;\\=]|(?:\\%[a-fA-F0-9]&#123;2&#125;))&#123;1,25&#125;)?\\@)?)?&quot;</div><div class="line">                    + &quot;((?:(?:[&quot;</div><div class="line">                    + GOOD_IRI_CHAR</div><div class="line">                    + &quot;][&quot;</div><div class="line">                    + GOOD_IRI_CHAR</div><div class="line">                    + &quot;\\-]&#123;0,64&#125;\\.)+&quot; // named host</div><div class="line">                    + TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL</div><div class="line">                    + &quot;|(?:(?:25[0-5]|2[0-4]&quot; // or ip address</div><div class="line">                    + &quot;[0-9]|[0-1][0-9]&#123;2&#125;|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]&quot;</div><div class="line">                    + &quot;|[0-1][0-9]&#123;2&#125;|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]&quot;</div><div class="line">                    + &quot;[0-9]&#123;2&#125;|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]&#123;2&#125;&quot; + &quot;|[1-9][0-9]|[0-9])))&quot;</div><div class="line">                    + &quot;(?:\\:\\d&#123;1,5&#125;)?)&quot; // plus option port number</div><div class="line">                    + &quot;(\\/(?:(?:[&quot; + GOOD_IRI_CHAR + &quot;\\;\\/\\?\\:\\@\\&amp;\\=\\#\\~&quot; // plus option query</div><div class="line">                    // params</div><div class="line">                    + &quot;\\-\\.\\+\\!\\*\\&apos;\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]&#123;2&#125;))*)?&quot; + &quot;(?:\\b|$)&quot;);</div><div class="line"></div><div class="line">    public static final Pattern EMAIL_ADDRESS = Pattern.compile(&quot;[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]&#123;1,256&#125;&quot; + &quot;\\@&quot;</div><div class="line">            + &quot;[a-zA-Z0-9][a-zA-Z0-9\\-]&#123;0,64&#125;&quot; + &quot;(&quot; + &quot;\\.&quot; + &quot;[a-zA-Z0-9][a-zA-Z0-9\\-]&#123;0,25&#125;&quot; + &quot;)+&quot;);</div><div class="line">    public static final Pattern EMAIL_PATTERN = Pattern.compile(&quot;[A-Z0-9a-z\\._%+-]+@([A-Za-z0-9-]+\\.)+[A-Za-z]&#123;2,4&#125;&quot;);</div><div class="line">    public static final Pattern WEB_PATTERN =</div><div class="line">            Pattern</div><div class="line">                    .compile(&quot;((http[s]&#123;0,1&#125;|ftp)://[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]&#123;2,4&#125;)(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(www.[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]&#123;2,4&#125;)(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)&quot;);</div><div class="line"></div><div class="line">    public static final Pattern PHONE = Pattern.compile( // sdd = space, dot, or dash</div><div class="line">            &quot;(\\+[0-9]+[\\- \\.]*)?&quot; // +&lt;digits&gt;&lt;sdd&gt;*</div><div class="line">                    + &quot;(\\([0-9]+\\)[\\- \\.]*)?&quot; // (&lt;digits&gt;)&lt;sdd&gt;*</div><div class="line">                    + &quot;([0-9][0-9\\- \\.][0-9\\- \\.]+[0-9])&quot;);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述WEB_URL正则仍不能正常识别,最后采用:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// all domain names</div><div class="line">private static final String[] ext = &#123;</div><div class="line">    &quot;top&quot;, &quot;com.cn&quot;, &quot;com&quot;, &quot;net&quot;, &quot;org&quot;, &quot;edu&quot;, &quot;gov&quot;, &quot;int&quot;, &quot;mil&quot;, &quot;cn&quot;, &quot;tel&quot;, &quot;biz&quot;, &quot;cc&quot;, &quot;tv&quot;, &quot;info&quot;, </div><div class="line">    &quot;name&quot;, &quot;hk&quot;, &quot;mobi&quot;, &quot;asia&quot;, &quot;cd&quot;, &quot;travel&quot;, &quot;pro&quot;, &quot;museum&quot;, &quot;coop&quot;, &quot;aero&quot;, &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, </div><div class="line">    &quot;ag&quot;, &quot;ai&quot;, &quot;al&quot;, &quot;am&quot;, &quot;an&quot;, &quot;ao&quot;, &quot;aq&quot;, &quot;ar&quot;, &quot;as&quot;, &quot;at&quot;, &quot;au&quot;, &quot;aw&quot;, &quot;az&quot;, &quot;ba&quot;, &quot;bb&quot;, &quot;bd&quot;, </div><div class="line">    &quot;be&quot;, &quot;bf&quot;, &quot;bg&quot;, &quot;bh&quot;, &quot;bi&quot;, &quot;bj&quot;, &quot;bm&quot;, &quot;bn&quot;, &quot;bo&quot;, &quot;br&quot;, &quot;bs&quot;, &quot;bt&quot;, &quot;bv&quot;, &quot;bw&quot;, &quot;by&quot;, &quot;bz&quot;, </div><div class="line">    &quot;ca&quot;, &quot;cc&quot;, &quot;cf&quot;, &quot;cg&quot;, &quot;ch&quot;, &quot;ci&quot;, &quot;ck&quot;, &quot;cl&quot;, &quot;cm&quot;, &quot;cn&quot;, &quot;co&quot;, &quot;cq&quot;, &quot;cr&quot;, &quot;cu&quot;, &quot;cv&quot;, &quot;cx&quot;, </div><div class="line">    &quot;cy&quot;, &quot;cz&quot;, &quot;de&quot;, &quot;dj&quot;, &quot;dk&quot;, &quot;dm&quot;, &quot;do&quot;, &quot;dz&quot;, &quot;ec&quot;, &quot;ee&quot;, &quot;eg&quot;, &quot;eh&quot;, &quot;es&quot;, &quot;et&quot;, &quot;ev&quot;, &quot;fi&quot;, </div><div class="line">    &quot;fj&quot;, &quot;fk&quot;, &quot;fm&quot;, &quot;fo&quot;, &quot;fr&quot;, &quot;ga&quot;, &quot;gb&quot;, &quot;gd&quot;, &quot;ge&quot;, &quot;gf&quot;, &quot;gh&quot;, &quot;gi&quot;, &quot;gl&quot;, &quot;gm&quot;, &quot;gn&quot;, &quot;gp&quot;, </div><div class="line">    &quot;gr&quot;, &quot;gt&quot;, &quot;gu&quot;, &quot;gw&quot;, &quot;gy&quot;, &quot;hk&quot;, &quot;hm&quot;, &quot;hn&quot;, &quot;hr&quot;, &quot;ht&quot;, &quot;hu&quot;, &quot;id&quot;, &quot;ie&quot;, &quot;il&quot;, &quot;in&quot;, &quot;io&quot;, </div><div class="line">    &quot;iq&quot;, &quot;ir&quot;, &quot;is&quot;, &quot;it&quot;, &quot;jm&quot;, &quot;jo&quot;, &quot;jp&quot;, &quot;ke&quot;, &quot;kg&quot;, &quot;kh&quot;, &quot;ki&quot;, &quot;km&quot;, &quot;kn&quot;, &quot;kp&quot;, &quot;kr&quot;, &quot;kw&quot;, </div><div class="line">    &quot;ky&quot;, &quot;kz&quot;, &quot;la&quot;, &quot;lb&quot;, &quot;lc&quot;, &quot;li&quot;, &quot;lk&quot;, &quot;lr&quot;, &quot;ls&quot;, &quot;lt&quot;, &quot;lu&quot;, &quot;lv&quot;, &quot;ly&quot;, &quot;ma&quot;, &quot;mc&quot;, &quot;md&quot;, </div><div class="line">    &quot;mg&quot;, &quot;mh&quot;, &quot;ml&quot;, &quot;mm&quot;, &quot;mn&quot;, &quot;mo&quot;, &quot;mp&quot;, &quot;mq&quot;, &quot;mr&quot;, &quot;ms&quot;, &quot;mt&quot;, &quot;mv&quot;, &quot;mw&quot;, &quot;mx&quot;, &quot;my&quot;, &quot;mz&quot;,</div><div class="line">    &quot;na&quot;, &quot;nc&quot;, &quot;ne&quot;, &quot;nf&quot;, &quot;ng&quot;, &quot;ni&quot;, &quot;nl&quot;, &quot;no&quot;, &quot;np&quot;, &quot;nr&quot;, &quot;nt&quot;, &quot;nu&quot;, &quot;nz&quot;, &quot;om&quot;, &quot;qa&quot;, &quot;pa&quot;, </div><div class="line">    &quot;pe&quot;, &quot;pf&quot;, &quot;pg&quot;, &quot;ph&quot;, &quot;pk&quot;, &quot;pl&quot;, &quot;pm&quot;, &quot;pn&quot;, &quot;pr&quot;, &quot;pt&quot;, &quot;pw&quot;, &quot;py&quot;, &quot;re&quot;, &quot;ro&quot;, &quot;ru&quot;, &quot;rw&quot;, </div><div class="line">    &quot;sa&quot;, &quot;sb&quot;, &quot;sc&quot;, &quot;sd&quot;, &quot;se&quot;, &quot;sg&quot;, &quot;sh&quot;, &quot;si&quot;, &quot;sj&quot;, &quot;sk&quot;, &quot;sl&quot;, &quot;sm&quot;, &quot;sn&quot;, &quot;so&quot;, &quot;sr&quot;, &quot;st&quot;, </div><div class="line">    &quot;su&quot;, &quot;sy&quot;, &quot;sz&quot;, &quot;tc&quot;, &quot;td&quot;, &quot;tf&quot;, &quot;tg&quot;, &quot;th&quot;, &quot;tj&quot;, &quot;tk&quot;, &quot;tm&quot;, &quot;tn&quot;, &quot;to&quot;, &quot;tp&quot;, &quot;tr&quot;, &quot;tt&quot;, </div><div class="line">    &quot;tv&quot;, &quot;tw&quot;, &quot;tz&quot;, &quot;ua&quot;, &quot;ug&quot;, &quot;uk&quot;, &quot;us&quot;, &quot;uy&quot;, &quot;va&quot;, &quot;vc&quot;, &quot;ve&quot;, &quot;vg&quot;, &quot;vn&quot;, &quot;vu&quot;, &quot;wf&quot;, &quot;ws&quot;, </div><div class="line">    &quot;ye&quot;, &quot;yu&quot;, &quot;za&quot;, &quot;zm&quot;, &quot;zr&quot;, &quot;zw&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static &#123;   </div><div class="line">    StringBuilder sb = new StringBuilder();   </div><div class="line">    sb.append(&quot;(&quot;);   </div><div class="line">    for (int i = 0; i &lt; ext.length; i++) &#123;      </div><div class="line">        sb.append(ext[i]);      </div><div class="line">        sb.append(&quot;|&quot;);   </div><div class="line">    &#125;   </div><div class="line">    sb.deleteCharAt(sb.length() - 1);   </div><div class="line">    sb.append(&quot;)&quot;);   </div><div class="line">    // final pattern str</div><div class="line">    String pattern = &quot;((https?|s?ftp|irc[6s]?|git|afp|telnet|smb)://)?((\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;)|((www\\.|[a-zA-Z\\.\\-]+\\.)?[a-zA-Z0-9\\-]+\\.&quot; + sb.toString() + &quot;(:[0-9]&#123;1,5&#125;)?))((/[a-zA-Z0-9\\./,;\\?&apos;\\+&amp;%\\$#=~_\\-]*)|([^\\u4e00-\\u9fa5\\s0-9a-zA-Z\\./,;\\?&apos;\\+&amp;%\\$#=~_\\-]*))&quot;;   </div><div class="line">    // Log.v(TAG, &quot;pattern = &quot; + pattern);   </div><div class="line">    WEB_URL = Pattern.compile(pattern);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IM开发过程中,对文本消息中的超练级进行点击处理,使用系统的&lt;code&gt;tv.setAutoLinkMask(Linkify.PHONE_NUMBERS | Linkify.WEB_URLS);&lt;/code&gt;方法:
&lt;figure class=&quot;highlight plai
    
    </summary>
    
      <category term="Android" scheme="http://wodekouwei.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://wodekouwei.com/tags/Android/"/>
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>常用命令备忘</title>
    <link href="http://wodekouwei.com/2019/02/26/tips-universal-cmd/"/>
    <id>http://wodekouwei.com/2019/02/26/tips-universal-cmd/</id>
    <published>2019-02-26T02:55:28.000Z</published>
    <updated>2019-03-01T06:08:33.104Z</updated>
    
    <content type="html"><![CDATA[<h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><ul>
<li><code>git stash save &quot;test-cmd-stash&quot;</code>:给stash增加message</li>
<li><code>git stash pop</code>:将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</li>
<li><code>git stash apply</code>:将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝</li>
<li><code>git stash list</code>:查看现有stash</li>
<li><code>git stash drop stash@{0}</code>:移除stash</li>
<li><code>git stash clear</code>:删除所有缓存的stash</li>
<li><code>git stash show</code>:查看指定stash的diff,后面可以跟着stash名字,还可以添加-p或–patch,查看特定stash的全部diff</li>
<li><code>git stash branch</code>:创建一个新的分支,检出储藏工作时的所处的提交,重新应用工作</li>
<li><code>git stash -u/--include-untracked</code>储藏untracked文件,<code>git stash -a/--all</code>:stash当前目录下所有修改</li>
</ul>
<h5 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h5>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;git-stash&quot;&gt;&lt;a href=&quot;#git-stash&quot; class=&quot;headerlink&quot; title=&quot;git stash&quot;&gt;&lt;/a&gt;git stash&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git stash save &amp;quot;test-cmd-
    
    </summary>
    
      <category term="tips" scheme="http://wodekouwei.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://wodekouwei.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装配置</title>
    <link href="http://wodekouwei.com/2019/02/15/env-centos-nginx/"/>
    <id>http://wodekouwei.com/2019/02/15/env-centos-nginx/</id>
    <published>2019-02-15T09:24:07.000Z</published>
    <updated>2019-02-15T09:45:08.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CentOS安装Nginx"><a href="#CentOS安装Nginx" class="headerlink" title="CentOS安装Nginx"></a>CentOS安装Nginx</h2><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。</p>
<p>在高连接并发的情况下，Nginx是Apache服务器不错的替代品。</p>
<p>系统平台: 阿里云CentOS7.6 64位</p>
<h3 id="1-安装编译工具及库文件"><a href="#1-安装编译工具及库文件" class="headerlink" title="1.安装编译工具及库文件"></a>1.安装编译工具及库文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</div></pre></td></tr></table></figure>
<h3 id="2-首先要安装PCRE"><a href="#2-首先要安装PCRE" class="headerlink" title="2.首先要安装PCRE"></a>2.首先要安装PCRE</h3><p>PCRE 作用是让 Nginx 支持 Rewrite 功能</p>
<h4 id="2-1-下载PCRE安装包"><a href="#2-1-下载PCRE安装包" class="headerlink" title="2.1 下载PCRE安装包:"></a>2.1 下载PCRE安装包:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src/</div><div class="line">wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz</div></pre></td></tr></table></figure>
<h4 id="2-2-解压安装包"><a href="#2-2-解压安装包" class="headerlink" title="2.2 解压安装包"></a>2.2 解压安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf pcre-8.35.tar.gz</div></pre></td></tr></table></figure>
<h4 id="2-3-进入安装包目录"><a href="#2-3-进入安装包目录" class="headerlink" title="2.3 进入安装包目录"></a>2.3 进入安装包目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd pcre-8.35</div></pre></td></tr></table></figure>
<h4 id="2-4-编译安装"><a href="#2-4-编译安装" class="headerlink" title="2.4 编译安装"></a>2.4 编译安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h5 id="2-5-查看pcre版本"><a href="#2-5-查看pcre版本" class="headerlink" title="2.5 查看pcre版本"></a>2.5 查看pcre版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pcre-config --version</div></pre></td></tr></table></figure>
<h3 id="3-安装Nginx"><a href="#3-安装Nginx" class="headerlink" title="3.安装Nginx"></a>3.安装Nginx</h3><h4 id="3-1-下载-Nginx，下载地址：http-nginx-org-download-nginx-1-6-2-tar-gz"><a href="#3-1-下载-Nginx，下载地址：http-nginx-org-download-nginx-1-6-2-tar-gz" class="headerlink" title="3.1 下载 Nginx，下载地址：http://nginx.org/download/nginx-1.6.2.tar.gz"></a>3.1 下载 Nginx，下载地址：<a href="http://nginx.org/download/nginx-1.6.2.tar.gz" target="_blank" rel="external">http://nginx.org/download/nginx-1.6.2.tar.gz</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src/</div><div class="line">wget http://nginx.org/download/nginx-1.6.2.tar.gz</div></pre></td></tr></table></figure>
<h4 id="3-2-解压安装包"><a href="#3-2-解压安装包" class="headerlink" title="3.2 解压安装包"></a>3.2 解压安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf nginx-1.6.2.tar.gz</div></pre></td></tr></table></figure>
<h4 id="3-3-进入安装包目录"><a href="#3-3-进入安装包目录" class="headerlink" title="3.3 进入安装包目录"></a>3.3 进入安装包目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd nginx-1.6.2</div></pre></td></tr></table></figure>
<h4 id="3-4-编译安装"><a href="#3-4-编译安装" class="headerlink" title="3.4 编译安装"></a>3.4 编译安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<h4 id="3-5-查看nginx版本"><a href="#3-5-查看nginx版本" class="headerlink" title="3.5 查看nginx版本"></a>3.5 查看nginx版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/webserver/nginx/sbin/nginx -v</div></pre></td></tr></table></figure>
<h3 id="4-Nginx-配置"><a href="#4-Nginx-配置" class="headerlink" title="4. Nginx 配置"></a>4. Nginx 配置</h3><p>创建 Nginx 运行使用的用户 www：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/sbin/groupadd www </div><div class="line">/usr/sbin/useradd -g www www</div></pre></td></tr></table></figure></p>
<p>配置nginx.conf ，将<code>/usr/local/webserver/nginx/conf/nginx.conf</code>替换为以下内容
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">cat /usr/local/webserver/nginx/conf/nginx.conf</div><div class="line"></div><div class="line">user www www;</div><div class="line">worker_processes 2; #设置值和CPU核心数一致</div><div class="line">error_log /usr/local/webserver/nginx/logs/nginx_error.log crit; #日志位置和日志级别</div><div class="line">pid /usr/local/webserver/nginx/nginx.pid;</div><div class="line">#Specifies the value for maximum file descriptors that can be opened by this process.</div><div class="line">worker_rlimit_nofile 65535;</div><div class="line">events</div><div class="line">&#123;</div><div class="line">  use epoll;</div><div class="line">  worker_connections 65535;</div><div class="line">&#125;</div><div class="line">http</div><div class="line">&#123;</div><div class="line">  include mime.types;</div><div class="line">  default_type application/octet-stream;</div><div class="line">  log_format main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">               &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">               &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</div><div class="line">  </div><div class="line">#charset gb2312;</div><div class="line">     </div><div class="line">  server_names_hash_bucket_size 128;</div><div class="line">  client_header_buffer_size 32k;</div><div class="line">  large_client_header_buffers 4 32k;</div><div class="line">  client_max_body_size 8m;</div><div class="line">     </div><div class="line">  sendfile on;</div><div class="line">  tcp_nopush on;</div><div class="line">  keepalive_timeout 60;</div><div class="line">  tcp_nodelay on;</div><div class="line">  fastcgi_connect_timeout 300;</div><div class="line">  fastcgi_send_timeout 300;</div><div class="line">  fastcgi_read_timeout 300;</div><div class="line">  fastcgi_buffer_size 64k;</div><div class="line">  fastcgi_buffers 4 64k;</div><div class="line">  fastcgi_busy_buffers_size 128k;</div><div class="line">  fastcgi_temp_file_write_size 128k;</div><div class="line">  gzip on; </div><div class="line">  gzip_min_length 1k;</div><div class="line">  gzip_buffers 4 16k;</div><div class="line">  gzip_http_version 1.0;</div><div class="line">  gzip_comp_level 2;</div><div class="line">  gzip_types text/plain application/x-javascript text/css application/xml;</div><div class="line">  gzip_vary on;</div><div class="line"> </div><div class="line">  #limit_zone crawler $binary_remote_addr 10m;</div><div class="line"> #下面是server虚拟主机的配置</div><div class="line"> server</div><div class="line">  &#123;</div><div class="line">    listen 80;#监听端口</div><div class="line">    server_name localhost;#域名</div><div class="line">    index index.html index.htm index.php;</div><div class="line">    root /usr/local/webserver/nginx/html;#站点目录</div><div class="line">      location ~ .*\.(php|php5)?$</div><div class="line">    &#123;</div><div class="line">      #fastcgi_pass unix:/tmp/php-cgi.sock;</div><div class="line">      fastcgi_pass 127.0.0.1:9000;</div><div class="line">      fastcgi_index index.php;</div><div class="line">      include fastcgi.conf;</div><div class="line">    &#125;</div><div class="line">    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$</div><div class="line">    &#123;</div><div class="line">      expires 30d;</div><div class="line">  # access_log off;</div><div class="line">    &#125;</div><div class="line">    location ~ .*\.(js|css)?$</div><div class="line">    &#123;</div><div class="line">      expires 15d;</div><div class="line">   # access_log off;</div><div class="line">    &#125;</div><div class="line">    access_log off;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检查配置文件nginx.conf的正确性命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/webserver/nginx/sbin/nginx -t</div></pre></td></tr></table></figure></p>
<h3 id="4-Nginx命令"><a href="#4-Nginx命令" class="headerlink" title="4. Nginx命令"></a>4. Nginx命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/usr/local/webserver/nginx/sbin/nginx                      # 启动</div><div class="line">/usr/local/webserver/nginx/sbin/nginx -s reload            # 重新载入配置文件</div><div class="line">/usr/local/webserver/nginx/sbin/nginx -s reopen            # 重启 Nginx</div><div class="line">/usr/local/webserver/nginx/sbin/nginx -s stop              # 停止 Nginx</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CentOS安装Nginx&quot;&gt;&lt;a href=&quot;#CentOS安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;CentOS安装Nginx&quot;&gt;&lt;/a&gt;CentOS安装Nginx&lt;/h2&gt;&lt;p&gt;Nginx(“engine x”)是一款是由俄罗斯的
    
    </summary>
    
      <category term="env" scheme="http://wodekouwei.com/categories/env/"/>
    
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
      <category term="Linux" scheme="http://wodekouwei.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG常用命令</title>
    <link href="http://wodekouwei.com/2019/02/11/ffmpeg-command/"/>
    <id>http://wodekouwei.com/2019/02/11/ffmpeg-command/</id>
    <published>2019-02-11T03:01:13.000Z</published>
    <updated>2019-02-11T03:04:23.967Z</updated>
    
    <content type="html"><![CDATA[<h6 id="将多个视频片段合成一个视频"><a href="#将多个视频片段合成一个视频" class="headerlink" title="将多个视频片段合成一个视频"></a>将多个视频片段合成一个视频</h6><p>新建文本文件,输入要合成的视频列表(如果文件名有奇怪的字符,需要转意)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">file &apos;output_train_video_0.mp4&apos;</div><div class="line">file &apos;output_train_video_1.mp4&apos;</div><div class="line">file &apos;output_train_video_2.mp4&apos;</div><div class="line">file &apos;output_train_video_3.mp4&apos;</div><div class="line">file &apos;output_train_video_4.mp4&apos;</div></pre></td></tr></table></figure></p>
<p>执行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ffmpeg -f concat -i filelist.txt -c copy output_set.mp4</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;将多个视频片段合成一个视频&quot;&gt;&lt;a href=&quot;#将多个视频片段合成一个视频&quot; class=&quot;headerlink&quot; title=&quot;将多个视频片段合成一个视频&quot;&gt;&lt;/a&gt;将多个视频片段合成一个视频&lt;/h6&gt;&lt;p&gt;新建文本文件,输入要合成的视频列表(如果文件名有奇怪
    
    </summary>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/categories/FFMPEG/"/>
    
    
      <category term="多媒体" scheme="http://wodekouwei.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="FFMPEG" scheme="http://wodekouwei.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL之EGL</title>
    <link href="http://wodekouwei.com/2019/01/30/gl-egl/"/>
    <id>http://wodekouwei.com/2019/01/30/gl-egl/</id>
    <published>2019-01-30T10:48:27.000Z</published>
    <updated>2019-03-04T15:33:08.868Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL ES的javax.microedition.khronos.openges包定义了平台无关的GL绘制指令,EGL(javax.microedition.khronos.egl)则定义了控制dispays,contexts以及surfaces的统一的平台接口.</p>
<p><img src="http://images.wodekouwei.com/gl/egl2.gif" alt="image">
EGL 是 OpenGL ES 渲染 API 和本地窗口系统(native platform window system)之间的一个中间接口层，它主要由系统制造商实现。EGL提供如下机制：</p>
<ul>
<li>与设备的原生窗口系统通信</li>
<li>查询绘图表面的可用类型和配置</li>
<li>创建绘图表面</li>
<li>在OpenGL ES 和其他图形渲染API之间同步渲染</li>
<li>管理纹理贴图等渲染资源</li>
</ul>
<p>为了让OpenGL ES能够绘制在当前设备上，我们需要EGL作为OpenGL ES与设备的桥梁。</p>
<p><img src="http://images.wodekouwei.com/gl/egl.png" alt="image"></p>
<ul>
<li>Display(EGLDisplay)是对实际显示设备的抽象</li>
<li>Surface(EGLSurface)是对用来存储图像的内存区域FrameBuffer的抽象,包括Color Buffer, Stencil Buffer, Depth Buffer.</li>
<li>Context(EGLContext)存储OpenGLES绘图的一些状态信息</li>
</ul>
<p>使用EGL绘制的一般步骤:</p>
<ol>
<li>获取EGLDisplay对象</li>
<li>初始化与EGLDisplay之间的连接</li>
<li>获取EGLConfig实例</li>
<li>创建EGLContext实例</li>
<li>创建EGLSurface实例</li>
<li>连接EGLContext和EGLSurface</li>
<li>使用GL指令绘制图形</li>
<li>断开并释放与EGLSurface关联的EGLContext对象</li>
<li>删除EGLSurface对象</li>
<li>删除EGLContext对象</li>
<li>终止与EGLDisplay之间的连接</li>
</ol>
<p>源码:
本地代码:</p>
<ul>
<li><code>frameworks/native/opengl/libs/EGL</code>:Android EGL框架，负责加载OpenGL函数库和EGL本地实现。</li>
<li><code>frameworks/native/opengl/libagl</code>:Android提供的OpenGL软件库</li>
</ul>
<p>JNI代码:</p>
<ul>
<li><code>frameworks/base/core/jni/com_google_android_gles_jni_EGLImpl.cpp</code>:EGL本地代码的JNI调用接口</li>
<li><code>frameworks/base/core/jni/com_google_android_gles_jni_GLImpl.cpp</code></li>
<li><code>frameworks/base/core/jni/android_opengl_GLESXXX.cpp</code>:OpenGL功能函数的JNI调用接口</li>
</ul>
<p>JAVA代码:</p>
<ul>
<li><code>frameworks/base/opengl/java/javax/microedition/khronos/egl</code></li>
<li><code>frameworks/base/opengl/java/javax/microedition/khronos/opengles</code></li>
<li><code>frameworks/base/opengl/java/com/google/android/gles_jni/</code></li>
<li><code>frameworks/base/opengl/java/android/opengl</code> :EGL和OpenGL的Java层接口，提供给应用开发者，通过JNI方式调用底层函数。</li>
</ul>
<h5 id="OpenGL-ES-EGL-Wrapper-库"><a href="#OpenGL-ES-EGL-Wrapper-库" class="headerlink" title="OpenGL ES/EGL Wrapper 库"></a>OpenGL ES/EGL Wrapper 库</h5><p>前面我们已经介绍过 OpenGL ES/EGL Wrapper 库是一个将 OpenGL ES API 和 OpenGL ES API 具体实现绑定在一起的库，它对应的源码路径是：/frameworks/native/opengl/libs/，其中:</p>
<p>libGLESv1_CM.so：OpenGL ES 1.x API 的 Wrapper 库
libGLESv2.so：OpenGL ES 2.0 的 Wrapper 库
libGLESv3.so：OpenGL ES 3.0 的 Wrapper 库
其中因为 OpenGL ES 3.0 API 是兼容 OpenGL ES 2.0 API 的，所以 libGLESv2.so 库本质上和 libGLESv3.so 库是一样的。</p>
<h5 id="OpenGL-ES-EGL-实现库"><a href="#OpenGL-ES-EGL-实现库" class="headerlink" title="OpenGL ES/EGL 实现库"></a>OpenGL ES/EGL 实现库</h5><p>如果Android系统平台支持 OpenGL ES 硬件加速渲染，那么 OpenGL ES/EGL 实现库由系统厂商以.so的共享链接库的形式提供，例如，Nexus 9 平板中的厂商提供的 OpenGL ES/EGL 实现库为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flounder:/vendor/lib64/egl # ls</div><div class="line">libEGL_tegra.so libGLESv1_CM_tegra.so libGLESv2_tegra.so</div></pre></td></tr></table></figure></p>
<p>如果Android系统平台不支持 OpenGL ES 硬件加速渲染，那么它就会默认启用软件模拟渲染，这时 OpenGL ES/EGL 实现库就是由 AOSP 提供，链接库的存在的路径为： /system/lib64/egl/libGLES_android.so。而 libGLES_android.so 库在 Android 7.1 系统对应的实现源码路径为：/frameworks/native/opengl/libagl/ 。</p>
<h5 id="Android-7-1-中加载-OpenGL-ES-库的过程"><a href="#Android-7-1-中加载-OpenGL-ES-库的过程" class="headerlink" title="Android 7.1 中加载 OpenGL ES 库的过程"></a>Android 7.1 中加载 OpenGL ES 库的过程</h5><p>Android 中图形渲染所采用的方式（硬件 or 软件）是在系统启动之后动态确定的，而确定渲染方式的这个源码文件就是 /frameworks/native/opengl/libs/EGL/Loader.cpp 。</p>
<p>####### Android 7.1 OpenGL ES 库和 EGL 库加载说明
How Android finds OpenGL libraries, and the death of egl.cfg 这篇文章中提到了非常关键的一点，就是从 Android Kitkat 4.4 之后，Android 中加载 OpenGL ES/EGL 库的方法发生了变化了（但是整个加载过程都是由 /frameworks/native/opengl/libs/EGL/Loader.cpp 程序所决定的，也就是说 Loader.cpp 文件发生了变化）。</p>
<p>在 Android 4.4 之前，加载 OpenGL ES 库是由 /system/lib/egl/egl.cfg 文件所决定的，通过读取这个配置文件来确定是加载 OpenGL ES 软件模拟实现的库，还是OpenGL ES 硬件加速实现的库。</p>
<p>但是，在Android 4.4 之后，Android 不再通过读取 egl.cfg 配置文件的方式来加载 OpenGL ES 库，新的加载 OpenGL ES 库的规则，如下所示：</p>
<p>从 /system/lib/egl 或者 /vendor/lib/egl/ 目录下加载 libGLES.so 库文件或者 libEGL_vendor.so，libGLESv1_CM_vendor.so，libGLESv2<em>vendor.so 库文件。
为了向下兼容旧的库的命名方式，同样也会加载 /system/lib/egl 或者 /vendor/lib/egl/ 目录下的 libGLES</em><em>.so 或者 libEGL_</em>.so，libGLESv1CM<em>.so，libGLESv2_</em>.so 库文件。
3.2　硬件加速渲染 or 软件模拟渲染？
前面我们提到 OpenGL ES 库的实现方式有两种，一种是硬件加速实现，一种是软件模拟实现，那么系统是怎么确定加载那一种 OpenGL ES 库的呢？</p>
<p>Android 7.1 源码中负责加载 OpenGL ES/EGL 库部分的代码位于：/frameworks/native/opengl/libs/EGL/Loader.cpp 文件中，这个文件中代码的主要入口函数是 Loader::open() 函数，而决定加载硬件加速渲染库还是软件模拟渲染库主要涉及到下面两个函数：</p>
<p>setEmulatorGlesValue()
checkGlesEmulationStatus()
下面就来简要的分析一下 Android 系统是如何选择加载硬件加速渲染库还是软件模拟渲染库：</p>
<ol>
<li><p>首先，Loader::open() 入口函数会调用 setEmulatorGlesValue() 从 property 属性系统中获取一些属性值来判断当前 Android 系统是否在 Emulator 环境中运行，并根据读取出来的信息来重新设置新的属性键值对，setEmulatorGlesValue() 函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static void setEmulatorGlesValue(void) &#123;</div><div class="line">     char prop[PROPERTY_VALUE_MAX];</div><div class="line">     property_get(&quot;ro.kernel.qemu&quot;, prop, &quot;0&quot;); //读取 ro.kernel.qemu 属性值，判断Android系统是否运行在 qemu 中</div><div class="line">     if (atoi(prop) != 1) return;</div><div class="line">    </div><div class="line">     property_get(&quot;ro.kernel.qemu.gles&quot;, prop, &quot;0&quot;); //读取 ro.kernel.qemu.gles 属性值，判断 qemu 中 OpenGL ES 库的实现方式</div><div class="line">     if (atoi(prop) == 1) &#123;</div><div class="line">         ALOGD(&quot;Emulator has host GPU support, qemu.gles is set to 1.&quot;);</div><div class="line">         property_set(&quot;qemu.gles&quot;, &quot;1&quot;);</div><div class="line">         return;</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     // for now, checking the following</div><div class="line">     // directory is good enough for emulator system images</div><div class="line">     const char* vendor_lib_path =</div><div class="line"> #if defined(__LP64__)</div><div class="line">         &quot;/vendor/lib64/egl&quot;;</div><div class="line"> #else</div><div class="line">         &quot;/vendor/lib/egl&quot;;</div><div class="line"> #endif</div><div class="line">    </div><div class="line">     const bool has_vendor_lib = (access(vendor_lib_path, R_OK) == 0);</div><div class="line">     //如果存在 vendor_lib_path 这个路径，那么就说明厂商提供了 OpenGL ES库自己的软件模拟渲染库，而不是 Android 系统自己编译得到的软件模拟渲染库</div><div class="line">     if (has_vendor_lib) &#123;</div><div class="line">         ALOGD(&quot;Emulator has vendor provided software renderer, qemu.gles is set to 2.&quot;);</div><div class="line">         property_set(&quot;qemu.gles&quot;, &quot;2&quot;);</div><div class="line">     &#125; else &#123;</div><div class="line">         ALOGD(&quot;Emulator without GPU support detected. &quot;</div><div class="line">               &quot;Fallback to legacy software renderer, qemu.gles is set to 0.&quot;);</div><div class="line">         property_set(&quot;qemu.gles&quot;, &quot;0&quot;); //最后，默认采取的是方案就是调用传统的Android系统自己编译得到软件模拟渲染库</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在 load_system_driver() 函数中，内部类 MatchFile 类中会调用 checkGlesEmulationStatus() 函数来检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能，然后根据 checkGlesEmulationStatus() 函数的返回状态值来确定要加载共享链接库的文件绝对路径。load_system_driver() 和 checkGlesEmulationStatus() 函数代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">static void* load_system_driver(const char* kind) &#123;</div><div class="line">     ATRACE_CALL();</div><div class="line">     class MatchFile &#123;</div><div class="line">     public:</div><div class="line">         //这个函数作用是返回需要加载打开的 OpenGL ES 和 EGL API 实现库文件的绝对路径</div><div class="line">         static String8 find(const char* kind) &#123;</div><div class="line">             String8 result;</div><div class="line">             int emulationStatus = checkGlesEmulationStatus(); //检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能</div><div class="line">             switch (emulationStatus) &#123;</div><div class="line">             case 0: //Android 运行在模拟器中，使用系统软件模拟实现的 OpenGL ES API 库 libGLES_android.so</div><div class="line"> #if defined(__LP64__)</div><div class="line">                 result.setTo(&quot;/system/lib64/egl/libGLES_android.so&quot;);</div><div class="line"> #else</div><div class="line">                 result.setTo(&quot;/system/lib/egl/libGLES_android.so&quot;);</div><div class="line"> #endif</div><div class="line">                 return result;</div><div class="line">             case 1: // Android 运行在模拟器中，通过主机系统中实现 OpenGL ES 加速渲染，通过 libGLES_emulation.so 库将  OpenGL ES API 指令重定向到 host 中执行</div><div class="line">                 // Use host-side OpenGL through the &quot;emulation&quot; library</div><div class="line"> #if defined(__LP64__)</div><div class="line">                 result.appendFormat(&quot;/system/lib64/egl/lib%s_emulation.so&quot;, kind);</div><div class="line"> #else</div><div class="line">                 result.appendFormat(&quot;/system/lib/egl/lib%s_emulation.so&quot;, kind);</div><div class="line"> #endif</div><div class="line">                 return result;</div><div class="line">             default:</div><div class="line">                 // Not in emulator, or use other guest-side implementation</div><div class="line">                 break;</div><div class="line">             &#125;</div><div class="line">    </div><div class="line">             // 如果不是上面两种情况，就根据库的命名规则去找到厂商实现库文件的绝对路径</div><div class="line">             String8 pattern;</div><div class="line">             pattern.appendFormat(&quot;lib%s&quot;, kind);</div><div class="line">             const char* const searchPaths[] = &#123;</div><div class="line"> #if defined(__LP64__)</div><div class="line">                 &quot;/vendor/lib64/egl&quot;,</div><div class="line">                 &quot;/system/lib64/egl&quot;</div><div class="line"> #else</div><div class="line">                 &quot;/vendor/lib/egl&quot;,</div><div class="line">                 &quot;/system/lib/egl&quot;</div><div class="line"> #endif</div><div class="line">             &#125;;</div><div class="line">                </div><div class="line">             ......</div><div class="line">     &#125;</div><div class="line">        </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">static int</div><div class="line"> checkGlesEmulationStatus(void)</div><div class="line"> &#123;</div><div class="line">     /* We&apos;re going to check for the following kernel parameters:</div><div class="line">      *</div><div class="line">      *    qemu=1                      -&gt; tells us that we run inside the emulator</div><div class="line">      *    android.qemu.gles=&lt;number&gt;  -&gt; tells us the GLES GPU emulation status</div><div class="line">      *</div><div class="line">      * Note that we will return &lt;number&gt; if we find it. This let us support</div><div class="line">      * more additionnal emulation modes in the future.</div><div class="line">      */</div><div class="line">     char  prop[PROPERTY_VALUE_MAX];</div><div class="line">     int   result = -1;</div><div class="line">    </div><div class="line">     /* Check if hardware acceleration disabled explicitly */</div><div class="line">     property_get(&quot;debug.egl.hw&quot;, prop, &quot;1&quot;); //读取 debu.egl.hw 属性值，判断3D硬件加速功能是否被关闭了</div><div class="line">     if (!atoi(prop)) &#123;</div><div class="line">         ALOGD(&quot;3D hardware acceleration is disabled&quot;);</div><div class="line">         return 0;</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     /* First, check for qemu=1 */</div><div class="line">     property_get(&quot;ro.kernel.qemu&quot;, prop, &quot;0&quot;); //读取ro.kernel.qemu，判断是否运行在 qemu 中</div><div class="line">     if (atoi(prop) != 1)</div><div class="line">         return -1;</div><div class="line">    </div><div class="line">     /* We are in the emulator, get GPU status value */</div><div class="line">     property_get(&quot;qemu.gles&quot;, prop, &quot;0&quot;); // 如果 Android 系统运行在 qemu 中，就返回 qemu.gles 的值，根据这个值就可以确定加载的是那种 OpenGL ES 库了</div><div class="line">     return atoi(prop);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ol>
<li>总结一下上面代码的功能就是，首先判断 Android 是否在 qemu 虚拟机中运行，如果不是，那么就直接去加载厂商存放库的路径中去加载 OpenGL ES 实现库（不管是硬件加速实现的，还是软件模拟实现的）；如果是在 qemu 中运行，那么就要根据返回的 emulationStatus 值 来确定是加软件模拟实现的 OpenGL ES API 库 libGLES_android.so，还是加载 libGLES_emulation.so库将 OpenGL ES 指令重定向到 Host 系统中去执行。</li>
</ol>
<h6 id="OpenGL-ES-EGL-库加载和解析过程"><a href="#OpenGL-ES-EGL-库加载和解析过程" class="headerlink" title="OpenGL ES/EGL 库加载和解析过程"></a>OpenGL ES/EGL 库加载和解析过程</h6><p>正如Android 系统图形栈: OpenGL ES 和 EGL 介绍这篇文章中分析的那样，在进行 OpenGL 编程时，最先开始需要获取 Display，这将调用 eglgGetDisplay() 函数被调用。在 eglGetDisplay() 里则会调用 egl_init_drivers() 初始化驱动：装载各个库进行解析，将 OpenGL ES/EGL API 函数接口和具体的实现绑定在一起，并将结果保存在 egl_connection_t 类型的全局变量 gEGLImpl 的结构体的成员变量中。</p>
<p>下面以 SurfaceFlinger 进程为例进行分析，整个 OpenGL ES/EGL 库的加载和解析流程如下所示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">op1=&gt;operation: SurfaceFlinger::init()</div><div class="line">sub=&gt;subroutine: Your Subroutine</div><div class="line">op2=&gt;operation: eglGetDisplay(EGL_DEFAULT_DISPLAY)</div><div class="line">op3=&gt;operation: egl_init_drivers()</div><div class="line">op4=&gt;operation: egl_init_drivers_locked();</div><div class="line">op5=&gt;operation: loader.open()</div><div class="line">op6=&gt;operation: load_driver()</div><div class="line">op7=&gt;operation: load_system_driver()</div><div class="line">op8=&gt;operation: Loader::init_api()</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;op7-&gt;op8-&gt;e</div></pre></td></tr></table></figure></p>
<p>gEGLImpl 全局变量
struct egl_connection_t 类型的 gEGLImpl 全局变量是一个非常重要变量，它里面的成员指向了打开的 OpenGL ES/EGL Wrapper 库和 OpenGL ES/EGL 实现库： /frameworks/native/opengl/libs/EGL/egl.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">egl_connection_t gEGLImpl;</div><div class="line">gl_hooks_t gHooks[2];</div><div class="line">gl_hooks_t gHooksNoContext;</div></pre></td></tr></table></figure>
<p>其中 egl_connection_t 的定义： /frameworks/native/opengl/libs/EGL/egldefs.h
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct egl_connection_t &#123;</div><div class="line">    enum &#123;</div><div class="line">        GLESv1_INDEX = 0,</div><div class="line">        GLESv2_INDEX = 1</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    inline egl_connection_t() : dso(0) &#123; &#125;</div><div class="line">    void *              dso; //指向打开的共享链接库的句柄</div><div class="line">    gl_hooks_t *        hooks[2]; //指向打开的 OpenGL ES API 对象</div><div class="line">    EGLint              major; // 主版本好</div><div class="line">    EGLint              minor;</div><div class="line">    egl_t               egl; //dui x</div><div class="line"></div><div class="line">    void*               libEgl;</div><div class="line">    void*               libGles1;</div><div class="line">    void*               libGles2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面就对其中的主要成员进行一个说明：</p>
<ul>
<li>hooks：这是一个 gl_hook_t* 类型的指针数组，它最终将 OpenGL ES API 和实现库钩在一起。</li>
<li>egl：这是一个 egl_t 类型的成员变量，它最终将 EGL API 和 EGL 实现库了钩在一起。
那么 gl_hook_t 和 egl_t 是什么呢？</li>
</ul>
<p>gl_hook_t 和 egl_t 的定义如下所示： /frameworks/native/opengl/libs/hooks.h
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#define GL_ENTRY(_r, _api, ...) _r (*_api)(__VA_ARGS__);</div><div class="line">#define EGL_ENTRY(_r, _api, ...) _r (*_api)(__VA_ARGS__);</div><div class="line"></div><div class="line">struct egl_t &#123;</div><div class="line">    #include &quot;EGL/egl_entries.in&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct gl_hooks_t &#123;</div><div class="line">    struct gl_t &#123;</div><div class="line">        #include &quot;entries.in&quot;</div><div class="line">    &#125; gl;</div><div class="line">    struct gl_ext_t &#123;</div><div class="line">        // __eglMustCastToProperFunctionPointerType 是一个 typedef 的函数指针类型，它的返回值是void，参数也是void</div><div class="line">        __eglMustCastToProperFunctionPointerType extensions[MAX_NUMBER_OF_GL_EXTENSIONS];</div><div class="line">    &#125; ext;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从上面的定义中我们发现，egl_t 和 gl_hooks_t 这两个结构体中主要就是一个 include 语句，那么它们包含的是什么呢？</p>
<p><code>#include “EGL/egl_entries.in 包含的文件路径如下所示： /frameworks/native/opengl/libs/EGL/egl_entries.in</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EGL_ENTRY(EGLDisplay, eglGetDisplay, NativeDisplayType)</div><div class="line">EGL_ENTRY(EGLBoolean, eglInitialize, EGLDisplay, EGLint*, EGLint*)</div><div class="line">EGL_ENTRY(EGLBoolean, eglTerminate, EGLDisplay)</div><div class="line">EGL_ENTRY(EGLBoolean, eglGetConfigs, EGLDisplay, EGLConfig*, EGLint, EGLint*)</div><div class="line">EGL_ENTRY(EGLBoolean, eglChooseConfig, EGLDisplay, const EGLint *, EGLConfig *, EGLint, EGLint *)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>在这个文件中，我们可以看到所有的内容都是 EGL_ENTRY 宏定义的，根据 EGL_ENTRY 宏定义： /frameworks/native/opengl/libs/EGL/hooks.h
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//下面的两个宏定义分别是 OpenGL 和 EGL API 函数的函数指针变量</div><div class="line">//这些函数变量最后会和具体的 OpenGL 和 EGL API 的实现绑定在一起</div><div class="line">#define GL_ENTRY(_r,_api,...) _r (*_api)(__VA_ARGS__);</div><div class="line">#define EGL_ENTRY(_r,_api,...) _r(*_api)(__VA_ARGS__);</div></pre></td></tr></table></figure></p>
<p>我们可以将下面的这个宏定义展开成如下的形式:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EGL_ENTRY(EGLDisplay, eglGetDisplay, NativeDisplayType)</div><div class="line">//展开后的形式如下所示，它实际上就是 EGL API 函数声明</div><div class="line">EGLDisplay eglGetDisplay(NativeDisplayType)</div></pre></td></tr></table></figure></p>
<p><code>#include “entries.in” 包含的文件路径为： /frameworks/native/opengl/libs/entries.in</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">GL_ENTRY(void, glReadPixels, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>和上面的 EGL_ENTRY 一样，GL_ENTRY 都是通过宏定义的形式来将 OpenGL ES 的 API 函数接口进行声明，例如，上面的宏定义声明可以展开成下面的形式：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GL_ENTRY(void, glReadPixels, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)</div><div class="line">// 展开后的形式如下所示，它实际上就是 OpenGL ES API 函数声明</div><div class="line">void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)</div></pre></td></tr></table></figure></p>
<p>最后，通过 entries.in 和 egl_entries.in 这两个文件，我们就可以得到 OpenGL ES 和 EGL 中的所有 API 函数接口的说明。</p>
<p>SurfaceFlinger 初始化成员变量 mEGLDisplay
在 SurfaceFlinger 类中有一个 EGLDisplay 类型的成员变量 mEGLDisplay，它是 EGL 中用来构建 OpenGL ES 渲染环境所需的参数。</p>
<p>SurfaceFlinger 中调用 eglGetDisplay() 初始化 mEGLDisplay 的代码如下： /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void SurfaceFlinger::init() &#123;</div><div class="line">    ALOGI(  &quot;SurfaceFlinger&apos;s main thread ready to run. &quot;</div><div class="line">            &quot;Initializing graphics H/W...&quot;);</div><div class="line"></div><div class="line">    status_t err;</div><div class="line">    Mutex::Autolock _l(mStateLock);</div><div class="line"></div><div class="line">    // initialize EGL for the default display</div><div class="line">    // 调用 eglGetDisplay 函数获取默认的显示设备</div><div class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); </div><div class="line">    eglInitialize(mEGLDisplay, NULL, NULL);</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>紧接着在 eglGetDisplay() 中调用 egl_init_drivers() /frameworks/native/opengl/libs/EGL/eglApi.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">EGLDisplay eglGetDisplay(EGLNativeDisplayType display)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    // 调用egl_init_drivers() 加载 OpenGL ES 库和 EGL 库</div><div class="line">    if (egl_init_drivers() == EGL_FALSE) &#123;</div><div class="line">        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display);</div><div class="line">    return dpy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，egl_init_drivers() 函数中使用了 pthread_mutex_lock 上锁保护，继续调用 egl_init_drivers_locked() 函数 /frameworks/native/opengl/libs/EGL/egl.cpp
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EGLBoolean egl_init_drivers() &#123;</div><div class="line">    EGLBoolean res;</div><div class="line">    pthread_mutex_lock(&amp;sInitDriverMutex);</div><div class="line">    // 使用了 pthread_mutex_lock 上锁保护，继续调用 egl_init_drivers_locked</div><div class="line">    res = egl_init_drivers_locked();</div><div class="line">    pthread_mutex_unlock(&amp;sInitDriverMutex);</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面就是对 egl_init_drivers_locked() 函数进行一个分析：</p>
<p>egl_init_drivers_locked() 函数代码如下所示： /frameworks/native/opengl/libs/EGL/egl.cpp
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//在该文件起始位置定义的全局变量</div><div class="line">egl_connection_t gEGLImpl; // 描述EGL实现内容的结构体对象</div><div class="line">gl_hooks_t gHooks[2]; // gl_hooks_t 是包含 OpenGL ES API 函数声明对应的函数指针结构体</div><div class="line">gl_hooks_t gHooksNoContext;</div><div class="line">pthread_key_t gGLWrapperKey = -1;</div><div class="line"></div><div class="line">static EGLBoolean egl_init_drivers_locked() &#123;</div><div class="line">    if (sEarlyInitState) &#123;</div><div class="line">        // initialized by static ctor. should be set here.</div><div class="line">        return EGL_FALSE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 得到 Loader 对象单例</div><div class="line">    // get our driver loader</div><div class="line">    Loader&amp; loader(Loader::getInstance());</div><div class="line"></div><div class="line">    //  gEGLImple 是一个全局变量，数据类型为 egl_connection_t 结构体类型</div><div class="line">    // dynamically load our EGL implementation</div><div class="line">    egl_connection_t* cnx = &amp;gEGLImpl;</div><div class="line"></div><div class="line">    // cnx-&gt;dso 本质上是一个 (void *)类型的指针，它指向的对象是 EGL 共享库打开之后的句柄</div><div class="line">    if (cnx-&gt;dso == 0) &#123; </div><div class="line">        // &gt;= 将cnx中的 hooks 数组中指向OpenGL ES API 函数指针结构体指的数组成员，用 gHooks 中的成员的地址去初始化</div><div class="line">        //也就是说 gEGLImpl 中 hook 数组指向 gHooks 数组，最终指向同一个 OpenGL ES API 函数指针的实现</div><div class="line">        cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX] =</div><div class="line">            &amp;gHooks[egl_connection_t::GLESv1_INDEX];</div><div class="line">        cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX] =</div><div class="line">            &amp;gHooks[egl_connection_t::GLESv2_INDEX];</div><div class="line"></div><div class="line">        // &gt;= 最后通过loader对象的open函数开始加载 OpenGL ES 和 EGL wrapper 库</div><div class="line">        cnx-&gt;dso = loader.open(cnx);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return cnx-&gt;dso ? EGL_TRUE : EGL_FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个函数中，有一个非常关键的 egl_connection_t 指针指向一个全局变量 gEGLImpl，当第一次初始化加载 OpenGL ES 实现库和 EGL 实现库时，还需要将 gEGLImpl 中的 hooks 数组中的两个指针指向一个全局的 gl_hooks_t 数组 gHooks（这就是两个指针钩子，最终初始化完成后将分别勾住 OpenGL ES 1.0 和 OpenGL ES 2.0 的实现库），接着调用 Loader 类的实例的 open() 函数完成从 OpenGL ES 实现库中完成符号解析工作。</p>
<p>通过 Loader 类加载和解析 OpenGL ES 库和 EGL 库
Loader::open() 函数的代码如下所示： /frameworks/native/opengl/libs/EGL/Loader.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// &gt;= Loader 类对象构造完成后，就在 /EGL/egl.cpp 文件中的 egl_init_drivers_locked() 中被调用</div><div class="line">void* Loader::open(egl_connection_t* cnx)</div><div class="line">&#123;</div><div class="line">    ATRACE_CALL();</div><div class="line"></div><div class="line">    void* dso;</div><div class="line">    driver_t* hnd = 0;</div><div class="line"></div><div class="line">    setEmulatorGlesValue();</div><div class="line"></div><div class="line">    dso = load_driver(&quot;GLES&quot;, cnx, EGL | GLESv1_CM | GLESv2);</div><div class="line">    if (dso) &#123;</div><div class="line">        hnd = new driver_t(dso);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Always load EGL first</div><div class="line">        dso = load_driver(&quot;EGL&quot;, cnx, EGL);</div><div class="line">        if (dso) &#123;</div><div class="line">            hnd = new driver_t(dso);</div><div class="line">            hnd-&gt;set( load_driver(&quot;GLESv1_CM&quot;, cnx, GLESv1_CM), GLESv1_CM );</div><div class="line">            hnd-&gt;set( load_driver(&quot;GLESv2&quot;,    cnx, GLESv2),    GLESv2 );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LOG_ALWAYS_FATAL_IF(!hnd, &quot;couldn&apos;t find an OpenGL ES implementation&quot;);</div><div class="line"></div><div class="line">    cnx-&gt;libEgl   = load_wrapper(EGL_WRAPPER_DIR &quot;/libEGL.so&quot;);</div><div class="line">    cnx-&gt;libGles2 = load_wrapper(EGL_WRAPPER_DIR &quot;/libGLESv2.so&quot;);</div><div class="line">    cnx-&gt;libGles1 = load_wrapper(EGL_WRAPPER_DIR &quot;/libGLESv1_CM.so&quot;);</div><div class="line"></div><div class="line">    LOG_ALWAYS_FATAL_IF(!cnx-&gt;libEgl,</div><div class="line">            &quot;couldn&apos;t load system EGL wrapper libraries&quot;);</div><div class="line"></div><div class="line">    LOG_ALWAYS_FATAL_IF(!cnx-&gt;libGles2 || !cnx-&gt;libGles1,</div><div class="line">            &quot;couldn&apos;t load system OpenGL ES wrapper libraries&quot;);</div><div class="line"></div><div class="line">    return (void*)hnd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>open() 函数主要负责 OpenGL ES 库加载前的准备工作，具体的加载细节，则是通过调用 load_driver() 去完成的。</p>
<p>Loader::load_driver() 函数代码如下所示： /frameworks/native/opengl/libs/EGL/Loader.cpp
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">void *Loader::load_driver(const char* kind,</div><div class="line">                          egl_connection_t* cnx, uint32_t mask)</div><div class="line">&#123;</div><div class="line">    ATRACE_CALL();</div><div class="line"></div><div class="line">    void* dso = nullptr;</div><div class="line">    if (mGetDriverNamespace) &#123;</div><div class="line">        android_namespace_t* ns = mGetDriverNamespace();</div><div class="line">        if (ns) &#123;</div><div class="line">            dso = load_updated_driver(kind, ns); //加载 OpenGL ES 实现库，放回打开的共享链接库的句柄</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!dso) &#123;</div><div class="line">        dso = load_system_driver(kind);</div><div class="line">        if (!dso)</div><div class="line">            return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 解析 EGL 库，并将wrapper 库 libEGL.so 中的函数 API 指针和具体的实现绑定在一起</div><div class="line">    if (mask &amp; EGL) &#123;</div><div class="line">        getProcAddress = (getProcAddressType)dlsym(dso, &quot;eglGetProcAddress&quot;);</div><div class="line"></div><div class="line">        ALOGE_IF(!getProcAddress,</div><div class="line">                 &quot;can&apos;t find eglGetProcAddress() in EGL driver library&quot;);</div><div class="line"></div><div class="line">        egl_t* egl = &amp;cnx-&gt;egl; //将 egl 指针指向描述当前系统支持 OpenGL ES和 EGL 全局变量的 gEGLImpl</div><div class="line">        __eglMustCastToProperFunctionPointerType* curr =</div><div class="line">            (__eglMustCastToProperFunctionPointerType*)egl;</div><div class="line">        char const * const * api = egl_names; //egl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 EGL API 函数指针</div><div class="line">        while (*api) &#123;</div><div class="line">            char const * name = *api;</div><div class="line">            __eglMustCastToProperFunctionPointerType f =</div><div class="line">                (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);</div><div class="line">            if (f == NULL) &#123;</div><div class="line">                // couldn&apos;t find the entry-point, use eglGetProcAddress()</div><div class="line">                f = getProcAddress(name);</div><div class="line">                if (f == NULL) &#123;</div><div class="line">                    f = (__eglMustCastToProperFunctionPointerType)0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            *curr++ = f; //这一步就是最关键的将共享链接库中的 EGL API 的实现和上层调用的 API 函数指针绑定在一起</div><div class="line">            api++; //指向下一个需要绑定的 api 函数</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 解析 OpenGL ES 库中的 OpenGL ES 1.x API 符号</div><div class="line">    if (mask &amp; GLESv1_CM) &#123;</div><div class="line">        // 调用 init_api 实现 OpenGL API 和对应实现函数的绑定</div><div class="line">        init_api(dso, gl_names, // gl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 OpenGL ES API 函数指针</div><div class="line">                 (__eglMustCastToProperFunctionPointerType*)</div><div class="line">                 &amp;cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl, //gl成员变量是一个结构体变量，结构体中的是 OpenGL ES API 函数指针</div><div class="line">                 getProcAddress);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 解析 OpenGL ES 库中的 OpenGL ES 2.0 API 符号</div><div class="line">    if (mask &amp; GLESv2) &#123;</div><div class="line">        init_api(dso, gl_names,</div><div class="line">                 (__eglMustCastToProperFunctionPointerType*)</div><div class="line">                 &amp;cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl,</div><div class="line">                 getProcAddress);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return dso;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Loader::load_driver() 它主要实现了两个功能：</p>
<p>通过 load_system_driver()  函数查找 OpenGL ES/EGL 实现库，并在指定的存放路径中找到共享链接库文件并打开它。
调用 init_api()解析打开的 OpenGL ES/EGL 共享链接库，将 OpenGL ES/EGL API 函数指针和共享链接库中实现的对应的函数符号绑定在一起，这样调用 OpenGL ES/EGL API 就会调用到具体实现的OpenGL ES/EGL 共享链接库中对应函数。
具体 load_system_driver() 函数和 init_api() 函数的实现就不一一展开了，大家可以到 /frameworks/native/opengl/libs/EGL/Loader.cpp 文件中查看，应该写得非常直接清楚了。</p>
<p>整个加载和解析的目的就是将 OpenGL ES/EGL API 和具体实现函数绑定在一起，这样当程序调用 OpenGL ES/EGL API 时，就会调用到实际的实现函数了。然后，在硬件平台上的 Android 系统加载的是硬件厂商提供的 OpenGL ES/EGL 实现库，而在 qemu 模拟器中运行的 Android 系统中加载的则是软件模拟实现的 OpenGL ES/EGL 库或者是将 OpenGL ES 重定向到主机系统中进行硬件加速的库。</p>
<p><a href="https://woshijpf.github.io/android/2017/09/05/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88OpenGLES%E5%92%8CEGL%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" target="_blank" rel="external">Android 系统图形栈（二）：OpenGL ES 库和 EGL 库加载过程</a>
<a href="http://www.2net.co.uk/tutorial/android-egl-cgf-is-dead" target="_blank" rel="external">How Android finds OpenGL libraries, and the death of egl.cfg</a></p>
<h4 id="eglSwapBuffers接口实现说明"><a href="#eglSwapBuffers接口实现说明" class="headerlink" title="eglSwapBuffers接口实现说明"></a>eglSwapBuffers接口实现说明</h4><p>一般性嵌入式平台
<img src="http://images.wodekouwei.com/gl/egl_swapbuffer.png" alt="iamge"></p>
<p>利用双缓冲进行Swap的时候，Display和Surface进行实际意义上的地址交换，来实现eglSwapBuffers的标准， 如上图的右侧所示。上图的左侧表示，单缓冲Framebuffer的形式，Surface永远都在后端， 显示的永远是Display，在GPU出现后已不使用。</p>
<p>Android平台:
为了实现eglSwapBuffers， eglSurface其实代表了一个从NativeWindow 申请到的一个Buffer（Dequeue操作）。当调用eglSwapBuffers时，对于一般应用窗口而言，NativeWindow将该Surface的Buffer 提交回去给SurfaceFlinger（Queue操作)，然后又重新从NativeWindow中重新Dequeue出来一个新的Buffer给eglSurface。而eglDisplay并不代表实际的意义。我们只是从接口上感觉是，surface和display进行了交换。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenGL ES的javax.microedition.khronos.openges包定义了平台无关的GL绘制指令,EGL(javax.microedition.khronos.egl)则定义了控制dispays,contexts以及surfaces的统一的平台接口.&lt;
    
    </summary>
    
      <category term="OpenGL" scheme="http://wodekouwei.com/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="http://wodekouwei.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>日常的</title>
    <link href="http://wodekouwei.com/2019/01/30/daily/"/>
    <id>http://wodekouwei.com/2019/01/30/daily/</id>
    <published>2019-01-30T10:36:22.000Z</published>
    <updated>2019-02-20T11:25:42.131Z</updated>
    
    <content type="html"><![CDATA[<p>Parameters were incorrect. We wanted {“required”:[“desiredCapabilities”],
pip uninstall selenium
pip install selenium==3.0.1</p>
<p>fbo与pbuffer区别</p>
<p>像zoom这样把多个流放到一个upd里究竟有什么好处?
节省端口
这个理由似乎不是很充分，付出的代价有点大，而且单机其实支持不了多少路，端口足够用了</p>
<p>付出什么代价了
单机支持一两千路足够视频会议用了\</p>
<p>猜测而已: 1. 避免NAT穿越时候多个Port的维护  2. 在UDP层面复用的话，保证UDP的流量足够，同时也避免了维护多个Socket，减小资源开销
当集群来应对大量客户的时候，这样做的话，机器之间会有很多的互相拉流的操作，</p>
<p>ICE打洞过程会快了，但是也得要支持动态更新啊，因为肯定会存在半路上有人进，有人出，SDP不是要变化吗？</p>
<p>没记错的话，RTP、RTCP曾经打算复用一个Port，避免一次使用两个 ：）</p>
<p>和TS的统计复用很类似
所以我猜测Zoom并不是全部随意把流放到一个Port里面去，上层逻辑是做了控制的
TS的统计复用是为了适应CBR</p>
<p>我抓包看到ZOOM是哪个SFU入，就从那个SFU出流，但流被复接连</p>
<p>是不是好做集群，好做负载均衡，好做就近接入，还是好和SD-WAN结合，我想ZOOM体验那么好，一定是多方面优化的结果，究竟在哪些地方不一样达成的这种效果</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Parameters were incorrect. We wanted {“required”:[“desiredCapabilities”],
pip uninstall selenium
pip install selenium==3.0.1&lt;/p&gt;
&lt;p&gt;fbo与p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android性能</title>
    <link href="http://wodekouwei.com/2019/01/30/at-android-performance/"/>
    <id>http://wodekouwei.com/2019/01/30/at-android-performance/</id>
    <published>2019-01-30T04:20:22.000Z</published>
    <updated>2019-03-05T14:27:10.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能标准"><a href="#性能标准" class="headerlink" title="性能标准"></a>性能标准</h2><p>安卓绿色联盟应用性能标准主要基于主观体验、资源消耗和应用质量三个方面进行制定。</p>
<ol>
<li>主观体验:主观体验主要是对应用启动时间和界面帧率制定标准，要求应用在视觉上足够流畅。其中应用启动时间又分为冷启动时间和热启动时间.安卓绿色联盟性能标准要求，应用冷启动时间需小于1000ms，热启动时间需小于500ms；普通应用帧率应大于55fps，游戏视频帧率应大于25fps。</li>
<li>资源消耗:资源消耗主要是要求应用不能占用过高的内存和CPU。安卓绿色联盟性能标准要求应用前台内存占用应小于500M，后台内存占用应小于400M；在CPU占用方面要求应用在后台灭屏5分钟后，CPU占用不超过2%。</li>
<li>应用质量:应用质量主要是对应用过度绘制和内存泄露的情况作出要求，规定应用不能存在过度绘制和内存泄露。安卓绿色联盟性能标准要求应用界面任意像素点不存在4x的绘制的情况， 3x绘制的区域不能超过界面面积的1/3，在Strict Mode中不允许有红框闪烁。</li>
</ol>
<h3 id="性能调试方法"><a href="#性能调试方法" class="headerlink" title="性能调试方法"></a>性能调试方法</h3><p>在了解性能调试方法之前，我们可以先通过下图了解安卓应用性能与系统之间的关系。一个应用从应用绘制到最终显示在LCD上经历了一个漫长的路径，在任何一个阶段出现延时都会导致界面上的卡顿。
<img src="http://images.wodekouwei.com/at-android-performance-201935151844.jpg" alt="at-android-performance-201935151844"></p>
<h4 id="1、Strict-Mode"><a href="#1、Strict-Mode" class="headerlink" title="1、Strict Mode"></a>1、Strict Mode</h4><p>Strict Mode意思为严格模式，是Android提供的一种运行时检测机制，一般用来检测在主线程发生的耗时动作，比如IO读写、数据库操作、复杂算法等。在手机设置开发者选项把Strict Mode打开，就可以在界面上把它打开了。</p>
<p>严格模式主要有2个策略，一个是线程策略，即ThreadPolicy，主要检测主线程中的一些耗时操作；另一个是虚拟机策略，即VmPolicy，主要检测一些对象的泄漏。</p>
<p>两大策略检测的内容和开启方法可以依据下图中的说明进行使用。
<strong>ThreadPolicy</strong>:</p>
<ul>
<li>自定义的耗时调用使用detectCustomSlowCalls()开启</li>
<li>磁盘读取操作使用detectDiskReads()开启</li>
<li>磁盘写入操作使用detectDiskWrites()开启</li>
<li>网络操作使用detectNetwork()开启</li>
</ul>
<p><strong>VmPolicy</strong>:</p>
<ul>
<li>Activity泄露使用detectActivityLeaks()开启</li>
<li>未关闭的Closable对象泄露使用detectLeakedClosableObjects()开启</li>
<li>泄露的Sqlite对象,使用detectLeakedSqlLiteObjects()开启</li>
<li>检测实例数量,使用setClassInstanceLimit()开启
严格模式有三种惩罚模式：应用崩溃、弹窗警告和打印日志。在性能测试中，我们可以通过APPLogcat抓取Strict Mode的日志，同时利用代码启用Strict Mode，配合我们所需要的策略和惩罚，就可以及时定位应用的违规细节，并及时进行性能优化。</li>
</ul>
<p>当我们碰到违规的行为时，该如何进行治理呢？建议将文件操作放到工作线程去完成，如果在主线程上提及操作，建议使用Apply和Commit去完成。如果存在对象未关闭的情况，可以通过对应的StackTrace进行关闭。</p>
<h4 id="2、OverDraw-DeBugger"><a href="#2、OverDraw-DeBugger" class="headerlink" title="2、OverDraw DeBugger"></a>2、OverDraw DeBugger</h4><p>Overdraw是指屏幕上的某个像素在同一帧的时间内被绘制了多次，这个工具使用色块来代表不同数量的过度绘制，我们可以使用这个工具来定位由过度绘制引起的用户界面卡顿问题。</p>
<p>在开发者选项中选择开启 Debug GPU Overdraw选项，即可在安卓设备上将过度绘制问题可视化。
<img src="http://images.wodekouwei.com/at-android-performance-201935152838.jpg" alt="at-android-performance-201935152838">
左图为正常模式下显示的视图，右图为开启GPU Overdraw后显示的视图</p>
<h4 id="3、Profile-GPU-Rendering"><a href="#3、Profile-GPU-Rendering" class="headerlink" title="3、Profile GPU Rendering"></a>3、Profile GPU Rendering</h4><p>ProfileGPU Rendering 工具以滚动直方图的形式直观地显示渲染界面窗口帧所花费的相对时间（以每帧 16 毫秒的速度作为对比基准）。这个工具同样也是在安卓设备的开发者选项中开启。每个管线的高度表示时间，管线中各个彩色区段代表不同含义。</p>
<p>下表介绍了使用运行Android 6.0及更高版本的设备时分析器中不同竖条区段的含义。
<img src="http://images.wodekouwei.com/at-android-performance-201935152931.jpg" alt="at-android-performance-201935152931"></p>
<h4 id="4、Android-Profiler"><a href="#4、Android-Profiler" class="headerlink" title="4、Android Profiler"></a>4、Android Profiler</h4><p>Android Profiler是一个Android Studio集成的应用性能分析器，可以实时查看CPU、Memory和Network的动态情况。以下重点介绍CPU Profiler：</p>
<p>CPU Profiler 可帮助您实时检查应用的 CPU 使用率和线程 Activity，并记录函数跟踪，方便大家优化和调试应用代码。</p>
<p>当打开 CPU Profiler 时，它将显示应用的 CPU 使用率和线程 Activity。
CPU Profiler可以选择不同的标签，并对应用线程进行跟踪。如：</p>
<ul>
<li>Flame Chart标签会提供一个倒置的调用图表，汇总相同的调用堆栈，收集调用顺序完全一致的函数，并在火焰图中用一个较长的横条表示它们。</li>
<li>Top Down标签能够提供每个函数调用上所花费的CPU时间。Self表示函数调用在执行自己的代码上所花的时间；Children表示函数调用子方法所花费的时间；Total表示Self和Children时间的总和。</li>
</ul>
<h4 id="5、Systrace"><a href="#5、Systrace" class="headerlink" title="5、Systrace"></a>5、Systrace</h4><p>Systrace是我们分析性能最常用的工具之一，它可以分析整机系统性能及动态场景的性能问题。</p>
<p>Systrace 允许您在系统级别收集和检查设备上运行的所有进程的计时信息。它将来自Android内核的数据（例如CPU调度程序，磁盘活动和应用程序线程）组合起来，以生成HTML报告。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935153057.jpg" alt="at-android-performance-201935153057">
上图左部是Systrace的界面，我们可以通过右边的代码抓取Systrace，观察进程的执行时间。在输入抓取命令时，时间参数一般选择5到10秒，因为时间过短可能会抓不到想要的数据，时间过长则可能抓取失败。</p>
<p>一般我们通过Chrome浏览器查看生成的trace文件，也可以通过DDMS图形界面去抓取Systrace。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935153130.jpg" alt="at-android-performance-201935153130">
拿到一个Systrace时主要考察哪些因素？首先看一下CPU的频率，找到对应的进程或者线程，查看相关信息；同时还要观察GPU的频率、Surface Flinger还有绘图的Buffer状态等。</p>
<p>当应用发生卡顿时，我们可以通过Systrace进行分析。在生成的trace文件中，找到主线程UI，每一帧都会标记一个带有F的圆形。当原型为绿色时，代表页面流畅，而黄色和红色则存在超时，我们可以点击去查看具体存在什么问题。</p>
<h3 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h3><p>应用启动时间是应用性能最重要的指标之一,分冷启动和热启动两种情况:</p>
<ul>
<li>冷启动:当APP启动时,后台没有该app的进程,这时系统会重新创建一个新的进程分配给该app,这个启动方式就叫做冷启动(后台不存在该APP进程)</li>
<li>热启动:当APP已经被打开,但是被按下返回键,Home键等按钮时回到桌面或者是其他程序的时候,再重新打开该APP时,这种方式叫做热启动(后台已经存在该APP进程)</li>
</ul>
<p>测试方法:
将手机root之后,使用adb工具连接手机.使用adb shell am start -S -W 命令获取应用冷启动时间,adb shell am Start -W命令获取应用冷启动时间.
<code>adb shell am start -W -n packagename/packageName.MainActivity</code>
<code>aapt dump badging &lt;apk路径&gt;</code>:搜package 的 launchable-activity</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-20193512931.png" alt="at-android-performance-20193512931">
执行成功后将返回三个测量到的时间：</p>
<ol>
<li>ThisTime:一般和TotalTime时间一样，除非在应用启动时开了一个透明的Activity预先处理一些事再显示出主Activity，这样将比TotalTime小。</li>
<li>TotalTime:应用的启动时间，包括创建进程+Application初始化+Activity初始化到界面显示。</li>
<li>WaitTime:一般比TotalTime大点，包括系统影响的耗时。</li>
</ol>
<p>关于ThisTime/TotalTime/WaitTime的区别,下面是其解释：“adb shell am start -W ”的实现在『frameworks\base\cmds\am\src\com\android\commands\am\Am.java』文件中。其实就是跨Binder调用ActivityManagerService.startActivityAndWait() 接口（后面将ActivityManagerService简称为AMS），这个接口返回的结果包含上面打印的ThisTime、TotalTime时间.</p>
<ul>
<li>startTime记录的刚准备调用startActivityAndWait()的时间点</li>
<li>endTime记录的是startActivityAndWait()函数调用返回的时间点</li>
<li>WaitTime = startActivityAndWait()调用耗时。</li>
</ul>
<p>ThisTime、TotalTime 的计算在 frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java 文件的 reportLaunchTimeLocked() 函数中。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private void reportLaunchTimeLocked(final long curTime) &#123;</div><div class="line">    final ActivityStack stack = task.stack;</div><div class="line">    final long thisTime = curTime - displayStartTime;</div><div class="line">    final long totalTime = stack.mLaunchStartTime != 0</div><div class="line">            ? (curTime - stack.mLaunchStartTime) : thisTime;</div><div class="line">    if (ActivityManagerService.SHOW_ACTIVITY_START_TIME) &#123;</div><div class="line">        Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;launching&quot;, 0);</div><div class="line">        EventLog.writeEvent(EventLogTags.AM_ACTIVITY_LAUNCH_TIME,</div><div class="line">                userId, System.identityHashCode(this), shortComponentName,</div><div class="line">                thisTime, totalTime);</div><div class="line">        StringBuilder sb = service.mStringBuilder;</div><div class="line">        sb.setLength(0);</div><div class="line">        sb.append(&quot;Displayed &quot;);</div><div class="line">        sb.append(shortComponentName);</div><div class="line">        sb.append(&quot;: &quot;);</div><div class="line">        TimeUtils.formatDuration(thisTime, sb);</div><div class="line">        if (thisTime != totalTime) &#123;</div><div class="line">            sb.append(&quot; (total &quot;);</div><div class="line">            TimeUtils.formatDuration(totalTime, sb);</div><div class="line">            sb.append(&quot;)&quot;);</div><div class="line">        &#125;</div><div class="line">        Log.i(ActivityManagerService.TAG, sb.toString());</div><div class="line">    &#125;</div><div class="line">    mStackSupervisor.reportActivityLaunchedLocked(false, this, thisTime, totalTime);</div><div class="line">    if (totalTime &gt; 0) &#123;</div><div class="line">        //service.mUsageStatsService.noteLaunchTime(realActivity, (int)totalTime);</div><div class="line">    &#125;</div><div class="line">    displayStartTime = 0;</div><div class="line">    stack.mLaunchStartTime = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>curTime表示该函数调用的时间点.</li>
<li>displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.</li>
<li>mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点.</li>
</ul>
<p>正常情况下点击桌面图标只启动一个有界面的 Activity，此时 displayStartTime 与mLaunchStartTime 便指向同一时间点，此时 ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的 Activity 做逻辑处理，接着又启动一个有界面的Activity，在这种启动一连串 Activity 的情况下（知乎的启动就是属于这种情况），displayStartTime 便指向最后一个 Activity 的开始启动时间点，mLaunchStartTime 指向第一个无界面Activity的开始启动时间点，此时 ThisTime！=TotalTime。这两种情况如下图：
<img src="http://images.wodekouwei.com/at-android-performance-20193514439.png" alt="at-android-performance-20193514439"></p>
<p>在上面的图中，我用①②③分别标注了三个时间段，在这三个时间段内分别干了什么事呢？</p>
<ul>
<li>在第①个时间段内，AMS 创建 ActivityRecord 记录块和选择合理的 Task、将当前Resume 的 Activity 进行 pause</li>
<li>在第②个时间段内，启动进程、调用无界面 Activity 的 onCreate() 等、 pause/finish 无界面的 Activity</li>
<li>在第③个时间段内，调用有界面 Activity 的 onCreate、onResume</li>
</ul>
<p>看到这里应该清楚 ThisTime、TotalTime、WaitTime 三个时间的关系了吧。WaitTime 就是总的耗时，包括前一个应用 Activity pause 的时间和新应用启动的时间；ThisTime 表示一连串启动 Activity 的最后一个 Activity 的启动耗时；TotalTime 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，但不包括前一个应用 Activity pause 的耗时。也就是说，开发者一般只要关心 TotalTime 即可，这个时间才是自己应用真正启动的耗时。</p>
<p>Event log中 TAG=am_activity_launch_time 中的两个值分表表示 ThisTime、TotalTime，跟通过 “adb shell am start -W ” 得到的值是一致的。</p>
<p>最后再说下系统根据什么来判断应用启动结束。我们知道应用启动包括进程启动、走 Activity生命周期 onCreate/onResume 等。在第一次 onResume 时添加窗口到WMS中，然后measure/layout/draw，窗口绘制完成后通知 WMS，WMS 在合适的时机控制界面开始显示(夹杂了界面切换动画逻辑)。记住是窗口界面显示出来后，WMS 才调用reportLaunchTimeLocked() 通知 AMS Activity 启动完成。</p>
<p>最后总结一下，如果只关心某个应用自身启动耗时，参考TotalTime；如果关心系统启动应用耗时，参考WaitTime；如果关心应用有界面Activity启动耗时，参考ThisTime。</p>
<p><strong>指标</strong></p>
<p>一般情况下，应用启动时间在1秒以内，用户反馈系统响应很快；1-3秒内完成启动，用户认为反应速度尚可；3-5秒内完成启动，用户会认为系统反应很慢，但是还可以接受；若启动时间超过5秒，则大部分用户会认为系统反应糟糕，甚至卸载应用。</p>
<p>安卓绿色联盟应用体验标准规定，应用冷启动时间应该不超过1000毫秒，热启动时间应该不超过500毫秒，若不满足，则无法获得绿色应用认证。</p>
<p>从上面的测评结果可以看出，参与测评的8款应用冷启动和热启动的时间都是非常快，也都符合安卓绿色联盟对绿色应用启动时间标准。其中QQ音乐和芒果TV的冷启动时间最为优秀，分别只有283毫秒和596毫秒。</p>
<p>Android系统上，APP无进程状态，启动流程见下：
Application的构造器方法 ——&gt;attachBaseContext() ——&gt;onCreate() ——&gt;Activity的构造方法 ——&gt;onCreate() ——&gt;配置主题中背景等属性 ——&gt;onStart() ——&gt;onResume() ——&gt;测量布局绘制显示在界面上。</p>
<p>当点击APP的启动图标时，安卓系统会从Zygote进程中fork创建出一个新的进程分配给该应用，之后会依次创建和初始化Application类、创建MainActivity类、加载主题样式Theme中的windowBackground等属性设置给MainActivity以及配置Activity层级上的一些属性、再inflate布局、当onCreate/onStart/onResume方法都走完了后最后才进行contentView的measure/layout/draw显示在界面上，所以直到这里，应用的第一次启动才算完成，这时候我们看到的界面也就是所说的第一帧。</p>
<p>启动时间:</p>
<ol>
<li>冷启动时间:当用户点击目标app图标的 timepoint到显示界面第一帧的时间段（当用户点击你的app那一刻到系统调用Activity.onCreate()之间的时间段）,在这个时间段内，WindowManager会先加载app主题样式中的windowBackground做为app的预览元素，然后再真正去加载activity的layout布局。API19 之后，系统会出打印日志输出启动的时间:冷启动时间 = 应用启动（创建进程） —&gt; 完成视图的第一次绘制（Activity内容对用户可见）；</li>
<li>热启动时间:用户把目标app切换至后台后，点击app图标的timepoint到显示界面第一帧的时间段</li>
</ol>
<p>优化建议</p>
<ol>
<li>减少Application中过多的三方SDK初始化操作，在真正使用到功能时在进行初始化操作。</li>
<li>减少首界面布局文件的层级和嵌套，来减少界面的量测和绘制的时间。</li>
<li>减少首界面oncreate()方法中的复杂逻辑和工作量，从而降低启动时间。</li>
<li>不要以静态变量的方式在Application中保存数据</li>
</ol>
<h3 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h3><p>人为感受的性能不好属于下面两种:</p>
<ol>
<li>响应时间,界面跳转后响应时间</li>
<li>流畅度,界面操作时或动画展示的效果</li>
</ol>
<p>流畅度的衡量指标:</p>
<ol>
<li>帧率fps</li>
<li>丢帧SF(Skipped frame)</li>
<li>流畅度SM(SMoothness)</li>
</ol>
<p>帧率计算:</p>
<ol>
<li><code>adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt;</code></li>
<li><code>adb shell dumpsys SurfaceFlinger --latency &lt;window_activity&gt;</code></li>
</ol>
<p><a href="https://blog.csdn.net/itfootball/article/details/43084527" target="_blank" rel="external">https://blog.csdn.net/itfootball/article/details/43084527</a>
<a href="https://developer.android.com/training/testing/performance?hl=zh-cn" target="_blank" rel="external">https://developer.android.com/training/testing/performance?hl=zh-cn</a>
<a href="https://testerhome.com/topics/4441" target="_blank" rel="external">https://testerhome.com/topics/4441</a>
<a href="https://testerhome.com/topics/4643" target="_blank" rel="external">https://testerhome.com/topics/4643</a></p>
<h4 id="页面响应时间TTLB-Time-To-Last-Byte"><a href="#页面响应时间TTLB-Time-To-Last-Byte" class="headerlink" title="页面响应时间TTLB(Time To Last Byte)"></a>页面响应时间TTLB(Time To Last Byte)</h4><p>页面响应时间是指从用户发出请求到客户端收到最后一个字节所耗费的时间.</p>
<h3 id="性能案例分析"><a href="#性能案例分析" class="headerlink" title="性能案例分析"></a>性能案例分析</h3><h4 id="案例1：界面滑动卡顿"><a href="#案例1：界面滑动卡顿" class="headerlink" title="案例1：界面滑动卡顿"></a>案例1：界面滑动卡顿</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154448.jpg" alt="at-android-performance-201935154448"></p>
<p>从图中可以看到，这是一个手动滑动事件，当deliverInput事件发生后，第一帧就发生了卡顿。从systrace看UI thread执行draw的时间相当耗时导致丢帧卡顿，而且大部分时间都在做decodeBitmap，共耗时99.045ms。这时，我们打开applog发现，有StrictMode相关的错误提示，从中可以定位到耗时函数。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-20193515453.jpg" alt="at-android-performance-20193515453"></p>
<p>从上图我们看出有一个网络访问违规，大概可以推测应用在从网络上下载了一个数据流，数据流里可能包含了一些图形，通过decodeBitmap把它解析出来展示在UI界面中。正产情况下，我们应该把网络访问放在工作线程里面去处理，将数据下载完了之后再放到主线程中去展示，避免这种问题的发生。</p>
<h4 id="案例2：Strict-Mode错误提示"><a href="#案例2：Strict-Mode错误提示" class="headerlink" title="案例2：Strict Mode错误提示"></a>案例2：Strict Mode错误提示</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154542.jpg" alt="at-android-performance-201935154542">
从上图Strict Mode的日志可以看出：StrictMode policy violation耗时2秒左右。通过最下行蓝色的log，可以知道应用是在某一个目录里面寻找一个文件，判断文件是否存在。</p>
<p>面对这种问题，我们应该把IO操作放到工作线程。正常情况下IO的发生非常快，但是在系统繁忙时，IO放在主线程会产生较大的问题，因为它要等别的程序读写完成之后，才会下发，产生超时。</p>
<h4 id="案例3：GPU调用不当导致的卡顿问题"><a href="#案例3：GPU调用不当导致的卡顿问题" class="headerlink" title="案例3：GPU调用不当导致的卡顿问题"></a>案例3：GPU调用不当导致的卡顿问题</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154612.jpg" alt="at-android-performance-201935154612">
这是一个GPU的例子，上图主要问题是GPU使用了太长时间处理应用传过来的buffer,例子中Surfaceflinger 使用GPU 做了图像叠加，说明图层比较多。使用GPU做叠加主要会产生功耗和唤醒耗时的问题。大家在做界面设计的时候，尽量不要使用GPU进行叠加。在上面的例子中，GPU叠加之后，导致了大概15ms左右的延时，因为GPU操作完成以后还需要交给Surfaceflinger把图像显示到屏幕上。</p>
<h4 id="案例4：CPU调用不当导致的界面滑动卡顿问题"><a href="#案例4：CPU调用不当导致的界面滑动卡顿问题" class="headerlink" title="案例4：CPU调用不当导致的界面滑动卡顿问题"></a>案例4：CPU调用不当导致的界面滑动卡顿问题</h4><p><img src="http://images.wodekouwei.com/at-android-performance-201935154711.jpg" alt="at-android-performance-201935154711">
可以通过上图的红色条块了解messageloop RunTask信息，红色条块上的蓝色bar，表示线程在CPU上的状态。蓝色表示这个线程处于等待CPU调度的状态，可见等待超过8ms的时间，是正常调度周期好几倍。导致这种情况发生的原因有两个：CPU负载过大或CPU调度出现了问题。在上图中我们可以看出，CPU0和CPU1使用率100%，但是CPU2和CPU3是offline的状态，说明系统出现问题，导致CPU2和CPU3未能唤醒，帮助完成系统任务。</p>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><h4 id="1、避免内存泄露"><a href="#1、避免内存泄露" class="headerlink" title="1、避免内存泄露"></a>1、避免内存泄露</h4><p>在应用开发过程中，首先要避免内存泄露的问题，内存泄露是一种比较严重的性能问题，在安卓绿色联盟应用性能标准中也要求应用不允许发生内存泄露。
常见内存泄露:</p>
<ol>
<li>手动关闭try/catch/finally中使用网络文件等流文件的对象,关注对象:HTTP,File, ContentProvider,Bitmap,Uri,Socket</li>
<li>注意关闭onDestroy()或者onPause()中未及时关闭对象,防止如下内存泄露:线程泄露,Handler泄露,广播泄露,第三方SDK/开源框架泄露,各种callBack/Listener的泄露</li>
</ol>
<p>常见内存泄露坚持工具:</p>
<ul>
<li>Memory Monitor</li>
<li>Allocation Tracker</li>
<li>Heap Viewer</li>
<li>LeakCanary</li>
</ul>
<h4 id="2、避免不良设计或程序算法导致CPU占有率持续偏高"><a href="#2、避免不良设计或程序算法导致CPU占有率持续偏高" class="headerlink" title="2、避免不良设计或程序算法导致CPU占有率持续偏高"></a>2、避免不良设计或程序算法导致CPU占有率持续偏高</h4><ul>
<li>主要业务处理分散到不同线程，便于后续利用多核处理器的并行处理能力，避免一核累死，7核围观；</li>
<li>使用top命令观察应用线程的CPU占有率，找出高负载的进程进行分析，并针对优化。</li>
</ul>
<h4 id="3、避免OnXXX-回调函数中进行耗时操作，避免主线程卡顿"><a href="#3、避免OnXXX-回调函数中进行耗时操作，避免主线程卡顿" class="headerlink" title="3、避免OnXXX 回调函数中进行耗时操作，避免主线程卡顿"></a>3、避免OnXXX 回调函数中进行耗时操作，避免主线程卡顿</h4><p>Android系统中正常情况下所有onXXX类函数均运行在主线程中。
两帧中间有一个因为接收广播处理导致的158ms的卡顿。在这些函数中，我们应该避免网络通信操作、文件读写操作、数据库数据改动的操作、图形处理、文本分析等操作，将这些工作尽可能的移到工作线程中去，从而避免主线程卡顿。</p>
<h4 id="4、合理使用系统资源"><a href="#4、合理使用系统资源" class="headerlink" title="4、合理使用系统资源"></a>4、合理使用系统资源</h4><p>合理使用系统资源主要指的是软资源。下图是对广播资源调用的一些建议。</p>
<ul>
<li>避免同一广播在多个不同实例中重复注册</li>
<li>对象释放时,必须保证注销广播,避免广播注册泄露</li>
<li>尽量不要过度依赖广播机制进行通信,只注册必要的广播</li>
<li>尽量不要注册使用频繁放生的系统广播</li>
<li>不高频调用系统服务接口,避免引起系统互锁造成阻塞</li>
</ul>
<h2 id="性能治理"><a href="#性能治理" class="headerlink" title="性能治理"></a>性能治理</h2><h3 id="主线程卡顿"><a href="#主线程卡顿" class="headerlink" title="主线程卡顿"></a>主线程卡顿</h3><p>主线程卡顿是因为主线程的消息超过阈值，从而导致页面丢帧。手淘通过接管主线程消息的分发机制，获取消息的分发耗时和消息类型，从而定位触发主线程卡顿的具体业务并进行针对性治理。</p>
<p>另外手淘在使用系统的SharedPreferences时，发现页面跳转导致界面ANR的情况。通过阅读系统源码，发现它在做Receiver或者Service时会强制把所有SharedPreferences apply的内容写入文档，导致ANR。针对这个问题，手淘重写SharedPreferences提升性能，减少了这类ANR问题的发生。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935222118.jpg" alt="at-android-performance-201935222118"></p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>手淘团队投入了大量时间对内存泄露进行治理。一方面通过接管系统底层组件的生命周期，当组件的生命周期销毁时，对它进行一个WeakReference的引用，然后根据GC事件触发情况来判定该对象是否泄漏。另一方面，在Native层通过Hook操作系统底层malloc和free方法，计算每一个so处理内存的情况，根据malloc与free差值大小与白名单进行对比判断是否存在内存泄露。</p>
<p>内存使用不当</p>
<p>何为内存使用不当？举个例子，当开发一个大小为100×100 view，实际却使用了200<em>200甚至更大的bitmap。比如在系统drawable目录下放置一张图片，在高清的设备上展示时，它会根据系统自身的原理对它进行拉伸。这时原本只需要单位1的内存（100</em>100），可能变成单位16的内存（400*400），内存的浪费率达到90%以上。针对这种情况，手淘做了一个内存使用不当排查插件。</p>
<p>视频也同样存这种问题，在低分辨率设备上播放高质量的视频不仅不会给用户带来更好的体验，还可能让设备出现卡顿。还有就是图片持有的问题，当页面已经沉入栈底，最好不要保留之前页面的图片。这样可以保证有足够的内存给前台页面使用，否则随着页面层级的深入，很容易出现OOM。</p>
<h3 id="资源泄露"><a href="#资源泄露" class="headerlink" title="资源泄露"></a>资源泄露</h3><p>手淘主要通过接管系统底层的open和close两个Native方法函数对资源泄露进行治理。当open和close没有成对出现，并且该业务并不是伴随整个应用生命周期（伴随整个生命周期的文件有白名单），可以判断该操作可能存在资源泄漏。平台会将该异常行为告知对应的开发同学检查和治理。数据库的治理同样也采用了这套方案。</p>
<h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><p>线程问题比较复杂。在线程创建时可能会触发一些意想不到的问题，比如Out Of Memory error。Out Of Memory error可能是由线程创建失败导致的。因此，手淘对线程创建进行了接管。业务在创建时，对它的方法调用栈进行聚类，就可以知道每个业务创建的线程数量，以及线程创建是否合理。建议应用开发者在创建线程时一定规范命名，以便快速定位具体的业务方。</p>
<h3 id="流量监控"><a href="#流量监控" class="headerlink" title="流量监控"></a>流量监控</h3><p>手淘主要是通过接管Socket协议，分析协议头部获取请求和回流数据内容的大小信息进行流量监控治理。如发现异常，可以让开发同学定位解决。同时也可以监听后台流量行为，观察APP切到后台以后是否还有大量的网络请求。</p>
<p><img src="http://images.wodekouwei.com/at-android-performance-201935222346.jpg" alt="at-android-performance-201935222346"></p>
<h3 id="设备评级"><a href="#设备评级" class="headerlink" title="设备评级"></a>设备评级</h3><p>安卓设备百花齐放，手淘对不同的设备采取了计分的方法进行评级，根据设备分数采用不同的策略，展示相应的图片、视频和业务，给用户带来最佳的性能体验。这个设备评级方案可以给开发同学提供指导建议，更好的展现业务形态。</p>
<h3 id="布局性能"><a href="#布局性能" class="headerlink" title="布局性能"></a>布局性能</h3><p>在开发的过程中，常常要通过HierarchyViewer的方法检查布局结构是否合理。手淘写了一套算法，检查页面结构是否合理，页面层级是否过深、页面层级是否还有继续优化的空间。同时还实现了一套OverDraw的算法，给开发同学提示具体哪个层级可以优化，怎么样的降层级，怎么样解决OverDraw的问题。</p>
<h3 id="用户体验优化"><a href="#用户体验优化" class="headerlink" title="用户体验优化"></a>用户体验优化</h3><p>手淘很关注用户的体验，包括启动时间、每个页面的打开耗时等。通过监控启动时各个子任务的耗时，以及对这些信息快速的分析，判断每一次发版质量变化的具体原因。</p>
<h3 id="4-X设备体验优化"><a href="#4-X设备体验优化" class="headerlink" title="4.X设备体验优化"></a>4.X设备体验优化</h3><p>随着产品功能越来越丰富和产品体积逐渐的壮大，4.X设备出现了multidex越来越慢的情况。基于这个现象，手淘把谷歌的support multidex包进行了重构改造。经过重构以后的support multidex方案，4.X设备的Dex加载随着Dex越来越多，它性能提升越好。</p>
<h3 id="内存容灾"><a href="#内存容灾" class="headerlink" title="内存容灾"></a>内存容灾</h3><p>内存容灾手淘一直很关注。当用户使用当前页面时，如果内存不足，手淘期望后台页面可以快速释放内存资源，为前台页面服务。手淘开发了内存容灾插件，监听JVM的GC事件以及轮寻物理页表计算实际使用物理内存，通过这个计算给手淘的业务方发送对应的内存水位事件，如果是属于非常高危的内存事件，就可以让后台快速的释放缓存资源，从而为可视的页面提供更好的服务</p>
<h2 id="稳定性治理"><a href="#稳定性治理" class="headerlink" title="稳定性治理"></a>稳定性治理</h2><p>稳定性的治理主要是两部分，Java Crash和Native Crash
<img src="http://images.wodekouwei.com/at-android-performance-201935222554.jpg" alt="at-android-performance-201935222554"></p>
<h3 id="Java-Crash治理"><a href="#Java-Crash治理" class="headerlink" title="Java Crash治理"></a>Java Crash治理</h3><p>手淘通过接管UncaughtExceptionHandler，拿到具体的Java Crash的信息及它的堆栈来进行Java Crash治理。Java Crash治理还有一个经常遇到的OOM的情况，一方面可能是虚拟机的内存不足导致的，另一方面可能是线程创建失败导致的，可以使用前面讲到的线程创建插件解决。</p>
<h3 id="Native-Crash治理"><a href="#Native-Crash治理" class="headerlink" title="Native Crash治理"></a>Native Crash治理</h3><p>手淘通过捕获信号量的方式对Native Crash进行治理。当Native发生异常时，创建一个子进程，通过ptrace的方式去dump Native Crash上下文的线程信息。 基于前面讲到的性能治理方式，OOM的Native Crash可以通过malloc和free的接管，定位具体是哪个SO导致这个问题的发生并进行治理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;性能标准&quot;&gt;&lt;a href=&quot;#性能标准&quot; class=&quot;headerlink&quot; title=&quot;性能标准&quot;&gt;&lt;/a&gt;性能标准&lt;/h2&gt;&lt;p&gt;安卓绿色联盟应用性能标准主要基于主观体验、资源消耗和应用质量三个方面进行制定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主观体验:主观体验
    
    </summary>
    
      <category term="autotest" scheme="http://wodekouwei.com/categories/autotest/"/>
    
    
      <category term="android" scheme="http://wodekouwei.com/tags/android/"/>
    
      <category term="autotest" scheme="http://wodekouwei.com/tags/autotest/"/>
    
      <category term="tools" scheme="http://wodekouwei.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>python之基础语法</title>
    <link href="http://wodekouwei.com/2019/01/18/l-python-basic/"/>
    <id>http://wodekouwei.com/2019/01/18/l-python-basic/</id>
    <published>2019-01-18T08:29:11.000Z</published>
    <updated>2019-01-30T04:16:55.306Z</updated>
    
    <content type="html"><![CDATA[<h6 id="python清空列表"><a href="#python清空列表" class="headerlink" title="python清空列表"></a>python清空列表</h6><ol>
<li>在非函数参数的list中使用<code>del list_new[]</code>或者<code>list_new = []</code>来清空列表</li>
<li>对于作为函数中的list,方法1行不通,因为函数执行后,list长度是不变的,但是可以在函数中释放一个参数list所占内存:<code>del list_new[:]</code>或者<code>list_new[:] = []</code>达到清空列表的目的,速度快,并且彻底</li>
</ol>
<h6 id="查看对象占用内存大小"><a href="#查看对象占用内存大小" class="headerlink" title="查看对象占用内存大小"></a>查看对象占用内存大小</h6><p>os.getsizeof(1.0)</p>
<h6 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import struct</div><div class="line">    import math</div><div class="line">    print(&quot;1000.003 is %s&quot; %(int(struct.pack(&apos;&gt;f&apos;, 1000.003).encode(&apos;hex&apos;), 16)))</div><div class="line">    print(&quot;1000.003 is %s&quot; %(struct.pack(&apos;&gt;I&apos;, 1000)))</div><div class="line">    #print(&quot;1000.003 is %d&quot; %(int(floor(1000.003))))</div></pre></td></tr></table></figure>
<p>IEEE 754标准是IEEE二进制浮点数算术标准(IEEE Standard for Floating-Point Arithmetic)的标准编号,它规定了浮点数在计算机当中的存储方式以及算术标准.
计算机中数据均是按二进制的方式存储的,浮点数的存储也是如此.但是由于浮点数的特殊性,无法采用整数的补码存储方式,浮点数需要有特定的存储方式.一个浮点数可以分成3部分存储:</p>
<ul>
<li>sign(符号)</li>
<li>exponent(指数)</li>
<li>fraction(尾数)</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/IEEE_754-1985" target="_blank" rel="external">https://en.wikipedia.org/wiki/IEEE_754-1985</a></p>
<h6 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h6><p>本地模块名和系统库模块名冲突报:
ImportError: cannot import name AttrItem
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import configparser </div><div class="line">print configparser.__file__</div></pre></td></tr></table></figure></p>
<p>自定义configparser与系统冲突,通过打印<strong>file</strong>查看</p>
]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;python清空列表&quot;&gt;&lt;a href=&quot;#python清空列表&quot; class=&quot;headerlink&quot; title=&quot;python清空列表&quot;&gt;&lt;/a&gt;python清空列表&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;在非函数参数的list中使用&lt;code&gt;del list_new
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="python" scheme="http://wodekouwei.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python之函数</title>
    <link href="http://wodekouwei.com/2019/01/17/l-python-method/"/>
    <id>http://wodekouwei.com/2019/01/17/l-python-method/</id>
    <published>2019-01-17T04:15:33.000Z</published>
    <updated>2019-01-17T09:50:11.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul>
<li>位置参数: <code>def power(x):</code></li>
<li>默认参数: <code>def power(x, n=2):</code> 默认参数必须指向不变对象！</li>
<li>可变参数: <code>def calc(*numbers):</code></li>
<li>关键字参数: <code>def person(name, age, **kw):</code></li>
<li>命名关键字参数:<code>def person(name, age, *, city, job):</code></li>
</ul>
<p>参数组合:
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</p>
<p>递归及尾递归优化</p>
<p>切片</p>
<p>迭代 
默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。
通过collections模块的Iterable类型判断一个对象是否可迭代
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from collections import Iterable</div><div class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</div><div class="line">False</div></pre></td></tr></table></figure></p>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</div><div class="line">...     print(i, value)</div><div class="line">...</div><div class="line">0 A</div><div class="line">1 B</div><div class="line">2 C</div></pre></td></tr></table></figure></p>
<p>列表生成器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">list(range(1, 11))</div><div class="line">[x * x for x in range(1, 11)]</div><div class="line">[x * x for x in range(1, 11) if x % 2 == 0]</div><div class="line">[m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; import os</div><div class="line">&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录</div><div class="line">[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</div><div class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]</div><div class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]</div><div class="line">&gt;&gt;&gt; [s.lower() for s in L]</div><div class="line">[&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</div></pre></td></tr></table></figure></p>
<p>生成器：generator 不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制
方法一:只要把一个列表生成式的[]改成()，就创建了一个generator：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</div><div class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</div><div class="line">&gt;&gt;&gt; g</div><div class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</div></pre></td></tr></table></figure></p>
<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">0</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">4</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">9</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">16</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">25</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">36</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">49</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">64</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">81</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">StopIteration</div></pre></td></tr></table></figure></p>
<p>断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</div><div class="line">&gt;&gt;&gt; for n in g:</div><div class="line">...     print(n)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：
函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>
<p>迭代器</p>
<p>高阶函数
map/reduce
map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<p>filter: 用于过滤序列</p>
<p>sorted: 对list进行排序</p>
<p>返回函数</p>
<p>匿名函数</p>
<p>装饰器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;call %s():&apos; % func.__name__)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure></p>
<p>偏函数
functools.partial</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数参数&quot;&gt;&lt;a href=&quot;#函数参数&quot; class=&quot;headerlink&quot; title=&quot;函数参数&quot;&gt;&lt;/a&gt;函数参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;位置参数: &lt;code&gt;def power(x):&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认参数: &lt;code&gt;de
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="python" scheme="http://wodekouwei.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python之面向对象</title>
    <link href="http://wodekouwei.com/2019/01/17/l-python-class/"/>
    <id>http://wodekouwei.com/2019/01/17/l-python-class/</id>
    <published>2019-01-17T02:48:57.000Z</published>
    <updated>2019-01-17T03:12:17.806Z</updated>
    
    <content type="html"><![CDATA[<h6 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h6><p>限制类的绑定属性</p>
<p><code>__str__</code>: print打印对象,返回用户看到的字符串
<code>__repr__</code>:返回程序开发者看到的字符串,如直接输入变量,是为调试服务的 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    def __str__(self):</div><div class="line">    return &apos;Student object (name: %s)&apos; % self.name</div><div class="line"></div><div class="line">print(Student(&apos;hell0&apos;))</div></pre></td></tr></table></figure></p>
<p>可以直接:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__repr = __str__</div></pre></td></tr></table></figure></p>
<p><code>__iter__</code>: 一个类用于for…in循环
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Fib(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.a, self.b = 0, 1</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        return self</div><div class="line">    </div><div class="line">    def __next__(self):</div><div class="line">        self.a, self.b = self.b, self.a+self.b</div><div class="line">        if self.a &gt; 100000:</div><div class="line">            raise StopIteration()</div><div class="line">        return self.a</div><div class="line"></div><div class="line">for n in Fib():</div><div class="line">    print(n)</div></pre></td></tr></table></figure></p>
<p><code>__getitem__</code>:Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; Fib()[5]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: &apos;Fib&apos; object does not support indexing</div></pre></td></tr></table></figure></p>
<p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Fib(object):</div><div class="line">    def __getitem__(self, n):</div><div class="line">        a, b = 1, 1</div><div class="line">        for x in range(n):</div><div class="line">            a, b = b, a + b</div><div class="line">        return a</div></pre></td></tr></table></figure></p>
<p>但是list有个神奇的切片方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list(range(100))[5:10]</div></pre></td></tr></table></figure></p>
<p>对于Fib却报错,原因是<strong>getitem</strong>()传入的参数可能是一个int,也可能是一个切片对象slice,所以要做判断
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def __getitem__(self, n):</div><div class="line">        if isinstance(n, int): # n是索引</div><div class="line">            a, b = 1, 1</div><div class="line">            for x in range(n):</div><div class="line">                a, b = b, a + b</div><div class="line">            return a</div><div class="line">        if isinstance(n, slice): # n是切片</div><div class="line">            start = n.start</div><div class="line">            stop = n.stop</div><div class="line">            if start is None:</div><div class="line">                start = 0</div><div class="line">            a, b = 1, 1</div><div class="line">            L = []</div><div class="line">            for x in range(stop):</div><div class="line">                if x &gt;= start:</div><div class="line">                    L.append(a)</div><div class="line">                a, b = b, a + b</div><div class="line">            return L</div></pre></td></tr></table></figure></p>
<p>但是现在没有对step参数处理f[:10:2],也没有对负数做处理
此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。
与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。
总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<p><code>__getattr__</code>:动态返回一个属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.name = &apos;Michael&apos;</div><div class="line"></div><div class="line">    def __getattr__(self, attr):</div><div class="line">        if attr==&apos;score&apos;:</div><div class="line">            return 99</div></pre></td></tr></table></figure></p>
<p>当调用不存在的属性时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值：
注意，只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性，比如name，不会在<strong>getattr</strong>中查找</p>
<p><code>__call__</code>:一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。</p>
<p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。请看示例
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    def __call__(self):</div><div class="line">        print(&apos;My name is %s.&apos; % self.name)</div></pre></td></tr></table></figure></p>
<p>调用方式如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = Student(&apos;Michael&apos;)</div><div class="line">&gt;&gt;&gt; s() # self参数不要传入</div><div class="line">My name is Michael.</div></pre></td></tr></table></figure></p>
<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; callable(Student())</div><div class="line">True</div><div class="line">&gt;&gt;&gt; callable(max)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; callable([1, 2, 3])</div><div class="line">False</div><div class="line">&gt;&gt;&gt; callable(None)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; callable(&apos;str&apos;)</div><div class="line">False</div></pre></td></tr></table></figure></p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from enum import Enum</div><div class="line"></div><div class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</div><div class="line"></div><div class="line">for name, member in Month.__members__.items():</div><div class="line">    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)</div></pre></td></tr></table></figure>
<p>value属性则是自动赋给成员的int常量，默认从1开始计数。
如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from enum import Enum, unique</div><div class="line"></div><div class="line">@unique</div><div class="line">class Weekday(Enum):</div><div class="line">    Sun = 0 # Sun的value被设定为0</div><div class="line">    Mon = 1</div><div class="line">    Tue = 2</div><div class="line">    Wed = 3</div><div class="line">    Thu = 4</div><div class="line">    Fri = 5</div><div class="line">    Sat = 6</div></pre></td></tr></table></figure></p>
<p>@unique装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; day1 = Weekday.Mon</div><div class="line">&gt;&gt;&gt; print(day1)</div><div class="line">Weekday.Mon</div><div class="line">&gt;&gt;&gt; print(Weekday.Tue)</div><div class="line">Weekday.Tue</div><div class="line">&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])</div><div class="line">Weekday.Tue</div><div class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; print(day1 == Weekday.Mon)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; print(day1 == Weekday.Tue)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; print(Weekday(1))</div><div class="line">Weekday.Mon</div><div class="line">&gt;&gt;&gt; print(day1 == Weekday(1))</div><div class="line">True</div><div class="line">&gt;&gt;&gt; Weekday(7)</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">ValueError: 7 is not a valid Weekday</div><div class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</div><div class="line">...     print(name, &apos;=&gt;&apos;, member)</div><div class="line">...</div><div class="line">Sun =&gt; Weekday.Sun</div><div class="line">Mon =&gt; Weekday.Mon</div><div class="line">Tue =&gt; Weekday.Tue</div><div class="line">Wed =&gt; Weekday.Wed</div><div class="line">Thu =&gt; Weekday.Thu</div><div class="line">Fri =&gt; Weekday.Fri</div><div class="line">Sat =&gt; Weekday.Sat</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;slots&quot;&gt;&lt;a href=&quot;#slots&quot; class=&quot;headerlink&quot; title=&quot;__slots__&quot;&gt;&lt;/a&gt;&lt;code&gt;__slots__&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;限制类的绑定属性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__str__&lt;/code&gt;:
    
    </summary>
    
      <category term="language" scheme="http://wodekouwei.com/categories/language/"/>
    
    
      <category term="language" scheme="http://wodekouwei.com/tags/language/"/>
    
      <category term="python" scheme="http://wodekouwei.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>vscode使用技巧</title>
    <link href="http://wodekouwei.com/2019/01/15/evn-mac-vscode/"/>
    <id>http://wodekouwei.com/2019/01/15/evn-mac-vscode/</id>
    <published>2019-01-15T02:31:09.000Z</published>
    <updated>2019-02-13T06:49:14.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="设置隐藏文件"><a href="#设置隐藏文件" class="headerlink" title="设置隐藏文件"></a>设置隐藏文件</h3><p>用于在资源管理器隐藏固定后缀的文件,配置方式:</p>
<ol>
<li>首选项-&gt;设置</li>
<li>搜索files.exclude,选择工作区设置</li>
<li>添加模式:<code>**/*.pyc</code></li>
</ol>
<h2 id="Creating-your-own-snippets"><a href="#Creating-your-own-snippets" class="headerlink" title="Creating your own snippets"></a>Creating your own snippets</h2><p>既然你点开了这个页面，那就说明要么你不知道 VSCode 上已有拓展「C/C++ Snippets」，要么你对这个拓展不甚满意。对于后者，本文将为你介绍如何在 VSCode 上设置 snippets，并为你提供一套可以直接用的 C 语言 snippets。</p>
<h3 id="1-snippet-简介"><a href="#1-snippet-简介" class="headerlink" title="1. snippet 简介"></a>1. snippet 简介</h3><p>snippet[ˈsnɪpɪt]，或者说「code snippet」，也即代码段，指的是能够帮助输入重复代码模式，比如循环或条件语句，的模板。通过 snippet ，我们仅仅输入一小段字符串，就可以在代码段引擎的帮助下，生成预定义的模板代码，接着我们还可以通过在预定义的光标位置之间跳转，来快速补全模板。</p>
<p>当然，看图更易懂。下图将 aja 补全为 JQuery 的 ajax() 方法，并通过光标的跳转，快速补全了待填键值对：
<img src="https://code.visualstudio.com/assets/docs/editor/userdefinedsnippets/ajax-snippet.gif" alt="image"></p>
<h3 id="2-snippet-配置流程"><a href="#2-snippet-配置流程" class="headerlink" title="2. snippet 配置流程"></a>2. snippet 配置流程</h3><p>进入 snippet 设置文件，这里提供了三种方法： 
通过快捷键「Ctrl + Shift + P」打开命令窗口（All Command Window），输入「snippet」，点选「首选项：配置用户代码段片段」；
点击界面最左侧竖栏（也即活动栏）最下方的齿轮按钮，在弹出来的菜单中点选「用户代码片段」；
按下「Alt」键切换菜单栏，通过文件 &gt; 首选项 &gt; 用户代码片段；
填写 snippets</p>
<h3 id="3-snippet-详细介绍"><a href="#3-snippet-详细介绍" class="headerlink" title="3. snippet 详细介绍"></a>3. snippet 详细介绍</h3><h4 id="3-1-引子"><a href="#3-1-引子" class="headerlink" title="3.1 引子"></a>3.1 引子</h4><p>设置文件头部的一个块注释给出了设置 snippet 的格式，了解过「json」就不会对此感到奇怪。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Place your snippets for C here. Each snippet is defined under a snippet name and has a prefix, body and </div><div class="line"> // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</div><div class="line"> // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </div><div class="line"> // same ids are connected.</div><div class="line"> // Example:</div><div class="line"> &quot;Print to console&quot;: &#123;</div><div class="line">    &quot;prefix&quot;: &quot;log&quot;,,</div><div class="line">    &quot;body&quot;: [</div><div class="line">        &quot;console.log(&apos;$1&apos;);&quot;,</div><div class="line">        &quot;$2&quot;</div><div class="line">    ],</div><div class="line">    &quot;description&quot;: &quot;Log output to console&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例定义了一个名为「Print to console」的 snippet，其功能为：在输入 log 并确认后，可将原文本替换为console.log(‘’);</p>
<h4 id="3-2-语法结构"><a href="#3-2-语法结构" class="headerlink" title="3.2 语法结构"></a>3.2 语法结构</h4><p>然而引子中只是最简单的功能，而 VSCode 的代码段引擎所能做的远不止这些。本文将以官方教程1为本，对其进行详实地阐述。</p>
<p>snippet 由三部分组成：</p>
<ol>
<li>prefix：前缀，定义了 snippets 从 IntelliSense 中呼出的关键字;</li>
<li>body： 主体，即模板的主体内容，其中每个字符串表示一行;</li>
<li>description：说明，会在 IntelliSense 候选栏中出现。未定义的情况下直接显示对象名，上例中将会显示 Print to console。
Snippet 的三个部分目前只有主体部分支持丰富的特性。接下来整篇文章都是拿来介绍主体部分的。主体部分的介绍将分为两部分：较为直接的基础用法，及结合正则表达式的高级用法。</li>
</ol>
<h4 id="3-3-Body-基本用法"><a href="#3-3-Body-基本用法" class="headerlink" title="3.3 Body - 基本用法"></a>3.3 Body - 基本用法</h4><p>主体部分可以使用特殊语法结构，来控制光标和要插入的文本，其支持的基本结构如下：</p>
<ol>
<li><p>Tabstops：制表符 
用「Tabstops」可以让编辑器的指针在 snippet 内跳转。使用 $1，$2 等指定光标位置。这些数字指定了光标跳转的顺序。特别地，$0表示最终光标位置。相同序号的「Tabstops」被链接在一起，将会同步更新，比如下列用于生成头文件封装的 snippet 被替换到编辑器上时，光标就将同时出现在所有$1位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;#ifndef $1&quot;</div><div class="line">&quot;#define $1&quot;</div><div class="line">&quot;#end // $1&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>Placeholders：占位符 
「Placeholder」是带有默认值的「Tabstops」，如${1：foo}。「placeholder」文本将被插入「Tabstops」位置，并在跳转时被全选，以方便修改。占位符还可以嵌套，例如${1:another ${2:placeholder}}。
比如，结构体的 snippet 主体可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct $&#123;1:name_t&#125; &#123;\n\t$2\n&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>作为「Placeholder」的name_t一方面可以提供默认的结构名称，另一方面可以作为输入的提示。</p>
<ol>
<li><p>Choice：可选项
「Choice」是提供可选值的「Placeholder」。其语法为一系列用逗号隔开，并最终被两个竖线圈起来的枚举值，比如 ${1|one,two,three|}。当光标跳转到该位置的时候，用户将会被提供多个值（one 或 two 或 three）以供选择。</p>
</li>
<li><p>Variables：变量
使用$name或${name:default}可以插入变量的值。当变量未赋值时（如），将插入其缺省值或空字符串。 当varibale未知（即，其名称未定义）时，将插入变量的名称，并将其转换为「Placeholder」。可以使用的「Variable」如下：</p>
</li>
</ol>
<ul>
<li>TM_SELECTED_TEXT：当前选定的文本或空字符串； </li>
<li>注：选定后通过在命令窗口点选「插入代码片段」插入。</li>
<li>TM_CURRENT_LINE：当前行的内容；</li>
<li>TM_CURRENT_WORD：光标所处单词或空字符串 </li>
<li>注：所谓光标一般为文本输入处那条闪来闪去的竖线，该项可定制。单词使用 VSCode 选词（Word Wrap）器选择。你最好只用它选择英文单词，因为这个选择器明显没有针对宽字符优化过，它甚至无法识别宽字符的标点符号。</li>
<li>TM_LINE_INDEX：行号（从零开始）；</li>
<li>TM_LINE_NUMBER：行号（从一开始）；</li>
<li>TM_FILENAME：当前文档的文件名；</li>
<li>TM_FILENAME_BASE：当前文档的文件名（不含后缀名）；</li>
<li>TM_DIRECTORY：当前文档所在目录；</li>
<li>TM_FILEPATH：当前文档的完整文件路径；</li>
<li><p>CLIPBOARD：当前剪贴板中内容。
此外，还有一些用于插入当前时间的变量，这里单独列出：</p>
</li>
<li><p>CURRENT_YEAR: 当前年份；</p>
</li>
<li>CURRENT_YEAR_SHORT: 当前年份的后两位；</li>
<li>CURRENT_MONTH: 格式化为两位数字的当前月份，如 02；</li>
<li>CURRENT_MONTH_NAME: 当前月份的全称，如 July；</li>
<li>CURRENT_MONTH_NAME_SHORT: 当前月份的简称，如 Jul；</li>
<li>CURRENT_DATE: 当天月份第几天；</li>
<li>CURRENT_DAY_NAME: 当天周几，如 Monday；</li>
<li>CURRENT_DAY_NAME_SHORT: 当天周几的简称，如 Mon；</li>
<li>CURRENT_HOUR: 当前小时（24 小时制）；</li>
<li>CURRENT_MINUTE: 当前分钟；</li>
<li>CURRENT_SECOND: 当前秒数。
注：这些都是变量名，不是宏，在实际使用的时要加上 $ 符。</li>
</ul>
<h4 id="3-4-Body-高级语法"><a href="#3-4-Body-高级语法" class="headerlink" title="3.4 Body - 高级语法"></a>3.4 Body - 高级语法</h4><h5 id="3-4-1-变量转换"><a href="#3-4-1-变量转换" class="headerlink" title="3.4.1 变量转换"></a>3.4.1 变量转换</h5><p>变量转换可将变量的值格式化处理后插入预定的位置。</p>
<h6 id="3-4-1-1-语法结构"><a href="#3-4-1-1-语法结构" class="headerlink" title="3.4.1.1 语法结构"></a>3.4.1.1 语法结构</h6><p>我们可以通过 ${var_name/regular_expression/format_string/options} 插入格式化后的代码段。显然，「variable transformations」由 4 部分构成：</p>
<ol>
<li>var_name：变量名；</li>
<li>regular_expression：正则表达式；</li>
<li>format_string：格式串；</li>
<li>options：正则表达式匹配选项。
其中正则表达式的写法和匹配选项部分不在本篇博文的讲解范围之内，具体内容请分别参考 javascript 有关 RegExp(pattern [, flags]) 构造函数中的 pattern 及 flags 参数项的说明2。</li>
</ol>
<p>本文只对 format_string 部分进行详细介绍。</p>
<h6 id="3-4-1-2-format-string-部分"><a href="#3-4-1-2-format-string-部分" class="headerlink" title="3.4.1.2 format_string 部分"></a>3.4.1.2 format_string 部分</h6><p>根据其 EBNF 范式，我们可以知道 format_string 其实是 format 或 text 的线性组合：</p>
<ol>
<li>text：也即没有任何作用的普通文本，你甚至可以使用汉字；</li>
<li>format：格式串，分为 7 种： </li>
</ol>
<ul>
<li>$sn：表示插入匹配项；</li>
<li>${sn}：同 $sn；</li>
<li>${sn:/upcase} 或 ${sn:/downcase} 或 ${sn:/capitalize}：表示将匹配项变更为「所有字母均大写/所有字母均小写/首字母大写其余小写」后，插入；</li>
<li>${sn:+if}：表示当匹配成功时，并且捕捉括号捕捉特定序号的捕捉项成功时，在捕捉项位置插入「if」所述语句；</li>
<li>${sn:?if:else}：表示当匹配成功，并且捕捉括号捕捉特定序号的捕捉项成功时，在捕捉项位置插入「if」所述语句；否则当匹配成功，但当捕捉括号捕捉特定序号的捕捉项失败时，在捕捉项位置插入「else」所述语句；</li>
<li>${sn:-else}：表示当匹配成功，但当捕捉括号捕捉特定序号的捕捉项失败时，在捕捉项位置插入「else」所述语句；</li>
<li>${sn:else}：同 ${sn:-else}。
format 的后三条理解起来可能比较困难。这里我们以倒数第三条为例进行说明。假设我们有一个「make.c」文件，我们有这么一条 snippet: “body”: “${TM_FILENAME/make.c(pp|++)?/${1:?c++:clang}/}”。整个模式串匹配成功，但是捕捉括号捕捉后缀名中的 pp 或 ++ 失败，因此判断条件在捕捉括号的位置插入捕捉失败时应插入的字符串，也即「clang」。<blockquote>
<p>注：
其中 sn 表示捕捉项的序号
其中 if 表示捕捉项捕捉成功时替换的文本
其中 else 表示捕捉项捕失败时替换的文本</p>
</blockquote>
</li>
</ul>
<h6 id="3-4-1-3-案例分析"><a href="#3-4-1-3-案例分析" class="headerlink" title="3.4.1.3 案例分析"></a>3.4.1.3 案例分析</h6><p>下面笔者再介绍一个简单的例子，帮助大家理解「variable transformations」。</p>
<p>假设有一个名为「make.c」的文件中，并且我们已经定义如下 snippet。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;#ifndef HEADER … #define … #endif&quot;:&#123;</div><div class="line">&quot;prefix&quot;: &quot;defheader&quot;,</div><div class="line">&quot;body&quot;: &quot;#ifndef $&#123;1:$&#123;TM_FILENAME/(.*)\\.C$/$&#123;1:/upcase&#125;_H/i&#125;&#125; \n#define $1 \n$&#123;2:header content&#125;\n#endif\t// $1&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中最复杂的模式为：${1:${TM_FILENAME/(.*)\.C$/${1:/upcase}_H/i}}，我们将之拆解为如下五部分： </p>
<ol>
<li>${1:…}：嵌套的 placeholder； </li>
<li>${TM_FILENAM/…/…/.}：「variable transformations」中的「var_name」，表示带后缀的文件名； </li>
<li>${…/(.*)\.C$/…/.}：「variable transformations」中的「regular_expression」，表示匹配任意以「.C」为后缀的字符串； </li>
<li>${…/…/${1:/upcase}_H/.}}：「variable transformations」中的「options」，表示将第一个捕捉项替换为大写的，并添加「_H」的后缀； </li>
<li>${…/…/…/i}：「variable transformations」中的「options」，表示无视大小写。</li>
</ol>
<h5 id="3-4-2-占位符转换"><a href="#3-4-2-占位符转换" class="headerlink" title="3.4.2 占位符转换"></a>3.4.2 占位符转换</h5><h6 id="3-4-2-1-语法结构"><a href="#3-4-2-1-语法结构" class="headerlink" title="3.4.2.1 语法结构"></a>3.4.2.1 语法结构</h6><p>我们可以通过 ${int/regular_expression/format_string/options} 插入格式化后的代码段。显然，与变量转换，「placeholder transformations」也由 4 部分构成：</p>
<ol>
<li>int：占位符相应光标序号；</li>
<li>regular_expression：正则表达式；</li>
<li>format_string：格式串；</li>
<li>options：正则表达式匹配选项。
上述全部内容我们都在前文介绍过了，因此此处不做赘述。我们唯一需要关注的是转换触发的时机：占位符转换将在进行占位符跳转（假设 1→2）的时候自动适用到当前占位符（1）。</li>
</ol>
<h6 id="3-4-2-2-案例分析"><a href="#3-4-2-2-案例分析" class="headerlink" title="3.4.2.2 案例分析"></a>3.4.2.2 案例分析</h6><p>假设我们已经这样的 Snippet：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;HelloWorld&quot;: &#123;</div><div class="line">  &quot;prefix&quot;: &quot;say_hello&quot;,</div><div class="line">  &quot;body&quot;: &quot;$&#123;1&#125; $&#123;2&#125; -&gt; $&#123;1/Hello/Hallo/&#125; $&#123;2/World/Welt/&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我们在两个制表位同时键入 Hello 并跳转的时候，第一个制表位依然保持 Hello 不变，而第二个制表位（占位符）被替换为 Hallo。键入 Welt 亦然。</p>
<h4 id="3-5-语法定义"><a href="#3-5-语法定义" class="headerlink" title="3.5 语法定义"></a>3.5 语法定义</h4><p>官网给出了 snippet 的 EBNF 范式的正则文法，注意，作普通字符使用时，$ , } 和 \ 可使用 \（反斜杠）转义。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">any         ::= tabstop | placeholder | choice | variable | text</div><div class="line">tabstop     ::= &apos;$&apos; int</div><div class="line">                | &apos;$&#123;&apos; int &apos;&#125;&apos;</div><div class="line">                | &apos;$&#123;&apos; int  transform &apos;&#125;&apos;</div><div class="line">placeholder ::= &apos;$&#123;&apos; int &apos;:&apos; any &apos;&#125;&apos;</div><div class="line">choice      ::= &apos;$&#123;&apos; int &apos;|&apos; text (&apos;,&apos; text)* &apos;|&#125;&apos;</div><div class="line">variable    ::= &apos;$&apos; var | &apos;$&#123;&apos; var &apos;&#125;&apos;</div><div class="line">                | &apos;$&#123;&apos; var &apos;:&apos; any &apos;&#125;&apos;</div><div class="line">                | &apos;$&#123;&apos; var transform &apos;&#125;&apos;</div><div class="line">transform   ::= &apos;/&apos; regex &apos;/&apos; (format | text)+ &apos;/&apos; options</div><div class="line">format      ::= &apos;$&apos; int | &apos;$&#123;&apos; int &apos;&#125;&apos;</div><div class="line">                | &apos;$&#123;&apos; int &apos;:&apos; &apos;/upcase&apos; | &apos;/downcase&apos; | &apos;/capitalize&apos; &apos;&#125;&apos;</div><div class="line">                | &apos;$&#123;&apos; int &apos;:+&apos; if &apos;&#125;&apos;</div><div class="line">                | &apos;$&#123;&apos; int &apos;:?&apos; if &apos;:&apos; else &apos;&#125;&apos;</div><div class="line">                | &apos;$&#123;&apos; int &apos;:-&apos; else &apos;&#125;&apos; | &apos;$&#123;&apos; int &apos;:&apos; else &apos;&#125;&apos;</div><div class="line">regex       ::= JavaScript Regular Expression value (ctor-string)</div><div class="line">options     ::= JavaScript Regular Expression option (ctor-options)</div><div class="line">var         ::= [_a-zA-Z] [_a-zA-Z0-9]*</div><div class="line">int         ::= [0-9]+</div><div class="line">text        ::= .*</div></pre></td></tr></table></figure></p>
<h3 id="4-一些建议"><a href="#4-一些建议" class="headerlink" title="4. 一些建议"></a>4. 一些建议</h3><p>默认情况下 snippet 在 IntelliSense 中的显示优先级并不高，而且在 IntelliSense 中选择相应 snippet 需要按「enter」键，这对于手指短的人来说并不是什么很好的体验。</p>
<p>所幸，VSCode 意识到了这一点，并为我们提供了改进的方式。我们可以在 VSCode 的用户设置（「Ctrl+P」在输入框中写「user settings」后点选）中，检索代码段，然后根据提示修改代码段的相关设置。</p>
<p>我们可以设置在 IntelliSense 中优先显示代码段，并可以通过「TAB」补全。</p>
<p>修改后设置文件中会多出这两行：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;editor.snippetSuggestions&quot;: &quot;top&quot;,</div><div class="line">&quot;editor.tabCompletion&quot;: true</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考:<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank" rel="external">https://code.visualstudio.com/docs/editor/userdefinedsnippets</a>
<a href="https://blog.csdn.net/maokelong95/article/details/54379046?utm_source=blogxgwz0" target="_blank" rel="external">https://blog.csdn.net/maokelong95/article/details/54379046?utm_source=blogxgwz0</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;h3 id=&quot;设置隐藏文件&quot;&gt;&lt;a href=&quot;#设置隐藏文件&quot; class=&quot;headerlink&quot; title=&quot;设置隐藏文件&quot;&gt;&lt;/a&gt;设
    
    </summary>
    
      <category term="env" scheme="http://wodekouwei.com/categories/env/"/>
    
    
      <category term="Mac" scheme="http://wodekouwei.com/tags/Mac/"/>
    
  </entry>
  
</feed>
