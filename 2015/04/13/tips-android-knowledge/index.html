<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,tips," />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="四大组件ActivityActivity生命周期 不同场景下Activity生命周期的变化过程 启动Activity： onCreate()—&amp;gt;onStart()—&amp;gt;onResume()，Activity进入运行状态。 Activity退居后台： 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—&amp;gt;onStop()，进入停滞状态。 Ac">
<meta name="keywords" content="Android,tips">
<meta property="og:type" content="article">
<meta property="og:title" content="Android系列基础知识">
<meta property="og:url" content="http://wodekouwei.com/2015/04/13/tips-android-knowledge/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta property="og:description" content="四大组件ActivityActivity生命周期 不同场景下Activity生命周期的变化过程 启动Activity： onCreate()—&amp;gt;onStart()—&amp;gt;onResume()，Activity进入运行状态。 Activity退居后台： 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—&amp;gt;onStop()，进入停滞状态。 Ac">
<meta property="og:image" content="http://images.wodekouwei.com/technology/activity-lifecycle.jpg">
<meta property="og:image" content="http://images.wodekouwei.com/technology/fragment-lifecycle.png">
<meta property="og:image" content="http://images.wodekouwei.com/technology/view_mechanism_flow.png">
<meta property="og:updated_time" content="2018-01-22T02:38:49.379Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android系列基础知识">
<meta name="twitter:description" content="四大组件ActivityActivity生命周期 不同场景下Activity生命周期的变化过程 启动Activity： onCreate()—&amp;gt;onStart()—&amp;gt;onResume()，Activity进入运行状态。 Activity退居后台： 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—&amp;gt;onStop()，进入停滞状态。 Ac">
<meta name="twitter:image" content="http://images.wodekouwei.com/technology/activity-lifecycle.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/2015/04/13/tips-android-knowledge/"/>





  <title> Android系列基础知识 | 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2015/04/13/tips-android-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android系列基础知识
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-13T22:34:05+08:00">
                2015-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2015/04/13/tips-android-knowledge/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h3><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><h5 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h5><p><img src="http://images.wodekouwei.com/technology/activity-lifecycle.jpg" alt="image"></p>
<h5 id="不同场景下Activity生命周期的变化过程"><a href="#不同场景下Activity生命周期的变化过程" class="headerlink" title="不同场景下Activity生命周期的变化过程"></a>不同场景下Activity生命周期的变化过程</h5><ul>
<li>启动Activity： onCreate()—&gt;onStart()—&gt;onResume()，Activity进入运行状态。</li>
<li>Activity退居后台： 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—&gt;onStop()，进入停滞状态。</li>
<li>Activity返回前台： onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。</li>
<li>Activity退居后台，且系统内存不足， 系统会杀死这个后台状态的Activity，若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()</li>
<li>锁定屏与解锁屏幕 只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()</li>
</ul>
<h5 id="Activity-四中launchMode"><a href="#Activity-四中launchMode" class="headerlink" title="Activity 四中launchMode"></a>Activity 四中launchMode</h5><ul>
<li>standard</li>
<li>singleTop</li>
<li>singleTask</li>
<li>singleInstance
我们可以在AndroidManifest.xml配置的android:launchMode属性为以上四种之一。</li>
</ul>
<ol>
<li>standard standard模式是默认的启动模式，不用为配置android:launchMode属性即可，当然也可以指定值为standard。standard启动模式，不管有没有已存在的实例，都生成新的实例。</li>
<li>singleTop 我们在上面的基础上为指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。跳转时系统会先在栈结构中寻找是否有一个Activity实例正位于栈顶，如果有则不再生成新的，而是直接使用。如果系统发现存在有Activity实例,但不是位于栈顶，重新生成一个实例。 这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。</li>
<li>singleTask 如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。</li>
<li>singleInstance 这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。</li>
</ol>
<p>LaunchMode使用场景</p>
<ol>
<li>singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</li>
<li>singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</li>
<li>singleInstance应用场景：闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。<h5 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h5><img src="http://images.wodekouwei.com/technology/fragment-lifecycle.png" alt="image"></li>
</ol>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol>
<li>若Activity已经销毁,此时AsynTask执行完并返回结果,会报异常么? 当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常.同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步</li>
<li>内存不足时,系统会杀死后台的Activity,如果需要进行一些临时状态的保存,在哪个方法进行:Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法,不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。除非该activity是被用户主动销毁的，通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。</li>
<li>Android两个应用能在同一个任务栈吗？栈一般以包名命名，两个应用的签名和udid要相同</li>
</ol>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><h5 id="保证Service在后台不被kill的方法"><a href="#保证Service在后台不被kill的方法" class="headerlink" title="保证Service在后台不被kill的方法"></a>保证Service在后台不被kill的方法</h5><ol>
<li>Service设置成START_STICKY kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样</li>
<li>通过 startForeground将进程设置为前台进程， 做前台服务，优先级和前台应用一个级别​，除非在系统内存非常缺，否则此进程不会被 kill</li>
<li>双进程Service： 让2个进程互相保护**，其中一个Service被清理后，另外没被清理的进程可以立即重启进程</li>
<li>QQ黑科技: 在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死</li>
<li>在已经root的设备下，修改相应的权限文件,将App伪装成系统级的应用 Android4.0系列的一个漏洞，已经确认可行</li>
<li>用C编写守护进程(即子进程) : Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响。鉴于目前提到的在Android-&gt;- Service层做双守护都会失败，我们可以fork出c进程，多进程守护。死循环在那检查是否还存在，具体的思路如下（Android5.0以上的版本不可行）</li>
<li>用C编写守护进程(即子进程)，守护进程做的事情就是循环检查目标进程是否存在，不存在则启动它。</li>
<li>在NDK环境中将1中编写的C代码编译打包成可执行文件(BUILD_EXECUTABLE)。主进程启动时将守护进程放入私有目录下，赋予可执行权限，启动它即可。</li>
<li>联系厂商，加入白名单</li>
</ol>
<h5 id="Service进程优先级"><a href="#Service进程优先级" class="headerlink" title="Service进程优先级"></a>Service进程优先级</h5><p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>
<h5 id="IntentServices"><a href="#IntentServices" class="headerlink" title="IntentServices"></a>IntentServices</h5><p>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题</p>
<p>生成一个默认的且与线程相互独立的工作线程执行所有发送到onStartCommand()方法的Intent,可以在onHandleIntent()中处理.</p>
<p>串行队列,每次只运行一个任务,不存在线程安全问题,所有任务执行完后自动停止服务,不需要自己手动调用stopSelf()来停止.</p>
<h4 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver\"></a>BroadcastReceiver\</h4><h5 id="Android引入广播机制原因"><a href="#Android引入广播机制原因" class="headerlink" title="Android引入广播机制原因"></a>Android引入广播机制原因</h5><ul>
<li>从MVC的角度考虑(应用程序内) 其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。</li>
<li>程序间互通消息(例如在自己的应用程序内监听系统来电)</li>
<li>效率上(参考UDP的广播协议在局域网的方便性)</li>
<li>设计模式上(反转控制的一种应用，类似监听者模式)</li>
</ul>
<h5 id="注册广播的两种方法"><a href="#注册广播的两种方法" class="headerlink" title="注册广播的两种方法"></a>注册广播的两种方法</h5><ol>
<li>静态注册:在清单文件中注册， 常见的有监听设备启动，常驻注册不会随程序生命周期改变</li>
<li>动态注册:在代码中注册，随着程序的结束，也就停止接受广播了<blockquote>
<p>补充一点：有些广播只能通过动态方式注册，比如时间变化事件、屏幕亮灭事件、电量变更事件，因为这些事件触发频率通常很高，如果允许后台监听，会导致进程频繁创建和销毁，从而影响系统整体性能</p>
</blockquote>
</li>
</ol>
<h5 id="两种广播类型"><a href="#两种广播类型" class="headerlink" title="两种广播类型"></a>两种广播类型</h5><p>普通广播为全局广播,LocalBroadcastManager是Android Support包提供了一个工具，是用来在同一个应用内的不同组件间发送Broadcast的。</p>
<p>使用LocalBroadcastManager有如下好处：</p>
<ul>
<li>发送的广播只会在自己App内传播，不会泄露给其他App，确保隐私数据不会泄露</li>
<li>其他App也无法向你的App发送该广播，不用担心其他App会来搞破坏</li>
<li>比系统全局广播更加高效</li>
</ul>
<p>和系统广播使用方式类似：
先通过<code>LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this)</code>; 获取实例,然后通过函数 registerReceiver来注册监听器</p>
<h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h4><h5 id="实现数据共享"><a href="#实现数据共享" class="headerlink" title="实现数据共享"></a>实现数据共享</h5><p>当一个应用程序需要把自己的数据暴露给其他程序使用时，该就用程序就可通过提供ContentProvider来实现；其他应用程序就可通过ContentResolver来操作ContentProvider暴露的数据。 一旦某个应用程序通过ContentProvider暴露了自己的数据操作接口，那么不管该应用程序是否启动，其他应用程序都可以通过该接口来操作该应用程序的内部数据，包括增加数据、删除数据、修改数据、查询数据等。</p>
<p>ContentProvider以某种Uri的形式对外提供数据，允许其他应用访问或修改数据；其他应用程序使用ContentResolver根据Uri去访问操作指定数据。 步骤：</p>
<ol>
<li>定义自己的ContentProvider类，该类需要继承Android提供的ContentProvider基类。</li>
<li>在AndroidManifest.xml文件中注册个ContentProvider，注册ContenProvider时需要为它绑定一个URL。 例： android:authorities=”com.myit.providers.MyProvider” /&gt; 说明：authorities就相当于为该ContentProvider指定URL。 注册后，其他应用程序就可以通过该Uri来访问MyProvider所暴露的数据了。</li>
<li>接下来，使用ContentResolver操作数据，Context提供了如下方法来获取ContentResolver对象。 一般来说，ContentProvider是单例模式，当多个应用程序通过ContentResolver来操作 ContentProvider提供的数据时，ContentResolver调用的数据操作将会委托给同一个ContentProvider处理。 使用ContentResolver操作数据只需两步： 1、调用Activity的ContentResolver获取ContentResolver对象。 2、根据需要调用ContentResolver的insert()、delete()、update()和query（）方法操作数据即可</li>
</ol>
<p>ContentProvider的主要还是用于数据共享，其可以对Sqlite，SharePreferences，File等进行数据操作用来共享数据。而sql的可以理解为数据库的一门语言，可以使用它完成CRUD等一系列的操作</p>
<h3 id="View与布局"><a href="#View与布局" class="headerlink" title="View与布局"></a>View与布局</h3><h4 id="LinearLayout和RelativeLayout性能对比"><a href="#LinearLayout和RelativeLayout性能对比" class="headerlink" title="LinearLayout和RelativeLayout性能对比"></a>LinearLayout和RelativeLayout性能对比</h4><ol>
<li>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure</li>
<li>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。</li>
<li>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。
最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</li>
</ol>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><h5 id="自定义view的基本流程"><a href="#自定义view的基本流程" class="headerlink" title="自定义view的基本流程"></a>自定义view的基本流程</h5><ol>
<li>明确需求，确定你想实现的效果</li>
<li>确定是使用组合控件的形式还是全新自定义的形式，组合控件即使用多个系统控件来合成一个新控件，你比如titilebar，这种形式相对简单，参考</li>
<li>如果是完全自定义一个view的话，你首先需要考虑继承哪个类，是View呢，还是ImageView等子类。</li>
<li>根据需要去复写View#onDraw、View#onMeasure、View#onLayout方法</li>
<li>根据需要去复写dispatchTouchEvent、onTouchEvent方法</li>
<li>根据需要为你的自定义view提供自定义属性，即编写attr.xml,然后在代码中通过TypedArray等类获取到自定义属性值</li>
<li>需要处理滑动冲突、像素转换等问题</li>
</ol>
<h5 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h5><p><img src="http://images.wodekouwei.com/technology/view_mechanism_flow.png" alt="image">
measure()方法，layout()，draw()三个方法主要存放了一些标识符，来判断每个View是否需要再重新测量，布局或者绘制，主要的绘制过程还是在onMeasure，onLayout，onDraw这个三个方法中</p>
<ol>
<li>onMesarue() 为整个View树计算实际的大小，即设置实际的高(对应属性:mMeasuredHeight)和宽(对应属性: mMeasureWidth)，每个View的控件的实际宽高都是由父视图和本身视图决定的。</li>
<li>onLayout() 为将整个根据子视图的大小以及布局参数将View树放到合适的位置上。</li>
<li>onDraw() 开始绘制图像，绘制的流程如下<ol>
<li>首先绘制该View的背景</li>
<li>调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li>
<li>如果该View是ViewGroup，调用dispatchDraw ()方法绘制子视图
绘制滚动条</li>
</ol>
</li>
</ol>
<blockquote>
<p>自定义View执行invalidate()方法,不会回调onDraw()可能的原因</p>
<ol>
<li>自定义一个view时，重写onDraw。调用view.invalidate(),会触发onDraw和computeScroll()。前提是该view被附加在当前窗口.
view.postInvalidate(); //是在非UI线程上调用的</li>
<li>自定义一个ViewGroup，重写onDraw。onDraw可能不会被调用，原因是需要先设置一个背景(颜色或图)。表示这个group有东西需要绘制了，才会触发draw，之后是onDraw。因此，一般直接重写dispatchDraw来绘制viewGroup.自定义一个ViewGroup,dispatchDraw会调用drawChild.</li>
</ol>
</blockquote>
<h5 id="事件传递机制"><a href="#事件传递机制" class="headerlink" title="事件传递机制"></a>事件传递机制</h5><ol>
<li>事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。</li>
<li>事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。</li>
<li>如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。</li>
<li>如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。</li>
<li>OnTouchListener优先于onTouchEvent()对事件进行消费。</li>
</ol>
<p>上面的消费即表示相应函数返回值为true。
View中setOnTouchListener中的onTouch,onTouchEvent,onClick的执行顺序:onTouch优于onTouchEvent,onTouchEvent优于onClick</p>
<p>Android下滑冲突的常见解决思路:相关的滑动组件 重写onInterceptTouchEvent，然后判断根据xy值，来决定是否要拦截当前操作</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h4 id="三种动画"><a href="#三种动画" class="headerlink" title="三种动画"></a>三种动画</h4><ul>
<li>逐帧动画(Drawable Animation)： 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间</li>
<li>补间动画(Tween Animation)： Tween可以对View对象实现一系列简单的动画效果，比如位移，缩放，旋转，透明度等等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。</li>
<li>属性动画(Property Animation)： 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了</li>
</ul>
<h4 id="动画原理"><a href="#动画原理" class="headerlink" title="动画原理"></a>动画原理</h4><p>Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件</p>
<h4 id="属性动画特性"><a href="#属性动画特性" class="headerlink" title="属性动画特性"></a>属性动画特性</h4><p>如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。
注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。
然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。
最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h4><ul>
<li>避免OverDraw过渡绘制</li>
<li>优化布局层级</li>
<li>避免嵌套过多无用布局</li>
<li>当我们在画布局的时候，如果能实现相同的功能，优先考虑相对布局，然后在考虑别的布局，不要用绝对布局。</li>
<li>使用<include>标签把复杂的界面需要抽取出来</include></li>
<li>使用<merge>标签，因为它在优化UI结构时起到很重要的作用。目的是通过删减多余或者额外的层级，从而优化整个Android Layout的结构。核心功能就是减少冗余的层次从而达到优化UI的目的！</merge></li>
<li>ViewStub 是一个隐藏的，不占用内存空间的视图对象，它可以在运行时延迟加载布局资源文件。<h4 id="ListView卡顿的原因以及优化策略"><a href="#ListView卡顿的原因以及优化策略" class="headerlink" title="ListView卡顿的原因以及优化策略"></a>ListView卡顿的原因以及优化策略</h4></li>
<li>重用converView： 通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</li>
<li>减少findViewById()操作： 将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作</li>
<li>避免在 getView 方法中做耗时的操作: 例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库glide</li>
<li>Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</li>
<li>尽量能保证 Adapter 的 hasStableIds() 返回 true 这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的</li>
<li>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。 由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现</li>
<li>使用 RecycleView 代替listview： 每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善</li>
<li>ListView 中元素避免半透明： 半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。 在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。</li>
<li>尽量开启硬件加速： 硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</li>
</ul>
<blockquote>
<p><strong>ViewHolder为什么要被声明成静态内部类</strong>
这个是考静态内部类和非静态内部类的主要区别之一。非静态内部类会隐式持有外部类的引用，就像大家经常将自定义的adapter在Activity类里，然后在adapter类里面是可以随意调用外部activity的方法的。当你将内部类定义为static时，你就调用不了外部类的实例方法了，因为这时候静态内部类是不持有外部类的引用的。声明ViewHolder静态内部类，可以将ViewHolder和外部类解引用。大家会说一般ViewHolder都很简单，不定义为static也没事吧。确实如此，但是如果你将它定义为static的，说明你懂这些含义。万一有一天你在这个ViewHolder加入一些复杂逻辑，做了一些耗时工作，那么如果ViewHolder是非静态内部类的话，就很容易出现内存泄露。如果是静态的话，你就不能直接引用外部类，迫使你关注如何避免相互引用。 所以将 ViewHolder内部类 定义为静态的，是一种好习惯</p>
</blockquote>
<h4 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h4><ol>
<li>资源对象没有关闭造成,如查询数据库没有关闭游标</li>
<li>构造Adapter时,没有使用缓存ConvertView</li>
<li>Bitmap对象在不使用时调用recycle()释放内存</li>
<li>context逃逸问题</li>
<li>注册没有取消,如动态注册广播在Activity销毁前没有unregisterReceiver</li>
<li>集合对象未清理,如无用时没有释放对象的引用</li>
<li>在Activity中使用非静态的内部类，并开启一个长时间运行的线程，因为内部类持有Activity的引用，会导致Activity本来可以被gc时却长期得不到回收</li>
</ol>
<h4 id="OOM发生情况"><a href="#OOM发生情况" class="headerlink" title="OOM发生情况"></a>OOM发生情况</h4><ol>
<li>类的静态变量持有大数据对象 静态变量长期维持到大数据对象的引用，阻止垃圾回收。</li>
<li>非静态内部类存在静态实例 非静态内部类会维持一个到外部类实例的引用，如果非静态内部类的实例是静态的，就会间接长期维持着外部类的引用，阻止被回收掉。</li>
<li>资源对象未关闭 资源性对象比如（Cursor，File文件等）往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们， 以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。 如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄露。 解决办法： 比如SQLiteCursor（在析构函数finalize（）,如果我们没有关闭它，它自己会调close()关闭）， 如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。 因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null. 在我们的程序退出时一定要确保我们的资源性对象已经关闭。 程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小， 对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险，记得try catch后，在finally方法中关闭连接</li>
<li>Handler内存泄漏 Handler作为内部类存在于Activity中，但是Handler生命周期与Activity生命周期往往并不是相同的，比如当Handler对象有Message在排队，则无法释放，进而导致本该释放的Acitivity也没有办法进行回收。 解决办法:声明handler为static类，这样内部类就不再持有外部类的引用了，就不会阻塞Activity的释放.如果内部类实在需要用到外部类的对象，可在其内部声明一个弱引用引用外部类
一些不良代码习惯 有些代码并不造成内存泄露，但是他们的资源没有得到重用，频繁的申请内存和销毁内存，消耗CPU资源的同时，也引起内存抖动 解决方案 如果需要频繁的申请内存对象和和释放对象，可以考虑使用对象池来增加对象的复用。 例如ListView便是采用这种思想，通过复用converview来避免频繁的GC</li>
</ol>
<h4 id="避免oom"><a href="#避免oom" class="headerlink" title="避免oom"></a>避免oom</h4><ol>
<li>使用更加轻量的数据结构 例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效，在于他们避免了对key与value的自动装箱（autoboxing），并且避免了装箱后的解箱。</li>
<li>避免在Android里面使用Enum Android官方培训课程提到过“Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.”，具体原理请参考《Android性能优化典范（三）》，所以请避免在Android里面使用到枚举。</li>
<li>减小Bitmap对象的内存占用 Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用可谓是重中之重，，通常来说有以下2个措施： inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。 decode format：解码格式，选择ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异</li>
<li>Bitmap对象的复用 缩小Bitmap的同时，也需要提高BitMap对象的复用率，避免频繁创建BitMap对象，复用的方法有以下2个措施 LRUCache : “最近最少使用算法”在Android中有极其普遍的应用。ListView与GridView等显示大量图片的控件里，就是使用LRU的机制来缓存处理好的Bitmap，把近期最少使用的数据从缓存中移除，保留使用最频繁的数据， inBitMap高级特性:利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小</li>
<li>使用更小的图片 在涉及给到资源图片时，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用更小的图片。尽量使用更小的图片不仅可以减少内存的使用，还能避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图时会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</li>
<li>StringBuilder 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</li>
<li>避免在onDraw方法里面执行对象的创建 类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</li>
</ol>
<h4 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h4><p>ANR全称Application Not Responding，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，用户可以自行选择继续等待亦或者是停止当前程序。一旦出现下面两种情况，则弹出ANR对话框</p>
<ol>
<li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li>
<li>BroadcastReceiver未在10秒内完成相关的处理</li>
</ol>
<p>Service在特定的时间内无法处理完成
超时的原因一般有两种：
(1)当前的事件没有机会得到处理（UI线程正在处理前一个事件没有及时完成或者looper被某种原因阻塞住）
(2)当前的事件正在处理，但没有及时完成
UI线程尽量只做跟UI相关的工作，耗时的工作（数据库操作，I/O，连接网络或者其他可能阻碍UI线程的操作）放入单独的线程处理，尽量用Handler来处理UI thread和thread之间的交互。
UI线程主要包括如下：</p>
<ul>
<li>Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick()</li>
<li>AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel()</li>
<li>Mainthread handler: handleMessage(), post(runnable r)</li>
</ul>
<h5 id="如何定位ANR错误"><a href="#如何定位ANR错误" class="headerlink" title="如何定位ANR错误"></a>如何定位ANR错误</h5><p>开发机器上,查看/data/anr/traces.text.最新的ANR信息在最开始部分.</p>
<h5 id="如何避免ANR"><a href="#如何避免ANR" class="headerlink" title="如何避免ANR"></a>如何避免ANR</h5><p>避免ANR最核心的一点就是在主线程减少耗时操作.通常需要从以下几个方案下手:</p>
<ol>
<li>使用子线程处理耗时IO操作。</li>
<li>降低子线程优先级使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li>
<li>使用Handler处理子线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li>
<li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li>
<li>BroadcastReceiver中onReceive代码也要尽量减少耗时操作建议使用IntentService处理。IntentService是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题</li>
</ol>
<h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><h4 id="Dalvik-JVM-ART区别"><a href="#Dalvik-JVM-ART区别" class="headerlink" title="Dalvik,JVM,ART区别"></a>Dalvik,JVM,ART区别</h4><h4 id="什么是Dalvik？"><a href="#什么是Dalvik？" class="headerlink" title="什么是Dalvik？"></a>什么是Dalvik？</h4><p>Dalvik是Google公司自己设计用于Android平台的虚拟机。
Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。
它可以支持已转换为<code>**.dex</code>格式<code>**</code>的Java应用程序的运行，<code>.dex</code>格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。
Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。
很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。
2014年6月25日，Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。</p>
<h4 id="什么是ART？"><a href="#什么是ART？" class="headerlink" title="什么是ART？"></a>什么是ART？</h4><p>即Android Runtime
ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<p><strong>ART优缺点</strong>
优点：</p>
<ol>
<li>系统性能的显著提升。</li>
<li>用启动更快、运行更快、体验更流畅、触感反馈更及时。</li>
<li>更长的电池续航能力。</li>
<li>支持更低的硬件。
缺点：</li>
<li>机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%（不过在应用包中，可执行的代码常常只是一部分。比如最新的 Google+ APK 是 28.3 MB，但是代码只有 6.9 MB。）</li>
<li>应用的安装时间会变长。</li>
</ol>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>JVM其核心目的，是为了构建一个真正跨OS平台，跨指令集的程序运行环境(VM)。DVM的目的是为了将android OS的本地资源和环境，以一种统一的界面提供给应用程序开发。严格来说，DVM不是真正的VM，它只是开发的时候提供了VM的环境，并不是在运行的时候提供真正的VM容器。这也是为什么JVM必须设计成stack-based的原因。</p>
<h4 id="Dalvik和JVM有啥关系？"><a href="#Dalvik和JVM有啥关系？" class="headerlink" title="Dalvik和JVM有啥关系？"></a>Dalvik和JVM有啥关系？</h4><p>主要区别：</p>
<ul>
<li>Dalvik是基于寄存器的，而JVM是基于栈的。</li>
<li>Dalvik运行dex文件，而JVM运行java字节码</li>
</ul>
<p>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。优化后的Dalvik较其他标准虚拟机存在一些不同特性:　</p>
<ol>
<li>占用更少空间　</li>
<li>为简化翻译，常量池只使用32位索引　　</li>
<li>标准Java字节码实行8位堆栈指令,Dalvik使用16位指令集直接作用于局部变量。局部变量通常来自4位的“虚拟寄存器”区。这样减少了Dalvik的指令计数，提高了翻译速度。　</li>
</ol>
<p>当Android启动时，Dalvik VM 监视所有的程序（APK），并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。
Dalvik解释器采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对齐。这样可以节省一个指令后进行查表的时间。为了强化功能, Dalvik还提供了快速翻译器（Fast Interpreter）。</p>
<p>一般来说,基于堆栈的机器必须使用指令才能从堆栈上的加载和操作数据,因此,相对基于寄存器的机器，它们需要更多的指令才能实现相同的性能。但是基于寄存器机器上的指令必须经过编码,因此,它们的指令往往更大。</p>
<p>Dalvik虚拟机既不支持Java SE 也不支持Java ME类库(如：Java类,AWT和Swing都不支持)。 相反,它使用自己建立的类库（Apache Harmony Java的一个子集）。</p>
<p>JVM：所有的jar程序，其运行环境完全是由JVM来提供，包括运行时，各类资源的调度，而JVM的架构，其设计为一个JVM里面可以运行多个java程序，JVM就像一个真正的“机器”，可以跑着多个程序。如果去看看一些企业级的JVM(例如tom cat，WAS)，从OS的进程管理中，一般你只能看见一个JVM的进程(当然，你也可以起多个JVM，但JVM架构就是OS-JVM-APP的3层运行时模式)，而看不见JVM里面运行的程序，而一个JVM里，可以跑多个java app。简单得说，JVM完全屏蔽了应用程序和OS之间的联系，而改用JVM充当了中间层，这也是一个真正跨平台运行时VM必须要做到的。只要是相同的 JDK，JVM为所有在其中运行的程序，提供了完全一致的运行环境，而不论你是什么样的底层OS和硬件条件。因此这也是我在其他一篇答案中提到，JVM的特点是取底层OS和硬件环境的交集，从而保障这种一致性。而所有应用程序和底层资源的互动，一定是依赖JVM的传递和转换来实现。JVM真正实现了一个 OS对应用程序运行时管理的所有功能。从开发环境角度和运行时角度，都是完全一致的真正VM</p>
<p>DVM：而DVM的特点在于使用了Zygote，Zygote有几个非常有意思的特点。</p>
<p>　　一是Zygote采用预加载，由其首先判定安装的APK的需要以及相互依存树，以及OS及硬件环境的特点，在每次启动的时候进行预加载(现在你明白为什么 android的app在应用管理里你能轻易查到它都调用了那些重庆肛肠科关键性的本地资源的原因了吧?)，这就意味着，你安装的应用越多，Zygote的加载就越慢，一般来说你的手机启动就会越慢。另外来说，在不同的硬件环境里(例如有无GPS芯片)Zygote初始化的实例是不同的。也就是说，zygote并不提供一个统一的运行环境，具有更好的弹性，这种机制意味着DVM可以取底层资源的合集来提供上层应用使用，差别只是在程序安装或者启动的过程中，DVM可以提示程序需求资源，本地环境可能未能满足而导致无法运行。DVM的Zygote并不是提供一个运行时容器，它提供的只是一个用于共享的进程，所有的应用程序运行，都是独立的，OS级别的进程，直接受到OS层面的资源控制以及调度的影响，只是他们共享Zygote说预加载的类而已。这也就是我为什么说，DVM就像是给每个应用程序在底层加了个套子，而不是提供了一个真正的运行时的VM。也就是说，DVM在开发环境中说提供的VM平台，和运行时的环境是很有可能不一致的。开发环境中提供的VM平台，是一个各种运行时可能环境的合集。</p>
<p>　　从这点上来说，一般我们认为，JVM中的JAVA程序的崩溃，最多导致JVM的崩溃，而不会导致OS崩溃，但是apk的崩溃，可以直接导致OS崩溃，android手机会因为应用程序死机，大家应该是很常见了。但是大家一般是不会看到java程序导致死机吧?因为运行时中间隔着一个JVM。(当然，其实还是有些小门道可以用java程序让OS崩溃，因为这个，我和某些JAVA大拿打赌赢过饭局，呵呵，不过这是其他话题，不在这里展开了)</p>
<p>　　除此之外，在JVM的机制中，不同的程序，打包以后，他们都是在运行层级真正独立的程序(指程序应用重庆妇科医院他们相互之间的关系，而不是和JVM的关系)，即便他们在包里使用了同样的类，运行时都是单独加载，单独运行的(及加载多遍)。</p>
<p>　　DVM这种预加载-共享的机制，使得不同应用之间，在运行时，是共享相同的类的，一般来说，在系统资源消耗方面，拥有更高的效率。</p>
<p>　　最后，补充一点，byte code并不意味着就是解释执行，也能是加载编译，安装编译，预编译等等。实际上，不同的byte code的程序，不同的技术，不同的具体语言，其真正执行的情况挺复杂，难以一概而论的，好多都是混合技术的案例。</p>
<p>在智能手机大部分都可以让用户选择使用Dalvik还是ART模式。当然默认还是使用Dalvik模式。
用法：设置-辅助功能-开发者选项（开发人员工具）-选择运行环境（不同的手机设置的步骤可能不一样）。</p>
<h3 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h3><h4 id="1-分析Java线程中断机制stop和interrupted的用法"><a href="#1-分析Java线程中断机制stop和interrupted的用法" class="headerlink" title="1. 分析Java线程中断机制stop和interrupted的用法"></a>1. 分析Java线程中断机制stop和interrupted的用法</h4><ol>
<li>当我们点击某个杀毒软件的取消按钮来停止查杀病毒时，当我们在控制台敲入quit命令以结束某个后台服务时……都需要通过一个线程去取消另一个线程正在执行的任务。Java没有提供一种安全直接的方法来停止某个线程，但是Java提供了中断机制。如果对Java中断没有一个全面的了解，可能会误以为被中断的线程将立马退出运行，但事实并非如此。中断机制是如何工作的？捕获或检测到中断后，是抛出InterruptedException还是重设中断状态以及在方法中吞掉中断状态会有什么后果？Thread.stop与中断相比又有哪些异同？什么情况下需要使用中断？本文将从以上几个方面进行描述。</li>
<li>中断的原理Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。这好比是家里的父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。Java中断模型也是这么简单，每个线程对象里都有一个boolean类型的标识（不一定就要是Thread类的字段，实际上也的确不是，这几个方法最终都是通过native方法来完成的），代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。例如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。java.lang.Thread类提供了几个方法来操作这个中断状态，这些方法包括：public static boolean interrupted测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。public boolean isInterrupted()测试线程是否已经中断。线程的中断状态不受该方法的影响。public void interrupt()中断线程。其中，interrupt方法是唯一能将中断状态设置为true的方法。静态方法interrupted会将当前线程的中断状态清除，但这个方法的命名极不直观，很容易造成误解，需要特别注意。
上面的例子中，线程t1通过调用interrupt方法将线程t2的中断状态置为true，t2可以在合适的时候调用interrupted或isInterrupted来检测状态并做相应的处理。此外，类库中的有些类的方法也可能会调用中断，如FutureTask中的cancel方法，如果传入的参数为true，它将会在正在运行异步任务的线程上调用interrupt方法，如果正在执行的异步任务中的代码没有对中断做出响应，那么cancel方法中的参数将不会起到什么效果；又如ThreadPoolExecutor中的shutdownNow方法会遍历线程池中的工作线程并调用线程的interrupt方法来中断线程，所以如果工作线程中正在执行的任务没有对中断做出响应，任务将一直执行直到正常结束。</li>
<li>中断的处理既然Java中断机制只是设置被中断线程的中断状态，那么被中断线程该做些什么？显然，作为一种协作机制，不会强求被中断线程一定要在某个点进行处理。实际上，被中断线程只需在合适的时候处理即可，如果没有合适的时间点，甚至可以不处理，这时候在任务处理层面，就跟没有调用中断方法一样。“合适的时候”与线程正在处理的业务逻辑紧密相关，例如，每次迭代的时候，进入一个可能阻塞且无法中断的方法之前等，但多半不会出现在某个临界区更新另一个对象状态的时候，因为这可能会导致对象处于不一致状态。
处理时机决定着程序的效率与中断响应的灵敏性。频繁的检查中断状态可能会使程序执行效率下降，相反，检查的较少可能使中断请求得不到及时响应。如果发出中断请求之后，被中断的线程继续执行一段时间不会给系统带来灾难，那么就可以将中断处理放到方便检查中断，同时又能从一定程度上保证响应灵敏度的地方。当程序的性能指标比较关键时，可能需要建立一个测试模型来分析最佳的中断检测点，以平衡性能和响应灵敏性。中断状态的管理<ul>
<li>一般说来，当可能阻塞的方法声明中有抛出InterruptedException则暗示该方法是可中断的，如BlockingQueue#put、BlockingQueue#take、Object#wait、Thread#sleep等，如果程序捕获到这些可中断的阻塞方法抛出的InterruptedException或检测到中断后，这些中断信息该如何处理？一般有以下两个通用原则：如果遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常，如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。 若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态。如果是检测并清除了中断状态，亦是如此。 一般的代码中，尤其是作为一个基础类库时，绝不应当吞掉中断，即捕获到InterruptedException后在catch里什么也不做，清除中断状态后又不重设中断状态也不抛出InterruptedException等。因为吞掉中断状态会导致方法调用栈的上层得不到这些信息。当然，凡事总有例外的时候，当你完全清楚自己的方法会被谁调用，而调用者也不会因为中断被吞掉了而遇到麻烦，就可以这么做。总得来说，就是要让方法调用栈的上层获知中断的发生。假设你写了一个类库，类库里有个方法amethod，在amethod中检测并清除了中断状态，而没有抛出InterruptedException，作为amethod的用户来说，他并不知道里面的细节，如果用户在调用amethod后也要使用中断来做些事情，那么在调用amethod之后他将永远也检测不到中断了，因为中断信息已经被amethod清除掉了。如果作为用户，遇到这样有问题的类库，又不能修改代码，那该怎么处理？只好在自己的类里设置一个自己的中断状态，在调用interrupt方法的时候，同时设置该状态，这实在是无路可走时才使用的方法。</li>
<li>中断的响应 程序里发现中断后该怎么响应？这就得视实际情况而定了。有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务……作为一种协作机制，这要与中断方协商好，当调用interrupt会发生些什么都是事先知道的，如做一些事务回滚操作，一些清理工作，一些补偿操作等。若不确定调用某个线程的interrupt后该线程会做出什么样的响应，那就不应当中断该线程。</li>
</ul>
</li>
<li>Thread.interrupt VS Thread.stopThread.stop方法已经不推荐使用了。而在某些方面Thread.stop与中断机制有着相似之处。如当线程在等待内置锁或IO时，stop跟interrupt一样，不会中止这些操作；当catch住stop导致的异常时，程序也可以继续执行，虽然stop本意是要停止线程，这么做会让程序行为变得更加混乱。那么它们的区别在哪里？最重要的就是中断需要程序自己去检测然后做相应的处理，而Thread.stop会直接在代码执行过程中抛出ThreadDeath错误，这是一个java.lang.Error的子类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package com.ticmy.interrupt;  </div><div class="line">import java.util.Arrays;  </div><div class="line">import java.util.Random;  </div><div class="line">import java.util.concurrent.TimeUnit;  </div><div class="line">public class TestStop &#123;  </div><div class="line">    private static final int[] array = new int[80000];  </div><div class="line">    private static final Thread t = new Thread() &#123;  </div><div class="line">        public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                System.out.println(sort(array));  </div><div class="line">            &#125; catch (Error err) &#123;  </div><div class="line">                err.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">            System.out.println(&quot;in thread t&quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;;  </div><div class="line"></div><div class="line">    static &#123;  </div><div class="line">        Random random = new Random();  </div><div class="line">        for(int i = 0; i &lt; array.length; i++) &#123;  </div><div class="line">            array[i] = random.nextInt(i + 1);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private static int sort(int[] array) &#123;  </div><div class="line">        for (int i = 0; i &lt; array.length-1; i++)&#123;  </div><div class="line">            for(int j = 0 ;j &lt; array.length - i - 1; j++)&#123;  </div><div class="line">                if(array[j] &lt; array[j + 1])&#123;  </div><div class="line">                    int temp = array[j];  </div><div class="line">                    array[j] = array[j + 1];  </div><div class="line">                    array[j + 1] = temp;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return array[0];  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        t.start();  </div><div class="line">        TimeUnit.SECONDS.sleep(1);  </div><div class="line">        System.out.println(&quot;go to stop thread t&quot;);  </div><div class="line">        t.stop();  </div><div class="line">        System.out.println(&quot;finish main&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个例子很简单，线程t里面做了一个非常耗时的排序操作，排序方法中，只有简单的加、减、赋值、比较等操作，一个可能的执行结果如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">go to stop thread t  </div><div class="line">java.lang.ThreadDeath  </div><div class="line">    at java.lang.Thread.stop(Thread.java:758)  </div><div class="line">    at com.ticmy.interrupt.TestStop.main(TestStop.java:44)  </div><div class="line">finish main  </div><div class="line">in thread t</div></pre></td></tr></table></figure></p>
<p>这里sort方法是个非常耗时的操作，也就是说主线程休眠一秒钟后调用stop的时候，线程t还在执行sort方法。就是这样一个简单的方法，也会抛出错误！换一句话说，调用stop后，大部分Java字节码都有可能抛出错误，哪怕是简单的加法！
如果线程当前正持有锁，stop之后则会释放该锁。由于此错误可能出现在很多地方，那么这就让编程人员防不胜防，极易造成对象状态的不一致。例如，对象obj中存放着一个范围值：最小值low，最大值high，且low不得大于high，这种关系由锁lock保护，以避免并发时产生竞态条件而导致该关系失效。假设当前low值是5，high值是10，当线程t获取lock后，将low值更新为了15，此时被stop了，真是糟糕，如果没有捕获住stop导致的Error，low的值就为15，high还是10，这导致它们之间的小于关系得不到保证，也就是对象状态被破坏了！如果在给low赋值的时候catch住stop导致的Error则可能使后面high变量的赋值继续，但是谁也不知道Error会在哪条语句抛出，如果对象状态之间的关系更复杂呢？这种方式几乎是无法维护的，太复杂了！如果是中断操作，它决计不会在执行low赋值的时候抛出错误，这样程序对于对象状态一致性就是可控的。
正是因为可能导致对象状态不一致，stop才被禁用。</p>
<ol>
<li>中断的使用通常，中断的使用场景有以下几个：<ul>
<li>点击某个桌面应用中的取消按钮时；</li>
<li>某个操作超过了一定的执行时间限制需要中止时；</li>
<li>多个线程做相同的事情，只要一个线程成功其它线程都可以取消时；</li>
<li>一组线程中的一个或多个出现错误导致整组都无法继续时；</li>
<li>当一个应用或服务需要停止时。
下面来看一个具体的例子。这个例子里，本打算采用GUI形式，但考虑到GUI代码会使程序复杂化，就使用控制台来模拟下核心的逻辑。这里新建了一个磁盘文件扫描的任务，扫描某个目录下的所有文件并将文件路径打印到控制台，扫描的过程可能会很长。若需要中止该任务，只需在控制台键入quit并回车即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.ticmy.interrupt;  </div><div class="line">import java.io.BufferedReader;  </div><div class="line">import java.io.File;  </div><div class="line">import java.io.InputStreamReader;  </div><div class="line"></div><div class="line">public class FileScanner &#123;  </div><div class="line">    private static void listFile(File f) throws InterruptedException &#123;  </div><div class="line">        if(f == null) &#123;  </div><div class="line">            throw new IllegalArgumentException();  </div><div class="line">        &#125;  </div><div class="line">        if(f.isFile()) &#123;  </div><div class="line">            System.out.println(f);  </div><div class="line">            return;  </div><div class="line">        &#125;  </div><div class="line">        File[] allFiles = f.listFiles();  </div><div class="line">        if(Thread.interrupted()) &#123;  </div><div class="line">            throw new InterruptedException(&quot;文件扫描任务被中断&quot;);  </div><div class="line">        &#125;  </div><div class="line">        for(File file : allFiles) &#123;  </div><div class="line">            //还可以将中断检测放到这里  </div><div class="line">            listFile(file);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static String readFromConsole() &#123;  </div><div class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  </div><div class="line">        try &#123;  </div><div class="line">            return reader.readLine();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">            return &quot;&quot;;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        final Thread fileIteratorThread = new Thread() &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                try &#123;  </div><div class="line">                    listFile(new File(&quot;c:\\&quot;));  </div><div class="line">                &#125; catch (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;;  </div><div class="line">        new Thread() &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                while(true) &#123;  </div><div class="line">                    if(&quot;quit&quot;.equalsIgnoreCase(readFromConsole())) &#123;  </div><div class="line">                        if(fileIteratorThread.isAlive()) &#123;  </div><div class="line">                            fileIteratorThread.interrupt();  </div><div class="line">                            return;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125; else &#123;  </div><div class="line">                        System.out.println(&quot;输入quit退出文件扫描&quot;);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;.start();  </div><div class="line">        fileIteratorThread.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>在扫描文件的过程中，对于中断的检测这里采用的策略是，如果碰到的是文件就不检测中断，是目录才检测中断，因为文件可能是非常多的，每次遇到文件都检测一次会降低程序执行效率。此外，在fileIteratorThread线程中，仅是捕获了InterruptedException，没有重设中断状态也没有继续抛出异常，因为我非常清楚它的使用环境，run方法的调用栈上层已经没有可能需要检测中断状态的方法了。
在这个程序中，输入quit完全可以执行System.exit(0)操作来退出程序，但正如前面提到的，这是个GUI程序核心逻辑的模拟，在GUI中，执行System.exit(0)会使得整个程序退出。</p>
<h4 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h4><ol>
<li><p>新建状态(New)：
当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</p>
</li>
<li><p>就绪状态(Runnable)
一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。
处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。</p>
</li>
<li>运行状态(Running)
当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.</li>
<li>阻塞状态(Blocked)
线程运行过程中，可能由于各种原因进入阻塞状态:
1&gt;线程通过调用sleep方法进入睡眠状态；
2&gt;线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
3&gt;线程试图得到一个锁，而该锁正被其他线程持有；
4&gt;线程在等待某个触发条件；<pre><code>......           
</code></pre>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</li>
<li>死亡状态(Dead)
有两个原因会导致线程死亡：
1) run方法正常退出而自然死亡，
2) 一个未捕获的异常终止了run方法而使线程猝死。
为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.</li>
</ol>
<h4 id="3-View-的onDraw与dispatchDraw"><a href="#3-View-的onDraw与dispatchDraw" class="headerlink" title="3.View 的onDraw与dispatchDraw"></a>3.View 的onDraw与dispatchDraw</h4><p>绘制VIew本身的内容，通过调用View.onDraw(canvas)函数实现
绘制自己的孩子通过dispatchDraw（canvas）实现
View组件的绘制会调用draw(Canvas canvas)方法，draw过程中主要是先画Drawable背景，对 drawable调用setBounds()然后是draw(Canvas c)方法.有点注意的是背景drawable的实际大小会影响view组件的大小，drawable的实际大小通过getIntrinsicWidth()和getIntrinsicHeight()获取，当背景比较大时view组件大小等于背景drawable的大小</p>
<p>画完背景后，draw过程会调用onDraw(Canvas canvas)方法，然后就是dispatchDraw(Canvas canvas)方法, dispatchDraw()主要是分发给子组件进行绘制，我们通常定制组件的时候重写的是onDraw()方法。值得注意的是ViewGroup容器组件的绘制，当它没有背景时直接调用的是dispatchDraw()方法, 而绕过了draw()方法，当它有背景的时候就调用draw()方法，而draw()方法里包含了dispatchDraw()方法的调用。因此要在ViewGroup上绘制东西的时候往往重写的是dispatchDraw()方法而不是onDraw()方法，或者自定制一个Drawable，重写它的draw(Canvas c)和 getIntrinsicWidth(),</p>
<p>getIntrinsicHeight()方法，然后设为背景。</p>
<h4 id="4-opengl可编程管线与固定区别"><a href="#4-opengl可编程管线与固定区别" class="headerlink" title="4.opengl可编程管线与固定区别"></a>4.opengl可编程管线与固定区别</h4><p>1）、固定渲染管线 ——这是标准的几何&amp;光照(T&amp;L)管线，功能是固定的，它控制着世界、视、投影变换及固定光照控制和纹理混合。T&amp;L管线可以被渲染状态控制，矩阵，光照和采制参数。
2）、顶点着色器——图形开发人员可以对渲染管线中的顶点运算和像素运算分别进行编程处理了，而无须象以前那样套用一些固定函数，取代设置参数来控制管线，最早出现与DX8，包括PS和VS两部分。</p>
<h4 id="5-光照"><a href="#5-光照" class="headerlink" title="5.光照"></a>5.光照</h4><h4 id="6-深度测试"><a href="#6-深度测试" class="headerlink" title="6.深度测试"></a>6.深度测试</h4><p>像素归属测试：这一步骤由OpenGL ES内部进行，不由开发人员控制；测试确定帧缓冲区的位置的像素是否归属当前OpenGL ES所有，如不属于或被另一个窗口遮挡，从而完全不显示这些像素。</p>
<p>裁剪测试：判断像素是否在由 glScissor 定义的剪裁矩形内，不在该剪裁区域内的像素就会被剪裁掉；</p>
<p>模板和深度测试：测试输入片段的模板和深度值上进行，以确定片段是否应该被拒绝；深度测试比较下一个片段与帧缓冲区中的片段的深度，从而决定哪一个像素在前面，哪一个像素被遮挡；</p>
<p>混合：是将片段的颜色和帧缓冲区中已有的颜色值进行混合，并将混合所得的新值写入帧缓冲；</p>
<p>抖动：可用于最小化因为使用有限精度在帧缓冲区中保存颜色值而产生的伪像。</p>
<p>Framebuffer：这是流水线的最后一个阶段，Framebuffer 中存储这可以用于渲染到屏幕或纹理中的像素值，也可以从Framebuffer 中读回像素值，但不能读取其他值（如深度值，模版值等）。</p>
<h4 id="7-Intent为什么可序列化的数据"><a href="#7-Intent为什么可序列化的数据" class="headerlink" title="7.Intent为什么可序列化的数据"></a>7.Intent为什么可序列化的数据</h4><p>大家都知道进行Android开发的时候，无法将对象的引用传给Activities或者Fragments，我们需要将这些对象放到一个Intent或者Bundle里面，然后再传递
序列化的原因基本三种情况：</p>
<ol>
<li>永久性保存对象，保存对象的字节序列到本地文件中；</li>
<li>对象在网络中传递；</li>
<li>对象在IPC间传递。<h4 id="8-SharedPreference"><a href="#8-SharedPreference" class="headerlink" title="8.SharedPreference"></a>8.SharedPreference</h4>之前为了解决应用的内存压力，在同一个应用中使用了多进程，但在程序自测的过程中发现不同进程之间的SharedPreferences数据不能共享，但应用内很多数据都是通过SharedPreferences来保存的，如果改成其它多进程通信的方式改动比较大。通过查看源码发现，在API Level&gt;=11即Android 3.0可以通过Context.MODE_MULTI_PROCESS属性来实现SharedPreferences多进程共享，具体使用方式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class PreferencesUtils &#123;</div><div class="line">    public static String PREFERENCE_NAME = &quot;SharedPreferencesDemo&quot;;</div><div class="line"></div><div class="line">    private PreferencesUtils()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static boolean putString(Context context, String key, String value) &#123;</div><div class="line">        SharedPreferences settings = context.getSharedPreferences(PREFERENCE_NAME, Context.MODE_MULTI_PROCESS);</div><div class="line">        SharedPreferences.Editor editor = settings.edit();</div><div class="line">        editor.putString(key, value);</div><div class="line">        return editor.commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String getString(Context context, String key, String defaultValue) &#123;</div><div class="line">        SharedPreferences settings = context.getSharedPreferences(PREFERENCE_NAME, Context.MODE_MULTI_PROCESS);</div><div class="line">        return settings.getString(key, defaultValue);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>本来以为通过MODE_MULTI_PROCESS属性使用SharedPreferences就可以解决不同进程之间不能共享数据的问题了，但SQA总是反馈一些随机但出现频率比较大的bug，比如在使用过程中没有清除程序数据的前提下，会出现欢迎界面和操作指引，这是通过保存在SharedPreferences的标志来判断用户是否是第一次启动程序的，分析发现保存在SharedPreferences中的数据丢失了，但代码中并没有去清除这些数据，所以推测可能是不同进程同一时间对SharedPreferences操作导致的，经验证确实如此，去掉多进程就不会再出现这个问题了。</p>
<p>由于进程间是不能内存共享的，每个进程操作的SharedPreferences都是一个单独的实例，上述的问题并不能通过锁来解决，这导致了多进程间通过SharedPreferences来共享数据是不安全的，这个问题只能通过多进程间其它的通信方式或者是在确保不会同时操作SharedPreferences数据的前提下使用SharedPreferences来解决。</p>
<p><strong>apply和commit都是提交保存，区别在于apply是异步执行的，不需要等待。不论删除，修改，增加都必须调用apply或者commit提交保存。</strong></p>
<h4 id="9-保存sd卡怎么加锁"><a href="#9-保存sd卡怎么加锁" class="headerlink" title="9.保存sd卡怎么加锁"></a>9.保存sd卡怎么加锁</h4><h4 id="10-Handler中Queue的排序方式"><a href="#10-Handler中Queue的排序方式" class="headerlink" title="10.Handler中Queue的排序方式"></a>10.Handler中Queue的排序方式</h4><h4 id="11-IOC-控制反转"><a href="#11-IOC-控制反转" class="headerlink" title="11.IOC 控制反转"></a>11.IOC 控制反转</h4><h4 id="12-Android-IPC"><a href="#12-Android-IPC" class="headerlink" title="12.Android IPC"></a>12.Android IPC</h4><h4 id="13-OKHttp与httpclient区别"><a href="#13-OKHttp与httpclient区别" class="headerlink" title="13.OKHttp与httpclient区别"></a>13.OKHttp与httpclient区别</h4>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://images.wodekouwei.com/Pay/weixin_qingkouwei.png" alt="轻口味 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://images.wodekouwei.com/Pay/zhifubao_qingkouwei.jpg" alt="轻口味 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/tips/" rel="tag"># tips</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/09/m-f-mp4/" rel="prev" title="MP4格式解析">
                MP4格式解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">98</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">52</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#四大组件"><span class="nav-number">1.</span> <span class="nav-text">四大组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity"><span class="nav-number">1.1.</span> <span class="nav-text">Activity</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Activity生命周期"><span class="nav-number">1.1.1.</span> <span class="nav-text">Activity生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不同场景下Activity生命周期的变化过程"><span class="nav-number">1.1.2.</span> <span class="nav-text">不同场景下Activity生命周期的变化过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Activity-四中launchMode"><span class="nav-number">1.1.3.</span> <span class="nav-text">Activity 四中launchMode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fragment"><span class="nav-number">1.1.4.</span> <span class="nav-text">fragment</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#问题"><span class="nav-number">1.1.5.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Service"><span class="nav-number">1.2.</span> <span class="nav-text">Service</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#保证Service在后台不被kill的方法"><span class="nav-number">1.2.1.</span> <span class="nav-text">保证Service在后台不被kill的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Service进程优先级"><span class="nav-number">1.2.2.</span> <span class="nav-text">Service进程优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IntentServices"><span class="nav-number">1.2.3.</span> <span class="nav-text">IntentServices</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BroadcastReceiver"><span class="nav-number">1.3.</span> <span class="nav-text">BroadcastReceiver\</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Android引入广播机制原因"><span class="nav-number">1.3.1.</span> <span class="nav-text">Android引入广播机制原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注册广播的两种方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">注册广播的两种方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两种广播类型"><span class="nav-number">1.3.3.</span> <span class="nav-text">两种广播类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ContentProvider"><span class="nav-number">1.4.</span> <span class="nav-text">ContentProvider</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现数据共享"><span class="nav-number">1.4.1.</span> <span class="nav-text">实现数据共享</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View与布局"><span class="nav-number">2.</span> <span class="nav-text">View与布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LinearLayout和RelativeLayout性能对比"><span class="nav-number">2.1.</span> <span class="nav-text">LinearLayout和RelativeLayout性能对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绘制"><span class="nav-number">2.2.</span> <span class="nav-text">绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义view的基本流程"><span class="nav-number">2.2.1.</span> <span class="nav-text">自定义view的基本流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#View的绘制流程"><span class="nav-number">2.2.2.</span> <span class="nav-text">View的绘制流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件传递机制"><span class="nav-number">2.2.3.</span> <span class="nav-text">事件传递机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动画"><span class="nav-number">3.</span> <span class="nav-text">动画</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三种动画"><span class="nav-number">3.1.</span> <span class="nav-text">三种动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动画原理"><span class="nav-number">3.2.</span> <span class="nav-text">动画原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性动画特性"><span class="nav-number">3.3.</span> <span class="nav-text">属性动画特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化"><span class="nav-number">4.</span> <span class="nav-text">优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#布局优化"><span class="nav-number">4.1.</span> <span class="nav-text">布局优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ListView卡顿的原因以及优化策略"><span class="nav-number">4.2.</span> <span class="nav-text">ListView卡顿的原因以及优化策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存泄露问题"><span class="nav-number">4.3.</span> <span class="nav-text">内存泄露问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OOM发生情况"><span class="nav-number">4.4.</span> <span class="nav-text">OOM发生情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免oom"><span class="nav-number">4.5.</span> <span class="nav-text">避免oom</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ANR"><span class="nav-number">4.6.</span> <span class="nav-text">ANR</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何定位ANR错误"><span class="nav-number">4.6.1.</span> <span class="nav-text">如何定位ANR错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何避免ANR"><span class="nav-number">4.6.2.</span> <span class="nav-text">如何避免ANR</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#native"><span class="nav-number">5.</span> <span class="nav-text">native</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dalvik-JVM-ART区别"><span class="nav-number">5.1.</span> <span class="nav-text">Dalvik,JVM,ART区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Dalvik？"><span class="nav-number">5.2.</span> <span class="nav-text">什么是Dalvik？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是ART？"><span class="nav-number">5.3.</span> <span class="nav-text">什么是ART？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM"><span class="nav-number">5.4.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dalvik和JVM有啥关系？"><span class="nav-number">5.5.</span> <span class="nav-text">Dalvik和JVM有啥关系？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题整理"><span class="nav-number">6.</span> <span class="nav-text">问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-分析Java线程中断机制stop和interrupted的用法"><span class="nav-number">6.1.</span> <span class="nav-text">1. 分析Java线程中断机制stop和interrupted的用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-线程状态"><span class="nav-number">6.2.</span> <span class="nav-text">2. 线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-View-的onDraw与dispatchDraw"><span class="nav-number">6.3.</span> <span class="nav-text">3.View 的onDraw与dispatchDraw</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-opengl可编程管线与固定区别"><span class="nav-number">6.4.</span> <span class="nav-text">4.opengl可编程管线与固定区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-光照"><span class="nav-number">6.5.</span> <span class="nav-text">5.光照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-深度测试"><span class="nav-number">6.6.</span> <span class="nav-text">6.深度测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Intent为什么可序列化的数据"><span class="nav-number">6.7.</span> <span class="nav-text">7.Intent为什么可序列化的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-SharedPreference"><span class="nav-number">6.8.</span> <span class="nav-text">8.SharedPreference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-保存sd卡怎么加锁"><span class="nav-number">6.9.</span> <span class="nav-text">9.保存sd卡怎么加锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-Handler中Queue的排序方式"><span class="nav-number">6.10.</span> <span class="nav-text">10.Handler中Queue的排序方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-IOC-控制反转"><span class="nav-number">6.11.</span> <span class="nav-text">11.IOC 控制反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-Android-IPC"><span class="nav-number">6.12.</span> <span class="nav-text">12.Android IPC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-OKHttp与httpclient区别"><span class="nav-number">6.13.</span> <span class="nav-text">13.OKHttp与httpclient区别</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  


  

</body>
</html>
