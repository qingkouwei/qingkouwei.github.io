<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="老司机种菜">
<meta property="og:url" content="http://wodekouwei.com/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机种菜">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/"/>





  <title> 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/12/tips-net-applicationlayer-diff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/12/tips-net-applicationlayer-diff/" itemprop="url">
                  tips-net-applicationlayer-diff
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T15:09:49+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="I-协议优化演进"><a href="#I-协议优化演进" class="headerlink" title="I. 协议优化演进"></a>I. 协议优化演进</h3><h4 id="1-带宽与拥塞"><a href="#1-带宽与拥塞" class="headerlink" title="1. 带宽与拥塞"></a>1. 带宽与拥塞</h4><p><strong>现状</strong></p>
<p>目前的网络基建越来越好，因此带宽的已经不再是瓶颈， 但是由于相关协议(如TCP)的拥塞窗口(CWND, congestion window)控制算法，很多时候并没有将带宽有效的利用，因此更有效的利用带宽是一个优化方向，特别针对视频、游戏等领域。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>QUIC:</strong> 基于UDP，QUIC可以支持无序的递交，因此通常单个丢包最多只会影响1个请求stream，并且QUIC中一定程度上拆分拥塞窗口来更好的适配多个多路复用的连接，来尽可能的利用带宽，目前已经在Youtube以及一些Google通用库(如字体库)上应用</li>
<li><strong>HTTP:</strong> 通过同时建立多个连接通道，由于每个通道有单独的拥塞窗口保证一个丢包最多只拥塞一个连接通道</li>
<li><strong>BBR:</strong> Google推出的全新的阻塞拥塞控制算法，从根本上解决该问题，通过交替测量带宽和激进的估算算法尽可能的占满带宽与降低延迟（此方式极大的提高了带宽利用率），目前已经在Youtube上应用</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>TCP:</strong> 由于采用”加性增，乘性减”的拥塞控制算法，错误的将网络中的错误丢包也认为是拥塞丢包，导致拥塞窗口被收敛的很小，带宽无法有效利用</li>
<li><strong>SPDY:</strong> 由于SPDY基于TCP，因此存在TCP相同的缺陷问题，并且虽然SPDY采用了多路复用，也做个各类优化，但是由于一个TCP连接只有一个拥塞窗口，因此一个请求stream丢包，就会导致整个通道被阻塞</li>
</ul>
<h4 id="2-握手的N-RTT的开销"><a href="#2-握手的N-RTT的开销" class="headerlink" title="2. 握手的N-RTT的开销"></a>2. 握手的N-RTT的开销</h4><p><strong>现状</strong></p>
<p>目前TCP与SSL/TLS(1.0,1.1,1.2)，每次建连需要TCP三次握手+安全握手需要: <code>4~5-RRT</code>，导致建连效率低下，Google、Facebook、Tencent(Wechat)等公司推出了各类优化策略。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>TLS1.3:</strong> 安全握手提出了0-RTT草案</li>
<li><strong>QUIC:</strong> 通过实现自己的安全模块，整个握手过程(TCP + TLS)采用全新的0-RTT方案，并计划当完成时适配到TLS1.3中</li>
<li><strong>Proxygen:</strong> Facebook基于QUIC的0-RTT协议进行优化，保证安全握手最多只有1-RTT，并运用在TCP中 ，并将贡献各类优化成果给TLS1.3</li>
<li><strong>mmtls:</strong> Wechat基于TLS1.3草案中的0-RTT，进行优化推出自己的mmtls，其对于长连接保障安全握手1-RTT，对于短连接安全握手尽可能使用0-RTT</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>SSL、TLS1.3之前版本:</strong>  在TLS1.2中，需要2~1-RTT(全握手需要2-RTT)</li>
</ul>
<h4 id="3-冗余数据"><a href="#3-冗余数据" class="headerlink" title="3. 冗余数据"></a>3. 冗余数据</h4><p><strong>现状</strong></p>
<p>通常的一般的HTTP请求，每次请求header基本上没什么变化；在一些情况下多个页面使用相同静态资源(js、logo等)，却每次都重复下载。</p>
<p><strong>应对</strong></p>
<ul>
<li><strong>SPDY:</strong> 采用<a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="external">DEFLATE</a>对请求头/响应头进行压缩</li>
<li><strong>HTTP/2:</strong> 采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="external">HPACK</a>算法对请求头/响应头进行压缩，并且通讯双方各自cache一份header fields表，避免了重复header的传输</li>
<li><strong>QUIC:</strong> 目前版本采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="external">HPACK</a>算法对请求头/响应头进行压缩</li>
<li><strong>HTTP/1.1、HTTP/2:</strong> 支持<code>Cache-Control</code>用于控制资源有效时间,支持<code>Last-Modified</code>来控制资源是否可复用</li>
<li><strong>Facebook geek方案:</strong>  将<code>expiration time</code>全部设置为1年，所有的资源请求链接，都采用概念性的连接(在请求链接后加上资源名的md5，再做mapping)(只要资源不变化链接就不变化)，保证已下载资源能被有效利用的同时，避免重复检测资源有效性</li>
<li><strong>浏览器优化:</strong> Facebook联系Chrome与Firefox，针对复用资源可复用检测频率进行调整(如firefox支持在<code>cache-control</code>中的<code>immutable</code>关键字表示资源不可变不用重复检测)</li>
</ul>
<p><strong>存在该缺陷的协议</strong></p>
<ul>
<li><strong>HTTP/1:</strong> 请求头未做压缩，不支持<code>Cache-Control</code>与<code>Last-Modified</code>因此存在冗余资源重复下载问题</li>
<li><strong>HTTP/1.1:</strong> 请求头未做压缩</li>
</ul>
<h4 id="4-预准备"><a href="#4-预准备" class="headerlink" title="4. 预准备"></a>4. 预准备</h4><ul>
<li><strong>Taobao:</strong> DNS-Prefetch、Preconnect、Prefetch、Flush HTML early、PreRender</li>
<li><strong>SPDY、HTTP/2、QUIC:</strong>: 允许服务端主动推服务端认为客户端需要的静态资源</li>
</ul>
<h4 id="5-负载均衡、超时策略优化与其他"><a href="#5-负载均衡、超时策略优化与其他" class="headerlink" title="5. 负载均衡、超时策略优化与其他"></a>5. 负载均衡、超时策略优化与其他</h4><ul>
<li><strong>负载均衡:</strong> 收益较小的长连接，带来服务端没必要的性能开销</li>
<li><strong>超时策略:</strong> 策略性的调整建连与维连时的超时重连的频率、时间、IP/端口，来应对弱网状况，何时快速放弃节约资源(无网状态)，何时找到可用资源快速恢复连接(被劫持、服务器某端口/IP故障、基站繁忙、连接信号弱、丢包率高)</li>
<li><strong>策略性阻塞:</strong> 根据网络情况、请求数目动态调整连接数来保证吞吐量与稳定性（如SPDY、HTTP/2、QUIC中的多路复用）</li>
<li><strong>DNS:</strong> 结合TTL有效管理本地DNS缓存的有效时间、以及缓存大小来减少DNS查询的阻塞，以及可以通过HTTPDNS优化DNS请求的线路以及来避免DNS被篡改等问题(如果使用okhttp3，可以指定DNS，并且可以为请求设定缓存大小与时间，可以很轻易的实现自己的HTTPDNS)</li>
</ul>
<h3 id="II-常见协议区分"><a href="#II-常见协议区分" class="headerlink" title="II. 常见协议区分"></a>II. 常见协议区分</h3><h4 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1. TCP"></a>1. TCP</h4><blockquote>
<p>关于TCP窗口的研究与学习，请移步<a href="/tcp-window/">TCP窗口</a></p>
</blockquote>
<p>目前应用最广泛的可靠的、有序的、自带问题校验修复(<a href="https://en.wikipedia.org/wiki/Error_detection_and_correction" target="_blank" rel="external">error-checked</a>)、传输协议，通常情况下发送端与接收端通过TCP协议来保障数据的可靠到达，中间层通过IP协议来路由数据的传递。</p>
<center><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152553.png" alt=""></center>

<ul>
<li><strong>建连:</strong> 通过三次握手，保障连接已可靠连接</li>
<li><strong>超时重试:</strong> 通过连接超时重试、读写超时重试机制，来保障连接的稳定性</li>
<li><strong>拥塞控制:</strong> 通过”加性增，乘性减”算法，来保障尽量少的报文传输尽量多的数据的同时，减少丢包重传的概率</li>
<li><strong>校验和:</strong> 通过对TCP/IP头进行”校验和”检查，来保障传输数据与地址信息的可靠</li>
<li><strong>有序性:</strong> 通过”序列号”来鉴别每个字节数据，保证接收端能够有序的重建传输数据，以及校验数据完整性</li>
<li><strong>应答机制:</strong> 每次接收端会发送Acks(Acknowledgements)给发送端告知数据以被接收</li>
<li><strong>断连:</strong> 通过四次挥手，保障连接已可靠断开</li>
</ul>
<h4 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h4><p><strong><code>HTTP1.1</code> vs <code>HTTP1.0</code></strong></p>
<ul>
<li><strong>更灵活缓存处理:</strong> 引入Etag(Entity tag)等目前常用的缓存相关策略</li>
<li><strong>优化带宽使用:</strong> 引入<code>range</code>头域，支持206(Partial Content)，用于数据断点续传。</li>
<li><strong>错误机制更完善:</strong> 引入24个错误状态码，如409(Conflict)请求资源与当前状态冲突； 410(Gone)资源在服务器上被永久删除</li>
<li><strong>Host头处理:</strong> 请求头中必须带上<code>host</code>，否则会报400 Bad Request，为了支持一台服务器上有多台虚拟主机，因此通常一个IP对应了多个域名</li>
<li><strong>长连接:</strong> 默认<code>Connection: keep-alive</code>，以复用已建连通道，不像<code>http1.0</code>每个请求都需要重新创建</li>
</ul>
<h4 id="3-HTTPS"><a href="#3-HTTPS" class="headerlink" title="3. HTTPS"></a>3. HTTPS</h4><p>1994年由 <strong>网景</strong> 提出，并应用在网景导航者浏览器中。最新的HTTPS协议在2000年5月公布的<code>RFC 2818</code>正式确定。</p>
<p>HTTPS协议是基于TLS(Transport Layer Security)/SSL(Secure Sockets Layer)对数据进行加密校验，保障了网络通信中的数据安全。</p>
<p>在当前大陆的网络环境而言，是有效避免运营商劫持的手段。</p>
<center><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152610.png" alt="image_1b8ji5se91a1kvn431umcc2vk9.png-44.3kB"></center>

<ul>
<li><strong>SSL与TLS:</strong> 早期HTTPS是通过SSL对数据验证加密，后SSL逐渐演变为现在的TLS，所以大多数为了有效的支持加密，都同时支持了SSL与STL</li>
<li><strong>TLS提高了SSL:</strong> 虽然最早的TLS1.0与SSL3.0非常类似，但是TLS采用HMAC(keyed-Hashing for Message Authentication Code)算法对数据验证相比SSL的MAC(Message Authentication Code)算法会更难破解，并且在其他方面也有一些小的改进</li>
<li><strong>请求端口:</strong> 443</li>
</ul>
<h4 id="4-SPDY"><a href="#4-SPDY" class="headerlink" title="4. SPDY"></a>4. SPDY</h4><blockquote>
<p>读音speedy</p>
</blockquote>
<p>是谷歌开发为了加快网页加载速度的网络协议。</p>
<p>SPDY兼容性: <a href="http://caniuse.com/#feat=spdy" target="_blank" rel="external">http://caniuse.com/#feat=spdy</a></p>
<center><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152616.png" alt="image_1b8jj8l511lag13eslpm1al918krm.png-23.8kB"></center>

<ul>
<li><strong>采用多路复用(multiplexing):</strong> 多个请求stream共享一个tcp连接， 降低延时、提高带宽利用率</li>
<li><strong>请求优先级:</strong> 允许给每个请求设置优先级，使得重要的请求得到优先响应</li>
<li><strong>TLS/SSL的加密传输:</strong> 强制要求使用TLS/SSL提高数据安全可靠性</li>
<li><strong>压缩<code>请求头/响应头</code>:</strong> 通过DEFLATE或gzip算法进行对<code>请求头/响应头</code>进行压缩</li>
<li><strong>支持Server Push:</strong> 允许服务端主动的推送资源(js、css)给客户端，当分析获知客户端将会需要时，以此利用起空闲带宽</li>
<li><strong>支持Server Hints:</strong> 允许服务端可以在客户端还没有发现将需要哪些资源的时候，主动通知客户端，以便于客户端实现准备好相关资源的缓存</li>
</ul>
<h4 id="5-HTTP-2"><a href="#5-HTTP-2" class="headerlink" title="5. HTTP/2"></a>5. HTTP/2</h4><blockquote>
<p>HTTP/2基于SPDY设计</p>
</blockquote>
<center><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152623.png" alt="image_1b90ik3e01di41tgr16hc12ks19uvp.png-129.5kB"></center>
<center><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152632.png" alt="image_1b8jku3ol1rbveu4es1tp8rk61j.png-125kB"></center>

<p><strong>HTTP/2 vs SPDY</strong></p>
<ul>
<li><strong>SSL/TLS:</strong> SPDY强制使用SSL/TLS，HTTP/2非强制(但是部分浏览器(如Chrome)不允许，所以目前如果使用HTTP/2最好都配置SSL/TLS)</li>
<li><strong>消息头压缩算法:</strong> HTTP/2消息头压缩算法采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="external">HPACK</a>，SPDY采用<a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="external">DEFLATE</a>，一般情况下HPACK的压缩率会高于DEFLATE</li>
<li><strong>传输格式:</strong> HTTP/2传输采用二进制而非文本，因此HTTP/2中的基本单位是帧, 文本形式众多很难权衡健壮、性能与复杂度，二进制弥补了这个缺陷，并且是无序的帧，最终根据头帧重新组装</li>
<li><strong>继承与优化:</strong> HTTP/2继承并优化了SPDY的多路复用与Server Push</li>
</ul>
<h4 id="6-QUIC"><a href="#6-QUIC" class="headerlink" title="6. QUIC"></a>6. QUIC</h4><ul>
<li>发音<code>quick</code></li>
<li>QUIC 参考了HTTP/2与SPDY</li>
<li>Google在2013年10月第一次在IETF展示QUIC, 2016年7月启动工作群</li>
<li>可靠的，多路复用的基于UDP的网络协议，内置安全加密模块，低延迟、运行在用户空间、开源的新一代网络协议。Google计划在完成后将其服务于所有的Google服务。</li>
</ul>
<center><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152640.png" alt=""></center>
<center><img src="http://images.wodekouwei.com/tips-net-applicationlayer-diff-2019312152646.png" alt=""></center>

<ul>
<li><strong>减少建连延迟:</strong> 从未访问过服务的情况下1-RTT，其他的可以立马开始传输数据(0-RTT)</li>
<li><strong>拥塞控制:</strong> 提升TCP Cubic拥塞控制</li>
<li><strong>HOL阻塞:</strong> 消除多路复用中的HOL阻塞(head-of-line blocking)</li>
<li><strong>更少的帧消耗:</strong> Quic数据包包含更少的帧，因此更多的数据包可以携带数据</li>
<li><strong>提升丢包重试:</strong> 丢包重试时使用新的序列号以及采用重新加密</li>
<li><strong>安全加密:</strong> 内置的加密模块(支持SNI，因此支持一个IP部署多个证书)，并且是默认打开的，相比TLS更高效的向前加密 - 完成以后，将计划适配到TLS 1.3中</li>
<li><strong>端口:</strong> 使用443端口来处理UDP协议数据 - <a href="https://community.spiceworks.com/topic/601177-port-80-443-udp-traffic-to-google" target="_blank" rel="external">Port 80/443 UDP Traffic to Google?</a></li>
<li><strong>其他:</strong> 更好的FEC(Forward error correction)机制、与Connection migration机制</li>
</ul>
<hr>
<ul>
<li><a href="http://lovestblog.cn/blog/2014/05/20/tcp-broken-pipe/" target="_blank" rel="external">从tcp原理角度理解Broken pipe和Connection Reset by Peer的区别</a></li>
<li><a href="http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf" target="_blank" rel="external">淘宝HTTPS探索</a></li>
<li><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="external">HTTP,HTTP/2,SPDY,HTTPS你应该知道的一些事</a></li>
<li><a href="https://docs.google.com/document/d/1lmL9EF6qKrk7gbazY8bIdvq3Pno2Xj_l_YShP40GLQE" target="_blank" rel="external">QUIC Geek FAQ</a></li>
<li><a href="https://github.com/google/bbr" target="_blank" rel="external">google/bbr</a></li>
<li><a href="http://www.cnblogs.com/mydomain/archive/2013/04/18/3027668.html" target="_blank" rel="external">滑动窗口和拥塞窗口简述</a></li>
<li><a href="https://www.zhihu.com/question/53559433" target="_blank" rel="external">BBR算法原理 - 李博杰</a></li>
<li><a href="https://www.nanog.org/sites/default/files/meetings/NANOG64/1051/20150603_Rogan_Quic_Next_Generation_v1.pdf" target="_blank" rel="external">QUIC - Next generation multiplexed transport over UDP</a></li>
<li><a href="https://code.facebook.com/posts/608854979307125/building-zero-protocol-for-fast-secure-mobile-connections/" target="_blank" rel="external">Building Zero protocol for fast, secure mobile connections</a></li>
<li><a href="https://github.com/WeMobileDev/article/blob/master/%E5%9F%BA%E4%BA%8ETLS1.3%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AEmmtls%E4%BB%8B%E7%BB%8D.md" target="_blank" rel="external">基于TLS1.3的微信安全通信协议mmtls介绍</a></li>
<li><a href="https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit" target="_blank" rel="external">QUIC Wire Layout Specification</a></li>
<li><a href="https://en.wikipedia.org/wiki/SPDY" target="_blank" rel="external">SPDY - Wiki</a></li>
<li><a href="https://code.facebook.com/posts/557147474482256/this-browser-tweak-saved-60-of-requests-to-facebook/" target="_blank" rel="external">This browser tweak saved 60% of requests to Facebook</a></li>
<li><a href="http://jiaolonghuang.github.io/2015/08/16/http2/" target="_blank" rel="external">HTTP2学习(四)—HTTP2的新特性</a></li>
<li><a href="https://www.chromium.org/spdy/link-headers-and-server-hint" target="_blank" rel="external">Server Push and Server Hints</a></li>
<li><a href="https://technet.microsoft.com/en-us/library/cc784450(v=ws.10" target="_blank" rel="external">What is TLS/SSL?</a>.aspx)</li>
<li><a href="http://peering.google.com/#/learn-more/quic" target="_blank" rel="external">QUIC - Google-peering</a></li>
<li><a href="https://www.chromium.org/quic" target="_blank" rel="external">QUIC教材</a></li>
<li><a href="https://www.youtube.com/watch?v=hQZ-0mXFmk8" target="_blank" rel="external">QUIC视频介绍</a></li>
<li><a href="https://tools.keycdn.com/http2-test" target="_blank" rel="external">Http2-test</a></li>
<li><a href="https://community.akamai.com/community/web-performance/blog/2015/06/05/useful-tools-for-http2-debugging" target="_blank" rel="external">Http2-debug</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-summarize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-summarize/" itemprop="url">
                  tips-net-summarize
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:42:21+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-http/" itemprop="url">
                  tips-net-http
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:22:25+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-mars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-mars/" itemprop="url">
                  tips-net-mars
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T18:17:18+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-tcp/" itemprop="url">
                  tips-net-tcp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T16:59:43+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311171945.png" alt="tips-net-tcp-2019311171945"></p>
<p>各个段位说明:</p>
<ul>
<li>源端口和目的端口:　　各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现</li>
<li>序号:　　占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li>
<li>确认号:　　占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号</li>
<li>数据偏移/首部长度:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)</li>
<li>保留:　　占 6 位,保留为今后使用,但目前应置为 0</li>
<li>紧急URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)</li>
<li>确认ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效</li>
<li>PSH(PuSH):　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付</li>
<li>RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接</li>
<li>同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文</li>
<li>终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接</li>
<li>检验和:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部</li>
<li>紧急指针:　　占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li>
<li>选项:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]</li>
<li>填充:　　这是为了使整个首部长度是 4 字节的整数倍</li>
<li>其他选项:<ul>
<li>窗口扩大:　　占 3 字节,其中有一个字节表示移位值 S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小</li>
<li>时间戳:　　占10 字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)</li>
<li>选择确认:　　接收方收到了和前面的字节流不连续的两2字节.如果这些字节的序号都在接收窗口之内,那么接收方就先收下这些数据,但要把这些信息准确地告诉发送方,使发送方不要再重复发送这些已收到的数据</li>
</ul>
</li>
</ul>
<h2 id="数据单位"><a href="#数据单位" class="headerlink" title="数据单位"></a>数据单位</h2><p>TCP 传送的数据单位协议是 TCP 报文段(segment)</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>TCP 是面向连接的传输层协议 每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的（一对一） TCP 提供可靠交付的服务 TCP 提供全双工通信 面向字节流</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的 TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的) TCP 可把太长的数据块划分短一些再传送.TCP 也可等待积累有足够多的字节后再构成报文段发送出去 每一条 TCP 连接有两个端点 TCP 连接的端点不是主机,不是主机的IP 地址,不是应用进程,也不是传输层的协议端口.TCP 连接的端点叫做套接字(socket)或插口</p>
<h2 id="自动重传请求ARQ"><a href="#自动重传请求ARQ" class="headerlink" title="自动重传请求ARQ"></a>自动重传请求ARQ</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)</p>
<h3 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认:"></a>累积确认:</h3><ul>
<li>定义:　　接收方一般采用累积确认的方式.即不必对收到的分组逐个发送确认,而是对按序到达的最后一个分组发送确认,这样就表示：到这个分组为止的所有分组都已正确收到了</li>
<li>优点:　　容易实现,即使确认丢失也不必重传</li>
<li>缺点:　　不能向发送方反映出接收方已经正确收到的所有分组的信息<h3 id="Go-back-N-回退N"><a href="#Go-back-N-回退N" class="headerlink" title="Go-back-N(回退N):"></a>Go-back-N(回退N):</h3>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了.这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li>TCP 连接的每一端都必须设有两个窗口      一个发送窗口和一个接收窗口</li>
<li>TCP 可靠传输机制用字节的序号进行控制.TCP 所有的确认都是基于序号而不是基于报文段</li>
<li>TCP 两端的四个窗口经常处于动态变化之中</li>
<li>TCP连接的往返时间 RTT 也不是固定不变的.需要使用特定的算法估算较为合理的重传时间</li>
</ul>
<h3 id="图释"><a href="#图释" class="headerlink" title="图释"></a>图释</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117259.png" alt="tips-net-tcp-201931117259"></p>
<h2 id="发送缓存"><a href="#发送缓存" class="headerlink" title="发送缓存"></a>发送缓存</h2><h3 id="发送缓存用来暂时存放："><a href="#发送缓存用来暂时存放：" class="headerlink" title="发送缓存用来暂时存放："></a>发送缓存用来暂时存放：</h3><ul>
<li>发送应用程序传送给发送方 TCP 准备发送的数据</li>
<li>TCP 已发送出但尚未收到确认的数据<h3 id="图释-1"><a href="#图释-1" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172637.png" alt="tips-net-tcp-2019311172637"></li>
</ul>
<h2 id="接收缓存"><a href="#接收缓存" class="headerlink" title="接收缓存"></a>接收缓存</h2><h3 id="接收缓存用来暂时存放："><a href="#接收缓存用来暂时存放：" class="headerlink" title="接收缓存用来暂时存放："></a>接收缓存用来暂时存放：</h3><ul>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据<h3 id="图释-2"><a href="#图释-2" class="headerlink" title="图释:"></a>图释:</h3><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172725.png" alt="tips-net-tcp-2019311172725"></li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口(rwnd)是用于流控的动态缩放可靠滑动的接收与发送窗口，防止发送端发送过快接收端被淹没
对应的还有拥塞窗口(rwnd),是在一个RTT内可以最多一次可发送的报文段数 — 发送方的流量控制</p>
<p>TCP是以报文段(若干字节)为单位，每一个报文段需要一次ACK确认收到，但是其带来的问题很明显，频繁的发送确认等待导致用于确认与等待的时间太长。引入窗口后，发送端只要在窗口内，便不用每次都等待ACK才发送下一个报文段，可以在发送窗口内一次连续发送几个报文段而无需等待ACK</p>
<h3 id="图释-3"><a href="#图释-3" class="headerlink" title="图释:"></a>图释:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311172750.png" alt="tips-net-tcp-2019311172750"></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点:"></a>特点:</h3><ul>
<li>以字节为单位的滑动窗口</li>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）<h3 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h3></li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程</li>
<li>TCP 要求接收方必须有累积确认的功能,这样可以减小传输开销</li>
</ul>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现:"></a>具体实现:</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-201931117296.png" alt="tips-net-tcp-201931117296">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172934.png" alt="tips-net-tcp-2019311172934">
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311172949.png" alt="tips-net-tcp-2019311172949">
<img src="http://images.wodekouwei.com/tips-net-tcp-201931117305.png" alt="tips-net-tcp-201931117305"></p>
<h3 id="发送窗口与接收窗口的关系"><a href="#发送窗口与接收窗口的关系" class="headerlink" title="发送窗口与接收窗口的关系"></a>发送窗口与接收窗口的关系</h3><p>TCP是双工协议，会话双方都可以同时接收与发送数据，因此双方都同时维护一个发送窗口与接收窗口。</p>
<ul>
<li>接收窗口大小取决于应用、系统、硬件等限制；</li>
<li>发送窗口大小取决于对方接收窗口的大小</li>
</ul>
<h3 id="窗口滑动协定"><a href="#窗口滑动协定" class="headerlink" title="窗口滑动协定"></a>窗口滑动协定</h3><ul>
<li>发送窗口只有在收到窗口内字节的ACK确认，才会滑动其左边界</li>
<li>接收窗口只有在窗口中所有的段都正确收到的情况下，才会滑动其左边界；当有字节未接收，但收到后面的字节的情况下，也会滑动，也不对后续字节确认，确保对方重传未接收字节<h3 id="哪些允许变化"><a href="#哪些允许变化" class="headerlink" title="哪些允许变化"></a>哪些允许变化</h3></li>
<li>最大报文段大小在握手中，就确定了</li>
<li>窗口缩放因子在握手中，就确定了</li>
<li>接收窗口大小在根据本地的处理能力与缓存剩余空间动态调整，通过ACK带给对方当前剩余的接收窗口大小</li>
</ul>
<h2 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311173223.png" alt="tips-net-tcp-2019311173223"></p>
<h2 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h2><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现:"></a>具体实现:</h3><p>TCP 每发送一个报文段,就对这个报文段设置一次计时器.只要计时器设置的重传时间到但还没有收到确认,就要重传这一报文段</p>
<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间:"></a>加权平均往返时间:</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h4><p>TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）,第一次测量到 RTT 样本时,RTTS 值就取为所测量到的 RTT 样本值.以后每测量到一个新的 RTT 样本,就按下式重新计算一次 RTTS：</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h4><p>新的 RTTS = ( 1 - α)×(旧的 RTTS)＋α(新的 RTT 样本)</p>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明:"></a>说明:</h4><p>式中,0 ≤ α＜ 1.若α很接近于零,表示 RTT 值更新较慢若选择 α 接近于1,则表示 RTT 值更新较快 RFC 2988 推荐的 α 值为 1/8,即 0.125</p>
<h3 id="超时重传时间RTO"><a href="#超时重传时间RTO" class="headerlink" title="超时重传时间RTO:"></a>超时重传时间RTO:</h3><p>RTO 应略大于上面得出的加权平均往返时间 RTTS. RFC 2988 建议使用下式计算 RTO：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RTO=RTTS + 4×RTTD</div></pre></td></tr></table></figure></p>
<p>RTTD 是 RTT 的偏差的加权平均值 RFC 2988 建议这样计算 RTTD.第一次测量时,RTTD 值取为测量到的 RTT 样本值的一半.在以后的测量中,则使用下式计算加权平均的 RTTD：</p>
<p><code>新的 RTTD = (1-β)×(旧的RTTD)+β×|RTTS﹣新的 RTT 样本|</code>
β是个小于 1 的系数,其推荐值是 1/4,即 0.25 在计算平均往返时间 RTT 时,只要报文段重传了,就不采用其往返时间样本</p>
<h3 id="修正的Karn算法"><a href="#修正的Karn算法" class="headerlink" title="修正的Karn算法:"></a>修正的Karn算法:</h3><p>报文段每重传一次,就把 RTO 增大一些：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">新的 RTO= γ×(旧的 RTO)</div></pre></td></tr></table></figure></p>
<p>系数γ 的典型值是 2 当不再发生报文段的重传时,才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值</p>
<h3 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h3><ul>
<li>TCP 为每一个连接设有一个持续计时器</li>
<li>只要 TCP 连接的一方收到对方的零窗口通知,就启动持续计时器</li>
<li>若持续计时器设置的时间到期,就发送一个零窗口探测报文段(仅携带 1 字节的数据),而对方就在确认这个探测报文段时给出了现在的窗口值</li>
<li>若窗口仍然是零,则收到这个报文段的一方就重新设置持续计时器</li>
<li>若窗口不是零,则死锁的僵局就可以打破了</li>
</ul>
<h2 id="报文段的发送时机"><a href="#报文段的发送时机" class="headerlink" title="报文段的发送时机"></a>报文段的发送时机</h2><p>TCP 维持一个变量,它等于最大报文段长度 MSS.只要缓存中存放的数据达到 MSS 字节时,就组装成一个 TCP 报文段发送出去 由发送方的应用进程指明要求发送报文段,即 TCP 支持的推送(push)操作 发送方的一个计时器期限到了,这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去</p>
<h2 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h2><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段:"></a>三个阶段:</h3><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立:"></a>连接建立:</h4><h5 id="图释-4"><a href="#图释-4" class="headerlink" title="图释:"></a>图释:</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174443.jpg" alt="tips-net-tcp-2019311174443"></p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>A 的 TCP 向 B 发出连接请求报文段,其首部中的同步位 SYN = 1,并选择序号 seq = x,表明传送数据时的第一个数据字节的序号是 x</li>
<li>B 的 TCP 收到连接请求报文段后,如同意,则发回确认(B 在确认报文段中应使 SYN = 1,使 ACK = 1,其确认号ack = x﹢1,自己选择的序号 seq = y)</li>
<li>A 收到此报文段后向 B 给出确认,其 ACK = 1,确认号 ack = y﹢1(A 的 TCP 通知上层应用进程,连接已经建立,B 的 TCP 收到主机 A 的确认后,也通知其上层应用进程：TCP 连接已经建立)</li>
</ul>
<h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放:"></a>连接释放:</h4><h5 id="图释-5"><a href="#图释-5" class="headerlink" title="图释"></a>图释</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174722.jpg" alt="tips-net-tcp-2019311174722"></p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤:"></a>步骤:</h5><ul>
<li>数据传输结束后,通信的双方都可释放连接.现在 A 的应用进程先向其 TCP 发出连接释放报文段,并停止再发送数据,主动关闭 TCP 连接(A 把连接释放报文段首部的 FIN = 1,其序号seq = u,等待 B 的确认)</li>
<li>B 发出确认,确认号 ack = u＋1,而这个报文段自己的序号 seq = v(TCP 服务器进程通知高层应用进程.从 A 到 B 这个方向的连接就释放了,TCP 连接处于半关闭状态.B 若发送数据,A 仍要接收)</li>
<li>若 B 已经没有要向 A 发送的数据,其应用进程就通知 TCP 释放连接</li>
<li>A 收到连接释放报文段后,必须发出确认,在确认报文段中 ACK = 1,确认号 ack=w﹢1,自己的序号 seq = u + 1</li>
</ul>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><p>TCP 连接必须经过时间 2MSL 后才真正释放掉(2MSL 的时间的用意 — 为了保证 A 发送的最后一个 ACK 报文段能够到达 B.防止 “已失效的连接请求报文段”出现在本连接中.A 在发送完最后一个 ACK 报文段后,再经过时间 2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失.这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段)</p>
<h5 id="发现丢失确认时候的处理"><a href="#发现丢失确认时候的处理" class="headerlink" title="发现丢失确认时候的处理"></a>发现丢失确认时候的处理</h5><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311174940.png" alt="tips-net-tcp-2019311174940"></p>
<h4 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题:"></a>三个问题:</h4><ul>
<li>要使每一方能够确知对方的存在</li>
<li>要允许双方协商一些参数(如最大报文段长度,最大窗口大小,服务质量等)</li>
<li>能够对运输实体资源(如缓存大小,连接表中的项目等)进行分配</li>
</ul>
<h2 id="发送TCP请求客户端"><a href="#发送TCP请求客户端" class="headerlink" title="发送TCP请求客户端"></a>发送TCP请求客户端</h2><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175058.png" alt="tips-net-tcp-2019311175058"></p>
<h2 id="拥塞处理相关概念"><a href="#拥塞处理相关概念" class="headerlink" title="拥塞处理相关概念"></a>拥塞处理相关概念</h2><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口:"></a>拥塞窗口:</h3><ul>
<li>含义:拥塞窗口的大小取决于网络的拥塞程度,并且动态地在变化.发送方让自己的发送窗口等于拥塞窗口.如再考虑到接收方的接收能力,则发送窗口还可能小于拥塞窗口</li>
<li>发送方控制拥塞窗口的原则:只要网络没有出现拥塞,拥塞窗口就再增大一些,以便把更多的分组发送出去.但只要网络出现拥塞,拥塞窗口就减小一些,以减少注入到网络中的分组数</li>
</ul>
<h3 id="乘法减小"><a href="#乘法减小" class="headerlink" title="乘法减小:"></a>乘法减小:</h3><p>是指不论在慢开始阶段还是拥塞避免阶段,只要出现一次超时(即出现一次网络拥塞),就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5</p>
<h3 id="加法增大"><a href="#加法增大" class="headerlink" title="加法增大:"></a>加法增大:</h3><p>是指执行拥塞避免算法后,在收到对所有报文段的确认后(即经过一个往返时间),就把拥塞窗口 cwnd增加一个 MSS 大小,使拥塞窗口缓慢增大,以防止网络过早出现拥塞</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传:"></a>快重传:</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认.这样做可以让发送方及早知道有报文段没有到达接收方,发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段
<img src="http://images.wodekouwei.com/tips-net-tcp-2019311175358.jpg" alt="tips-net-tcp-2019311175358"></p>
<h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复:"></a>快恢复:</h3><p>当发送端收到连续三个重复的确认时,就执行“乘法减小”算法,把慢开始门限 ssthresh 减半.但接下去不执行慢开始算法</p>
<h3 id="发送窗口的上限值"><a href="#发送窗口的上限值" class="headerlink" title="发送窗口的上限值:"></a>发送窗口的上限值:</h3><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个,即应按以下公式确定： 发送窗口的上限值   Min [rwnd, cwnd]</p>
<p>当 rwnd &lt; cwnd 时,是接收方的接收能力限制发送窗口的最大值
当 cwnd &lt; rwnd 时,则是网络的拥塞限制发送窗口的最大值</p>
<h2 id="避免拥塞具体实现"><a href="#避免拥塞具体实现" class="headerlink" title="避免拥塞具体实现"></a>避免拥塞具体实现</h2><h3 id="有滑动窗口了，为什么还要拥塞窗口"><a href="#有滑动窗口了，为什么还要拥塞窗口" class="headerlink" title="有滑动窗口了，为什么还要拥塞窗口"></a>有滑动窗口了，为什么还要拥塞窗口</h3><p>发送方与接收方之间存在多个路由器和速率较慢的链路时，一些中间路由器就必须缓存分组，并可能耗尽缓存，此时便会出现拥塞，这将严重降低了TCP连接的吞吐量，拥塞窗口就是为了防止过多的数据注入到网络中，中间路由无法消化的问题。</p>
<p>TCP的做法是引入拥塞窗口(cwnd)并策略性的调整其大小，如上文提到的发送窗口大小是取滑动窗口大小与拥塞窗口大小的最小值，这个正是用来缓解该问题，下面是拥塞窗口大小变化的策略:</p>
<h4 id="1-慢开始、拥塞控制"><a href="#1-慢开始、拥塞控制" class="headerlink" title="1. 慢开始、拥塞控制"></a>1. 慢开始、拥塞控制</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312133854.png" alt="tips-net-tcp-2019312133854">
其目的是: 拥塞发生时循序减少主机发送到网络的报文数，使得这时路由器有足够的时间消化积压的报文。</p>
<ul>
<li>当主机开发发送数据时，拥塞窗口(cwnd)被初始化为1个报文段，试探性的发送1个字节的报文</li>
<li>每收到一个ACK，拥塞窗口大小就指数的增加报文段数目(1,2,4,16…)</li>
<li>最终到达提前预设的慢开始阀值(ssthresh)，停止使用慢开始算法，改用拥塞避免算法</li>
<li>拥塞避免算法是每经过一个RTT，拥塞窗口就增加一个报文段，即改为线性的增加报文段</li>
<li>最终会出现网络拥塞，比如丢包等情况，停止拥塞避免算法，将慢开始阀值设置为目前拥塞时拥塞窗口大小的一半(但不能小于2)，并重置拥塞窗口大小为1个报文段，开始新的一轮慢开始 </li>
</ul>
<p>慢开始门限 ssthresh 的用法:</p>
<ul>
<li>当 cwnd &lt; ssthresh 时,使用慢开始算法</li>
<li>当 cwnd &gt; ssthresh 时,停止使用慢开始算法而改用拥塞避免算法</li>
<li>当 cwnd = ssthresh 时,既可使用慢开始算法,也可使用拥塞避免算法</li>
</ul>
<h4 id="2-快重传，快恢复"><a href="#2-快重传，快恢复" class="headerlink" title="2. 快重传，快恢复"></a>2. 快重传，快恢复</h4><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134328.png" alt="tips-net-tcp-2019312134328">
其目的是: 减少因为拥塞导致的数据包丢失的重传时间，避免无用的数据到网络</p>
<p>接收方: 如果一个包丢失，后续的包继续发送针对该包的重传请求</p>
<p>发送方: 一旦收到三个一样的确认，判定为拥塞:</p>
<ul>
<li>立即重传该包</li>
<li>开始执行快恢复算法</li>
<li>快恢复是慢开始阀值设置为目前拥塞时拥塞窗口大小的一半；拥塞窗口大小设置为目前设置后的慢开始阀值的大小；执行拥塞避免算法</li>
</ul>
<h2 id="TCP窗口特殊情况"><a href="#TCP窗口特殊情况" class="headerlink" title="TCP窗口特殊情况"></a>TCP窗口特殊情况</h2><h3 id="1-Persistence-timer"><a href="#1-Persistence-timer" class="headerlink" title="1. Persistence timer"></a>1. Persistence timer</h3><p><img src="http://images.wodekouwei.com/tips-net-tcp-2019312134856.png" alt="tips-net-tcp-2019312134856">
防止丢包导致发送端停留在上次收到的接收窗口大小为0的情况:</p>
<ul>
<li>接收端B: 我的缓存已满，接收窗口为0</li>
<li>发送端A: 停止发送数据, 并启动持续计时器(Persistence timer)</li>
<li>接收端B: 消化完缓存，发送报文给发送端A，我的接收窗口大小为400，但是 这个报文丢了</li>
<li>发送端A: 计时器时间到，发送一个1字节的探测报文</li>
<li>接收端B: 重新发送，接收窗口大小为400</li>
<li>发送端A: 继续发送数据<h3 id="2-应用层每次单字节发送"><a href="#2-应用层每次单字节发送" class="headerlink" title="2. 应用层每次单字节发送"></a>2. 应用层每次单字节发送</h3>单个发送字节，然后等待一个确认，再发送一个字节，这样为一个字节添加40个字节头的做法，无疑增加了网络中许多不必要的报文，该问题TCP层的解决方案:</li>
</ul>
<p>发送方采用Nagle算法:</p>
<ul>
<li>若应用层是逐个字节把数据送到TCP，那么TCP不会逐个的发送，而是先发送第一个数据字节，然后缓存剩余的</li>
<li>在收到第一个字节的ACK获知网络情况与对方的接收窗口大小后，把缓存的剩余字节组成合适的报文发送出去</li>
<li>到达的数据达到发送窗口大小的一半或者报文段的最大长度时，立即发送</li>
</ul>
<p>接收方的做法:</p>
<ul>
<li>等待本地有足够的缓存空间容纳一个报文段，或者等到本地的缓存空间有一半空闲的时候，再通知发送端发送数据。</li>
</ul>
<h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p>说明:</p>
<ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名.状态之间的箭头表示可能发生的状态变迁</li>
<li>箭头旁边的字,表明引起这种变迁的原因,或表明发生状态变迁后又出现什么动作</li>
<li>图中有三种不同的箭头<ul>
<li>粗实线箭头表示对客户进程的正常变迁</li>
<li>粗虚线箭头表示对服务器进程的正常变迁</li>
<li>另一种细线箭头表示异常变迁</li>
</ul>
</li>
</ul>
<p><img src="http://images.wodekouwei.com/tips-net-tcp-2019311175949.png" alt="tips-net-tcp-2019311175949"></p>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><h4 id="什么是MTU-Maximum-Transmit-Unit"><a href="#什么是MTU-Maximum-Transmit-Unit" class="headerlink" title="什么是MTU(Maximum Transmit Unit)"></a>什么是MTU(Maximum Transmit Unit)</h4><p>由于以太网传输的限制，每个以太网网数据帧的大小都是落在在区间[64Bytes,1518Bytes]中的，不在区间内的一般会被视为错误的数据帧，以太网转发设备直接丢弃。而根据以太网每帧的数据构成，除去固定的部分，留给上层协议的只有Data域的1500Bytes，我们将它称为MTU。</p>
<p>以太网(Ethernet II)每帧的数据构成: 目的Mac地址(DMAC)+源Mac地址(SMAC)+类型(Type)+数据(Data)+校验(CRC) = 6Bytes(48bit)DMAC + 6Bytes(48bit)SMAC + 2Bytes(16bit)Type + 1500BytesData + 4Bytes(24bit)CRC</p>
<h4 id="MTU造成什么影响"><a href="#MTU造成什么影响" class="headerlink" title="MTU造成什么影响"></a>MTU造成什么影响</h4><p>由于一个帧放不下，如IP协议，就会对数据包进行分片处理，这就导致了原本一次可以搞定的，被分为多次，降低传输性能，不过我们可以通过在数据包包头加上DF(DonotFragment)标签来强制不被分片处理。</p>
<p>UDP协议不用关心数据的到达的有序以及正确，因此对分片无特殊要求
TCP协议相反，因此TCP协议本身的最大报文段大小MSS也受MTU影响，通常MSS是: MTU - 20Bytes(IP Header) - 20Bytes(TCP Header)
不过好在绝大多数的网络链路都是1500Bytes的MTU或者更大</p>
<h3 id="什么是MSS-Maximum-Segment-Size"><a href="#什么是MSS-Maximum-Segment-Size" class="headerlink" title="什么是MSS(Maximum Segment Size)"></a>什么是MSS(Maximum Segment Size)</h3><p>TCP的最大报文段大小，只包含TCP Payload(不包含TCP Header与TCP Option)的TCP每次能够传输的最大数据分段的大小，可以用来限制每次发送的字节数。通常大小为1460Bytes(1500BytesMTU - 20Bytes(IP Header) - 20Bytes(TCP Header))</p>
<p>MSS是在TCP建连时确定的，通讯双方会根据双方提供的MSS值，取最小的MSS作为该次连接数据传输的MSS</p>
<h3 id="什么是WS-Window-Scaling"><a href="#什么是WS-Window-Scaling" class="headerlink" title="什么是WS(Window Scaling)"></a>什么是WS(Window Scaling)</h3><p>TCP首部中表示Window Size的字段只有16位，因此按照协议，能表示的最大窗口大小是2^16-1=65535Bytes(64Kb)，因此TCP的选项字段中包含了窗口扩大因子(WS)分别用option-kind、option-length、option-data来表示，这个参数可带可不带，只有在双方都支持的情况下，才会生效。如双方的WS都是256，而后我们ACK Window size value是5，那么此时就可以表示我们的接收窗口是1280Bytes(5*256=1280)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/zhangdaisylove/article/details/47294315" target="_blank" rel="external">TCP的滑动窗口与拥塞窗口</a>
<a href="http://blog.chinaunix.net/uid-26275986-id-4109679.html" target="_blank" rel="external">计算机网络【七】：可靠传输的实现</a>
<a href="http://blog.csdn.net/cloud323/article/details/77481711" target="_blank" rel="external">TCP窗口控制、流控制、拥塞控制</a>
<a href="http://blog.csdn.net/hldjf/article/details/7450565" target="_blank" rel="external">也谈一下TCP segment of a reassembled PDU</a>
<a href="https://www.zhihu.com/question/48454744" target="_blank" rel="external">TCP流量控制中的滑动窗口大小</a>
<a href="https://my.oschina.net/xinxingegeya/blog/485650" target="_blank" rel="external">TCP 滑动窗口（发送窗口和接收窗口）</a>
<a href="https://www.zhihu.com/question/32255109" target="_blank" rel="external">TCP协议的滑动窗口具体是怎样控制流量的？</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/11/tips-net-nat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/11/tips-net-nat/" itemprop="url">
                  tips-net-nat
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T11:05:57+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-NAT"><a href="#1-NAT" class="headerlink" title="1.NAT"></a>1.NAT</h2><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。
这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>
<p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p>
<h3 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h3><p>是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。</p>
<h3 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h3><p>是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p>
<h3 id="端口多路复用（Port-address-Translation-PAT"><a href="#端口多路复用（Port-address-Translation-PAT" class="headerlink" title="端口多路复用（Port address Translation,PAT)"></a>端口多路复用（Port address Translation,PAT)</h3><p>是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。
ALG（Application Level Gateway），即应用程序级网关技术：传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。例如：对于FTP协议的PORT/PASV命令、DNS协议的 “A” 和 “PTR” queries命令和部分ICMP消息类型等都需要相应的ALG来支持。
如果协议数据报文中不包含地址信息，则很容易利用传统的NAT技术来完成透明的地址转换功能，通常我们使用的如下应用就可以直接利用传统的NAT技术：HTTP、TELNET、FINGER、NTP、NFS、ARCHIE、RLOGIN、RSH、RCP等。</p>
<h2 id="2-TCP长连接"><a href="#2-TCP长连接" class="headerlink" title="2.TCP长连接"></a>2.TCP长连接</h2><p>TCP连接建立后只要不明确关闭，逻辑上连接一直存在。
TCP是有保活定时器的，可以打开保活定时器来维持长连接，设置SO_KEEPALIVE才会开启，时间间隔默认7200s，也就是2h，这个默认是关闭的。</p>
<p>注意：HTTP的keepalive和TCP的用处不大一样tcp。</p>
<h2 id="3-NAT超时"><a href="#3-NAT超时" class="headerlink" title="3.NAT超时"></a>3.NAT超时</h2><p>因为 IP v4 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换(Network Address Translation，NAT)。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯。
大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。
长连接心跳间隔必须要小于NAT超时时间(aging-time)，如果超过aging-time不做心跳，TCP长连接链路就会中断，Server就无法发送Push给手机，只能等到客户端下次心跳失败后，重建连接才能取到消息。</p>
<p>因为IPv4地址不足, 或者我们想通过无线路由器上网, 我们的设备可能会处在一个NAT设备的后面, 生活中最常见的NAT设备是家用路由器.
NAT设备会在IP封包通过设备时修改源/目的IP地址. 对于家用路由器来说, 使用的是网络地址端口转换(NAPT), 它不仅改IP, 还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP. 举个例子, NAPT维护一个类似下表的NAT表
|内网地址|    外网地址|
|—|—|
|192.168.0.2:5566|    120.132.92.21:9200|
|192.168.0.3:7788|    120.132.92.21:9201|
|192.168.0.3:8888|    120.132.92.21:9202|</p>
<p>NAT设备会根据NAT表对出去和进来的数据做修改, 比如将192.168.0.3:8888发出去的封包改成120.132.92.21:9202, 外部就认为他们是在和120.132.92.21:9202通信. 同时NAT设备会将120.132.92.21:9202收到的封包的IP和端口改成192.168.0.3:8888, 再发给内网的主机, 这样内部和外部就能双向通信了, 但如果其中192.168.0.3:8888 == 120.132.92.21:9202这一映射因为某些原因被NAT设备淘汰了, 那么外部设备就无法直接与192.168.0.3:8888通信了.</p>
<p>国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断.</p>
<h2 id="4-心跳包"><a href="#4-心跳包" class="headerlink" title="4.心跳包"></a>4.心跳包</h2><ul>
<li>心跳的原因：虽然理论tcp连接后一直不断，但实际上会断网。见：比如 NAT超时，更多 影响TCP连接寿命的因素</li>
<li>心跳包的主要作用是告知对方连接端，我还活着，心还在跳。</li>
<li>心跳时长多少？
　　
现实是残酷的, 根据网上的一些说法, 中移动2/3G下, NAT超时时间为5分钟, 中国电信3G则大于28分钟, 理想的情况下, 客户端应当以略小于NAT超时时间的间隔来发送心跳包.
|地区/网络|NAT超时时间|
|—|—|
|中国移动3G和2G|5分钟|
|中国联通2G|5分钟|
|中国电信3G|大于28分钟|
|美国3G|大于28分钟|
|台湾3G|大于28分钟|</li>
</ul>
<p>wifi下, NAT超时时间都会比较长, 据说宽带的网关一般没有空闲释放机制, GCM有些时候在wifi下的心跳比在移动网络下的心跳要快, 可能是因为wifi下联网通信耗费的电量比移动网络下小</p>
<h2 id="5-心跳包和轮询的区别"><a href="#5-心跳包和轮询的区别" class="headerlink" title="5.心跳包和轮询的区别"></a>5.心跳包和轮询的区别</h2><p>心跳包和轮询看起来类似, 都是客户端主动联系服务器, 但是区别很大.</p>
<ul>
<li>轮询是为了获取数据, 而心跳是为了保活TCP连接.</li>
<li>轮询得越频繁, 获取数据就越及时, 心跳的频繁与否和数据是否及时没有直接关系</li>
<li>轮询比心跳能耗更高, 因为一次轮询需要经过TCP三次握手, 四次挥手, 单次心跳不需要建立和拆除TCP连接.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/08/tips-android-net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/08/tips-android-net/" itemprop="url">
                  Android架构之网络优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T17:13:46+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常规的网络框架设计和常用的网络优化方案。</p>
<ol>
<li>网络框架OkHttp</li>
</ol>
<ul>
<li>简洁易用的接口</li>
<li>拦截器机制，网络重试与跳转</li>
<li>连接池复用</li>
</ul>
<ol>
<li>网络加速</li>
</ol>
<ul>
<li>HttpDNS与IP直连</li>
<li>连接加速：短连接复用、Http2多路复用、长连接</li>
</ul>
<ol>
<li>数据压缩与序列化</li>
</ol>
<ul>
<li>Json vs ProtoBuf</li>
<li>压缩算法</li>
<li>序列化</li>
</ul>
<ol>
<li>长连接技术与Mars架构</li>
</ol>
<ul>
<li>智能心跳机制</li>
<li>自动重连</li>
<li>Android跨进程实现</li>
<li>智能唤醒</li>
</ul>
<ol>
<li>如何应对复杂网络</li>
</ol>
<ul>
<li>弱网</li>
<li>网络超时、振荡</li>
<li>404与DNS劫持</li>
</ul>
<ol>
<li>如何保证网络数据安全</li>
</ol>
<ul>
<li>TLS协议，握手与证书</li>
<li>数据签名及校验</li>
</ul>
<p><a href="https://github.com/dhhAndroid/RxWebSocket" target="_blank" rel="external">https://github.com/dhhAndroid/RxWebSocket</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/07/tips-android-sharedpreferences/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/07/tips-android-sharedpreferences/" itemprop="url">
                  Android SharedPreference详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T12:17:40+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SharedPreferences作为一种数据持久化的方式，是处理简单的key-value类型数据时的首选。</p>
<h3 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法:"></a>一般用法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//demo是该sharedpreference对应文件名,对应的是一个xml文件,里面存放key-value格式的数据.</div><div class="line">SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;demo&quot;, MODE_WORLD_WRITEABLE);</div><div class="line">//提供了getXXX的读取数据方法</div><div class="line">boolean xxx = sharedPreferences.getBoolean(&quot;xxx&quot;, false);</div><div class="line">//通过Editor提供了putXXX系列的存储方法,调用完需要使用apply()或commit()使之生效,不同点后面介绍</div><div class="line">SharedPreferences.Editor edit = sharedPreferences.edit();</div><div class="line">edit.putBoolean(&quot;xxx&quot;, true);</div><div class="line">edit.apply();//使存储生效</div><div class="line">//edit.commit();//使存储生效</div></pre></td></tr></table></figure>
<p>每个SharedPreferences都对应了当前package的<code>data/data/package_name/share_prefs/</code>目录下的一个文件</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>Context.java中getSharedPreferences接口说明:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Retrieve and hold the contents of the preferences file &apos;name&apos;, returning</div><div class="line">     * a SharedPreferences through which you can retrieve and modify its</div><div class="line">     * values.  Only one instance of the SharedPreferences object is returned</div><div class="line">     * to any callers for the same name, meaning they will see each other&apos;s</div><div class="line">     * edits as soon as they are made.</div><div class="line">     *</div><div class="line">     * @param name Desired preferences file. If a preferences file by this name</div><div class="line">     * does not exist, it will be created when you retrieve an</div><div class="line">     * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).</div><div class="line">     * @param mode Operating mode.  Use 0 or &#123;@link #MODE_PRIVATE&#125; for the</div><div class="line">     * default operation, &#123;@link #MODE_WORLD_READABLE&#125;</div><div class="line">     * and &#123;@link #MODE_WORLD_WRITEABLE&#125; to control permissions.</div><div class="line">     *</div><div class="line">     * @return The single &#123;@link SharedPreferences&#125; instance that can be used</div><div class="line">     *         to retrieve and modify the preference values.</div><div class="line">     *</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">    public abstract SharedPreferences getSharedPreferences(String name,</div><div class="line">            int mode);</div></pre></td></tr></table></figure></p>
<p>ContextImpl中getSharedPreferences实现:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public SharedPreferences getSharedPreferences(String name, int mode) &#123;</div><div class="line">        SharedPreferencesImpl sp;</div><div class="line">        synchronized (ContextImpl.class) &#123;</div><div class="line">            if (sSharedPrefs == null) &#123;</div><div class="line">                sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String packageName = getPackageName();</div><div class="line">            ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</div><div class="line">            if (packagePrefs == null) &#123;</div><div class="line">                packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</div><div class="line">                sSharedPrefs.put(packageName, packagePrefs);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // At least one application in the world actually passes in a null</div><div class="line">            // name.  This happened to work because when we generated the file name</div><div class="line">            // we would stringify it to &quot;null.xml&quot;.  Nice.</div><div class="line">            if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">                    Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">                if (name == null) &#123;</div><div class="line">                    name = &quot;null&quot;;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sp = packagePrefs.get(name);</div><div class="line">            if (sp == null) &#123;</div><div class="line">                File prefsFile = getSharedPrefsFile(name);</div><div class="line">                sp = new SharedPreferencesImpl(prefsFile, mode);</div><div class="line">                packagePrefs.put(name, sp);</div><div class="line">                return sp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">            // If somebody else (some other process) changed the prefs</div><div class="line">            // file behind our back, we reload it.  This has been the</div><div class="line">            // historical (if undocumented) behavior.</div><div class="line">            sp.startReloadIfChangedUnexpectedly();</div><div class="line">        &#125;</div><div class="line">        return sp;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码里，我们可以看出，</p>
<ol>
<li>SharedPreferencesImpl是保存在全局个map cache里的，只会创建一次。</li>
<li>MODE_MULTI_PROCESS模式下，每次获取都会尝试去读取文件reload。当然会有一些逻辑尽量减少读取次数，比如当前是否有正在进行的读取操作，文件的修改时间和大小与上次有没有变化等。</li>
</ol>
<p>Context.java中提供了以下四种mode:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">//这是默认模式，仅caller uid的进程可访问</div><div class="line">/**</div><div class="line">     * File creation mode: the default mode, where the created file can only</div><div class="line">     * be accessed by the calling application (or all applications sharing the</div><div class="line">     * same user ID).</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">int MODE_PRIVATE = 0x0000;</div><div class="line"></div><div class="line">//所有人可写，也就是任何应用都可修改它，这是极其危险的，因此改选项已被Deprected</div><div class="line">/**</div><div class="line">     * @deprecated Creating world-readable files is very dangerous, and likely</div><div class="line">     * to cause security holes in applications.  It is strongly discouraged;</div><div class="line">     * instead, applications should use more formal mechanism for interactions</div><div class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</div><div class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</div><div class="line">     * access mode will remain on a file, such as when it goes through a</div><div class="line">     * backup and restore.</div><div class="line">     * File creation mode: allow all other applications to have read access</div><div class="line">     * to the created file.</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">int MODE_WORLD_READABLE = 0x0001; </div><div class="line"></div><div class="line">//所有人可读，这个参数同样非常危险，可能导致隐私数据泄漏</div><div class="line">/**</div><div class="line">     * @deprecated Creating world-writable files is very dangerous, and likely</div><div class="line">     * to cause security holes in applications.  It is strongly discouraged;</div><div class="line">     * instead, applications should use more formal mechanism for interactions</div><div class="line">     * such as &#123;@link ContentProvider&#125;, &#123;@link BroadcastReceiver&#125;, and</div><div class="line">     * &#123;@link android.app.Service&#125;.  There are no guarantees that this</div><div class="line">     * access mode will remain on a file, such as when it goes through a</div><div class="line">     * backup and restore.</div><div class="line">     * File creation mode: allow all other applications to have write access</div><div class="line">     * to the created file.</div><div class="line">     * @see #MODE_PRIVATE</div><div class="line">     * @see #MODE_WORLD_READABLE</div><div class="line">     */</div><div class="line">int MODE_WORLD_READABLE = 0x0002</div><div class="line"></div><div class="line">//设置该参数后，每次获取对应的SharedPreferences时都会尝试从磁盘中读取修改过的文件 </div><div class="line">/**</div><div class="line">     * SharedPreference loading flag: when set, the file on disk will</div><div class="line">     * be checked for modification even if the shared preferences</div><div class="line">     * instance is already loaded in this process.  This behavior is</div><div class="line">     * sometimes desired in cases where the application has multiple</div><div class="line">     * processes, all writing to the same SharedPreferences file.</div><div class="line">     * Generally there are better forms of communication between</div><div class="line">     * processes, though.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;This was the legacy (but undocumented) behavior in and</div><div class="line">     * before Gingerbread (Android 2.3) and this flag is implied when</div><div class="line">     * targetting such releases.  For applications targetting SDK</div><div class="line">     * versions &lt;em&gt;greater than&lt;/em&gt; Android 2.3, this flag must be</div><div class="line">     * explicitly set if desired.</div><div class="line">     *</div><div class="line">     * @see #getSharedPreferences</div><div class="line">     *</div><div class="line">     * @deprecated MODE_MULTI_PROCESS does not work reliably in</div><div class="line">     * some versions of Android, and furthermore does not provide any</div><div class="line">     * mechanism for reconciling concurrent modifications across</div><div class="line">     * processes.  Applications should not attempt to use it.  Instead,</div><div class="line">     * they should use an explicit cross-process data management</div><div class="line">     * approach such as &#123;@link android.content.ContentProvider ContentProvider&#125;.</div><div class="line">     */</div><div class="line">int MODE_MULTI_PROCESS = 0x0004;</div></pre></td></tr></table></figure></p>
<h4 id="MODE-MULTI-PROCESS"><a href="#MODE-MULTI-PROCESS" class="headerlink" title="MODE_MULTI_PROCESS"></a>MODE_MULTI_PROCESS</h4><p>当设置MODE_MULTI_PROCESS这个参数的时候，即使当前进程内已经创建了该SharedPreferences，仍然在每次获取的时候都会尝试从本地文件中刷新。在同一个进程中，同一个文件只有一个实例。MODE_MULTI_PROCESS的作用如上getSharedPreferences实现.这个方法先判断是否已创建SharedPreferences实例，若未创建，则先创建。之后判断mode如果为MODE_MULTI_PROCESS, 则调用startReloadIfChangeUnexpectedly()，看下其实现:
SharedPreferencesImpl.java
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void startReloadIfChangedUnexpectedly() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            // TODO: wait for any pending writes to disk?</div><div class="line">            if (!hasFileChangedUnexpectedly()) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            startLoadFromDisk();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mLoaded = false;</div><div class="line">        &#125;</div><div class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    loadFromDiskLocked();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出MODE_MULTI_PROCESS的作用就是在每次获取SharedPreferences实例的时候尝试从磁盘中加载修改过的数据，并且读取是在异步线程中，因此一个线程的修改最终会反映到另一个线程，但不能立即反映到另一个进程，所以通过SharedPreferences无法实现多进程同步。
综合: 如果仅仅让多进程可访问同一个SharedPref文件，不需要设置MODE_MULTI_PROCESS, 如果需要实现多进程同步，必须设置这个参数，但也只能实现最终一致，无法即时同步。</p>
<p><strong>由于SharedPreference内容都会在内存里存一份，所以不要使用SharedPreference保存较大的内容，避免不必要的内存浪费。</strong></p>
<p>注意有一个锁mLoaded ,在对SharedPreference做其他操作时，都必须等待该锁释放:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Nullable</div><div class="line">    public String getString(String key, @Nullable String defValue) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            awaitLoadedLocked();</div><div class="line">            String v = (String)mMap.get(key);</div><div class="line">            return v != null ? v : defValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>写操作有两个commit apply 。 commit 是同步的，写入内存的同时会等待写入文件完成，apply是异步的，先写入内存，在异步线程里再写入文件。apply肯定要快一些,优先推荐使用apply:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">         * Commit your preferences changes back from this Editor to the</div><div class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line">         * performs the requested modifications, replacing whatever is currently</div><div class="line">         * in the SharedPreferences.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line">         * time, the last one to call commit wins.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;If you don&apos;t care about the return value and you&apos;re</div><div class="line">         * using this from your application&apos;s main thread, consider</div><div class="line">         * using &#123;@link #apply&#125; instead.</div><div class="line">         *</div><div class="line">         * @return Returns true if the new values were successfully written</div><div class="line">         * to persistent storage.</div><div class="line">         */</div><div class="line">        boolean commit();</div><div class="line">        /**</div><div class="line">         * Commit your preferences changes back from this Editor to the</div><div class="line">         * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line">         * performs the requested modifications, replacing whatever is currently</div><div class="line">         * in the SharedPreferences.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line">         * time, the last one to call apply wins.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out</div><div class="line">         * to persistent storage synchronously, &#123;@link #apply&#125;</div><div class="line">         * commits its changes to the in-memory</div><div class="line">         * &#123;@link SharedPreferences&#125; immediately but starts an</div><div class="line">         * asynchronous commit to disk and you won&apos;t be notified of</div><div class="line">         * any failures.  If another editor on this</div><div class="line">         * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125;</div><div class="line">         * while a &#123;@link #apply&#125; is still outstanding, the</div><div class="line">         * &#123;@link #commit&#125; will block until all async commits are</div><div class="line">         * completed as well as the commit itself.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within</div><div class="line">         * a process, it&apos;s safe to replace any instance of &#123;@link #commit&#125; with</div><div class="line">         * &#123;@link #apply&#125; if you were already ignoring the return value.</div><div class="line">         *</div><div class="line">         * &lt;p&gt;You don&apos;t need to worry about Android component</div><div class="line">         * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt;</div><div class="line">         * writing to disk.  The framework makes sure in-flight disk</div><div class="line">         * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching</div><div class="line">         * states.</div><div class="line">         *</div><div class="line">         * &lt;p class=&apos;note&apos;&gt;The SharedPreferences.Editor interface</div><div class="line">         * isn&apos;t expected to be implemented directly.  However, if you</div><div class="line">         * previously did implement it and are now getting errors</div><div class="line">         * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call</div><div class="line">         * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;.</div><div class="line">         */</div><div class="line">        void apply();</div></pre></td></tr></table></figure></p>
<p>注册/解注册sharedpreference变动监听:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Registers a callback to be invoked when a change happens to a preference.</div><div class="line">     *</div><div class="line">     * &lt;p class=&quot;caution&quot;&gt;&lt;strong&gt;Caution:&lt;/strong&gt; The preference manager does</div><div class="line">     * not currently store a strong reference to the listener. You must store a</div><div class="line">     * strong reference to the listener, or it will be susceptible to garbage</div><div class="line">     * collection. We recommend you keep a reference to the listener in the</div><div class="line">     * instance data of an object that will exist as long as you need the</div><div class="line">     * listener.&lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param listener The callback that will run.</div><div class="line">     * @see #unregisterOnSharedPreferenceChangeListener</div><div class="line">     */</div><div class="line">    void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Unregisters a previous callback.</div><div class="line">     * </div><div class="line">     * @param listener The callback that should be unregistered.</div><div class="line">     * @see #registerOnSharedPreferenceChangeListener</div><div class="line">     */</div><div class="line">    void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener);</div></pre></td></tr></table></figure></p>
<h4 id="为什么不推荐使用MODE-MULTI-PROCESS"><a href="#为什么不推荐使用MODE-MULTI-PROCESS" class="headerlink" title="为什么不推荐使用MODE_MULTI_PROCESS?"></a>为什么不推荐使用MODE_MULTI_PROCESS?</h4><p>android文档已经Deprected了这个flag，并且说明不应该通过SharedPreference做进程间数据共享？这是为啥呢？从前面但分析可看到当设置这个flag后，每次获取(获取而不是初次创建)SharedPreferences实例的时候，会判断shared_pref文件是否修改过:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private boolean hasFileChangedUnexpectedly() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mDiskWritesInFlight &gt; 0) &#123;</div><div class="line">                // If we know we caused it, it&apos;s not unexpected.</div><div class="line">                if (DEBUG) Log.d(TAG, &quot;disk write in flight, not unexpected.&quot;);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final StructStat stat;</div><div class="line">        try &#123;</div><div class="line">            /*</div><div class="line">             * Metadata operations don&apos;t usually count as a block guard</div><div class="line">             * violation, but we explicitly want this one.</div><div class="line">             */</div><div class="line">            BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">            stat = Os.stat(mFile.getPath());</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里先判断mDiskWritesInFlight&gt;0，如果成立，说明是当前进程修改了文件，不需要重新读取。然后通过文件最后修改时间，判断文件是否修改过。如果修改了，则重新读取:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mLoaded = false;</div><div class="line">        &#125;</div><div class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    loadFromDiskLocked();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void loadFromDiskLocked() &#123;</div><div class="line">        if (mLoaded) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (mBackupFile.exists()) &#123;</div><div class="line">            mFile.delete();</div><div class="line">            mBackupFile.renameTo(mFile);</div><div class="line">        &#125;</div><div class="line">        Map map = null;</div><div class="line">        StructStat stat = null;</div><div class="line">        try &#123;</div><div class="line">            stat = Os.stat(mFile.getPath());</div><div class="line">            if (mFile.canRead()) &#123;</div><div class="line">                BufferedInputStream str = null;</div><div class="line">                try &#123;</div><div class="line">                    str = new BufferedInputStream(</div><div class="line">                            new FileInputStream(mFile), 16*1024);</div><div class="line">                    map = XmlUtils.readMapXml(str);</div><div class="line">                &#125; finally &#123;</div><div class="line">                    IoUtils.closeQuietly(str);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">        &#125;</div><div class="line">        mLoaded = true;</div><div class="line">        if (map != null) &#123;</div><div class="line">            mMap = map;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125; else &#123;</div><div class="line">            mMap = new HashMap&lt;String, Object&gt;();</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里起码有3个坑！</p>
<ol>
<li>使用MODE_MULTI_PROCESS时，不要保存SharedPreference变量，必须每次都从context.getSharedPreferences 获取。如果你图方便使用变量存了下来，那么无法触发reload，有可能两个进程数据不同步。</li>
<li>前面提到过，load数据是耗时的，并且其他操作会等待该锁。这意味着很多时候获取SharedPreference数据都不得不从文件再读一遍，大大降低了内存缓存的作用。文件读写耗时也影响了性能。</li>
<li>修改数据时得用commit，保证修改时写入了文件，这样其他进程才能通过文件大小或修改时间感知到。</li>
</ol>
<p>重点是这段:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mBackupFile.exists()) &#123;</div><div class="line">      mFile.delete();</div><div class="line">      mBackupFile.renameTo(mFile);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新读取时，如果发现存在mBackupFile,则将原文件mFile删除，并将mBackupFile重命名为mFile。mBackupFile又是如何创建的呢？答案是在修改SharedPreferences时将内存中的数据写会磁盘时创建的:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">        // Rename the current file so it may be used as a backup during the next read</div><div class="line">        if (mFile.exists()) &#123;</div><div class="line">            if (!mBackupFile.exists()) &#123;</div><div class="line">                if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                    mcr.setDiskWriteResult(false);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                mFile.delete();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        final StructStat stat = Os.stat(mFile.getPath());</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        mcr.setDiskWriteResult(true);</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码只保留了核心流程，忽略了错误处理流程。可以看到，写文件的步骤大致是:</p>
<ol>
<li>将原文件重命名为mBackupFile</li>
<li>重新创建原文件mFile, 并将内容写入其中</li>
<li>删除mBackupFile</li>
</ol>
<p>所以，只有当一个进程正处于写文件的过程中的时候，如果另一个进程读文件，才会看到mBackupFile, 这时候读进程会将mBackupFile重命名为mFile, 这样读结果是，读进程只能读到修改前的文件，同时，由于mBackupFile重命名为了mFile,  所以写进程写那个文件就没有文件名引用了，因此其写入的内容无法再被任何进程访问到。所以其内容丢失了，可认为写入失败了，而SharedPreferences对这种失败情况没有任何重试机制，所以就可能出现数据丢失的情况。
回到这段的重点：为什么不推荐用MODE_MULTI_PROCESS？从前面分析可知，这种模式下，每次获取SharedPreferences都会检测文件是否改变，只要读的时候另一进程在写，就会导致写丢失。这样失败概率就会大幅度提高。反之，若不设置这个模式，则只在第一次创建SharedPreferences的时候读取，导致写失败的概率就会大幅度降低，当然，仍然存在失败的可能。</p>
<h4 id="为什么不做写失败重试？"><a href="#为什么不做写失败重试？" class="headerlink" title="为什么不做写失败重试？"></a>为什么不做写失败重试？</h4><p>为什么android不做写失败重试呢？原因是写进程并不能发现写失败的情况。难道写的过程中，目标文件被删不会抛异常吗？答案是不会。删除文件只是从文件系统中删除了一个节点信息而已，重命名也是新建了一个具有相同名称的节点信息，并把文件地址指向另一个磁盘地址而已，原来，之前的写过程仍然会成功写到原来的磁盘地址。所以目前的实现方案并不能检测到失败。</p>
<h4 id="有没有办法解决写失败呢？"><a href="#有没有办法解决写失败呢？" class="headerlink" title="有没有办法解决写失败呢？"></a>有没有办法解决写失败呢？</h4><p>个人觉得是可以做到的，读里面读那段关键操作:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mBackupFile.exists()) &#123;</div><div class="line">      mFile.delete();</div><div class="line">      mBackupFile.renameTo(mFile);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mBackupFile存在，意味着当前正处于写读过程中，这时候是不是可以考虑直接读mBackupFile文件，而不删除mFile呢？这样读话，读取效果一样，都是读的mBackupFile，同时写进程写的mFile也不会被mBacupFile覆盖，写也就能成功了。即使通过这段代码重命名，写进程写完后发现mBackupFile不存在了，其实也能认为发生了读重命名，大可以重试一次。</p>
<h3 id="多进程使用SharedPreference方案"><a href="#多进程使用SharedPreference方案" class="headerlink" title="多进程使用SharedPreference方案"></a>多进程使用SharedPreference方案</h3><p>说简单也简单，就是依据google的建议使用ContentProvider了。我看过网上很多的例子，但总是觉得少了点什么</p>
<p>有的方案里将所有读取操作都写作静态方法，没有继承SharedPreference 。 这样做需要强制改变调用者的使用习惯，不怎么好。
大部分方案做成ContentProvider后，所有的调用都走的ContentProvider。但如果调用进程与SharedPreference 本身就是同一个进程，只用走原生的流程就行了，不用拐个弯去访问ContentProvider，减少不必要的性能损耗。</p>
<p>我这里也写了一个跨进程方案，简单介绍如下
SharedPreferenceProxy 继承SharedPreferences。其所有操作都是通过ContentProvider完成。简要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class SharedPreferenceProxy implements SharedPreferences &#123;</div><div class="line">@Nullable</div><div class="line">    @Override</div><div class="line">    public String getString(String key, @Nullable String defValue) &#123;</div><div class="line">        OpEntry result = getResult(OpEntry.obtainGetOperation(key).setStringValue(defValue));</div><div class="line">        return result == null ? defValue : result.getStringValue(defValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Editor edit() &#123;</div><div class="line">        return new EditorImpl();</div><div class="line">    &#125;</div><div class="line">    private OpEntry getResult(@NonNull OpEntry input) &#123;</div><div class="line">        try &#123;</div><div class="line">            Bundle res = ctx.getContentResolver().call(PreferenceUtil.URI</div><div class="line">                    , PreferenceUtil.METHOD_QUERY_VALUE</div><div class="line">                    , preferName</div><div class="line">                    , input.getBundle());</div><div class="line">            return new OpEntry(res);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">...</div><div class="line"></div><div class="line">    public class EditorImpl implements Editor &#123;</div><div class="line">        private ArrayList&lt;OpEntry&gt; mModified = new ArrayList&lt;&gt;();</div><div class="line">        @Override</div><div class="line">        public Editor putString(String key, @Nullable String value) &#123;</div><div class="line">            OpEntry entry = OpEntry.obtainPutOperation(key).setStringValue(value);</div><div class="line">            return addOps(entry);</div><div class="line">        &#125;</div><div class="line">       @Override</div><div class="line">        public void apply() &#123;</div><div class="line">            Bundle intput = new Bundle();</div><div class="line">            intput.putParcelableArrayList(PreferenceUtil.KEY_VALUES, convertBundleList());</div><div class="line">            intput.putInt(OpEntry.KEY_OP_TYPE, OpEntry.OP_TYPE_APPLY);</div><div class="line">            try &#123;</div><div class="line">                ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_EIDIT_VALUE, preferName, intput);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">...</div><div class="line">        &#125;</div><div class="line">...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>OpEntry只是一个对Bundle操作封装的类。
所有跨进程的操作都是通过SharedPreferenceProvider的call方法完成。SharedPreferenceProvider里会访问真正的SharedPreference
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SharedPreferenceProvider extends ContentProvider&#123;</div><div class="line"></div><div class="line">    private Map&lt;String, MethodProcess&gt; processerMap = new ArrayMap&lt;&gt;();</div><div class="line">    @Override</div><div class="line">    public boolean onCreate() &#123;</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_VALUE, methodQueryValues);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_CONTAIN_KEY, methodContainKey);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_EIDIT_VALUE, methodEditor);</div><div class="line">        processerMap.put(PreferenceUtil.METHOD_QUERY_PID, methodQueryPid);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;</div><div class="line">        MethodProcess processer = processerMap.get(method);</div><div class="line">        return processer == null?null:processer.process(arg, extras);</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重要差别的地方在这里：在调用getSharedPreferences时，会先判断caller的进程pid是否与SharedPreferenceProvider相同。如果不同，则返回SharedPreferenceProxy。如果相同，则返回ctx.getSharedPreferences。只会在第一次调用时进行判断，结果会保存起来。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public static SharedPreferences getSharedPreferences(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        //First check if the same process</div><div class="line">        if (processFlag.get() == 0) &#123;</div><div class="line">            Bundle bundle = ctx.getContentResolver().call(PreferenceUtil.URI, PreferenceUtil.METHOD_QUERY_PID, &quot;&quot;, null);</div><div class="line">            int pid = 0;</div><div class="line">            if (bundle != null) &#123;</div><div class="line">                pid = bundle.getInt(PreferenceUtil.KEY_VALUES);</div><div class="line">            &#125;</div><div class="line">            //Can not get the pid, something wrong!</div><div class="line">            if (pid == 0) &#123;</div><div class="line">                return getFromLocalProcess(ctx, preferName);</div><div class="line">            &#125;</div><div class="line">            processFlag.set(Process.myPid() == pid ? 1 : -1);</div><div class="line">            return getSharedPreferences(ctx, preferName);</div><div class="line">        &#125; else if (processFlag.get() &gt; 0) &#123;</div><div class="line">            return getFromLocalProcess(ctx, preferName);</div><div class="line">        &#125; else &#123;</div><div class="line">            return getFromRemoteProcess(ctx, preferName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private static SharedPreferences getFromRemoteProcess(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        synchronized (SharedPreferenceProxy.class) &#123;</div><div class="line">            if (sharedPreferenceProxyMap == null) &#123;</div><div class="line">                sharedPreferenceProxyMap = new ArrayMap&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            SharedPreferenceProxy preferenceProxy = sharedPreferenceProxyMap.get(preferName);</div><div class="line">            if (preferenceProxy == null) &#123;</div><div class="line">                preferenceProxy = new SharedPreferenceProxy(ctx.getApplicationContext(), preferName);</div><div class="line">                sharedPreferenceProxyMap.put(preferName, preferenceProxy);</div><div class="line">            &#125;</div><div class="line">            return preferenceProxy;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static SharedPreferences getFromLocalProcess(@NonNull Context ctx, String preferName) &#123;</div><div class="line">        return ctx.getSharedPreferences(preferName, Context.MODE_PRIVATE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样，只有当调用者是正真跨进程时才走的contentProvider。对于同进程的情况，就没有必要走contentProvider了。对调用者来说，这都是透明的，只需要获取SharedPreferences就行了，不用关心获得的是SharedPreferenceProxy，还是SharedPreferenceImpl。即使你当前没有涉及到多进程使用，将所有获取SharedPreference的地方封装并替换后，对当前逻辑也没有任何影响。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/07/flutter-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/07/flutter-introduce/" itemprop="url">
                  Flutter介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T10:19:24+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Flutter是一款由Google开发的开源、跨平台的移动端开发框架，使用Flutter开发出的应用符合不同平台的原生体验，可以让应用看起来跟系统更加协调。
Flutter是一个全新的移动UI框架，它允许使用同一个代码库构建高性能的Android和iOS应用，同时它也是Google即将推出的Fuchsia操作系统的开发平台。通过自定义的Flutter引擎可以将其嵌入到其他平台，旨在帮助开发者使用一套代码开发高性能、高保真的Android和iOS应用。</p>
<h3 id="Flutter优点"><a href="#Flutter优点" class="headerlink" title="Flutter优点"></a>Flutter优点</h3><h4 id="原生性能"><a href="#原生性能" class="headerlink" title="原生性能"></a>原生性能</h4><p>Flutter会以原生的性能提供给开发者，它的开发性能非常接近传统的Native，包括渲染方式、AOT的编译方式和其他优化。</p>
<p>Flutter开发的页面跟Native没有差距。在安卓中低端机型里，基于Flutter开发出来的APP在帧率上会有更流畅的体现，内存占用也会有更低的消耗。</p>
<p><strong>渲染方式,AOT,无锁GC</strong></p>
<h4 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h4><p>Flutter因其本身的跨端性，大幅提升了传统的安卓开发速度。一般认为，前端开发的速度较快，基于Flutter，开发速度比前端更快。
<strong>压秒级,有状态的热重载</strong></p>
<h4 id="统一的应用开发体验"><a href="#统一的应用开发体验" class="headerlink" title="统一的应用开发体验"></a>统一的应用开发体验</h4><p>在跨端层面上，由于Flutter把两端的渲染机制下沉到更低的渲染层，基于统一的C++层的渲染引擎来搭建底层的UI框架，因此，Flutter会让跨端体验得到更一致的效果。
<strong>两端一致的开发方式,MD和IOS风格</strong></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>内存的问题。随着Flutter页面的堆栈变得越来越深，内存的释放并没有得到及时的释放。</li>
<li>字体的问题。不同的字体在不同的机器里渲染的效果非常不一致。</li>
<li>截图会出现黑屏的问题。</li>
<li>图片缓存的问题。跟安卓端的图片缓存是完全不同的体系。</li>
<li>它的暗黑区、适配问题，</li>
<li>私有库、中间件的适配，</li>
<li>不支持反射和序列化，</li>
<li>集成问题,怎么把Native的组件集成到Flutter体系</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2019/03/05/tips-android-targetsdkversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/05/tips-android-targetsdkversion/" itemprop="url">
                  应用targetSdkVersion升级指导
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T16:00:20+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应电信终端产业协会（TAF）发布的《移动应用软件高 API 等级预置与分发自律公约》（以下简称《公约》）要求：截止到2019年5月1日所有新发布的应用 API 必须为26或更高，2019年8月1日现有应用 API 必须升级为26或更高。《公约》发布至今得到了国内主流互联网及终端制造企业的积极响应。</p>
<ul>
<li>对应用开发者来说，不按时更新Target SDK版本的应用，应用市场将采取强制下架的策略，已上架应用将无法更新。</li>
<li>对用户来说，未适配Android M或更高版本的应用安装在Android M或更高版本时，会默认授予申请的所有权限，且应用运行时无弹框授权提示。其中包括通讯录、电话、短信、通讯记录、位置、麦克风、相机等危险权限，导致用户在不知情的情况下泄露隐私信息，对用户个人信息安全造成危害。</li>
</ul>
<p><strong>应用targetSdkVersion升级流程</strong>
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935161819.jpg" alt="tips-android-targetsdkversion-201935161819"></p>
<h2 id="targetSdkVersion-相关变更介绍"><a href="#targetSdkVersion-相关变更介绍" class="headerlink" title="targetSdkVersion 相关变更介绍"></a>targetSdkVersion 相关变更介绍</h2><h3 id="Android5-x（22-19）及以下版本变更"><a href="#Android5-x（22-19）及以下版本变更" class="headerlink" title="Android5.x（22-19）及以下版本变更"></a>Android5.x（22-19）及以下版本变更</h3><p><img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935184537.jpg" alt="tips-android-targetsdkversion-201935184537"></p>
<h3 id="Android6-0变更"><a href="#Android6-0变更" class="headerlink" title="Android6.0变更"></a>Android6.0变更</h3><h4 id="（一）相关变更"><a href="#（一）相关变更" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><p><strong>运行时权限</strong></p>
<p>此版本引入了一种新的权限模式，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，为安装的应用分别授予或撤销权限，同时为开发者精简了安装和自动更新过程。</p>
<p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。确定应用是否已被授予权限，可调用新增的 checkSelfPermission() 方法。请求权限，可调用新增的 requestPermissions() 方法。具体参考：</p>
<p><a href="https://developer.android.google.cn/training/permissions/requesting" target="_blank" rel="external">https://developer.android.google.cn/training/permissions/requesting</a></p>
<p>####（二）适配指导</p>
<p>• 解释需要权限的原因：系统在开发者调用 requestPermissions() 时显示的权限对话框将说明应用需要的权限，但不会解释为何需要这些权限。某些情况下，用户可能会感到困惑，因此，建议在调用 requestPermissions() 之前向用户解释应用需要相应权限的原因。</p>
<ul>
<li>仅申请应用真正需要的权限</li>
<li>如果应用在启动之后一次要求用户提供多项权限，用户可能会感到无所适从并因此退出应用 。建议开发者应根据需要请求权限，对于某一些权限应用可以在真正需要使用的时候再尝试申请用户动态授权。</li>
</ul>
<h3 id="Android7-0"><a href="#Android7-0" class="headerlink" title="Android7.0"></a>Android7.0</h3><h4 id="（一）相关变更-1"><a href="#（一）相关变更-1" class="headerlink" title="（一）相关变更"></a>（一）相关变更</h4><h5 id="1-系统禁止链接到非-NDK-库"><a href="#1-系统禁止链接到非-NDK-库" class="headerlink" title="1.系统禁止链接到非 NDK 库"></a>1.系统禁止链接到非 NDK 库</h5><p>从 Android 7.0 开始，系统将阻止应用动态链接非公开 NDK 库，原因为NDK 库可能会导致应用崩溃，此行为变更主要目的在为跨平台更新和不同设备提供统一的应用体验。即使应用中的代码不会链接私有库，但第三方静态库可能会进行链接，因此建议所有开发者都需进行相应检查，确保应用不会在运行 Android 7.0 的设备上崩溃。如果应用使用的是原生代码，则只能使用公开 NDK API。（<a href="https://developer.android.com/ndk/guides/stable_apis）" target="_blank" rel="external">https://developer.android.com/ndk/guides/stable_apis）</a></p>
<h5 id="2-低电耗模式DOZE（系统状态）"><a href="#2-低电耗模式DOZE（系统状态）" class="headerlink" title="2.低电耗模式DOZE（系统状态）"></a>2.低电耗模式DOZE（系统状态）</h5><p>进入条件：灭屏、未充电、静止持续1小时
退出条件：亮屏或移动或充电</p>
<p>限制资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停应用的Sync任务</li>
<li>暂停应用的JobScheduler任务</li>
<li>忽略应用的wakelocks</li>
<li>标准Alarm推迟到维护窗口</li>
<li>不执行wifi扫描</li>
</ul>
<h5 id="3-低电耗模式Lite-Idle（系统状态）"><a href="#3-低电耗模式Lite-Idle（系统状态）" class="headerlink" title="3.低电耗模式Lite Idle（系统状态）"></a>3.低电耗模式Lite Idle（系统状态）</h5><p>进入条件：灭屏、未充电持续5分钟(Android P调整为3分钟）
退出条件：亮屏或充电
限制资源</p>
<ul>
<li>限制应用访问网络。</li>
<li>暂停应用运行Sync任务 。</li>
<li>暂停应用运行JobScheduler任务。</li>
</ul>
<h5 id="4-AppStandby模式（应用状态）"><a href="#4-AppStandby模式（应用状态）" class="headerlink" title="4.AppStandby模式（应用状态）"></a>4.AppStandby模式（应用状态）</h5><p>进入AppIdle条件：应用后台空闲总时间&gt;48小时且亮屏后台空闲时间 &gt; 12小时
排除&amp;退出条件：前台应用、有前台服务的应用、通知栏或锁屏通知消息的应用或进行充电
不限制的应用：系统应用UID&lt;10000的，Persist常驻应用，电池优化白名单，系统关联的其他应用
限制的资源</p>
<ul>
<li>限制应用访问网络</li>
<li>暂停执行应用的Sync任务</li>
<li>暂停执行应用的JobScheduler任务</li>
</ul>
<h5 id="5-App-Standby-Bucket-应用待机分组模式-Android-P特性）"><a href="#5-App-Standby-Bucket-应用待机分组模式-Android-P特性）" class="headerlink" title="5.App Standby Bucket 应用待机分组模式( Android P特性）"></a>5.App Standby Bucket 应用待机分组模式( Android P特性）</h5><p>应用待机分组模式是在Doze模式未生效时（亮屏或刚刚灭屏时），对运行在后台的用户不可感知应用的耗电管控扩展。</p>
<h4 id="（二）适配指导"><a href="#（二）适配指导" class="headerlink" title="（二）适配指导"></a>（二）适配指导</h4><p>低电耗模式和应用待机模式适配指导如下：</p>
<p>• 前台服务</p>
<p>应用需要在后台访问网络或者使用CPU时可以通过此方式。</p>
<p>• Doze白名单</p>
<p>查询应用是不是再doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PowerManager powerManager = (PowerManager)getSystemService(POWER_SERVICE);</div><div class="line">boolean hasIgnored = powerManager.isIgnoringBatteryOptimizations(activity.getPackageName());</div></pre></td></tr></table></figure></p>
<p>向用户申请授权添加doze白名单:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);</div><div class="line">intent.setData(Uri.parse(&quot;package:&quot;+activity.getPackageName()));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<h3 id="Android8-0-变更"><a href="#Android8-0-变更" class="headerlink" title="Android8.0 变更"></a>Android8.0 变更</h3><h4 id="1-后台服务限制"><a href="#1-后台服务限制" class="headerlink" title="1.后台服务限制"></a>1.后台服务限制</h4><h5 id="①哪些应用会受到后台服务限制？"><a href="#①哪些应用会受到后台服务限制？" class="headerlink" title="①哪些应用会受到后台服务限制？"></a>①哪些应用会受到后台服务限制？</h5><ul>
<li>TargetSDK&gt;=26的应用</li>
<li>TargetSDK&lt;26且被用户主动设置为限制后台活动的应用（华为EMUI8.x未提供配置）</li>
</ul>
<p>注意：Doze 白名单中的应用不受限制（用户可以设置，手机管家配置有默认值白名单）</p>
<h5 id="②前台如何定义？"><a href="#②前台如何定义？" class="headerlink" title="②前台如何定义？"></a>②前台如何定义？</h5><ul>
<li>前台有可见 Activity</li>
<li>前台服务可以后台播放</li>
<li>绑定服务的情况<h5 id="③后台服务限制，限制了哪些行为？"><a href="#③后台服务限制，限制了哪些行为？" class="headerlink" title="③后台服务限制，限制了哪些行为？"></a>③后台服务限制，限制了哪些行为？</h5></li>
<li>应用进入 uidldle 后，会被调用 Service.stopself()</li>
<li>应用进入 uidldle 后，不允许通过 startService启动服务</li>
<li>应用进程仍然存在，JobScheduler、Alarm、广播等均能触发</li>
<li>广播接收线程处理短暂业务，无法拉起后台服务</li>
<li>非安卓组件线程 CPU 超标时，谷歌原生机制会强制kill进程<h5 id="④临时白名单机制"><a href="#④临时白名单机制" class="headerlink" title="④临时白名单机制"></a>④临时白名单机制</h5>系统调用应用时，少量场景会将应用添加到临时白名单（有效时间30秒~300秒）：</li>
<li>处理高优先级 FCM 消息</li>
<li>接收短信彩信</li>
<li>用户点击通知栏，执行 PendingIntent<h5 id="⑤用户设置限制后台活动之后的影响（Android-P优化）"><a href="#⑤用户设置限制后台活动之后的影响（Android-P优化）" class="headerlink" title="⑤用户设置限制后台活动之后的影响（Android P优化）"></a>⑤用户设置限制后台活动之后的影响（Android P优化）</h5></li>
<li>应用退后台，1分钟就会被停止 Service（包括正在执行的前台任务）</li>
<li>限制访问网络</li>
<li>限制 Alarm 触发</li>
<li>限制 JobScheduler 执行</li>
</ul>
<h4 id="2-广播限制"><a href="#2-广播限制" class="headerlink" title="2.广播限制"></a>2.广播限制</h4><p>Android 8.0 的应用无法继续在其清单中为隐式广播注册广播接收器,但也存在例外情况：</p>
<ul>
<li>应用可以继续在清单中注册显式广播</li>
<li>应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注 册接收器</li>
<li>需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用 ，而不会发送至设备上的所有应用</li>
<li>白名单豁免隐式广播的列表：<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="external">https://developer.android.com/guide/components/broadcast-exceptions</a></li>
</ul>
<p>后台执行限制的适配建议</p>
<ul>
<li>使用 JobScheduler 代替</li>
<li>增加前台服务</li>
<li>加 Doze 白名单（不推荐）</li>
</ul>
<h4 id="3-最大屏幕纵横比"><a href="#3-最大屏幕纵横比" class="headerlink" title="3.最大屏幕纵横比"></a>3.最大屏幕纵横比</h4><p>以 Android 7.1（API 级别 25）或更低版本为目标平台中应用默认的最大屏幕纵横比为1.86。针对 Android 8.0 或更高版本的应用没有默认的最大纵横比，如需设置请在应用 androidmanifest 文件定义 maxAspectRatio 属性（注意：如果应用没有显示申明不支持 resizeableActivity，系统将会忽略应用设置的 maxAspectRatio属性）</p>
<h4 id="4-其他变更"><a href="#4-其他变更" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>提醒窗口</td>
<td>使用SYSTEM_ALERT_WINDOW权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口:TYPE_PHONE,TYPE_PRIORITY_PHONE,TYPE_SYSTEM_ALERT,TYPE_SYSTEM_OVERLAY,TYPE_SYSTEM_ERROR,应用必须使用名为TYPE_APPLICATION_OVERLAY的新窗口类型</td>
</tr>
<tr>
<td>权限</td>
<td>在Android8.0之前,如果应用在运行时请求权限并且被授予该权限,系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用.对于针对8.0的应用,此行为已被纠正.系统只会授予应用明确请求的权限.然而,一旦用户为应用授予某个权限,则所有后续对该权限组中权限的请求都被自动批准.建议应用在使用所有的敏感权限之前,都先判断一下权限是否已经被授予,如果没有授予需要申请动态权限.</td>
</tr>
<tr>
<td>Linker</td>
<td>O版本在linker中新增加检查就是在load之前检测一下需要加载的section的权限,被加载的段不允许同事具有E(可执行)和W(可写)权限.如果有这样的段,则linker报错</td>
</tr>
<tr>
<td>Build.SERIAL弃用</td>
<td>需要知道硬件序列号的应用应改为使用新的Build.getSerial()函数,该函数要求具有READ_PHONE_STATE权限</td>
</tr>
</tbody>
</table>
<h3 id="Android9-0-变更"><a href="#Android9-0-变更" class="headerlink" title="Android9.0 变更"></a>Android9.0 变更</h3><h4 id="1-非SDK管控"><a href="#1-非SDK管控" class="headerlink" title="1.非SDK管控"></a>1.非SDK管控</h4><table>
<thead>
<tr>
<th>名单类型</th>
<th>影响</th>
<th>名单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浅灰名单</td>
<td>targetSDK&gt;=P时,警告</td>
<td>已有应用在使用非SDK接口,仍然可以继续使用</td>
</tr>
<tr>
<td>深灰名单</td>
<td>targetSDK<p时,警告;>=时,不允许调用</p时,警告;></td>
<td>应用可能还在使用</td>
</tr>
<tr>
<td>黑名单</td>
<td>所有三方应用不允许调用</td>
<td>灰名单(深灰+浅灰)之外的其他所有非SDK接口都会被添加到黑名单,应用发现有使用黑名单的接口需要马上整改,或者反馈给谷歌申请加灰名单</td>
</tr>
</tbody>
</table>
<p>使用谷歌提供的非 SDK 扫描工具查看应用使用的深灰名单和黑名单非 SDK 接口： <a href="https://android.googlesource.com/platform/prebuilts/runtime/+/" target="_blank" rel="external">https://android.googlesource.com/platform/prebuilts/runtime/+/</a> master/appcompat/</p>
<h4 id="2-Apache-HTTP-客户端弃用"><a href="#2-Apache-HTTP-客户端弃用" class="headerlink" title="2. Apache HTTP 客户端弃用"></a>2. Apache HTTP 客户端弃用</h4><p>默认情况下该内容库已从 bootclasspath 中移除且不可用于应用，应用不能使用系统的 classloader 加载 org.apache.http.* 库，否则会抛 NoClassDefFoundError。</p>
<p>适配建议</p>
<ul>
<li>方法一：如果要继续使用 Apache HTTP 客户端，以 Android 9.0及更高版本为目标的应用可以向其 AndroidManifest.xml 添加以下内容：<code>&lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot;/&gt;</code></li>
<li>方法二：如果必须要继续使用 Apache HTTP 客户端，开发者可以将 org.apache.http.legacy库打包进自己的apk。</li>
<li>推荐方法：使用 HttpURLConnection 类替代 apache-http</li>
</ul>
<h4 id="3-内联方法不允许跨dex"><a href="#3-内联方法不允许跨dex" class="headerlink" title="3.内联方法不允许跨dex"></a>3.内联方法不允许跨dex</h4><p>Google 在 Android P 新增检测：如果调用某个 inline 方法的类与 inline 方法所在的类由不同的 classloader 加载，就会主动发起 abort（inline不允许跨dex文件）导致应用 crash。
<img src="http://images.wodekouwei.com/tips-android-targetsdkversion-201935181033.jpg" alt="tips-android-targetsdkversion-201935181033"></p>
<h5 id="兼容性影响"><a href="#兼容性影响" class="headerlink" title="兼容性影响"></a>兼容性影响</h5><p>对使用插件和热修复的应用有很大影响，需要重点测试。</p>
<h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><ul>
<li>启动应用，构造热修复场景，在 app 侧触发热修复</li>
<li><code>adb shell cmd package compile -m speed -f my-package 应用包名 (inline编译)</code></li>
<li>重启应用，检查是否会出现闪退问题</li>
</ul>
<h5 id="适配建议"><a href="#适配建议" class="headerlink" title="适配建议"></a>适配建议</h5><ul>
<li>尽量避免使用不同的 classloader 加载相关的类。</li>
<li>如果一定要这样做的话，需要避免内联，比如在函数里面加 try catch， 这样 compiler就不会将这个函数 inline。</li>
</ul>
<h4 id="4-其他变更-1"><a href="#4-其他变更-1" class="headerlink" title="4.其他变更"></a>4.其他变更</h4><table>
<thead>
<tr>
<th>变更</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>前台服务</td>
<td>使用前台服务的应用必须请求FOREGROUND_SERVICE权限.这是普通权限,因此,系统会自动为请求权限的应用授予此权限.如果针对Android9或更高版本的应用尝试创建一个前台服务且未请求FOREGROUND_SERVICE,则系统会引发SecurityException.</td>
</tr>
<tr>
<td>DNS隐私</td>
<td>应用应采用私有DNS API.具体而言,当系统解析程序正在执行DNS-over-TLS时,应用应确保任何内置DNS客户端均使用加密的DNS查找和系统相同的主机名,或停用它而改用系统解析程序</td>
</tr>
<tr>
<td>默认情况下启用网络传输层安全协议(TLS)</td>
<td>默认情况下isCleartextTrafficPermitted()函数返回false.如果您的应用需要为特定域名启动明文,您必须在应用的网络安全性配置中针对这些域名将cleartextTrafficPermitted显式设置为true</td>
</tr>
<tr>
<td>webview数据目录不允许共享</td>
<td>应用无法再让多个进程公用同一个WebView数据目录.如果应用中的多个进程需要访问同一网络数据,您需要自行在这些进程之间复制数据.例如,您可以调用getCookie()和setCooki(),在不同进程之间手动传输Cookie数据</td>
</tr>
<tr>
<td>以应用为单位的SELinux域名</td>
<td>应用的私有数据只能由该应用访问.要与其他应用共享文件,请使用contentprovider</td>
</tr>
</tbody>
</table>
<p>其他的变更和非 TargetSdkVersion 相关的变更以及新特性，可以在谷歌开发者网站查阅：<a href="https://developer.android.google.cn/about/versions/oreo/" target="_blank" rel="external">https://developer.android.google.cn/about/versions/oreo/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">159</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
