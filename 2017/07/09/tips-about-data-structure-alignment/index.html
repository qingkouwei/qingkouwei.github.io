<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="tips,Memory," />





  <link rel="alternate" href="/atom.xml" title="老司机种菜" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Wrote by mutouyun. 1. 内存对齐（Data Structure Alignment）是什么内存对齐，或者说字节对齐，是一个数据类型所能存放的内存地址的属性（Alignment is a property of a memory address）。 这个属性是一个无符号整数，并且这个整数必须是2的N次方（1、2、4、8、……、1024、……）。 当我们说，一个数据类型的内存对齐为">
<meta name="keywords" content="tips,Memory">
<meta property="og:type" content="article">
<meta property="og:title" content="关于内存对齐那些事">
<meta property="og:url" content="http://wodekouwei.com/2017/07/09/tips-about-data-structure-alignment/index.html">
<meta property="og:site_name" content="老司机种菜">
<meta property="og:description" content="Wrote by mutouyun. 1. 内存对齐（Data Structure Alignment）是什么内存对齐，或者说字节对齐，是一个数据类型所能存放的内存地址的属性（Alignment is a property of a memory address）。 这个属性是一个无符号整数，并且这个整数必须是2的N次方（1、2、4、8、……、1024、……）。 当我们说，一个数据类型的内存对齐为">
<meta property="og:image" content="http://images.wodekouwei.com/technology/dsa1.png">
<meta property="og:image" content="http://images.wodekouwei.com/technology/dsa2.png">
<meta property="og:image" content="http://images.wodekouwei.com/technology/dsa3.png">
<meta property="og:updated_time" content="2017-07-09T06:09:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于内存对齐那些事">
<meta name="twitter:description" content="Wrote by mutouyun. 1. 内存对齐（Data Structure Alignment）是什么内存对齐，或者说字节对齐，是一个数据类型所能存放的内存地址的属性（Alignment is a property of a memory address）。 这个属性是一个无符号整数，并且这个整数必须是2的N次方（1、2、4、8、……、1024、……）。 当我们说，一个数据类型的内存对齐为">
<meta name="twitter:image" content="http://images.wodekouwei.com/technology/dsa1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wodekouwei.com/2017/07/09/tips-about-data-structure-alignment/"/>





  <title> 关于内存对齐那些事 | 老司机种菜 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2021aa5f03a4203621d42ef374e0d5f7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老司机种菜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wodekouwei.com/2017/07/09/tips-about-data-structure-alignment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="轻口味">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老司机种菜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                关于内存对齐那些事
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T13:37:24+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Memory/" itemprop="url" rel="index">
                    <span itemprop="name">Memory</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2017/07/09/tips-about-data-structure-alignment/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Wrote <a href="http://darkc.at/about-data-structure-alignment/" target="_blank" rel="external">by mutouyun.</a></p>
<h3 id="1-内存对齐（Data-Structure-Alignment）是什么"><a href="#1-内存对齐（Data-Structure-Alignment）是什么" class="headerlink" title="1. 内存对齐（Data Structure Alignment）是什么"></a>1. 内存对齐（Data Structure Alignment）是什么</h3><p>内存对齐，或者说字节对齐，是一个数据类型所能存放的内存地址的属性（Alignment is a property of a memory address）。
这个属性是一个无符号整数，并且这个整数必须是2的N次方（1、2、4、8、……、1024、……）。
当我们说，一个数据类型的内存对齐为8时，意思就是指这个数据类型所定义出来的所有变量，其内存地址都是8的倍数。</p>
<p>当一个基本数据类型（fundamental types）的对齐属性，和这个数据类型的大小相等时，这种对齐方式称作自然对齐（naturally aligned）。
比如，一个4字节大小的int型数据，默认情况下它的字节对齐也是4。</p>
<h3 id="2-为什么我们需要内存对齐"><a href="#2-为什么我们需要内存对齐" class="headerlink" title="2. 为什么我们需要内存对齐"></a>2. 为什么我们需要内存对齐</h3><p>这是因为，并不是每一个硬件平台都能够随便访问任意位置的内存的。
微软的MSDN里有这样一段话：</p>
<blockquote>
<p>Many CPUs, such as those based on Alpha, IA-64, MIPS, and SuperH architectures, refuse to read misaligned data. When a program requests that one of these CPUs access data that is not aligned, the CPU enters an exception state and notifies the software that it cannot continue. On ARM, MIPS, and SH device platforms, for example, the operating system default is to give the application an exception notification when a misaligned access is requested.</p>
</blockquote>
<p>大意是说，有不少平台的CPU，比如Alpha、IA-64、MIPS还有SuperH架构，若读取的数据是未对齐的（比如一个4字节的int在一个奇数内存地址上），将拒绝访问，或抛出硬件异常。</p>
<p>另外，在维基百科里也记载着如下内容：</p>
<blockquote>
<p>Data alignment means putting the data at a memory offset equal to some multiple of the word size, which increases the system’s performance due to the way the CPU handles memory.</p>
</blockquote>
<p>意思是，考虑到CPU处理内存的方式（32位的x86 CPU，一个时钟周期可以读取4个连续的内存单元，即4字节），使用字节对齐将会提高系统的性能（也就是CPU读取内存数据的效率。比如你一个int放在奇数内存位置上，想把这4个字节读出来，32位CPU就需要两次。但对齐之后一次就可以了）。</p>
<h3 id="3-内存对齐带来的数据结构大小变化"><a href="#3-内存对齐带来的数据结构大小变化" class="headerlink" title="3. 内存对齐带来的数据结构大小变化"></a>3. 内存对齐带来的数据结构大小变化</h3><p>因为有了内存对齐，因此数据在内存里的存放就不是紧挨着的，而是可能会出现一些空隙（Data Structure Padding，也就是用于填充的空白内容）。因此对基本数据类型来说可能还好说，对于一个内部有多个基本类型的结构体（struct）或类而言，sizeof的结果往往和想象中不大一样。</p>
<p>让我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct MyStruct  </div><div class="line">&#123;  </div><div class="line">    char a;         // 1 byte  </div><div class="line">    int b;          // 4 bytes  </div><div class="line">    short c;        // 2 bytes  </div><div class="line">    long long d;    // 8 bytes  </div><div class="line">    char e;         // 1 byte  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以看到，MyStruct中有5个成员，如果直接相加的话大小应该是16，但在32位MSVC里它的sizeof结果是32。
之所以结果出现偏差，为了保证这个结构体里的每个成员都应该在它对齐了的内存位置上，而在某些位置插入了Padding。</p>
<p>下面我们尝试考虑内存对齐，来计算一下这个结构体的大小。首先，我们可以假设MyStruct的整体偏移从0x00开始，这样就可以暂时忽略MyStruct本身的对齐。这时，结构体的整体内存分布如下图所示：
<img src="http://images.wodekouwei.com/technology/dsa1.png" alt="iamge">
我们可以看到，char和int之间；short和long long之间，为了保证成员各自的对齐属性，分别插入了一些Padding。
因此整个结构体会被填充得看起来像这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct MyStruct  </div><div class="line">&#123;  </div><div class="line">    char a;         // 1 byte  </div><div class="line">    char pad_0[3];  // Padding 3  </div><div class="line">    int b;          // 4 bytes  </div><div class="line">    short c;        // 2 bytes  </div><div class="line">    char pad_1[6];  // Padding 6  </div><div class="line">    long long d;    // 8 bytes  </div><div class="line">    char e;         // 1 byte  </div><div class="line">    char pad_2[7];  // Padding 7  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注意到上面加了Padding的示意结构体里，e的后面还跟了7个字节的填充。这是因为结构体的整体大小必须可被对齐值整除，所以“char e”的后面还会被继续填充7个字节好让结构体的整体大小是8的倍数32。</p>
<p>我们可以在gcc + 32位linux中尝试计算sizeof(MyStruct)，得到的结果是24。
这是因为gcc中的对齐规则和MSVC不一样，不同的平台下会使用不同的默认对齐值（The default alignment is fixed for a particular target ABI）。在gcc + 32位linux中，大小超过4字节的基本类型仍然按4字节对齐。因此MyStruct的内存布局这时看起来应该像这个样子：
<img src="http://images.wodekouwei.com/technology/dsa2.png" alt="image"></p>
<p>下面我们来确定这个结构体类型本身的内存对齐是多少。为了保证结构体内的每个成员都能够放在它自然对齐的位置上，对这个结构体本身来说最理想的内存对齐数值应该是结构体里内存对齐数值最大的成员的内存对齐数。
也就是说，对于上面的MyStruct，结构体类型本身的内存对齐应该是8。并且，当我们强制对齐方式小于8时，比如设置MyStruct对齐为2，那么其内部成员的对齐也将被强制不能超过2。</p>
<p>为什么？因为对于一个数据类型来说，其内部成员的位置应该是相对固定的。假如上面这个结构体整体按1或者2字节对齐，而成员却按照各自的方式自然对齐，就有可能出现成员的相对偏移量随内存位置而改变的问题。
比如说，我们可以画一下整个结构体按1字节对齐，并且结构体内的每个成员按自然位置对齐的内存布局：</p>
<p><img src="http://images.wodekouwei.com/technology/dsa3.png" alt="image"></p>
<p>上面的第一种情况，假设MyStruct的起始地址是0x01（因为结构体本身的偏移按1字节对齐），那么char和int之间将会被填充2个字节的Padding，以保证int的对齐还是4字节。
如果第二次分配MyStruct的内存时起始地址变为0x03，由于int还是4字节对齐，则char和int之间将不会填充Padding（填充了反而不对齐了）。
以此类推，若MyStruct按1字节对齐时不强制所有成员的对齐均不超过1的话，这个结构体里的相对偏移方式一共有4种。</p>
<p>因此对于结构体来说，默认的对齐将等于其中对齐最大的成员的对齐值。并且，当我们限定结构体的内存对齐时，同时也限定了结构体内所有成员的内存对齐不能超过结构体本身的内存对齐。</p>
<h3 id="4-指定内存对齐"><a href="#4-指定内存对齐" class="headerlink" title="4. 指定内存对齐"></a>4. 指定内存对齐</h3><p>在C++98/03里，对内存对齐的操作在不同的编译器里可能有不同的方法。</p>
<p>在MSVC中，一般使用#progma pack来指定内存对齐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#pragma pack(1) // 指定后面的内容内存对齐为1  </div><div class="line">struct MyStruct  </div><div class="line">&#123;  </div><div class="line">    char a;         // 1 byte  </div><div class="line">    int b;          // 4 bytes  </div><div class="line">    short c;        // 2 bytes  </div><div class="line">    long long d;    // 8 bytes  </div><div class="line">    char e;         // 1 byte  </div><div class="line">&#125;;  </div><div class="line">#pragma pack() // 还原默认的内存对齐</div></pre></td></tr></table></figure>
<p>这时，MyStruct由于按1字节对齐，其中的所有成员都将变为1字节对齐，因此sizeof(MyStruct)将等于16。
还有另外一个简单的方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__declspec(align(64)) struct MyStruct  </div><div class="line">&#123;  </div><div class="line">    char a;         // 1 byte  </div><div class="line">    int b;          // 4 bytes  </div><div class="line">    short c;        // 2 bytes  </div><div class="line">    long long d;    // 8 bytes  </div><div class="line">    char e;         // 1 byte  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>__declspec(align(64))</code>将指定内存对齐为64。比较坑的是，这种方法不能指定内存对齐小于默认对齐，也就是说它只能调大不能调小<code>（__declspec(align(#)) can only increase alignment restrictions）</code>。因此下面这样写会忽略掉declspec：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__declspec(align(1)) struct MyStruct // ...  </div><div class="line">// warning C4359: &apos;MyStruct&apos;: Alignment specifier is less than actual alignment (8), and will be ignored.</div></pre></td></tr></table></figure>
<p>微软的<code>__declspec(align(#))</code>，其#的内容可以是预编译宏，但不能是编译期数值：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#define XX 32  </div><div class="line">struct __declspec(align(XX)) MyStruct_1 &#123;&#125;; // OK  </div><div class="line"></div><div class="line">template &lt;size_t YY&gt;  </div><div class="line">struct __declspec(align(YY)) MyStruct_2 &#123;&#125;; // error C2059: syntax error: &apos;identifier&apos;  </div><div class="line"></div><div class="line">static const unsigned ZZ = 32;  </div><div class="line">struct __declspec(align(ZZ)) MyStruct_3 &#123;&#125;; // error C2057: expected constant expression</div></pre></td></tr></table></figure></p>
<p>在Visual C++ Compiler November 2013 CTP之后，微软终于支持编译期数值的写法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">template &lt;size_t YY&gt;  </div><div class="line">struct __declspec(align(YY)) MyStruct_2 &#123;&#125;; // OK in 2013 CTP</div></pre></td></tr></table></figure>
<p><code>__declspec(align(#))</code>最大支持对齐为8192（Valid entries are integer powers of two from 1 to 8192）。</p>
<p>下面再来看gcc。gcc和MSVC一样，可以使用#pragma pack：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#pragma pack(1)  </div><div class="line">struct MyStruct  </div><div class="line">&#123;  </div><div class="line">    // ...  </div><div class="line">&#125;;  </div><div class="line">#pragma pack()</div></pre></td></tr></table></figure></p>
<p>另外，也可以使用<code>__attribute__((__aligned__((#))))</code>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct __attribute__((__aligned__((1)))) MyStruct_1  </div><div class="line">&#123;  </div><div class="line">    // ...  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line">struct MyStruct_2  </div><div class="line">&#123;  </div><div class="line">    // ...  </div><div class="line">&#125; __attribute__((__aligned__((1))));</div></pre></td></tr></table></figure></p>
<p>这东西写上面写下面都是可以的，但是不能写在struct前面。
和MSVC一样，<code>__attribute__</code>也只能把字节对齐改大，不能改小（The aligned attribute can only increase the alignment）。比较坑的是当你试图改小的时候，gcc没有任何编译提示信息。
gcc可以接受一个宏或编译期数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define XX 1  </div><div class="line">struct __attribute__((__aligned__((XX)))) MyStruct_1 &#123;&#125;; // OK  </div><div class="line"></div><div class="line">template &lt;size_t YY&gt;  </div><div class="line">struct __attribute__((__aligned__((YY)))) MyStruct_2 &#123;&#125;; // OK  </div><div class="line"></div><div class="line">static const unsigned ZZ = 1;  </div><div class="line">struct __attribute__((__aligned__((ZZ)))) MyStruct_3 &#123;&#125;;  </div><div class="line">//                                        ^  </div><div class="line">// error: requested alignment is not an integer constant</div></pre></td></tr></table></figure>
<p>gcc的<code>__attribute__((__aligned__((#))))</code>支持的上限受限于链接器（Note that the effectiveness of aligned attributes may be limited by inherent limitations in your linker）。</p>
<h3 id="5-获得内存对齐"><a href="#5-获得内存对齐" class="headerlink" title="5. 获得内存对齐"></a>5. 获得内存对齐</h3><p>同样的，在C++98/03里，不同的编译器可能有不同的方法来获得一个类型的内存对齐。</p>
<p>MSVC使用__alignof操作符获得内存对齐大小：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyStruct xx;  </div><div class="line">std::cout &lt;&lt; __alignof(xx) &lt;&lt; std::endl;  </div><div class="line">std::cout &lt;&lt; __alignof(MyStruct) &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p>gcc则使用<code>__alignof__</code>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyStruct xx;  </div><div class="line">std::cout &lt;&lt; __alignof__(xx) &lt;&lt; std::endl;  </div><div class="line">std::cout &lt;&lt; __alignof__(MyStruct) &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，不论是<code>__alignof</code>还是<code>__alignof__</code>，对于对齐的计算都发生在编译期。因此像下面这样写：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a;  </div><div class="line">char&amp; c = reinterpret_cast&lt;char&amp;&gt;(a);  </div><div class="line">std::cout &lt;&lt; __alignof__(c) &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p>得到的结果将是1。</p>
<p>如果需要在运行时动态计算一个变量的内存对齐，比如根据一个void*指针指向的内存地址来判断这个地址的内存对齐是多少，我们可以用下面这个简单的方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__declspec(align(128)) long a = 0;  </div><div class="line">size_t x = reinterpret_cast&lt;size_t&gt;(&amp;a);  </div><div class="line">x &amp;= ~(x - 1);  // 计算a的内存对齐大小  </div><div class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p>用这种方式得到的内存对齐大小可能比实际的大，因为它是切实的获得这个内存地址到底能被多大的2^N整除。</p>
<h3 id="6-堆内存的内存对齐"><a href="#6-堆内存的内存对齐" class="headerlink" title="6. 堆内存的内存对齐"></a>6. 堆内存的内存对齐</h3><p>我们在讨论内存对齐的时候很容易忽略掉堆内存。我们经常会使用malloc分配内存，却不理会这块内存的对齐方式，仿佛堆内存不需要考虑内存对齐一样。
实际上，malloc一般使用当前平台默认的最大内存对齐数对齐内存。比如MSVC在32位下一般是8字节对齐；64位下则是16字节（In Visual C++, the fundamental alignment is the alignment that’s required for a double, or 8 bytes. In code that targets 64-bit platforms, it’s 16 bytes）。这样对于常规的数据都是没有问题的。
但是如果我们自定义的内存对齐超出了这个范围，则是不能直接使用malloc来获取内存的。</p>
<p>当我们需要分配一块具有特定内存对齐的内存块时，在MSVC下应当使用_aligned_malloc；而在gcc下一般使用memalign等函数。</p>
<p>其实自己实现一个简易的aligned_malloc是很容易的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;assert.h&gt;  </div><div class="line"></div><div class="line">inline void* aligned_malloc(size_t size, size_t alignment)  </div><div class="line">&#123;  </div><div class="line">    // 检查alignment是否是2^N  </div><div class="line">    assert(!(alignment &amp; (alignment - 1)));  </div><div class="line">    // 计算出一个最大的offset，sizeof(void*)是为了存储原始指针地址  </div><div class="line">    size_t offset = sizeof(void*) + (--alignment);  </div><div class="line"></div><div class="line">    // 分配一块带offset的内存  </div><div class="line">    char* p = static_cast&lt;char*&gt;(malloc(offset + size));  </div><div class="line">    if (!p) return nullptr;  </div><div class="line"></div><div class="line">    // 通过“&amp; (~alignment)”把多计算的offset减掉  </div><div class="line">    void* r = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;size_t&gt;(p + offset) &amp; (~alignment));  </div><div class="line">    // 将r当做一个指向void*的指针，在r当前地址前面放入原始地址  </div><div class="line">    static_cast&lt;void**&gt;(r)[-1] = p;  </div><div class="line">    // 返回经过对齐的内存地址  </div><div class="line">    return r;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">inline void aligned_free(void* p)  </div><div class="line">&#123;  </div><div class="line">    // 还原回原始地址，并free  </div><div class="line">    free(static_cast&lt;void**&gt;(p)[-1]);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="7-C-11中对内存对齐的操作"><a href="#7-C-11中对内存对齐的操作" class="headerlink" title="7. C++11中对内存对齐的操作"></a>7. C++11中对内存对齐的操作</h3><p>C++11标准里统一了内存对齐的相关操作。</p>
<p>指定内存对齐使用alignas说明符：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">alignas(32) long long a = 0;  </div><div class="line"></div><div class="line">#define XX 1  </div><div class="line">struct alignas(XX) MyStruct_1 &#123;&#125;; // OK  </div><div class="line"></div><div class="line">template &lt;size_t YY = 1&gt;  </div><div class="line">struct alignas(YY) MyStruct_2 &#123;&#125;; // OK  </div><div class="line"></div><div class="line">static const unsigned ZZ = 1;  </div><div class="line">struct alignas(ZZ) MyStruct_3 &#123;&#125;; // OK</div></pre></td></tr></table></figure></p>
<p>注意到MyStruct_3编译是OK的。在C++11里，只要是一个编译期数值（包括static const）都支持alignas（the assignment-expression shall be an integral constant expression，参考ISO/IEC-14882:2011，7.6.2 Alignment specifier，第2款）。
但是需要小心的是，目前微软的编译器（Visual C++ Compiler November 2013 CTP）在MyStruct_3的情况下仍然会报error C2057。
另外，alignas同前面介绍的<code>__declspec</code>、<code>__attribute__</code>一样，只能改大不能改小（参考ISO/IEC-14882:2011，7.6.2 Alignment specifier，第5款）。如果需要改小，比如设置对齐为1的话，仍然需要使用#pragma pack。或者，可以使用C++11里#pragma的等价物_Pragma（微软暂不支持这个）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_Pragma(&quot;pack(1)&quot;)  </div><div class="line">struct MyStruct  </div><div class="line">&#123;  </div><div class="line">    char a;         // 1 byte  </div><div class="line">    int b;          // 4 bytes  </div><div class="line">    short c;        // 2 bytes  </div><div class="line">    long long d;    // 8 bytes  </div><div class="line">    char e;         // 1 byte  </div><div class="line">&#125;;  </div><div class="line">_Pragma(&quot;pack()&quot;)</div></pre></td></tr></table></figure></p>
<p>除了这些之外，alignas比<code>__declspec</code>、<code>这个char就按int的方式对齐了。
获取内存对齐使用alignof操作符：</code>强大的地方在于它还可以这样用：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alignas(int) char c;</div></pre></td></tr></table></figure></p>
<p>这个char就按int的方式对齐了。
获取内存对齐使用alignof操作符：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyStruct xx;  </div><div class="line">std::cout &lt;&lt; alignof(xx) &lt;&lt; std::endl;  </div><div class="line">std::cout &lt;&lt; alignof(MyStruct) &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p>相关注意点和前面介绍的<code>__alignof</code>、<code>__alignof__</code>并无二致。
除了alignas和alignof，C++11中还提供了几个有用的工具。</p>
<p>A. std::alignment_of</p>
<p>功能是编译期计算类型的内存对齐。
std里提供这个是为了补充alignof的功能。alignof只能返回一个size_t，而alignment_of则继承自std::integral_constant，因此拥有value_type、type、operator()等接口（或者说操作）。</p>
<p>B. std::aligned_storage</p>
<p>这是个好东西。我们知道，很多时候需要分配一块单纯的内存块，比如new char[32]，之后再使用placement new在这块内存上构建对象：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char xx[32];  </div><div class="line">::new (xx) MyStruct;</div></pre></td></tr></table></figure></p>
<p>但是char[32]是1字节对齐的，xx很有可能并不在MyStruct指定的对齐位置上。这时调用placement new构造内存块，可能会引起效率问题或出错，这时我们应该使用std::aligned_storage来构造内存块：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::aligned_storage&lt;sizeof(MyStruct), alignof(MyStruct)&gt;::type xx;  </div><div class="line">::new (&amp;xx) MyStruct;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，当使用堆内存的时候我们可能还是需要aligned_malloc。因为现在的编译器里new并不能在超出默认最大对齐后，还能保证内存的对齐是正确的。比如在MSVC 2013里，下面的代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct alignas(32) MyStruct  </div><div class="line">&#123;  </div><div class="line">    char a;         // 1 byte  </div><div class="line">    int b;          // 4 bytes  </div><div class="line">    short c;        // 2 bytes  </div><div class="line">    long long d;    // 8 bytes  </div><div class="line">    char e;         // 1 byte  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line">void* p = new MyStruct;  </div><div class="line">// warning C4316: &apos;MyStruct&apos; : object allocated on the heap may not be aligned 32</div></pre></td></tr></table></figure></p>
<p>将会得到一个编译警告。</p>
<p>C. std::max_align_t</p>
<p>返回当前平台的最大默认内存对齐类型。malloc返回的内存，其对齐和max_align_t类型的对齐大小应当是一致的。
我们可以通过下面这个方式获得当前平台的最大默认内存对齐数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">std::cout &lt;&lt; alignof(std::max_align_t) &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p>D. std::align</p>
<p>这货是一个函数，用来在一大块内存当中获取一个符合指定内存要求的地址。
看下面这个例子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">char buffer[] = &quot;------------------------&quot;;  </div><div class="line">void * pt = buffer;  </div><div class="line">std::size_t space = sizeof(buffer) - 1;  </div><div class="line">std::align(alignof(int), sizeof(char), pt, space);</div></pre></td></tr></table></figure></p>
<p>意思是，在buffer这个大内存块中，指定内存对齐为alignof(int)，找一块sizeof(char)大小的内存，并在找到这块内存后，将地址放入pt，将buffer从pt开始的长度放入space。</p>
<p>关于这个函数的更多信息，可以参考<a href="http://www.cplusplus.com/reference/memory/align/" target="_blank" rel="external">这里</a>。</p>
<p>关于内存对齐，该说的就是这么多了。我们经常会看到内存对齐的应用，是在网络收发包中。一般用于发送的结构体，都是1字节对齐的，目的是统一收发双方（可能处于不同平台）之间的数据内存布局，以及减少不必要的流量消耗。</p>
<p>C++11中为我们提供了不少有用的工具，可以让我们方便的操作内存对齐。但是在堆内存方面，我们很可能还是需要自己想办法。不过在平时的应用中，因为很少会手动指定内存对齐到大于系统默认的对齐数，所以倒也不比每次new/delete的时候都提心吊胆。</p>
<hr>
<p>参考文章：</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Data_structure_alignment" target="_blank" rel="external">Data structure alignment</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms253949.aspx" target="_blank" rel="external">About Data Alignment</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/2e70t5y1.aspx" target="_blank" rel="external">#pragma pack</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/83ythb65.aspx" target="_blank" rel="external">align (C++)</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/45t0s5f4.aspx" target="_blank" rel="external">__alignof Operator</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Structure-Packing-Pragmas.html" target="_blank" rel="external">6.57.8 Structure-Packing Pragmas</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Type-Attributes.html" target="_blank" rel="external">5.32 Specifying Attributes of Types</a></li>
<li><a href="http://chuansu.iteye.com/blog/1487350" target="_blank" rel="external">C/C++ Data alignment 及 struct size深入分析</a></li>
<li><a href="http://www.cnblogs.com/TenosDoIt/p/3590491.html" target="_blank" rel="external">C++ 内存对齐</a></li>
<li><a href="http://www.cnblogs.com/lingjingqiu/p/3446457.html" target="_blank" rel="external">结构/类对齐的声明方式</a></li>
<li><a href="http://www.cnblogs.com/alfredzzj/archive/2012/06/17/2552431.html" target="_blank" rel="external">字节对齐（强制对齐以及自然对齐）</a></li>
<li><a href="http://blog.csdn.net/typhoonzb/article/details/4732520" target="_blank" rel="external">malloc函数字节对齐很经典的问题</a></li>
<li><a href="http://blog.csdn.net/21aspnet/article/details/6729724" target="_blank" rel="external">C语言字节对齐</a></li>
<li><a href="http://blog.csdn.net/xcl168/article/details/19269157" target="_blank" rel="external">网络编程(9)内存对齐对跨平台通讯的影响</a></li>
<li><a href="http://stackoverflow.com/questions/16305311/usage-issue-of-stdalign" target="_blank" rel="external">Usage Issue of std::align</a></li>
<li><a href="http://stackoverflow.com/questions/17378444/stdalign-and-stdaligned-storage-for-aligned-allocation-of-memory-blocks" target="_blank" rel="external">std::align and std::aligned_storage for aligned allocation of memory blocks</a></li>
</ol>
<blockquote>
<p><a href="http://www.cnblogs.com/fangkm/p/4370492.html" target="_blank" rel="external">http://www.cnblogs.com/fangkm/p/4370492.html</a></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://images.wodekouwei.com/Pay/weixin_qingkouwei.png" alt="轻口味 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://images.wodekouwei.com/Pay/zhifubao_qingkouwei.jpg" alt="轻口味 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/tips/" rel="tag"># tips</a>
          
            <a href="/tags/Memory/" rel="tag"># Memory</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/06/webrtc-modules/" rel="next" title="WebRTC的模块处理机制">
                <i class="fa fa-chevron-left"></i> WebRTC的模块处理机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/11/webrtc-source-peerconnection/" rel="prev" title="WebRtc源码分析(1) PeerConnection">
                WebRtc源码分析(1) PeerConnection <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images.wodekouwei.com/avatar/winnle_the_pooh.jpg"
               alt="轻口味" />
          <p class="site-author-name" itemprop="name">轻口味</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">53</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingkouwei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/LightTaste" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/turnpp/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/shen-jun-wei-9/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/ossrs/srs" title="SRS" target="_blank">SRS</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-内存对齐（Data-Structure-Alignment）是什么"><span class="nav-number">1.</span> <span class="nav-text">1. 内存对齐（Data Structure Alignment）是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-为什么我们需要内存对齐"><span class="nav-number">2.</span> <span class="nav-text">2. 为什么我们需要内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-内存对齐带来的数据结构大小变化"><span class="nav-number">3.</span> <span class="nav-text">3. 内存对齐带来的数据结构大小变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-指定内存对齐"><span class="nav-number">4.</span> <span class="nav-text">4. 指定内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-获得内存对齐"><span class="nav-number">5.</span> <span class="nav-text">5. 获得内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-堆内存的内存对齐"><span class="nav-number">6.</span> <span class="nav-text">6. 堆内存的内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-C-11中对内存对齐的操作"><span class="nav-number">7.</span> <span class="nav-text">7. C++11中对内存对齐的操作</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轻口味</span>
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">京ICP备17018543号</a>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "bb46b146831e4e34808d09cd94c85f50",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  


  

</body>
</html>
